<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Sep 13 13:37:40 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>kahuna_apr24.pro (Documentation for ../suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="kahuna_apr24.pro (Documentation for ../suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO makelimbstrips, thresh, xstrips, ystrips, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Makes limb strips from full-length strips</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xstrips : out, required, type=structure</span>
<span class="comments">;           Structure containing row strips</span>
<span class="comments">;       ystrips : out, required, type=structure</span>
<span class="comments">;           Structure containing column strips</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; IF n_elements(region) EQ 0 THEN region = 1</span>
IF region EQ !null THEN region = 1

COMMON vblock, wholeimage

<span class="comments">; Going through and doing a little commenting, think I forgot how this works:</span>

makestrips, thresh, c4xstrips, c4ystrips, region=region, time=time

start = SYSTIME(1,/seconds)

ministrip_side_buffer = byte(!param.ministrip_length)/2 
<span class="comments">; have to byte it since we read the ministrip_length as a float</span>

<span class="comments">; Contains coordinates of chord enpoints</span>
rowchord_endpoints = FLTARR(2,N_ELEMENTS(c4xstrips))
colchord_endpoints = FLTARR(2,N_ELEMENTS(c4ystrips))
<span class="comments">;   Seeing where the array starts to be greater than the thresh</span>
FOR i = 0,N_ELEMENTS(c4ystrips)-1 DO BEGIN
    col_where = WHERE(c4ystrips[i].ARRAY GT thresh)
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,N_ELEMENTS(c4xstrips) -1 DO BEGIN
    row_where = WHERE(c4xstrips[i].ARRAY GT thresh)
    rowchord_endpoints[0,i] = row_where[0]
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

<span class="comments">; Preallocating the array, replicating it by the number of strips there are</span>
xstrips = REPLICATE({ROWINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:BYTARR(!param.ministrip_length), $
        ENDPOINTS:BYTARR(!param.ministrip_length), $
        xoffset:c4xstrips.xoffset},N_ELEMENTS(c4xstrips))
ystrips = REPLICATE({COLINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:BYTARR(!param.ministrip_length), $
        ENDPOINTS:BYTARR(!param.ministrip_length), $
        yoffset:c4ystrips.yoffset},N_ELEMENTS(c4ystrips))

<span class="comments">;Filling out structure with cut-down strip information</span>
FOR i = 0,N_ELEMENTS(c4xstrips) - 1 DO BEGIN
    xstrips[i].ROWINDEX     = c4xstrips[i].ROWINDEX
    <span class="comments">; If there is no strip that cuts through the sun, set things to 0</span>
    IF rowchord_endpoints[0,i] EQ -1 THEN BEGIN
        xstrips[i].STARTPOINTS  = BYTARR(!param.ministrip_length) 
        xstrips[i].BEGINDEX     = 0
    ENDIF ELSE BEGIN
        <span class="comments">; STARTPOINTS is the cut down strip with length = ministrip_length and contains</span>
        <span class="comments">; the indices from rowchord_endpoints[0,i] +/- ministrip_side_buffer</span>
        xstrips[i].STARTPOINTS  = $
        <span class="comments">; IF chord is too long, it tries to crop from outside of image file</span>
            (c4xstrips[i].ARRAY)[rowchord_endpoints[0,i]-ministrip_side_buffer:$
            rowchord_endpoints[0,i]+ministrip_side_buffer]   
        <span class="comments">; BEGINDEX is the index of the strip where it begins. </span>
        <span class="comments">; e.g., the array is 5 long, starts from index 9 and is centered around index 11</span>
        xstrips[i].BEGINDEX     = FIX(rowchord_endpoints[0,i] - ministrip_side_buffer)
    ENDELSE

    IF rowchord_endpoints[1,i] EQ -1 THEN BEGIN
        xstrips[i].ENDPOINTS    = BYTARR(!param.ministrip_length)
        xstrips[i].ENDINDEX    = 0
    ENDIF ELSE BEGIN
        xstrips[i].ENDPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[1,i]-ministrip_side_buffer:$
            rowchord_endpoints[1,i]+ministrip_side_buffer]   
        xstrips[i].ENDINDEX     = FIX(rowchord_endpoints[1,i] - ministrip_side_buffer)
    ENDELSE
ENDFOR


FOR k = 0,N_ELEMENTS(c4ystrips) - 1 DO BEGIN
    ystrips[k].COLINDEX     = c4ystrips[k].COLINDEX
    IF colchord_endpoints[0,k] EQ -1 THEN BEGIN
        ystrips[k].STARTPOINTS  = BYTARR(!param.ministrip_length) 
        ystrips[k].BEGINDEX     = 0
    ENDIF ELSE BEGIN 
        ystrips[k].STARTPOINTS  = (c4ystrips[k].ARRAY)[colchord_endpoints[0,k]- $
            ministrip_side_buffer:colchord_endpoints[0,k]+ministrip_side_buffer]
        ystrips[k].BEGINDEX     = FIX(colchord_endpoints[0,k] - ministrip_side_buffer)
    ENDELSE

    IF colchord_endpoints[1,k] EQ -1 THEN BEGIN
        ystrips[k].ENDPOINTS    = BYTARR(!param.ministrip_length) 
        ystrips[k].ENDINDEX     = 0        
    ENDIF ELSE BEGIN
        ystrips[k].ENDPOINTS    = (c4ystrips[k].ARRAY)[colchord_endpoints[1,k]- $
        ministrip_side_buffer:colchord_endpoints[1,k]+ministrip_side_buffer]
        ystrips[k].ENDINDEX     = FIX(colchord_endpoints[1,k] - ministrip_side_buffer) 
    ENDELSE
ENDFOR


finish = SYSTIME(1,/seconds)

IF KEYWORD_SET(time) THEN  print,'Elapsed Time for makelimbstrips: ', $
    STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

 
FUNCTION quickmask, input_image, thresh
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds center of mask where pixels are above a given threshold</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       input_image : in, required, type=byte</span>
<span class="comments">;           2D array of pixels to mask with threshold</span>
<span class="comments">;       thresh : in, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;-</span>

<span class="comments">; input_image = FLOAT(input_image)</span>
a = input_image[SORT(input_image)]
niceimage = a[0:(1-!param.elim_perc/100)*(N_ELEMENTS(a)-1)]
<span class="comments">; Eliminating the highest 1% of data</span>
IF thresh eq !null then thresh = !param.reg1thresh*MAX(niceimage)
<span class="comments">; IF n_elements(thresh) EQ 0 THEN thresh = 0.25*MAX(image)</span>

s = SIZE(input_image,/dimensions)
n_col = s[0]
n_row = s[1]

suncheck = input_image gt thresh
xpos = TOTAL( TOTAL(suncheck, 2) * INDGEN(n_col) ) / TOTAL(suncheck)
ypos = TOTAL( TOTAL(suncheck, 1) * INDGEN(n_row) ) / TOTAL(suncheck)

RETURN, {xpos:xpos,ypos:ypos}
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


FUNCTION quickfidmask, input_image, thresh
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds center of mask where pixels are above a given threshold</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       input_image : in, required, type=byte</span>
<span class="comments">;           2D array of pixels to mask with threshold</span>
<span class="comments">;       thresh : in, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;-</span>

input_image = FLOAT(input_image)
a = input_image[SORT(input_image)]
niceimage = a[0:(1-!param.elim_perc/100)*(N_ELEMENTS(a)-1)]
<span class="comments">; Eliminating the highest 1% of data</span>
IF thresh eq !null then thresh = !param.reg1thresh*MAX(niceimage)
<span class="comments">; IF n_elements(thresh) EQ 0 THEN thresh = 0.25*MAX(image)</span>

s = SIZE(input_image,/dimensions)
n_col = s[0]
n_row = s[1]

suncheck = input_image lt thresh
xpos = TOTAL( TOTAL(suncheck, 2) * INDGEN(n_col) ) / TOTAL(suncheck)
ypos = TOTAL( TOTAL(suncheck, 1) * INDGEN(n_row) ) / TOTAL(suncheck)

RETURN, {xpos:xpos,ypos:ypos}
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>



FUNCTION whichcropmethod, region
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Crops differently according to which region is selected. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       region : in, required, type=integer</span>
<span class="comments">;           1) main sun</span>
<span class="comments">;           2) 50% brightness sun</span>
<span class="comments">;           3) 25% brightness sun</span>
<span class="comments">;-</span>
COMMON vblock, wholeimage

<span class="comments">; crop_box = BYTE(!param.crop_box)</span>

a = wholeimage[BSORT(wholeimage)]
niceimage = a[0:(1-!param.elim_perc/100)*(N_ELEMENTS(a)-1)]

thresh = !param.reg1thresh_mult*max(niceimage)
ducks = quickmask(wholeimage,thresh)

image = wholeimage[ducks.xpos- !param.crop_box:ducks.xpos+ !param.crop_box, $
    ducks.ypos- !param.crop_box:ducks.ypos+ !param.crop_box]

mainxpos = ducks.xpos
mainypos = ducks.ypos
xoffset = ducks.xpos- !param.crop_box
yoffset = ducks.ypos- !param.crop_box

IF REGION NE 1 THEN BEGIN
    circscancrop, mainxpos, mainypos, image, thresh, xpos, ypos, xoffset, yoffset, region=region, time=time
ENDIF

print,'thresh is: ', thresh
<span class="comments">; There is a strong fiducial at image[*,53], but it's not on the limb. It's pretty darn close though. </span>
<span class="comments">; Now, need to replicate those conditions</span>

<span class="comments">; plot,image[40,*],/nodata</span>

<span class="comments">; i=0</span>
<span class="comments">; while get_kbrd(0) EQ '' do BEGIN</span>
<span class="comments">; oplot, image[*,i]</span>
<span class="comments">; wait,.2</span>
<span class="comments">; i++</span>
<span class="comments">; ENDWHILE</span>
<span class="comments">; plot,image[0:20,53]</span>
<span class="comments">; stop</span>

<span class="comments">; stop</span>
RETURN,{image:image, xoffset:xoffset, yoffset:yoffset, thresh:thresh}
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO makestrips, thresh, xstrips, ystrips, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Only saves 5 strips centered around the solar diameter to reduce the amount of limb-</span>
<span class="comments">;           darkened pixels and to make the polynomial-fitted limbs more-or-less look similar. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;   thresh : out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;   xstrips : out, required, type=structure</span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips : out, required, type=structure</span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;   region : in, required, type=integer, default=1</span>
<span class="comments">;       Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Prints elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; IF n_elements(region) EQ 0 THEN region = 1</span>
IF region eq !null then region = 1

COMMON vblock, wholeimage

struct = whichcropmethod(region)
ducks = quickmask(struct.image)
thresh = struct.thresh

start = SYSTIME(1,/seconds)

animage = struct.image
s = SIZE(animage,/dimensions)
length = s[0]
height = s[1]

rowchord_endpoints = FLTARR(2,!param.nstrips)
colchord_endpoints = FLTARR(2,!param.nstrips)

xstrips = REPLICATE({ROWINDEX:0, ARRAY:BYTARR(length), xoffset:struct.xoffset}, !param.nstrips)
ystrips = REPLICATE({COLINDEX:0, ARRAY:BYTARR(height), yoffset:struct.yoffset}, !param.nstrips)

FOR i = 0,!param.nstrips - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = animage[*, ROUND(ducks.xpos)+(i-!param.nstrips/2)* !param.scan_width]
    ystrips[i].COLINDEX = i
    ystrips[i].ARRAY = animage[ROUND(ducks.ypos)+(i-!param.nstrips/2)* !param.scan_width,*]
ENDFOR

finish = SYSTIME(1,/seconds)
IF KEYWORD_SET(time) THEN  print,'Elapsed Time for makestrips: ', $
    STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO circscancrop, mainxpos, mainypos, image, thresh, xpos, ypos, xoffset, yoffset, region=region, $
     time=time
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Quickly finds the center of the main sun, scans in a circle, and locates the two secondary </span>
<span class="comments">;       suns' centers. Crops either of the secondary suns based on what region specified.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       mainxpos : in, required</span>
<span class="comments">;           X position of 100% brightness sun to scan in a circle around</span>
<span class="comments">;       mainypos : in, required</span>
<span class="comments">;           Y position of 100% brightness sun to scan in a circle around</span>
<span class="comments">;       image : out, required</span>
<span class="comments">;           Cropped area</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used in finding center</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           Computed X position of center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Computed Y position of center</span>
<span class="comments">;       xoffset : out, required</span>
<span class="comments">;           X offset of cropped region's bottom left corner</span>
<span class="comments">;       yoffset : out, required</span>
<span class="comments">;           Y offset of cropped region's bottom left corner</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Print the elapsed time</span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
ON_ERROR,2

COMMON vblock, wholeimage

start = SYSTIME(1,/s)

arr=(FINDGEN(!param.deg_num*!param.res)/!param.res + 90)*!dtor
<span class="comments">; only adding 90 so that it starts from 12 o'clock assuming there is</span>
<span class="comments">; no dim sun at that location</span>

radius = 129  <span class="comments">; well this is rather arbitrary</span>
r2bit = 2

<span class="comments">; The way we have it scanning now is if it doesn't find the aux sun, it scans at a radius interval of </span>
<span class="comments">; 10 so that it looks at the r_orig - interval and r_orig + interval radii. Now, what if the sun isn't there? </span>

r2 = radius + 20*r2bit              <span class="comments">;20 is an arbitrary number, can be anything, really</span>
x = radius*COS(arr) + mainxpos
y = radius*SIN(arr) + mainypos
x2 = r2*COS(arr)    + mainxpos
y2 = r2*SIN(arr)    + mainypos


loop: BEGIN
    IF !param.file EQ 'dimsun1.fits' THEN radius = BYTE( !param.scan_radius ) 

    <span class="comments">; Have to use .3 instead of .25 for dimsun2, don't know why</span>
    sorted =  wholeimage[bsort(wholeimage)]
    thresh = !param.reg2thresh_mult*MAX(sorted[0:(1-!param.elim_perc/100)*(N_ELEMENTS(sorted)-1)] )
    <span class="comments">; ^^</span>
    <span class="comments">; Well this doesn't work.</span>
    thresh = !param.reg2thresh_mult*MAX(wholeimage)
    <span class="comments">; Alright, for some reason, clipping out the top 1% changes the thresh from 53.7 to 64.5</span>
    <span class="comments">; which makes the centerx,centery go from 337,76 (correct)</span>
    <span class="comments">; to</span>
    <span class="comments">; 144,19 (so, so wrong)</span>
    <span class="comments">; now, how to deal with it?</span>

    pri_scan = WHERE(wholeimage[x,y] GT thresh,pri_where)
    aux_scan = WHERE(wholeimage[x2,y2] GT thresh,aux_where)

    <span class="comments">; print,aux_where, ' aux_where before if statement'</span>
    IF aux_where NE 0 THEN BEGIN
    <span class="comments">; stop</span>
        in_inner  = ((WHERE(wholeimage[x,y]     GT thresh))[0])/!param.res - !param.circscan_buffer
        out_inner = ((WHERE(wholeimage[x,y]     GT thresh))[-1])/!param.res + !param.circscan_buffer
        in_outer  = ((WHERE(wholeimage[x2,y2]   GT thresh))[0])/!param.res - !param.circscan_buffer
        out_outer = ((WHERE(wholeimage[x2,y2]   GT thresh))[-1])/!param.res + !param.circscan_buffer
    ENDIF ELSE BEGIN
        r2bit*=-1
        GOTO, loop
    ENDELSE
END

otherloop: BEGIN
    IF REGION EQ 3 THEN BEGIN
        thresh = 0.2*MAX(wholeimage) <span class="comments">;dimsun2 works if i set the thresh to .2 instead of .15</span>
        <span class="comments">; The other sun is so dim that weird parts are being picked up. How to fix? Is being dim a problem?</span>
        sorted =  wholeimage[bsort(wholeimage)]
        thresh = !param.reg3thresh_mult*MAX( sorted[0:(1-!param.elim_perc/100)*(N_ELEMENTS(sorted)-1)] )
        <span class="comments">; ^^</span>
        <span class="comments">; Well this doesn't work.</span>
        <span class="comments">; print,thresh</span>
        <span class="comments">; thresh = !param.reg3thresh_mult*MAX(wholeimage)</span>
        
        <span class="comments">; check to make sure we're scanning at the right radius</span>
        n_check = WHERE((wholeimage[x2,y2] GT thresh) EQ 1,n_where)

        IF n_where NE 0 THEN BEGIN
            part1 = wholeimage[x[0:in_inner*!param.res],y[0:in_inner*!param.res]]
            part2 = wholeimage[x[out_inner*!param.res:N_ELEMENTS(x)-1],y[out_inner*!param.res:N_ELEMENTS(x)-1]]
            part1b = wholeimage[x2[0:in_outer*!param.res],y2[0:in_outer*!param.res]]
            part2b = wholeimage[x[out_outer*!param.res:N_ELEMENTS(x)-1],y[out_outer*!param.res:N_ELEMENTS(x)-1]]

            in_inner  = ((WHERE([part1,part2]   gt thresh))[0])/!param.res - !param.circscan_buffer
            out_inner = ((WHERE([part1,part2]   gt thresh))[-1])/!param.res + !param.circscan_buffer
            in_outer  = ((WHERE([part1b,part2b] gt thresh))[0])/!param.res - !param.circscan_buffer
            out_outer = ((WHERE([part1b,part2b] gt thresh))[-1])/!param.res + !param.circscan_buffer

        ENDIF ELSE BEGIN
            r2bit*=-1
            GOTO, otherloop
        ENDELSE
        <span class="comments">; Setting this to 0 actually messes up fitting. use only to show what pixels are being circscanned</span>
        <span class="comments">; wholeimage[x[in_inner:out_inner],y[in_inner:out_inner]] = 0</span>
        <span class="comments">; wholeimage[x2[in_outer:out_outer],y2[in_outer:out_outer]] = 0</span>
        <span class="comments">; stop</span>
    ENDIF
END


centerangle = !dtor*(90 + MEAN([in_inner,out_inner]))
centerx = mainxpos + radius*COS(centerangle)
centery = mainypos + radius*SIN(centerangle)

<span class="comments">; This part fails with the bright pixels</span>

image = wholeimage[centerx - !param.crop_box:centerx + !param.crop_box,$
    centery - !param.crop_box:centery + !param.crop_box]
xoffset = centerx- !param.crop_box
yoffset = centery- !param.crop_box

finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'getstruct took: '+STRCOMPRESS(finish-start)+$
    ' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO limbfit, thresh, xpos, ypos, plot=plot, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Uses the data from makelimbstrips and fits an n-th order polynomial to the limb to find where</span>
<span class="comments">;       it crosses the threshold.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           X center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Y center</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region : in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       plot : in, optional</span>
<span class="comments">;           Makes some nice plots</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

if region eq !null then region = 1

COMMON vblock, wholeimage

<span class="comments">; Run the program to get our structures</span>
makelimbstrips, thresh, xstrips, ystrips, region=region, time=time

start = SYSTIME(1,/seconds)

xlen    = 0
xsum    = 0
xnum    = 0   
ylen    = 0
ysum    = 0
ynum    = 0
xarr    = FINDGEN(N_ELEMENTS(xstrips[4].STARTPOINTS))
yarr    = FINDGEN(N_ELEMENTS(ystrips[4].STARTPOINTS))
tx      = FINDGEN(N_ELEMENTS(xstrips[4].STARTPOINTS) * 1000)/100
ylenarr = FINDGEN(N_ELEMENTS(ystrips))
xlenarr = FINDGEN(N_ELEMENTS(xstrips))

<span class="comments">;Deal with rows</span>
FOR n=0,N_ELEMENTS(xstrips)-1 DO BEGIN
    <span class="comments">; Using fz_roots instead of SPLINE interpolating. Saving lines and making code more readable</span>

    startresult     = REFORM(POLY_FIT(xarr,xstrips[n].STARTPOINTS, !param.order))
    endresult       = REFORM(POLY_FIT(xarr,xstrips[n].ENDPOINTS, !param.order))

    <span class="comments">; Solving for roots but want to include threshold value</span>
    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF xstrips[n].BEGINDEX GT 0 THEN BEGIN
        <span class="comments">; Get roots (complex)</span>
        begroots    = FZ_ROOTS(startresult)
        <span class="comments">; Take only roots with no imaginary components</span>
        begusable   = (REAL_PART(begroots))[WHERE(IMAGINARY(begroots) eq 0.)]
        <span class="comments">; Find smallest root (apparently I have to choose the smaller one)</span>
        <span class="comments">; Or i can find the midpoints using the other two roots then take the average of the two,</span>
        <span class="comments">; that way works too, but why would I do that?</span>
        begusable   = (begusable[WHERE(begusable gt 0)])[0]
        stripbeg    = xstrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF xstrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = FZ_ROOTS(endresult)
        endusable   = (REAL_PART(endroots))[WHERE(IMAGINARY(endroots) eq 0.)]
        endusable   = (endusable[WHERE(endusable gt 0)])[0]
        stripend    = xstrips[n].ENDINDEX + endusable
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    <span class="comments">; Stick the midpoints in an array to take the mean of later</span>
    xlenarr[n] = MEAN([[stripend],[stripbeg]])
ENDFOR    

FOR n=0,N_ELEMENTS(ystrips)-1 DO BEGIN
    startresult     = REFORM(POLY_FIT(yarr,ystrips[n].STARTPOINTS, !param.order))
    endresult       = REFORM(POLY_FIT(yarr,ystrips[n].ENDPOINTS, !param.order))

    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF ystrips[n].BEGINDEX GT 0 THEN BEGIN
        begroots    = FZ_ROOTS(startresult)
        begusable   = (REAL_PART(begroots))[WHERE(IMAGINARY(begroots) eq 0.)]
        begusable   = (begusable[WHERE(begusable gt 0)])[0]
        stripbeg    = ystrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF ystrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = FZ_ROOTS(endresult)
        endusable   = (REAL_PART(endroots))[WHERE(IMAGINARY(endroots) eq 0.)]
        endusable   = (endusable[WHERE(endusable gt 0)])[0]
        stripend    = ystrips[n].ENDINDEX + endusable
        
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    ylenarr[n] = MEAN([[stripend],[stripbeg]])
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = MEAN(xlenarr[WHERE(xlenarr ne 0)]) + (xstrips.xoffset)[0]
ypos = MEAN(ylenarr[WHERE(ylenarr ne 0)]) + (ystrips.yoffset)[0]

IF KEYWORD_SET(plot) THEN BEGIN
    wn = 3
    startresult = POLY_FIT(xarr,xstrips[wn].STARTPOINTS, !param.order)
    endresult = POLY_FIT(xarr,xstrips[wn].ENDPOINTS, !param.order)

    CASE !param.order OF
    1: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','SPLINEd Data'],linestyle=[0,1],/bottom,/right,charsize=2

    window,0
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','SPLINEd Data'],linestyle=[0,1],/bottom,/left,charsize=2
ENDIF

finish = SYSTIME(1,/seconds)

IF KEYWORD_SET(time) THEN  print,'Elapsed Time for limbfit: ',STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO getstruct, struct, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds the centers of a triple-sun image and loads all relevant information</span>
<span class="comments">;       including offsets and angles into a new structure.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       struct : out, required, type=structure</span>
<span class="comments">;           Structure containing the centers and cropped images of all 3 suns</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
ON_ERROR,2

COMMON vblock, wholeimage

start = SYSTIME(1,/s)

center1 = {center1,xpos:0d,ypos:0d,thresh:0d}
center2 = {center2,xpos:0d,ypos:0d,thresh:0d}
center3 = {center3,xpos:0d,ypos:0d,thresh:0d}

limbfit, thresh, xpos, ypos, plot=plot, region=1, time=time
center1.xpos = xpos
center1.ypos = ypos
center1.thresh = thresh

limbfit, thresh, xpos, ypos, plot=plot, region=2, time=time
center2.xpos = xpos
center2.ypos = ypos
center2.thresh = thresh

limbfit, thresh, xpos, ypos, plot=plot, region=3, time=time
center3.xpos = xpos
center3.ypos = ypos
center3.thresh = thresh

theta = !radeg*atan((center3.ypos - center2.ypos)/(center3.xpos - center2.xpos))
hypot = sqrt((center3.ypos - center2.ypos)^2 + (center3.xpos - center2.xpos)^2)
offset = ((center1.xpos - center2.xpos)*(center3.ypos - center2.ypos) - $
    (center1.ypos - center2.ypos)*(center3.xpos - center2.xpos))/hypot

struct = {KAHUNA, center1:center1, center2:center2, center3:center3, $
    theta:theta, offset:offset}
finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'getstruct took: '+STRCOMPRESS(finish-start)+$
    ' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="auxcrop;:source"></a>function auxcrop<span class="comments">;, mainxpos, mainypos, image, thresh, xpos, ypos, xoffset, yoffset, region=region, $</span>
     <span class="comments">;time=time</span>

<span class="comments">; input the region</span>


<span class="comments">; replacing circscancrop because this is so much simpler. </span>

<span class="comments">; we already know the center of the main sun, crop it out</span>
a = findgen(10,10)
<span class="comments">; if center is 5,5</span>
b = fltarr(10,10) + 1
b[4:6,4:6] -= 1
newmask = a*b

<span class="comments">; work with this image</span>

<span class="comments">; thresh = .6*MAX(newmask[0:(1-!param.elim_perc/100)*(N_ELEMENTS(newmask)-1)])</span>

<span class="comments">; but instead of .6 it's a parameter</span>

<span class="comments">; shoud do a check where if there are no adjacent pixels near a bright pixel, eliminate it, BUT that would be a mean amount of calculation</span>

<span class="comments">; quickmask newmask with the above thresh</span>

<span class="comments">; the once we find center, crop out that part too, rinse above steps</span>

<span class="comments">; Is it a problem that reg 3 needs the coords of reg 2? Nah old code does the same.</span>

<span class="comments">; centerx = mainxpos + radius*COS(centerangle)</span>
<span class="comments">; centery = mainypos + radius*SIN(centerangle)</span>

<span class="comments">; ; This part fails with the bright pixels</span>

<span class="comments">; image = wholeimage[centerx - !param.crop_box:centerx + !param.crop_box,$</span>
<span class="comments">;     centery - !param.crop_box:centery + !param.crop_box]</span>
<span class="comments">; xoffset = centerx- !param.crop_box</span>
<span class="comments">; yoffset = centery- !param.crop_box</span>


<span class="comments">; output the crop area</span>
<span class="comments">; return, </span>
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="cropme:source"></a>function cropme, input, pix

    s = size(input,/d)
    nrow = s[0]
    ncol = s[1]
    output = input[(nrow-1)/2 - pix:(nrow-1)/2 + pix,(ncol-1)/2 - pix:(ncol-1)/2 + pix]

return, output
end

<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="bordercheck:source"></a>function bordercheck, input

s = SIZE(input,/dim)
wn_row = s[0]
wn_col = s[1]
datmask = BYTARR(wn_row,wn_col) + 1
datmask[(1/!param.mask_border_perc)*wn_row:(1-(1/!param.mask_border_perc))*wn_row,$
    (1/!param.mask_border_perc)*wn_col:(1-(1/!param.mask_border_perc))*wn_col] = 0

<span class="comments">; min_val should be a really low number, the mode of input is 3</span>
min_val = MODE(input)

if TOTAL(datmask*input) gt N_ELEMENTS(datmask[WHERE(datmask eq 1)])*min_val then okaybit=0 else okaybit=1

return, okaybit
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="morescratch:source"></a>function morescratch, input, thresh

bigxpb = SHIFT_DIFF(EMBOSS(input),dir=3) lt thresh
bigypb = SHIFT_DIFF(EMBOSS(input,az=90),dir=1) lt thresh

for p = 0,5 do begin
    tmpcrop = input[10:38+p,8:42]
    xpb = bigxpb[10:38+p,8:42]
    ypb = bigypb[10:38+p,8:42]
    
    s = size(tmpcrop,/d)
    bordermask = bytarr(s[0],s[1]) + 1
    <span class="comments">; any specific reason we have the border 2 pixels instead of 1?</span>
    bordermask[1:s[0]-2,1:s[1]-2] = 0

    mcrop = bordermask * tmpcrop

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = MODE(ind_col)
    b = MODE(ind_col[WHERE(ind_col ne a)])

    c = MODE(ind_row)
    d = MODE(ind_row[WHERE(ind_row ne c)])

    <span class="comments">; Just to make it sorted</span>
    xpos = [a,b]
    ypos = [c,d]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    xmcrop = bordermask * xpb
    ymcrop = bordermask * ypb

    ind_col = WHERE(xmcrop eq 1) mod ncol
    ind_row = WHERE(ymcrop eq 1)/nrow



print,ind_col
print,ind_row
    <span class="comments">; if N_ELEMENTS(row_border) eq 1 then row_border = MODE(ind_row)</span>
    <span class="comments">; if N_ELEMENTS(col_border) eq 1 then col_border = MODE(ind_col)</span>

    <span class="comments">; Look at each index, 6 pixels in</span>

    <span class="comments">; If we see a fiducial cut off, either</span>

    <span class="comments">; ignore fiducial</span>
    <span class="comments">; or</span>
    <span class="comments">; crop it out</span>
    <span class="comments">; need to identify whether to use 0:6 or -7:-1</span>
    if WHERE(xmcrop eq 1) eq [-1] then print,'col_slice boo' else begin
        col_slice = FLTARR(N_ELEMENTS(ind_col),nrow)
        for i=0,N_ELEMENTS(ind_col)-1 do begin
            col_slice[i,*] = REFORM(tmpcrop[ind_col[i],*])
            if WHERE(xpb[ind_col[i],*] eq 1) eq [0] then begin
                print,'cropping 0:6'

                <span class="comments">; So this is the part of the program where we need to </span>
                <span class="comments">; do the smart thing of checking to make sure that the fiducials are being</span>
                <span class="comments">; thresholded correctly, but how do we do that? </span>

                <span class="comments">; What is somevalue? How do we quantify it?</span>

        <span class="comments">; if N_ELEMENTS(FLOAT(col_slice[i,0:6]) - MODE(tmpcrop) lt somevalue) lt 6 then okaybit=0 else okaybit=1</span>
        <span class="comments">; I think we should use something with derivatives because we know approximately </span>
        <span class="comments">; how dim the fiducials will get. Instead of replying on pixel values, we rely</span>
        <span class="comments">; on the relative pixel changes which may/may not be more robust</span>

        if N_ELEMENTS(DERIV(DERIV(FLOAT(col_slice[i,0:6])))) gt 0 lt 6 then okb = 0 else okb = 1

        <span class="comments">; This isn't going to work because the threshold of 0 is too high. According to this</span>
        <span class="comments">; current setup, if a fiducial is right on the edge, it'll ALWAYS be bad.</span>

        
        <span class="comments">; I can actually not use parentheses here, is it ok?</span>
        <span class="comments">;Honestly, what's the purpose of doing this "X-Y lt thresh" instead of "X lt thresh"?</span>


        <span class="comments">; The problem is that I'm unable to quantify the fiducials in the way I want</span>
            endif
            if WHERE(xpb[ind_col[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    if WHERE(ymcrop eq 1) eq [-1] then print,'row_slice boo' else begin
        row_slice = FLTARR(ncol,N_ELEMENTS(ind_row))
        for i=0,N_ELEMENTS(ind_row)-1 do begin
            row_slice[*,i] = REFORM(tmpcrop[*,ind_row[i]])
            if WHERE(ypb[ind_row[i],*] eq 1) eq [0] then print,'cropping 0:6'
            if WHERE(ypb[ind_row[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    <span class="comments">; wait, why is it that if I do something to tmpcrop it wiggs out?</span>

    !p.multi=[0,1,3]
    oldcharsize = !p.charsize
    !p.charsize=2
    <span class="comments">; The right of the vline is where the fiducial is</span>
    window,p
    <span class="comments">; ps_start,filename='betterslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
        range = (FLOAT(tmpcrop[*,20]))[-6:-1]
        plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [-6:-1] edge of (input[10:'+strcompress(38+p)+',8:42])[*,20]',xs=3,ys=3
        vline,5-p
        hline,-20
        plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3
        vline,5-p
        plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3
        vline,5-p
    <span class="comments">; ps_end</span>
    !p.multi=0
    !p.charsize=oldcharsize
endfor
<span class="comments">; stop</span>
<span class="comments">; wait, why does -20 work?</span>
<span class="comments">; ??</span>
<span class="comments">; ??????</span>



<span class="comments">; Instead of looking only at edge 6 pixels...?</span>

<span class="comments">; What is this shit</span>

<span class="comments">; cgimage,convol(float(tmpcrop),kernel,/edge_truncate,/center) * (scale_vector(convol(float(tmpcrop),kernel,/edge_truncate,/center)) lt .3),/k</span>

<span class="comments">; kernel = [[-.5,1,-.5],[1,1,1],[-.5,1,-.5]]</span>
<span class="comments">; kernel = [[0,1,0],[1,1,1],[0,1,0]]</span>
<span class="comments">; kernel = [[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0]]</span>
kernel = [[0,0,1,1,0,0],[0,0,1,1,0,0],[1,1,1,1,1,1],[1,1,1,1,1,1],[0,0,1,1,0,0],[0,0,1,1,0,0]]




<span class="comments">; fiducial locations</span>
<span class="comments">; [24:33,16:27]</span>
<span class="comments">; [24:33,0:10]</span>
<span class="comments">; [5:15,0:10]</span>
<span class="comments">; [5:15,16:27]</span>

first = [24,24,5,5]
second = [33,33,15,15]
third = [16,0,0,16]
fourth = [27,10,10,27]

for hail = 0,3 do begin
    circ = convol(float(tmpcrop),kernel,/edge_truncate,/center)
    crop_circ = circ[first[hail]:second[hail],third[hail]:fourth[hail]]

    <span class="comments">; CONVOL before crop makes the image a little lighter, shape stays the same though</span>

    thresh = .85*max(crop_circ)
    centers=quickfidmask(crop_circ,thresh)
    glorb = tmpcrop[first[hail]:second[hail],third[hail]:fourth[hail]]
    <span class="comments">; glorb[centers.xpos,*] =.7*max(crop_circ)</span>
    <span class="comments">; glorb[*,centers.ypos] = .7*max(crop_circ)</span>

    <span class="comments">; omg, we can just convol() it, then find a quickfidmask!</span>
    finefine = INTERPOLATE(crop_circ,FINDGEN((SIZE(crop_circ,/d))[0] *10)/10.,FINDGEN((SIZE(crop_circ,/d))[1] *10)/10.,/grid,cubic=-.5)
    finefine[centers.xpos * 10,*] =.8*max(finefine)
    finefine[*,10*centers.ypos] = .8*max(finefine)

    !p.multi=[0,2,2]
        window,20 + hail,xsize=700,ysize=1000
        <span class="comments">; ps_start,filename='cropcomp'+strcompress(hail,/rem)+'.eps',/encapsulated,/color,xsize=7,ysize=10</span>
        cgimage,glorb,/k
        cgimage,tmpcrop[first[hail]:second[hail],third[hail]:fourth[hail]],/k
        cgimage,finefine,/k,/axes,title='Interpolated circ_crop'
        cgimage,crop_circ,/k,/axes,title='CONVOL() of fiducial'
        <span class="comments">; ps_end,/png</span>
    !p.multi=0
endfor
<span class="comments">; cgimage,glorb,/k,output='glorb.png'</span>
<span class="comments">; cgimage,tmpcrop[first[hail]:second[hail],third[hail]:fourth[hail]],/k,output='regularcrop.png'</span>
<span class="comments">; cgimage,finefine,/k,/axes,title='Interpolated circ_crop',output='interpcrop.png'</span>
<span class="comments">; cgimage,crop_circ,/k,/axes,title='CONVOL() of fiducial',output='convolcrop.png'</span>
<span class="comments">; ********</span>
<span class="comments">; ********</span>
<span class="comments">; So from the result of these plots, we see that using quickfidmask works well for isolated fiducials but not really</span>
<span class="comments">; on edge fiducials. </span>
<span class="comments">; ********</span>
<span class="comments">; ********</span>

<span class="comments">; Now we're more or less back to where we started?</span>

<span class="comments">; HOW TO DEAL WITH CF</span>

<span class="comments">; window,3</span>
<span class="comments">; plot,DERIV(float(TS_SMOOTH(reform(range),10) -  range)),psym=-4,title='deriv of ts_smooth(x) - x'</span>
<span class="comments">; vline,18</span>
<span class="comments">; vline,24</span>
<span class="comments">; window,4</span>
<span class="comments">; cgimage,SHIFT_DIFF(EMBOSS(tmpcrop),dir=3),/k,title='filter of cropped',/axes</span>
<span class="comments">; window,5</span>
<span class="comments">; cgimage,(shift_diff(emboss(input),dir=3))[10:43,8:42],/k,title='cropped',/axes</span>
<span class="comments">; window,6</span>
<span class="comments">; cgimage,SHIFT_DIFF(EMBOSS(input[10:40,8:42],/edge_truncate),dir=3,/edge_truncate),/k,'filter of cropped with edge_truncate',/axes</span>




<span class="comments">; So this is actually a good way to do it?</span>
<span class="comments">; Not if the fiducial is on the edge, bro.</span>
<span class="comments">; if this is okay, then just count how far it is from the edge</span>


a = emboss(float(tmpcrop),az=180,/edge_truncate)
b = emboss(float(tmpcrop),az=0,/edge_truncate)
cgimage,abs(a-b),/k
<span class="comments">; not that great of an image >_></span>








stop


return,okaybit
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="edgefidcheck:source"></a>function edgefidcheck, input, thresh

for p = 0,5 do begin
    tmpcrop = input[10:38+p,8:42]
    xpb = SHIFT_DIFF(EMBOSS(tmpcrop,az=180,/edge_truncate),dir=4,/edge_truncate) lt thresh
    ypb = SHIFT_DIFF(EMBOSS(tmpcrop,az=90,/edge_truncate),dir=1,/edge_truncate) lt thresh

    s = size(tmpcrop,/d)
    bordermask = bytarr(s[0],s[1]) + 1
    <span class="comments">; any specific reason we have the border 2 pixels instead of 1?</span>
    bordermask[1:s[0]-2,1:s[1]-2] = 0

    mcrop = bordermask * tmpcrop

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = MODE(ind_col)
    b = MODE(ind_col[WHERE(ind_col ne a)])

    c = MODE(ind_row)
    d = MODE(ind_row[WHERE(ind_row ne c)])

    <span class="comments">; Just to make it sorted</span>
    xpos = [a,b]
    ypos = [c,d]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    xmcrop = bordermask * xpb
    ymcrop = bordermask * ypb

    ind_col = WHERE(xmcrop eq 1) mod ncol
    ind_row = WHERE(ymcrop eq 1)/nrow

    <span class="comments">; if N_ELEMENTS(row_border) eq 1 then row_border = MODE(ind_row)</span>
    <span class="comments">; if N_ELEMENTS(col_border) eq 1 then col_border = MODE(ind_col)</span>

    <span class="comments">; Look at each index, 6 pixels in</span>

    <span class="comments">; If we see a fiducial cut off, either</span>

    <span class="comments">; ignore fiducial</span>
    <span class="comments">; or</span>
    <span class="comments">; crop it out</span>
    <span class="comments">; need to identify whether to use 0:6 or -7:-1</span>
    if WHERE(xmcrop eq 1) eq [-1] then print,'col_slice boo' else begin
        col_slice = FLTARR(N_ELEMENTS(ind_col),nrow)
        for i=0,N_ELEMENTS(ind_col)-1 do begin
            col_slice[i,*] = REFORM(tmpcrop[ind_col[i],*])
            if WHERE(xpb[ind_col[i],*] eq 1) eq [0] then begin
                print,'cropping 0:6'

                <span class="comments">; So this is the part of the program where we need to </span>
                <span class="comments">; do the smart thing of checking to make sure that the fiducials are being</span>
                <span class="comments">; thresholded correctly, but how do we do that? </span>

                <span class="comments">; What is somevalue? How do we quantify it?</span>

        <span class="comments">; if N_ELEMENTS(FLOAT(col_slice[i,0:6]) - MODE(tmpcrop) lt somevalue) lt 6 then okaybit=0 else okaybit=1</span>
        <span class="comments">; I think we should use something with derivatives because we know approximately </span>
        <span class="comments">; how dim the fiducials will get. Instead of replying on pixel values, we rely</span>
        <span class="comments">; on the relative pixel changes which may/may not be more robust</span>

        if N_ELEMENTS(DERIV(DERIV(FLOAT(col_slice[i,0:6])))) gt 0 lt 6 then okb = 0 else okb = 1

        <span class="comments">; This isn't going to work because the threshold of 0 is too high. According to this</span>
        <span class="comments">; current setup, if a fiducial is right on the edge, it'll ALWAYS be bad.</span>

        
        <span class="comments">; I can actually not use parentheses here, is it ok?</span>
        <span class="comments">;Honestly, what's the purpose of doing this "X-Y lt thresh" instead of "X lt thresh"?</span>


        <span class="comments">; The problem is that I'm unable to quantify the fiducials in the way I want</span>
            endif
            if WHERE(xpb[ind_col[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    if WHERE(ymcrop eq 1) eq [-1] then print,'row_slice boo' else begin
        row_slice = FLTARR(ncol,N_ELEMENTS(ind_row))
        for i=0,N_ELEMENTS(ind_row)-1 do begin
            row_slice[*,i] = REFORM(tmpcrop[*,ind_row[i]])
            if WHERE(ypb[ind_row[i],*] eq 1) eq [0] then print,'cropping 0:6'
            if WHERE(ypb[ind_row[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    <span class="comments">; !p.multi=[0,1,3]</span>
    <span class="comments">; oldcharsize = !p.charsize</span>
    <span class="comments">; !p.charsize=2</span>
    <span class="comments">; ; The right of the vline is where the fiducial is</span>
    <span class="comments">; window,p</span>
    <span class="comments">; ; ps_start,filename='betterslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
    <span class="comments">;     range = (FLOAT(tmpcrop[*,20]))[-6:-1]</span>
    <span class="comments">;     plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [-6:-1] edge of (input[10:'+strcompress(38+p)+',8:42])[*,20]',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p</span>
    <span class="comments">;     hline,-20</span>
    <span class="comments">;     plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p</span>
    <span class="comments">;     plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p</span>
    <span class="comments">; ; ps_end</span>
    <span class="comments">; !p.multi=0</span>
    <span class="comments">; !p.charsize=oldcharsize</span>
    
    <span class="comments">; window,p</span>
    ps_start,filename='fidcheck_newdegree'+strcompress(p,/rem)+'.eps',/encapsulated,/color
        cgimage,tmpcrop,/k,/axes,title='(input[10:'+strcompress(38+p,/rem)+',8:42])[*,20]'
        plot_edges,xpb,thick=3,x0=.5,y0=.5
        plot_edges,ypb,dcolor=220,thick=3,x0=.5,y0=.5
    ps_end,/png,resize=100,/delete

endfor


stop


return,okaybit
end

<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="galapagos:source"></a>function galapagos, input, thresh

for p = 1,6 do begin
    tmpcrop = input[8:40,12-p:42]
    xpb = SHIFT_DIFF(EMBOSS(tmpcrop,/edge_truncate,az=0),dir=3,/edge_truncate) lt thresh
    ypb = SHIFT_DIFF(EMBOSS(tmpcrop,az=90,/edge_truncate),dir=1,/edge_truncate) lt thresh


    s = size(tmpcrop,/d)
    bordermask = bytarr(s[0],s[1]) + 1
    <span class="comments">; any specific reason we have the border 2 pixels instead of 1?</span>
    bordermask[1:s[0]-2,1:s[1]-2] = 0

    mcrop = bordermask * tmpcrop

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = MODE(ind_col)
    b = MODE(ind_col[WHERE(ind_col ne a)])

    c = MODE(ind_row)
    d = MODE(ind_row[WHERE(ind_row ne c)])

    <span class="comments">; Just to make it sorted</span>
    xpos = [a,b]
    ypos = [c,d]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    xmcrop = bordermask * xpb
    ymcrop = bordermask * ypb

    ind_col = WHERE(xmcrop eq 1) mod ncol
    ind_row = WHERE(ymcrop eq 1)/nrow

    if WHERE(xmcrop eq 1) eq [-1] then print,'col_slice boo' else begin
        col_slice = FLTARR(N_ELEMENTS(ind_col),nrow)
        for i=0,N_ELEMENTS(ind_col)-1 do begin
            col_slice[i,*] = REFORM(tmpcrop[ind_col[i],*])
            if WHERE(xpb[ind_col[i],*] eq 1) eq [0] then begin
                print,'cropping 0:6'
                if N_ELEMENTS(DERIV(DERIV(FLOAT(col_slice[i,0:6])))) gt 0 lt 6 then okb = 0 else okb = 1
            endif
            if WHERE(xpb[ind_col[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    if WHERE(ymcrop eq 1) eq [-1] then print,'row_slice boo' else begin
        row_slice = FLTARR(ncol,N_ELEMENTS(ind_row))
        for i=0,N_ELEMENTS(ind_row)-1 do begin
            row_slice[*,i] = REFORM(tmpcrop[*,ind_row[i]])
            if WHERE(ypb[ind_row[i],*] eq 1) eq [0] then print,'cropping 0:6'
            if WHERE(ypb[ind_row[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    <span class="comments">; !p.multi=[0,1,3]</span>
    <span class="comments">; oldcharsize = !p.charsize</span>
    <span class="comments">; !p.charsize=2</span>

    <span class="comments">; ;Everything to left of vline is fiducial</span>

    <span class="comments">; window,p</span>
    <span class="comments">; ; ps_start,filename='anotherslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
    <span class="comments">;     range = (FLOAT(tmpcrop[12,*]))[0:5]</span>
    <span class="comments">;     plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [0:5] edge of (input[8:40,'+strcompress(12-p,/rem)+':42])[12,*]',xs=3,ys=3</span>
    <span class="comments">;     vline,p-1</span>
    <span class="comments">;     hline,-30    </span>
    <span class="comments">;     plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,p-1    </span>
    <span class="comments">;     plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,p-1</span>
    <span class="comments">; ; ps_end</span>
    <span class="comments">; !p.multi=0</span>
    <span class="comments">; !p.charsize=oldcharsize</span>
        window,p
    <span class="comments">; ps_start,filename='moarfidcheck'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
        cgimage,tmpcrop,/k,/axes,title='(input[10:'+strcompress(38+p,/rem)+',8:42])[*,20]'
        plot_edges,xpb,x0=.5,y0=.5,thick=3
        plot_edges,ypb,dcolor=220,x0=.5,y0=.5,thick=3
    <span class="comments">; ps_end,/png,resize=100</span>
endfor

<span class="comments">; stop</span>
okaybit=1
return,okaybit
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="scratch:source"></a>function scratch, input, thresh

bigxpb = SHIFT_DIFF(EMBOSS(input),dir=3) lt thresh
bigypb = SHIFT_DIFF(EMBOSS(input,az=90),dir=1) lt thresh

for p = 1,6 do begin
    tmpcrop = input[8:40,12-p:42]
    xpb = bigxpb[8:40,12-p:42]
    ypb = bigypb[8:40,12-p:42]
    s = size(tmpcrop,/d)
    bordermask = bytarr(s[0],s[1]) + 1
    <span class="comments">; any specific reason we have the border 2 pixels instead of 1?</span>
    bordermask[1:s[0]-2,1:s[1]-2] = 0

    mcrop = bordermask * tmpcrop

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = MODE(ind_col)
    b = MODE(ind_col[WHERE(ind_col ne a)])

    c = MODE(ind_row)
    d = MODE(ind_row[WHERE(ind_row ne c)])

    <span class="comments">; Just to make it sorted</span>
    xpos = [a,b]
    ypos = [c,d]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    xmcrop = bordermask * xpb
    ymcrop = bordermask * ypb

    ind_col = WHERE(xmcrop eq 1) mod ncol
    ind_row = WHERE(ymcrop eq 1)/nrow

    if WHERE(xmcrop eq 1) eq [-1] then print,'col_slice boo' else begin
        col_slice = FLTARR(N_ELEMENTS(ind_col),nrow)
        for i=0,N_ELEMENTS(ind_col)-1 do begin
            col_slice[i,*] = REFORM(tmpcrop[ind_col[i],*])
            if WHERE(xpb[ind_col[i],*] eq 1) eq [0] then begin
                print,'cropping 0:6'
                if N_ELEMENTS(DERIV(DERIV(FLOAT(col_slice[i,0:6])))) gt 0 lt 6 then okb = 0 else okb = 1
            endif
            if WHERE(xpb[ind_col[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    if WHERE(ymcrop eq 1) eq [-1] then print,'row_slice boo' else begin
        row_slice = FLTARR(ncol,N_ELEMENTS(ind_row))
        for i=0,N_ELEMENTS(ind_row)-1 do begin
            row_slice[*,i] = REFORM(tmpcrop[*,ind_row[i]])
            if WHERE(ypb[ind_row[i],*] eq 1) eq [0] then print,'cropping 0:6'
            if WHERE(ypb[ind_row[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    !p.multi=[0,1,3]
    oldcharsize = !p.charsize
    !p.charsize=2

    <span class="comments">;Everything to left of vline is fiducial</span>

    window,p
    <span class="comments">; ps_start,filename='anotherslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
        range = (FLOAT(tmpcrop[12,*]))[0:5]
        plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [0:5] edge of (input[8:40,'+strcompress(12-p,/rem)+':42])[12,*]',xs=3,ys=3
        vline,p-1
        hline,-30    
        plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3
        vline,p-1    
        plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3
        vline,p-1
    <span class="comments">; ps_end</span>
    !p.multi=0
    !p.charsize=oldcharsize
endfor

stop
return,okaybit
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="barkbark:source"></a>function barkbark, input, thresh

bigxpb = SHIFT_DIFF(EMBOSS(input),dir=3) lt thresh
bigypb = SHIFT_DIFF(EMBOSS(input,az=90),dir=1) lt thresh

for p = 0,5 do begin
    tmpcrop = input[8:38+p,6:42]
    xpb = bigxpb[8:38+p,6:42]
    ypb = bigypb[8:38+p,6:42]
    s = size(tmpcrop,/d)
    bordermask = bytarr(s[0],s[1]) + 1
    <span class="comments">; any specific reason we have the border 2 pixels instead of 1?</span>
    bordermask[1:s[0]-2,1:s[1]-2] = 0

    mcrop = bordermask * tmpcrop

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = MODE(ind_col)
    b = MODE(ind_col[WHERE(ind_col ne a)])

    c = MODE(ind_row)
    d = MODE(ind_row[WHERE(ind_row ne c)])

    <span class="comments">; Just to make it sorted</span>
    xpos = [a,b]
    ypos = [c,d]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    xmcrop = bordermask * xpb
    ymcrop = bordermask * ypb

    ind_col = WHERE(xmcrop eq 1) mod ncol
    ind_row = WHERE(ymcrop eq 1)/nrow

    if WHERE(xmcrop eq 1) eq [-1] then print,'col_slice boo' else begin
        col_slice = FLTARR(N_ELEMENTS(ind_col),nrow)
        for i=0,N_ELEMENTS(ind_col)-1 do begin
            col_slice[i,*] = REFORM(tmpcrop[ind_col[i],*])
            if WHERE(xpb[ind_col[i],*] eq 1) eq [0] then begin
                print,'cropping 0:6'
                if N_ELEMENTS(DERIV(DERIV(FLOAT(col_slice[i,0:6])))) gt 0 lt 6 then okb = 0 else okb = 1
            endif
            if WHERE(xpb[ind_col[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    if WHERE(ymcrop eq 1) eq [-1] then print,'row_slice boo' else begin
        row_slice = FLTARR(ncol,N_ELEMENTS(ind_row))
        for i=0,N_ELEMENTS(ind_row)-1 do begin
            row_slice[*,i] = REFORM(tmpcrop[*,ind_row[i]])
            if WHERE(ypb[ind_row[i],*] eq 1) eq [0] then print,'cropping 0:6'
            if WHERE(ypb[ind_row[i],*] eq 1) eq [-1] then print,'cropping -7:-1'
        endfor
    endelse

    <span class="comments">; !p.multi=[0,1,3]</span>
    <span class="comments">; oldcharsize = !p.charsize</span>
    <span class="comments">; !p.charsize=2</span>

    <span class="comments">; ;Everything to left of vline is fiducial</span>

    <span class="comments">; window,p</span>
    <span class="comments">; ; ps_start,filename='anotherslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
    <span class="comments">;     range = (FLOAT(tmpcrop[33,*]))[0:5] ;up-down</span>
    <span class="comments">;     plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [0:5] edge of (input[8:43,'+strcompress(6+p,/rem)+':42])[33,*]',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p</span>
    <span class="comments">;     hline,-30    </span>
    <span class="comments">;     plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p    </span>
    <span class="comments">;     plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3</span>
    <span class="comments">;     vline,5-p</span>
    <span class="comments">; ; ps_end</span>
    <span class="comments">; !p.multi=0</span>
    <span class="comments">; !p.charsize=oldcharsize</span>

    !p.multi=[0,1,3]
    oldcharsize = !p.charsize
    !p.charsize=2

    window,p
    <span class="comments">; Everything to right of vline is fiducial</span>
    <span class="comments">; ps_start,filename='anotherslice'+strcompress(p,/rem)+'.eps',/encapsulated,/color</span>
        range = (FLOAT(tmpcrop[*,2]))[-6:-1] <span class="comments">; left-right</span>
        <span class="comments">; stop</span>
        plot,range - mode(tmpcrop),psym=-4,title='array - mode(wholeimage) from [0:5] edge of (input[8:43,'+strcompress(6+p,/rem)+':42])[*,2]',xs=3,ys=3
        vline,5-p
        hline,-30    
        plot,DERIV(range),psym=-4,title='1st deriv of slice',xs=3,ys=3
        vline,5-p    
        plot,(DERIV(DERIV(range)))[*],psym=-4,title='2nd deriv of slice',xs=3,ys=3
        vline,5-p
    <span class="comments">; ps_end</span>
    !p.multi=0
    !p.charsize=oldcharsize

endfor

<span class="comments">; stop</span>
return,okaybit
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="last6pixels:source"></a>function last6pixels, input, thresh

datcrop = input[18:43,6:31]

<span class="comments">; ps_start,filename='datcrop_color.eps',/color,/encapsulated</span>
<span class="comments">; s = size(datcrop,/dim)</span>
<span class="comments">; maskcrop = bytarr(s[0],s[1])</span>
<span class="comments">; taskcrop = bytarr(s[0],s[1])</span>
<span class="comments">; baskcrop = bytarr(s[0],s[1])</span>
<span class="comments">; askcrop  = bytarr(s[0],s[1])</span>
<span class="comments">; maskcrop[2,0:11] =  1</span>
<span class="comments">; taskcrop[3,0:11] = 1</span>
<span class="comments">; baskcrop[0:11,2] = 1</span>
<span class="comments">; askcrop[0:11,3] = 1</span>
<span class="comments">; cgimage,datcrop,/k,/axes</span>
<span class="comments">; plot_edges,maskcrop,thick=3,x0=.5,y0=.5</span>
<span class="comments">; plot_edges,taskcrop,thick=3,x0=.5,y0=.5,dcolor=200</span>
<span class="comments">; plot_edges,baskcrop,thick=3,x0=.5,y0=.5,dcolor=220</span>
<span class="comments">; plot_edges,askcrop,thick=3,x0=.5,y0=.5,dcolor=150</span>
<span class="comments">; ps_end,/png,resize=100</span>
<span class="comments">; stop</span>
<span class="comments">; cgimage,datcrop,/k,output='datcrop.png'</span>

!p.multi=[0,1,6]

a=0
for z = 0,3 do begin
    ps_start,filename='botleft'+strcompress(z,/rem)+'.eps',/encapsulated,xsize=7,ysize=12
    for i = 0,5 do begin
        case z of
          0:range = (datcrop[*,2])[0+a:11+a]
          1:range = (datcrop[*,3])[0+a:11+a]
          2:range = (datcrop[2,*])[0+a:11+a]
          3:range = (datcrop[3,*])[0+a:11+a]
        endcase
        plot,range - mode(datcrop),psym=-4,title='array - mode(wholeimage) from [0:11] edge of (input['+strcompress(18+a,/rem)+':43,6:31])[*,2]',xs=3,ys=3
        vline,5-i
        hline,-20 
        hline,-10,linestyle=1
        a++
    endfor
    a=0
    ps_end

    <span class="comments">;*****</span>

    ps_start,filename='botright'+strcompress(z,/rem)+'.eps',/encapsulated,xsize=7,ysize=12
    for i = 0,5 do begin
        case z of
          0:range = (datcrop[*,2])[-12-a:-1-a]
          1:range = (datcrop[*,3])[-12-a:-1-a]
          2:range = (datcrop[-2,*])[0+a:11+a]
          3:range = (datcrop[-3,*])[0+a:11+a]
        endcase
        plot,range - mode(datcrop),psym=-4,title='array - mode(wholeimage) from [0:11] edge of (input['+strcompress(18+a,/rem)+':43,6:31])[*,2]',xs=3,ys=3
        if (z eq 0 ) || (z eq 1) then vline,6+i else  vline,5-i
        hline,-20 
        hline,-10,linestyle=1
        a++
    endfor
    a=0
    ps_end
    
    <span class="comments">;*****</span>

    ps_start,filename='topleft'+strcompress(z,/rem)+'.eps',/encapsulated,xsize=7,ysize=12
    for i = 0,5 do begin
        case z of
          0:range = (datcrop[2,*])[-12-a:-1-a]
          1:range = (datcrop[3,*])[-12-a:-1-a]
          2:range = (datcrop[*,-2])[0+a:11+a]
          3:range = (datcrop[*,-3])[0+a:11+a]
        endcase
        plot,range - mode(datcrop),psym=-4,title='array - mode(wholeimage) from [0:11] edge of (input['+strcompress(18+a,/rem)+':43,6:31])[*,2]',xs=3,ys=3
        if (z eq 0 ) || (z eq 1) then vline,6+i else  vline,5-i
        hline,-20 
        hline,-10,linestyle=1
        a++
    endfor
    a=0
    ps_end

    <span class="comments">;*****</span>

    ps_start,filename='topright'+strcompress(z,/rem)+'.eps',/encapsulated,xsize=7,ysize=12
    for i = 0,5 do begin
        case z of
          0:range = (datcrop[-2,*])[-12-a:-1-a]
          1:range = (datcrop[-3,*])[-12-a:-1-a]
          2:range = (datcrop[*,-2])[-12-a:-1-a]
          3:range = (datcrop[*,-3])[-12-a:-1-a]
        endcase
        plot,range - mode(datcrop),psym=-4,title='array - mode(wholeimage) from [0:11] edge of (input['+strcompress(18+a,/rem)+':43,6:31])[*,2]',xs=3,ys=3
        vline,6+i
        hline,-20 
        hline,-10,linestyle=1
        a++
    endfor
    a=0
    ps_end
endfor

<span class="comments">; this is all for 1 fiducial</span>



!p.multi=0
stop
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="smoothit:source"></a>pro smoothit, input

sorted = float(input[bsort(input)])

<span class="comments">; u_input only looks good if the positions are so that the aux suns aren't in the same col/row as another sun</span>
<span class="comments">; If there's any that do, it's going to be sucks.</span>
<span class="comments">; Thus, this is only for looks</span>
u_input = input[uniq(input)]
u_sort = float(u_input[sort(u_input)])

n_col = (size(input,/dim))[0]
n_row = (size(input,/dim))[1]
xarr = fan(findgen(n_col),n_row)
yarr = transpose(fan(findgen(n_row),n_col))

xsort = xarr[bsort(input)]
ysort = yarr[bsort(input)]

skimmed = sorted[0:(1-!param.elim_perc/100)*(N_ELEMENTS(sorted)-1)]

<span class="comments">; ps_start,filename='saysitall.eps',/encapsulated</span>
<span class="comments">; !p.multi=[0,1,3]</span>
<span class="comments">; plot,xsort,psym=3,title='X Positions'</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; plot,ysort,psym=3,title='Y Positions'</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; plot,sorted</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; !p.multi=0</span>
<span class="comments">; ps_end</span>
<span class="comments">; stop</span>

n_smooth = 100.
smoothed = ts_smooth(skimmed,n_smooth,order=3)
reg_smooth = smooth(skimmed,n_smooth,/edge_truncate)
med_smooth = median(skimmed,n_smooth)


<span class="comments">; the goal of smoothit is so that we can find the peaks of the suns, right? Once we have this 1D array we can work on isolating 1 or 2 suns.</span>
<span class="comments">; This way, we don't have to worry about keyword crap. </span>


<span class="comments">; !p.charsize=2</span>
<span class="comments">; window,1</span>
<span class="comments">; plot,DERIV(smoothed),yr=[0,.1],xr=[1e5,n_elements(skimmed)-1]</span>
<span class="comments">; window,2</span>
<span class="comments">; plot,DERIV(smooth(skimmed,1000)),yr=[0,.1],xr=[1e5,n_elements(skimmed)-1]</span>

<span class="comments">; ; ps_start,filename='d_.eps',/encapsulated</span>
<span class="comments">; window,0</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(smooth)',yr=[-100,300]</span>
<span class="comments">; ; oplot,deriv(reg_smooth)*3000</span>
<span class="comments">; oplot,scale_vector(deriv(reg_smooth),min(skimmed),max(skimmed))</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>
<span class="comments">; ; ps_end</span>

<span class="comments">; ps_start,filename='d_s_d_reg.eps',/encapsulated</span>
<span class="comments">; ; window,1</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(smooth(deriv(smooth)))',yr=[-100,300]</span>
<span class="comments">; ; oplot,deriv(smooth(deriv(reg_smooth)*2000000,1000,/edge_truncate))</span>
<span class="comments">; oplot,scale_vector(deriv(smooth(deriv(reg_smooth),1000,/edge_truncate)),min(skimmed),max(skimmed))</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>
<span class="comments">; ps_end</span>

<span class="comments">; ps_start,filename='d_ts.eps',/encapsulated</span>
<span class="comments">; ; window,2</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth)',yr=[-100,300]</span>
<span class="comments">; oplot,scale_vector(deriv(smoothed),min(skimmed),max(skimmed))</span>
<span class="comments">; ; oplot,deriv(smoothed)*3000</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>
<span class="comments">; ps_end</span>

<span class="comments">; ps_start,filename='d_s_d_ts.eps',/encapsulated</span>
<span class="comments">; ; window,3</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(smooth(deriv(ts_smooth)))',yr=[-100,300]</span>
<span class="comments">; ; oplot,deriv( smooth(deriv(smoothed)*2000000,1000,/edge_truncate) )</span>
<span class="comments">; oplot,scale_vector(deriv( smooth(deriv(smoothed),1000,/edge_truncate) ),min(skimmed),max(skimmed))</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>

<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; ps_end</span>

<span class="comments">; ps_start,filename='d_ts_d_reg.eps',/encapsulated</span>
<span class="comments">; ; window,4</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth(deriv(smooth)))',yr=[-100,300]</span>
<span class="comments">; ; oplot,deriv(ts_smooth(deriv(reg_smooth),1000,order=3))</span>
<span class="comments">; oplot,scale_vector(deriv(ts_smooth(deriv(reg_smooth),1000,order=3)),min(skimmed),max(skimmed))</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>
<span class="comments">; ps_end</span>

<span class="comments">; ps_start,filename='d_ts_d_ts.eps',/encapsulated</span>
<span class="comments">; ; window,5</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth(deriv(ts_smooth)))',yr=[-100,300]</span>
<span class="comments">; ; oplot,deriv( ts_smooth(deriv(smoothed)*2000000,1000,order=3) )</span>
<span class="comments">; oplot,scale_vector(deriv( ts_smooth(deriv(smoothed),1000,order=3) ),min(skimmed),max(skimmed))</span>
<span class="comments">; ; oplot,shift(deriv(deriv(smoothed*200000)),500)</span>

<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>
<span class="comments">; xyouts, 1.42e5,200,'Main sun'</span>
<span class="comments">; xyouts, 1.39e5,200,'50% sun'</span>
<span class="comments">; xyouts, 1.35e5,200,'25% sun'</span>
<span class="comments">; ps_end</span>





<span class="comments">; I have a question: shouldn't the deriv(skimmed) have minima at the boundary lines? A minima would imply that</span>
<span class="comments">; boundary is changing the least when suddenly it jumps to a high value. Am I inorrect in understanding this?</span>


<span class="comments">; window,0</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(reg_smooth)',yr=[-100,300]</span>
<span class="comments">; oplot,scale_vector(deriv(smoothed),min(skimmed),max(skimmed))</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>


<span class="comments">; window,1</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth(deriv(ts_smooth)))',yr=[-100,300]</span>
<span class="comments">; oplot,scale_vector(deriv( ts_smooth(deriv(smoothed),n_smooth,order=3) ),min(skimmed),max(skimmed))</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>

<span class="comments">; window,2</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='shift(deriv(reg_smooth),'+strcompress(n_smooth/2,/rem)+')',yr=[-100,300]</span>
<span class="comments">; oplot,shift(scale_vector(deriv(smoothed),min(skimmed),max(skimmed)),n_smooth/2)</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>

<span class="comments">; window,0</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(reg_smooth)',yr=[0,.2]</span>
<span class="comments">; oplot,deriv(smoothed)</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>


<span class="comments">; window,1</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth(deriv(ts_smooth)))',yr=[0,1]</span>
<span class="comments">; oplot,scale_vector(deriv( ts_smooth(deriv(smoothed),n_smooth,order=3) ),0,1)</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>

<span class="comments">; find peak, zero out</span>
<span class="comments">; find peak, zero out</span>

arr = scale_vector(deriv( ts_smooth(deriv(smoothed),n_smooth,order=3) ),0,1)
peak_1 = mean(where(arr gt .7))
<span class="comments">; t_arr = [arr[0:peak_1-100],arr[peak_1+100:n_elements(arr)-1]]</span>
arr[peak_1-100:peak_1+100]=0
<span class="comments">; peak_2 = mean(where(arr[t_arr gt. 6))</span>
peak_2 = mean(where(arr gt .6))
<span class="comments">; t_arr = [arr[0:peak_2-100],arr[peak_2+100:n_elements(arr)-1]]</span>
arr[peak_2-100:peak_2+100]=0
peak_3 = mean(where(arr gt .5))

<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='deriv(ts_smooth(deriv(ts_smooth)))',yr=[0,1]</span>
<span class="comments">; oplot,scale_vector(deriv( ts_smooth(deriv(smoothed),n_smooth,order=3) ),0,1)</span>
<span class="comments">; vline,peak_1</span>
<span class="comments">; vline,peak_2</span>
<span class="comments">; vline,peak_3</span>

thresh100 = skimmed[peak_1+n_elements(skimmed)*.001]
thresh50 = skimmed[peak_2+n_elements(skimmed)*.001]
thresh25 = skimmed[peak_3+n_elements(skimmed)*.001]

print,thresh100
print,thresh50
print,thresh25

<span class="comments">; window,2</span>
<span class="comments">; plot,skimmed,xr=[1.3e5,n_elements(skimmed)-1],title='shift(deriv(reg_smooth),'+strcompress(n_smooth/2,/rem)+')',yr=[0,.2]</span>
<span class="comments">; oplot,shift(deriv(smoothed),n_smooth/2)</span>
<span class="comments">; vline,141231.25</span>
<span class="comments">; vline,138022.30</span>
<span class="comments">; vline,134328.27</span>


<span class="comments">; window,3</span>
<span class="comments">; plot,histogram(skimmed,binsize=1),yr=[0,300]</span>
<span class="comments">; maybe we should just histogram it, dude.</span>
<span class="comments">; This way we don't have to fucking smooth it</span>

<span class="comments">; ps_start,filename='histozoom.eps',/encapsulated</span>
<span class="comments">; !p.multi=[0,1,2]</span>
<span class="comments">; plot,histogram(skimmed,binsize=1)</span>
<span class="comments">; plot,histogram(skimmed,binsize=1),yr=[0,300]</span>
<span class="comments">; !p.multi=0</span>
<span class="comments">; ps_end</span>
stop
end


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;   KAHUNA</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Finds the center of 3 suns in a single image. Currently limited to a .bmp test image. Instead</span>
<span class="comments">;   of scanning rows to crop, scans in a circle. Using solar centers, identifies fiducial positions.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   JEREN SUZUKI::</span>
<span class="comments">;</span>
<span class="comments">;       Space Sciences Laboratory</span>
<span class="comments">;       7 Gauss Way</span>
<span class="comments">;       Berkeley, CA 94720 USA</span>
<span class="comments">;       E-mail: jsuzuki@ssl.berkeley.edu</span>
<span class="comments">;-</span>

<span class="comments">; PRO kahuna, file, time=time</span>
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       This version uses limb fitting opposed to masking (tricenter). </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;</span>
<span class="comments">;   :TODO: </span>
<span class="comments">;       Find and ISOLATE fiducials, not just mask them out</span>
<span class="comments">;</span>
<span class="comments">;       Ignore center if sun is too close to edge (or if when cropping, we cro outside wholeimage)</span>
<span class="comments">;</span>
<span class="comments">;       Use 25% of median(image)</span>
<span class="comments">;</span>
<span class="comments">;       Make sure program doesn't freak out when sun isn't in POV</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
ON_ERROR,2

start=SYSTIME(1,/s)

<span class="comments">; profiler,/system</span>
<span class="comments">; profiler</span>

<span class="comments">; DEATH TO THE COMMON BLOCK (or not)</span>
COMMON vblock, wholeimage
file = 'dimsun1.fits'
readcol,'pblock.txt',var,num,format='A,F',delimiter=' '
    for i=0,N_ELEMENTS(var)-1 do (SCOPE_VARFETCH(var[i],/enter,level=0))=num[i]

c = CREATE_STRUCT(var[0],num[0])

<span class="comments">;This takes, like, no time.</span>
for i=1,N_ELEMENTS(var)-1 do begin
    c = CREATE_STRUCT(c,var[i],num[i])
endfor

c = CREATE_STRUCT(c,'file','dimsun1.fits')

defsysv,'!param',c

<span class="comments">; print,'Parameters:'</span>
<span class="comments">; for i=0,N_ELEMENTS(var)-1 do print,var[i],num[i],format='(A,A)'</span>

<span class="comments">; wholeimage = mrdfits(file)</span>

<span class="comments">; Centers of dottedimage.fits</span>
<span class="comments">; wholeimage[200,300] = 255</span>
<span class="comments">; wholeimage[202,139] = 255</span>
<span class="comments">; wholeimage[87,231] = 255</span>
<span class="comments">; wholeimage[401,45] = 255</span>
<span class="comments">; wholeimage[23,143] = 255</span>
<span class="comments">; wholeimage[34,290] = 255</span>
<span class="comments">; wholeimage[420,242] = 255</span>

<span class="comments">; Main sun x pos:       210.50238</span>
<span class="comments">; Main sun y pos:       154.27054</span>
<span class="comments">; 50% sun x pos:        337.80600</span>
<span class="comments">; 50% sun y pos:        76.894958</span>
<span class="comments">; 25% sun x pos:        78.683426</span>
<span class="comments">; 25% sun y pos:        235.11536</span>

wholeimage = mrdfits('dottedimage.fits')
rabbit = mrdfits('2whole.fits')
rabbit=rabbit[0,*,*]
turtle = mrdfits('partial3rd.fits')
ox = mrdfits('2partials.fits')
<span class="comments">; wholeimage = mrdfits(file)</span>
<span class="comments">; mwrfits,wholeimage,'dottedimage.fits',/create</span>
<span class="comments">; window,0</span>
<span class="comments">; cgimage,rabbit,/k</span>
<span class="comments">; window,1</span>
<span class="comments">; cgimage,turtle,/k</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,ox,/k</span>

borderbit = bordercheck(wholeimage)

<span class="comments">; read_jpeg,'plots_tables_images/2whole.jpeg',lun</span>
<span class="comments">; mwrfits,lun,'2whole.fits',/create</span>
<span class="comments">; read_jpeg,'plots_tables_images/partial3rd.jpeg',red</span>
<span class="comments">; mwrfits,red,'partial3rd.fits',/create</span>
<span class="comments">; read_jpeg,'plots_tables_images/2partials.jpeg',stairs</span>
<span class="comments">; mwrfits,stairs,'2partials.fits',/create</span>

<span class="comments">; stop</span>

getstruct, struct, time=time

<span class="comments">; profiler,/report,data=data</span>
<span class="comments">; profiler,/reset,/clear</span>

<span class="comments">; print,data[sort(-data.time)],format='(A-20, I7, F12.5, F10.5, I9)'</span>

print,'Main sun x pos:',struct.center1.xpos
print,'Main sun y pos:',struct.center1.ypos
print,'50% sun x pos: ',struct.center2.xpos
print,'50% sun y pos: ',struct.center2.ypos
print,'25% sun x pos: ',struct.center3.xpos
print,'25% sun y pos: ',struct.center3.ypos

<span class="comments">; wholeimage2 = wholeimage</span>
<span class="comments">; wholeimage3 = wholeimage</span>

<span class="comments">; wholeimage[struct.center1.xpos,*]=20</span>
<span class="comments">; wholeimage[*,struct.center1.ypos]=20</span>
<span class="comments">; wholeimage2[struct.center2.xpos,*]=20</span>
<span class="comments">; wholeimage2[*,struct.center2.ypos]=20</span>
<span class="comments">; wholeimage3[struct.center3.xpos,*]=20</span>
<span class="comments">; wholeimage3[*,struct.center3.ypos]=20</span>

<span class="comments">; ; window,0</span>
<span class="comments">; ; cgimage,wholeimage,/k,output=strmid(file,0,7)+'_'+'region1.png'</span>
<span class="comments">; ; ; window,2</span>
<span class="comments">; ; cgimage,wholeimage2,/k,output=strmid(file,0,7)+'_'+'region2.png'</span>
<span class="comments">; ; ; window,3</span>
<span class="comments">; ; cgimage,wholeimage3,/k,output=strmid(file,0,7)+'_'+'region3.png'</span>

<span class="comments">; window,0</span>
<span class="comments">; cgimage,wholeimage,/k</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,wholeimage2,/k</span>
<span class="comments">; window,3</span>
<span class="comments">; cgimage,wholeimage3,/k</span>

crop = wholeimage[struct.center1.xpos-!param.safecrop:struct.center1.xpos+!param.safecrop,$
    struct.center1.ypos-!param.safecrop:struct.center1.ypos+!param.safecrop]
thresh = 0.5*MIN((SHIFT_DIFF(EMBOSS(crop),dir=3)))
borderbit = bordercheck(wholeimage)

smoothit,wholeimage

stop

rabbits = last6pixels(crop,thresh)
turtles = galapagos(crop,thresh)

edgefidbit = edgefidcheck(crop,thresh)
hmmm = barkbark(crop,thresh)
hmmm = scratch(crop,thresh)


stop
finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'merrygotrace took: '+strcompress(finish-start)+$
    ' seconds'
end
</code>
    </div>
  </body>
</html>