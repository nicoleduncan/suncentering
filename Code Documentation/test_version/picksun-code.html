<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Sep 13 13:37:52 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>picksun.pro (Documentation for ../suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="picksun.pro (Documentation for ../suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION picksun, inputimage, inputstruct
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Decides which suns to ignore. Creates a mask with the bottom corners cut off and then creates a bordermask of the remaining area. Any center positions of suns within this bordermask are deemed partial.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputimage: in, required</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       inputstruct: in, required, type=structure</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

s = SIZE(inputimage,/d)
n_col = s[0]
n_row = s[1]
n = !param.triangle_size*s[0]

amask = FLTARR(s) + 1

i = REBIN(INDGEN(n), n, n)           
j = REBIN(TRANSPOSE(INDGEN(n)), n, n)
botleft = ROTATE(i ge j,1)
botright = j ge i

amask[0,0] = botleft
amask[(1 - !param.triangle_size)*s[0],0]=botright
<span class="comments">; 1296*966</span>
padding = 100
paddedimage = FLTARR(s+padding*2)
paddedimage[padding,padding]=amask

<span class="comments">; ghetto erode:</span>
<span class="comments">; pad mask with lots of 0s</span>
<span class="comments">; shift mask right, set to 1</span>
right = SHIFT(paddedimage , !param.border_pad,0)
<span class="comments">; shift mask left, ditto</span>
left = SHIFT(paddedimage, - !param.border_pad,0)
<span class="comments">; shift mask up</span>
up = SHIFT(paddedimage,0 , !param.border_pad)
<span class="comments">; shift mask down</span>
down = SHIFT(paddedimage,0, - !param.border_pad)

<span class="comments">; This is sketchy, only can do this because we know for exact the shape of the triangle</span>
side = SQRT( ( !param.border_pad^2)/2)

upright = SHIFT(paddedimage,-side,side)
upleft = SHIFT(paddedimage,side,side)

<span class="comments">; multiple all masks together</span>
tiny = right*left*up*down*upright*upleft
<span class="comments">; unpad</span>
fixedmask = tiny[padding:s[0]+padding-1,padding:s[1]+padding-1]

<span class="comments">; take that erode</span>
<span class="comments">; cgimage,(amask-fixedmask)*rotate(FINDGEN(s),2),/k</span>

a = fixedmask

<span class="comments">; This works, right?</span>

if N_ELEMENTS(inputstruct) eq 1 then begin
    a[inputstruct[0].xpos,inputstruct[0].ypos] = !values.f_nan
    if MEAN(a) eq !values.f_nan then inputstruct[0].partial = 1
endif else begin
    for i = 0,N_ELEMENTS(inputstruct)-1 do begin
        a[inputstruct[i].xpos,inputstruct[i].ypos] = !values.f_nan
        if MEAN(a) eq !values.f_nan then inputstruct[i].partial = 1
        a = fixedmask
    endfor
endelse

RETURN,inputstruct
end
</code>
    </div>
  </body>
</html>