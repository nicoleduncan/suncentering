<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Sep 13 13:37:51 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>idfids.pro (Documentation for ../suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="idfids.pro (Documentation for ../suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="idfids:source"></a>function idfids, fidstruct, centerstruct

<span class="comments">; So, how do we know which fids are which?</span>

<span class="comments">; For each fiducial, assign a combination of distances as a letter. i.e.,</span>

<span class="comments">; beta = [A, B, C, D, E, F]</span>
<span class="comments">; beta = [0, 0, 0, 0, 0, 0]</span>

<span class="comments">; since we know the distances between certain points and which fiducials they belong to, we check if those distances line up with our fiducials</span>

<span class="comments">; If the distance between point alpha and beta is l, then we look up the distance l and see which fiducials they correspond to. In the table, l is the distance between fiducials A and D. e go to our matrix and for the beta fiducial, we say that it can be either A or D. Now the array looks like:</span>

<span class="comments">; beta = [A, B, C, D, E, F]</span>
<span class="comments">; beta = [1, 0, 0, 1, 0, 0]</span>

<span class="comments">; Great. Now we look up the distance between beta and phi and find the distance to be d. We look up the distance d and see that it links fiducials D and F. Now the array looks like:</span>

<span class="comments">; beta = [A, B, C, D, E, F]</span>
<span class="comments">; beta = [1, 0, 0, 2, 0, 1]</span>

<span class="comments">; we're incrementing by 1 for each possible fiducial it could be. Technically we can stop at 2 but for robustness we do 3. We look up the distance between beta and omicron and find the distance to be w. w marks the distance between the C and D fiducial. Now the array looks like:</span>

<span class="comments">; beta = [A, B, C, D, E, F]</span>
<span class="comments">; beta = [1, 0, 1, 3, 0, 0]</span>

<span class="comments">; After enough iterations, we deduce beta (which holds no meaning) is fiducial D on the grid. Done.</span>

<span class="comments">; THIS IS A REALLY BAD WAY</span>
<span class="comments">; THIS IS A REALLY BAD WAY</span>
<span class="comments">; THIS IS A REALLY BAD WAY</span>
<span class="comments">; THIS IS A REALLY BAD WAY</span>
<span class="comments">; THIS IS A REALLY BAD WAY</span>

<span class="comments">; ; Assuming that the list is a list of fid chords</span>
<span class="comments">; a=posscomb(4)</span>

<span class="comments">; ; fidstruct[0].fidarr[0].x,fidstruct[0].fidarr[0].y = 1 fid coord</span>
<span class="comments">; n=4</span>
<span class="comments">; i = REBIN(LINDGEN(n), n, n)           </span>
<span class="comments">; j = REBIN(TRANSPOSE(LINDGEN(n)), n, n)</span>
<span class="comments">; mask = i gt j</span>

<span class="comments">; dx = fan(fidstruct[0].fidarr.subx,4)</span>
<span class="comments">; tdx = transpose(dx)</span>
<span class="comments">; x = (dx - tdx)^2</span>

<span class="comments">; dy = fan(fidstruct[0].fidarr.suby,4)</span>
<span class="comments">; tdy = transpose(dy)</span>
<span class="comments">; y = (dy - tdy)^2</span>

<span class="comments">; d = sqrt(x + y) * mask</span>

<span class="comments">; print,d</span>

<span class="comments">; don't do a list of chords, combinations get obscene.</span>








<span class="comments">; Assuming that the is a list of fid coords:</span>

<span class="comments">; if F1 is a fiducial with positions F1=[x1,y1] and list is a list of known fid positions:</span>

<span class="comments">; list =  [x1,y1]</span>
<span class="comments">;         [x2,y2]</span>
<span class="comments">;         [x3,y3]</span>
<span class="comments">;         [x4,y4]</span>
<span class="comments">;         etc</span>

<span class="comments">; Then the closest fiducial to F1 is found with:</span>

<span class="comments">; sqrt((list[0,*] - F1[0])^2+(list[1,*] - F1[1])^2)</span>

<span class="comments">; f1=[2,3]</span>



<span class="comments">; newx = subx + centerstruct[0].limbxpos - !param.crop_box</span>


readcol,'fidlist.txt',id,xpos,ypos,format='A,F,F',delimiter=' '
fidl = CREATE_STRUCT('id',id[0],'xpos',xpos[0],'ypos',ypos[0]) 
for i=1,N_ELEMENTS(id)-1 do begin
    fidl=[fidl,{id:id[i],xpos:xpos[i],ypos:ypos[i]}]
endfor

flist = [reform(fidl.xpos,1,6),reform(fidl.ypos,1,6)]
ourflist = [reform(fidstruct.fidarr.subx,1,4),reform(fidstruct.fidarr.suby,1,4)]

for i = 0,3 do begin
    f1 = ourflist[*,i]
    a=sqrt((flist[0,*] - F1[0])^2+(flist[1,*] - F1[1])^2)
    fidstruct.fidarr[i].id = (fidl.id)[where(a eq min(a))]
endfor








<span class="comments">; so actually</span>

<span class="comments">; the list can't be from a point selected from taking a picture since that'll awlays change, the only thing that won't change is the ditance between fiducials. So if I can convert the distance between fiducials to a grid, then we're okay.  </span>


stop
RETURN, fidstruct
end
</code>
    </div>
  </body>
</html>