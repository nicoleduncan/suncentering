<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Sep 13 13:37:28 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fid_locate.pro (Documentation for ../suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fid_locate.pro (Documentation for ../suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION fid_locate, inputimage, inputstruct,mcenter=mcenter
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Locates the whole and sub-pixel positions of fiducials in a cropped solar image</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputimage: in, required</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       inputstruct: in, required</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       mcenter: in, optional</span>
<span class="comments">;           Finds the center of the local maxima using a binary mask instead of parabolic peak fitting. </span>
<span class="comments">;</span>
<span class="comments">;-</span>

badcrop = inputimage[inputstruct[0].limbxpos - !param.soldiskr : inputstruct[0].limbxpos + !param.soldiskr,inputstruct[0].limbypos - !param.soldiskr : inputstruct[0].limbypos + !param.soldiskr]
 
badcrop[WHERE(badcrop eq MAX(badcrop))] = MODE(badcrop)

s = SIZE(badcrop,/dim)
kernel = [[0,0,1,1,0,0],[0,0,1,1,0,0],[1,1,1,1,1,1],[1,1,1,1,1,1],[0,0,1,1,0,0],[0,0,1,1,0,0]]
image = CONVOL(FLOAT(badcrop),kernel,/edge_truncate)

fidthresh = .01
<span class="comments">; seems like .01 is a good thresh value. Why? Beats me.</span>
<span class="comments">; Also, need 5 fiducial pixels for there to be a fiducial detection</span>

pixelfiducials = INDGEN(s)
fidlength = 3
fidwidth = 2
threshold = MEAN(image) + fidthresh*STDDEV(image)
newthresh = MEAN(image) + fidthresh/2*STDDEV(image)
fidpos = {x:0.,y:0.,subpx:0.,subpy:0.}
basestr = fidpos
ff = 0

<span class="comments">; shave off .0004s by moving these two lines out</span>
xpos = pixelfiducials mod s[0]
ypos = pixelfiducials/s[1]

for i = 1, s[0]-2 do begin
    for j = 1,s[1]-2 do begin
        thisvalue = image[i,j]
        if thisvalue lt threshold then begin
            if thisvalue lt image[i,j+1] and $
            thisvalue lt image[i,j-1] and $
            thisvalue lt image[i+1,j] and $
            thisvalue lt image[i-1,j] then begin
                redundant=0
                for k = 0, N_ELEMENTS(pixelfiducials)-1 do begin
                <span class="comments">; This part is being super-iterated</span>
                    if ABS(xpos[k] - i) lt fidlength*2 and ABS(ypos[k] - j) lt fidlength*2 then begin
                        redundant=1
                        thatvalue = image[xpos[k],ypos[k]]
                        if thisvalue lt thatvalue then begin
                            if ff ne 0 then fidpos = [fidpos,basestr]
                            fidpos[ff].x = i
                            fidpos[ff].y = j
                            ff++
                            break 
                        endif
                    endif
                endfor
            endif
        endif
    endfor
endfor

<span class="comments">; let's interp to subpixel values, yo.</span>
<span class="comments">; Let's try to do it Albert's way first</span>
<span class="comments">; Let's stick with Albert's way</span>

if KEYWORD_SET(mcenter) then begin
<span class="comments">; It's already stupid fast as it is.</span>
    for k = 0,N_ELEMENTS(fidpos)-1 do begin
        caa=0
        cbb=0
        avg=0
        xrange = [fidpos[k].x - fidwidth,fidpos[k].x + fidwidth + 1]
        yrange = [fidpos[k].y - fidwidth,fidpos[k].y + fidwidth + 1]
        for aa = 0,xrange[1]-xrange[0] do begin
            for bb = 0,yrange[1]-yrange[0] do begin
                thisvalue = image[aa+xrange[0],bb+yrange[0]]
                if thisvalue lt newthresh then begin
                    caa += aa*thisvalue
                    cbb += bb*thisvalue
                    avg += thisvalue
                endif
            endfor
        endfor
        fidpos[k].subpx=caa/avg+xrange[0]
        fidpos[k].subpy=cbb/avg+yrange[0]
    endfor
endif else begin
    for k = 0,N_ELEMENTS(fidpos)-1 do begin
        z = image[fidpos[k].x-1:fidpos[k].x+1,fidpos[k].y-1:fidpos[k].y+1]
        result = paradip(z)
        <span class="comments">; result = parapeak(1/z)</span>
        fidpos[k].subpx = fidpos[k].x + result[0]
        fidpos[k].subpy = fidpos[k].y + result[1]
    endfor
endelse
<span class="comments">; stop</span>
RETURN,fidpos
END
</code>
    </div>
  </body>
</html>