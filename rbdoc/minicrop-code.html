<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Sat Dec  8 17:12:50 2012 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>minicrop.pro (Documentation for /Users/safusu/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="minicrop.pro (Documentation for /Users/safusu/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO minicrop, temparr, rowscan, colscan, rowendscan, colendscan, scan_width,$
        sundiam, thresh,time=time
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Small function to keep code small in cropit. Finds the row where the threshold is crossed</span>
<span class="comments">;       and then steps back in the x-direction to find the left side of the cropping box. Skips </span>
<span class="comments">;       over the sun by a predetermined value then crops out the sun. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       temparr : in, required, type=byte</span>
<span class="comments">;           2D array to check boundary limits of</span>
<span class="comments">;       rowscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the rows from</span>
<span class="comments">;       colscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the columns from</span>
<span class="comments">;       rowendscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the rows to</span>
<span class="comments">;       colendscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the columns to</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           How apart the scans are for minicrop(). </span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;       temparr : in, required, type=byte</span>
<span class="comments">;           2D array to check boundary limits of</span>
<span class="comments">;       thresh : in, required, type=float</span>
<span class="comments">;           What the minimum threshold will be for scanning</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Print the elapsed time</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

start = systime(1,/s)
rowscan=0

WHILE total(where(temparr[*,rowscan*scan_width] GT thresh/2)) EQ -1 DO BEGIN
    rowscan++
ENDWHILE
<span class="comments">; Doing it this way so that if in the case of 3 suns, if 1 sun is more left than the sun which </span>
<span class="comments">; is the most bottom, the cropping will correctly choose the right sun.</span>
colscan = fix(((where(temparr[*,rowscan*scan_width] GT thresh/2))[0] - sundiam/2 + $
        n_elements(where(temparr[*,rowscan*scan_width] GT thresh/2))/2 )/scan_width)


rowendscan = rowscan + sundiam/scan_width <span class="comments">; Jumping to other side of sun</span>
colendscan = colscan + sundiam/scan_width

<span class="comments">;Since the column scanning is rough, have to give the ends a little room.</span>
rowscan     -= 2
colscan     -= 2
rowendscan  += 2
colendscan  += 2

finish = systime(1,/s)
IF keyword_set(time) THEN print,' minicrop took '+strcompress(finish-start,/remove)+' seconds'

RETURN
END
</code>
    </div>
  </body>
</html>