<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Sat Dec  8 17:08:55 2012 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>data__crop.pro (Documentation for /Users/safusu/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="data__crop.pro (Documentation for /Users/safusu/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION data::crop, file, scan_width, sigmavalue, sundiam, time=time, region=region
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Loads a triple-sun image and crops out selected regions one-by-one.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file: in, required, type = string, default = 'triplesun.bmp'</span>
<span class="comments">;           What file to find 4 centers for</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           How apart the scans are for minicrop(). </span>
<span class="comments">;       sigmavalue : in, required, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam: in, required, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;</span>
<span class="comments">; </span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

IF n_elements(scan_width) EQ 0 THEN scan_width = 5
IF n_elements(sigmavalue) EQ 0 THEN sigmavalue = 2
IF n_elements(sundiam)    EQ 0 THEN sundiam = 70
IF n_elements(region)     EQ 0 THEN region = 1

start  = systime(1,/s)

inputarr=self->read(file)

thresh = max(inputarr) - sigmavalue*stddev(inputarr)
temparr = inputarr * (inputarr GT thresh)

limits = self->minicrop(scan_width,sundiam,temparr,thresh,time=time)

CASE region OF

1:  cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
2:  BEGIN
    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0
    
    <span class="comments">;****************************************************************************************</span>
    temparr = inputarr * (inputarr LT thresh)

    limits = self->minicrop(scan_width,sundiam,temparr,thresh,time=time)

    cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
    END

3:  BEGIN
    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>
    <span class="comments">; Step 2: Black out the first dimsum</span>
    temparr = inputarr * (inputarr LT thresh)

    limits = self->minicrop(scan_width,sundiam,temparr,thresh,time=time)

    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>

    <span class="comments">; Step 3: Crop what's left</span>
    temparr = inputarr * (inputarr LT thresh)

    limits = self->minicrop(scan_width,sundiam,temparr,thresh,time=time)

    cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
    END
ENDCASE

self->set,{image:cropped,xoffset:limits.colscan*scan_width,$
    yoffset:limits.rowscan*scan_width}
finish = systime(1,/s)
IF keyword_set(time) THEN print,'Elapsed time for boundaries(): '+strcompress(finish-start,/remove)+' seconds'
RETURN,self
END
</code>
    </div>
  </body>
</html>