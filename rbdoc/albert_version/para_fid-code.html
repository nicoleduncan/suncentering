<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jun 11 15:09:27 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>para_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="para_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION para_fid, inputimage, inputstruct
<span class="comments">; 3x faster than fid_faster</span>
<span class="comments">; .005 to execute if using gaussfit</span>

<span class="comments">; 10x faster than fid_faster if using parapeak</span>
<span class="comments">; .001 to execute if using parapeak</span>

k=0
z=fltarr(3,3,/nozero)

<span class="comments">; cropped-down image of sun</span>
crop = FLOAT(inputimage[inputstruct.limbxpos - !param.crop_box:inputstruct.limbxpos + !param.crop_box,inputstruct.limbypos - !param.crop_box:inputstruct.limbypos + !param.crop_box])

<span class="comments">; plots of x and y totals to identify rows/columns of fiducials</span>
yt = TOTAL(crop,1)
xt = TOTAL(crop,2)

<span class="comments">; array of differences between sum profile and smoothed sum profile</span>
ysums = yt - SMOOTH(yt, !param.fid_smooth_candidates)
xsums = xt - SMOOTH(xt, !param.fid_smooth_candidates)

<span class="comments">; Identify where it looks like a fiducial</span>
yfids = WHERE(ysums le !param.fid_smooth_thresh) <span class="comments">;try little less</span>
xfids = WHERE(xsums le !param.fid_smooth_thresh)

<span class="comments">; Rule out adjacent indices</span>
aa=xfids
aa= [0,aa,0]
bb = aa - SHIFT(aa,1)
cc = aa[WHERE(bb ne 1)]
xx = cc[1:-2]

aa=yfids
aa= [0,aa,0]
bb = aa - SHIFT(aa,1)
cc = aa[WHERE(bb ne 1)]
yy = cc[1:-2]

<span class="comments">; Breaks if indices aren't exactly consecutive... need to work on that</span>

fidpos = REPLICATE({fidpos,x:0.,y:0.,subx:0.,suby:0.},N_ELEMENTS(xx)>N_ELEMENTS(yy))

<span class="comments">; Loop through each x and y position combination </span>
for i = 0,N_ELEMENTS(xx)-1 do begin
    for j = 0,N_ELEMENTS(yy)-1 do begin
        <span class="comments">; To eliminate coords that are just solar pixels and not fiducials (on disk)</span>
        if crop[xx[i],yy[j]] lt !param.disk_brightness then begin
            
            aa = crop[xx[i] - !param.fid_crop_box:xx[i] + !param.fid_crop_box,yy[j] - !param.fid_crop_box:yy[j] + !param.fid_crop_box]

            rowsum=TOTAL(aa,1) <span class="comments">; Summing rows to get a y position profile</span>
            ysum=SMOOTH(rowsum,10)-rowsum   <span class="comments">;The array we're thresholding</span>
            bw = WHERE(ysum gt !param.onedsumthresh,n_bw)

            colsum=TOTAL(aa,2)
            xsum=SMOOTH(colsum,10)-colsum
            dw = WHERE(xsum gt !param.onedsumthresh,n_dw)
            
            <span class="comments">; if there are any array values above a threshold, it's definitely a fiducial</span>
            if n_bw ne 0 and n_dw ne 0 then begin
                    fidpos[k].x=xx[i]
                    fidpos[k].y=yy[j]

                    <span class="comments">; Find peaks</span>
                    maxx = where(xsum eq max(xsum))
                    maxy = where(ysum eq max(ysum))
                    <span class="comments">; Fit a parabola to these</span>
                    xarr = xsum[maxx-1:maxx+1]
                    yarr = ysum[maxy-1:maxy+1]

                    <span class="comments">; Making some fake 3x3 so that we can use parapeak</span>
                    z[0:2] = xarr * yarr[2]
                    z[3:5] = xarr * yarr[1]
                    z[6:8] = xarr * yarr[0]
                    
                    result = parapeak(z)
                    
                    fidpos[k].subx = maxx + result[0] + xx[i] - !param.fid_crop_box
                    fidpos[k].suby = maxy + result[1] + yy[j] - !param.fid_crop_box

                    k++
                    if k eq N_ELEMENTS(xx)>N_ELEMENTS(yy) then break
            endif
        endif
    endfor
endfor

RETURN,fidpos
end
</code>
    </div>
  </body>
</html>