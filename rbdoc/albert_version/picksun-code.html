<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jun 11 15:09:27 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>picksun.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="picksun.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION picksun, inputimage, inputstruct
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Decides which suns to ignore. Looks along the border pixels of the image and if 6 consecutive pixels are seen, it finds the closest sun (which will be a partial sun) and marks it as no good</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputimage: in, required</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       inputstruct: in, required</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

s = SIZE(inputimage,/d)
n_col = s[0]
n_row = s[1]
vec = !Null

<span class="comments">; Have to do some stupid strucutre stuff because tags are different</span>
a = fltarr(3)
names = tag_names( !thresh)
if WHERE(names eq 'REG1') ne -1 then a[0] = !thresh.reg1
if WHERE(names eq 'REG2') ne -1 then a[1] = !thresh.reg2
if WHERE(names eq 'REG3') ne -1 then a[2] = !thresh.reg3

<span class="comments">; scan in bottom,right,top,left</span>

<span class="comments">; threshmask = inputimage gt MIN(a[where(a ne 0)])</span>
<span class="comments">; bottom = threshmask[*,0]</span>
<span class="comments">; top = threshmask[*,-1]</span>
<span class="comments">; left = REFORM(threshmask[0,*])</span>
<span class="comments">; right = REFORM(threshmask[-1,*])</span>

<span class="comments">; borderarr = [bottom,right,REVERSE(top),REVERSE(left)]</span>

<span class="comments">; xarr = [FINDGEN(n_col),REPLICATE(n_col-1,n_row),REVERSE(FINDGEN(n_col)),REPLICATE(0,n_row)]</span>
<span class="comments">; yarr = [REPLICATE(0,n_col),FINDGEN(n_row),REPLICATE(n_row-1,n_col),REVERSE(FINDGEN(n_row))]</span>

<span class="comments">; ; If we have 6 consecutive pixels then it's bad</span>
<span class="comments">; if TOTAL(borderarr) gt 6 then begin</span>
<span class="comments">;     for i =0,N_ELEMENTS(borderarr)-1 do begin</span>
<span class="comments">;         ; Keep track of how many consecutive picels there are</span>
<span class="comments">;         if borderarr[i+1] + borderarr[i] eq 2 then vec = [vec,i] else vec = !Null</span>
<span class="comments">;         ; If we get 6 in a row, get out of this for loop</span>
<span class="comments">;         if N_ELEMENTS(vec) gt 6 then break</span>
<span class="comments">;     endfor</span>

<span class="comments">;     if vec ne !Null then begin</span>
<span class="comments">;         xcenter = MEAN(xarr[vec])</span>
<span class="comments">;         ycenter = MEAN(yarr[vec])</span>
<span class="comments">;         ; Pick closest center</span>
<span class="comments">;         sundist = SQRT((inputstruct.xpos-xcenter)^2 + (inputstruct.ypos-ycenter)^2)</span>
<span class="comments">;         closest_sun = (inputstruct.reg)[WHERE(sundist eq MIN(sundist))]</span>
<span class="comments">;         borderarr[vec[0]:vec[0] + !param.sundiam]=0</span>
<span class="comments">;     endif</span>
    
<span class="comments">;     ; Set the closest sun to the xcenter,ycenter of the consecutive 6 pixels to nearest center</span>
<span class="comments">;     inputstruct[WHERE(inputstruct.reg eq closest_sun[0])].partial=1</span>


<span class="comments">;     ; We have 3 suns so I'm making 1 nested if loop</span>
<span class="comments">;     if TOTAL(borderarr) gt 6 then begin</span>
<span class="comments">;         for i =0,N_ELEMENTS(borderarr)-1 do begin</span>
<span class="comments">;             if borderarr[i+1] + borderarr[i] eq 2 then vec = [vec,i] else vec = !Null</span>
<span class="comments">;             if N_ELEMENTS(vec) gt 6 then break</span>
<span class="comments">;         endfor</span>

<span class="comments">;         if vec ne !Null then begin</span>
<span class="comments">;             xcenter = MEAN(xarr[vec])</span>
<span class="comments">;             ycenter = MEAN(yarr[vec])</span>

<span class="comments">;             ; pick closest center</span>
<span class="comments">;             sundist = SQRT((inputstruct.xpos-xcenter)^2 + (inputstruct.ypos-ycenter)^2)</span>
<span class="comments">;             closest_sun = (inputstruct.reg)[WHERE(sundist eq MIN(sundist))]</span>
<span class="comments">;             borderarr[vec[0]:vec[0] + !param.sundiam]=0</span>
<span class="comments">;         endif</span>

<span class="comments">;         inputstruct[WHERE(inputstruct.reg eq closest_sun[0])].partial=1</span>
<span class="comments">;     endif</span>
<span class="comments">; endif</span>


<span class="comments">; Trying a new method instead of the consecutive 6 pixels check</span>
<span class="comments">; if N_ELEMENTS(inputstruct) eq 1 then begin</span>
<span class="comments">;     if inputstruct[0].npix lt !param.sunpixnum * !param.partial_perc then inputstruct[0].partial = 1</span>
<span class="comments">; endif else begin</span>
<span class="comments">;     for i = 0,N_ELEMENTS(inputstruct)-1 do begin</span>
<span class="comments">;         if inputstruct[i].npix lt !param.sunpixnum * !param.partial_perc then inputstruct[i].partial = 1</span>
<span class="comments">;     endfor</span>
<span class="comments">; endelse</span>

<span class="comments">; Use a new method that checks to see if the center of the blob is within a distance of the border</span>

amask = FLTARR(s)+1

n = !param.triangle_size*s[0]
i = REBIN(INDGEN(n), n, n)           
j = REBIN(TRANSPOSE(INDGEN(n)), n, n)
botleft = ROTATE(i ge j,1)
botright = j ge i

amask[0,0] = botleft
amask[(1 - !param.triangle_size)*s[0],0]=botright
<span class="comments">; 1296*966</span>
padding = 100
paddedimage = FLTARR(s+padding*2)
paddedimage[padding,padding]=amask

<span class="comments">; ghetto erode:</span>
<span class="comments">; pad mask with lots of 0s</span>
<span class="comments">; shift mask right, set to 1</span>
right = SHIFT(paddedimage , !param.border_pad,0)
<span class="comments">; shift mask left, ditto</span>
left = SHIFT(paddedimage, - !param.border_pad,0)
<span class="comments">; shift mask up</span>
up = SHIFT(paddedimage,0 , !param.border_pad)
<span class="comments">; shift mask down</span>
down = SHIFT(paddedimage,0, - !param.border_pad)

<span class="comments">; This is sketchy, only can do this because we know for exact the shape of the triangle</span>
side = SQRT( ( !param.border_pad^2)/2)

upright = SHIFT(paddedimage,-side,side)
upleft = SHIFT(paddedimage,side,side)

<span class="comments">; multiple all masks together</span>
tiny = right*left*up*down*upright*upleft
<span class="comments">; unpad</span>
fixedmask = tiny[padding:s[0]+padding-1,padding:s[1]+padding-1]

<span class="comments">; take that erode</span>
<span class="comments">; done</span>

<span class="comments">; cgimage,(amask-fixedmask)*rotate(FINDGEN(s),2),/k</span>

a = fixedmask

<span class="comments">; This works, right?</span>

if N_ELEMENTS(inputstruct) eq 1 then begin
    a[inputstruct[0].xpos,inputstruct[0].ypos] = !values.f_nan
    if MEAN(a) eq !values.f_nan then inputstruct[0].partial = 1
endif else begin
    for i = 0,N_ELEMENTS(inputstruct)-1 do begin
        a[inputstruct[i].xpos,inputstruct[i].ypos] = !values.f_nan
        if MEAN(a) eq !values.f_nan then inputstruct[i].partial = 1
        a = fixedmask
    endfor
endelse



RETURN,inputstruct
end
</code>
    </div>
  </body>
</html>