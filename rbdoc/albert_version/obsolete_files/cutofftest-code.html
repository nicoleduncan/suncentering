<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Jun 21 16:58:51 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cutofftest.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cutofftest.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION cutofftest, inputimage, inputstruct, fidstruct

crop = inputimage[inputstruct.limbxpos - !param.crop_box:inputstruct.limbxpos + !param.crop_box,inputstruct.limbypos - !param.crop_box:inputstruct.limbypos + !param.crop_box]
s = size(crop,/d)
prime = quickmask(crop,inputstruct.thresh)

<span class="comments">; loadct,13</span>
<span class="comments">; only go up to 3</span>
<span class="comments">; maybe go up to 5 col-wide at a time</span>

<span class="comments">; ps_start,filename='cutofftestside.eps',/encap,xsize=6,ysize=8</span>
<span class="comments">; !p.multi=[0,3,3]</span>
<span class="comments">; for i = 0, 8 do begin</span>
<span class="comments">;    somecrop = crop[35 + i*10:s[0]-1,0:s[1]-1]</span>
<span class="comments">;    somec = quickmask (somecrop,inputstruct.thresh)</span>
<span class="comments">;    somecrop[somec.xpos-1:somec.xpos+1,somec.ypos-1:somec.ypos+1]=255</span>
<span class="comments">;    somecrop[prime.xpos-(35 + i*10) - 1:prime.xpos-(35+i*10) + 1 ,prime.ypos-1:prime.ypos+1]=180</span>
<span class="comments">;    print,prime.xpos-(35 + i*10) - somec.xpos</span>
<span class="comments">;    print,prime.ypos - somec.ypos</span>
<span class="comments">;    a=where(somecrop gt inputstruct.thresh,n_pix)</span>
<span class="comments">;    print,n_pix</span>
<span class="comments">;    cgimage,somecrop,/k</span>
<span class="comments">; endfor</span>
<span class="comments">; ps_end</span>

<span class="comments">; print, 'interim'</span>

<span class="comments">; ;================================================================================</span>

<span class="comments">; ;================================================================================</span>

<span class="comments">; ps_start,filename='cutofftestcorner.eps',/encap,xsize=6,ysize=8</span>
<span class="comments">; !p.multi=[0,3,3]</span>
<span class="comments">; for i = 0, 8 do begin</span>
<span class="comments">;    somecrop = crop[35 + i*10:s[0]-1,35 + i*10:s[1]-1]</span>
<span class="comments">;    somec = quickmask(somecrop,inputstruct.thresh)</span>
<span class="comments">;    somecrop[somec.xpos-1:somec.xpos+1,somec.ypos-1:somec.ypos+1]=255</span>
<span class="comments">;    somecrop[prime.xpos-(35 + i*10) - 1:prime.xpos-(35+i*10) + 1 ,prime.ypos-(35+ i*10) -1:prime.ypos-(35+i*10)+1]=180</span>
<span class="comments">;    cgimage,somecrop,/k</span>
<span class="comments">;    a=where(somecrop gt inputstruct.thresh,n_pix)</span>
<span class="comments">;    print,n_pix</span>
<span class="comments">;    print,prime.xpos-(35 + i*10) - somec.xpos</span>
<span class="comments">;    print,prime.ypos-(35 + i*10) - somec.ypos</span>
<span class="comments">; endfor</span>
<span class="comments">; ps_end</span>









<span class="comments">; ; ps_start,filename='side5col.eps',/encap,xsize=6,ysize=4</span>
<span class="comments">; ; !p.multi=[0,3,2]</span>
<span class="comments">; for i = 0, 5 do begin</span>
<span class="comments">;    somecrop = crop[35 + i*5:s[0]-1,0:s[1]-1]</span>
<span class="comments">;    somec = quickmask (somecrop,inputstruct.thresh)</span>
<span class="comments">;    somecrop[somec.xpos-1:somec.xpos+1,somec.ypos-1:somec.ypos+1]=255</span>
<span class="comments">;    somecrop[prime.xpos-(35 + i*5) - 1:prime.xpos-(35+i*5) + 1 ,prime.ypos-1:prime.ypos+1]=180</span>
<span class="comments">;    ; print,prime.xpos-(35 + i*5) - somec.xpos</span>
<span class="comments">;    ; print,prime.ypos - somec.ypos</span>
<span class="comments">;    a=where(somecrop gt inputstruct.thresh,n_pix)</span>
<span class="comments">;    print,n_pix/26597.</span>
<span class="comments">;    ; cgimage,somecrop,/k</span>
<span class="comments">; endfor</span>
<span class="comments">; ; ps_end</span>

<span class="comments">; print, 'interim'</span>

<span class="comments">; ;================================================================================</span>

<span class="comments">; ;================================================================================</span>

<span class="comments">; ; ps_start,filename='diag5col.eps',/encap,xsize=6,ysize=4</span>
<span class="comments">; ; !p.multi=[0,3,2]</span>
<span class="comments">; for i = 0, 5 do begin</span>
<span class="comments">;    somecrop = crop[35 + i*5:s[0]-1,35 + i*5:s[1]-1]</span>
<span class="comments">;    somec = quickmask(somecrop,inputstruct.thresh)</span>
<span class="comments">;    somecrop[somec.xpos-1:somec.xpos+1,somec.ypos-1:somec.ypos+1]=255</span>
<span class="comments">;    somecrop[prime.xpos-(35 + i*5) - 1:prime.xpos-(35+i*5) + 1 ,prime.ypos-(35+ i*5) -1:prime.ypos-(35+i*5)+1]=180</span>
<span class="comments">;    ; cgimage,somecrop,/k</span>
<span class="comments">;    a=where(somecrop gt inputstruct.thresh,n_pix)</span>
<span class="comments">;    print,n_pix/26597.</span>
<span class="comments">;    ; print,prime.xpos-(35 + i*5) - somec.xpos</span>
<span class="comments">;    ; print,prime.ypos-(35 + i*5) - somec.ypos</span>
<span class="comments">; endfor</span>
<span class="comments">; ; ps_end</span>
<span class="comments">; ; What are we looking for in particular here?</span>

<span class="comments">; ; plot,crop[*,0]</span>
<span class="comments">; ; for i = 0,((size(crop,/dim))[0])-1 do begin</span>
<span class="comments">; ; plot,crop[*,i]</span>
<span class="comments">; ; wait,.1</span>
<span class="comments">; ; endfor</span>


tic
squirtle = float((transpose(crop))[*])
temparr = float(crop[*])
n_col = (size(crop,/dim))[0]

<span class="comments">; kernel = [1,1,1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1]</span>
<span class="comments">; kernel = [1,1,1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1]</span>
kernel = [1,0,0,0,1]

<span class="comments">; we don't want pluses though, we want smooth hills</span>
<span class="comments">; kernel = [1,1,1,1,1,0,0,0,0,0,1,1,1,1,1]</span>
<span class="comments">; looks good:</span>
<span class="comments">; kernel = [1,-1,-1,-1,1]</span>
kernel = [1,0,1]

<span class="comments">; for i = 0,n_col-1 do begin</span>

<span class="comments">;     ; a=CONVOL(FIX(crop[*,i]),[1,1,1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1],/edge_truncate)</span>
<span class="comments">;     ; plot,a</span>
<span class="comments">;     ; oplot,crop[*,i]</span>
<span class="comments">;     ; vline,where(a eq max(a))</span>
<span class="comments">;     ; wait,.1</span>
<span class="comments">;     a = temparr[i*n_col:(i+1)*n_col-1]</span>
<span class="comments">;     ca = CONVOL(a,kernel,/edge_truncate)</span>
<span class="comments">;     if i eq 0 then ta = ca else ta =[ta,ca]</span>
<span class="comments">;     ; plot,ca</span>
<span class="comments">;     ; oplot,a</span>
<span class="comments">; endfor</span>
<span class="comments">; cgimage,reform(ta,241,241),/k</span>
<span class="comments">; print,fidstruct.subpx</span>
<span class="comments">; print,fidstruct.subpy</span>
<span class="comments">; um, we can just do this: .0003 s compared to .003 of for-loop compared to .026 of 2D convol. 10x faster? BS.</span>
test = convol(temparr,kernel)
ytest = convol(squirtle,kernel)

im = reform(test,241,241)
yim = reform(ytest,241,241)

tyim = transpose(yim)
toc


tic
fidwidth = 3
fidlength = 15
kernel = fltarr(fidlength,fidlength)
kernel[0:fidwidth-1,*]=1
kernel[*,0:fidwidth-1]=1
kernel = SHIFT(kernel,2*fidwidth,2*fidwidth)

image = CONVOL(FIX(crop),kernel,/edge_truncate)
toc

<span class="comments">; .001 to do the x and y things convols. The transposing sucks.</span>

<span class="comments">; for i = 0,n_elements(fidstruct)-1 do begin</span>
<span class="comments">;     im[fidstruct[i].subpx,fidstruct[i].subpy]=300</span>
<span class="comments">;     tyim[fidstruct[i].subpx,fidstruct[i].subpy]=300</span>
<span class="comments">; endfor</span>

<span class="comments">; somearea = (im*tyim)[34:74,88:128]</span>

somearea = im*tyim
atmp = somearea
somefactor = .5
fidfloor = 8000
s = size(somearea,/d)
threshold = mean(somearea) - somefactor*stddev(somearea)

<span class="comments">; this motherfucking for loop takes .02 s, same as other for loop</span>
for i = 2, s[0]-3 do begin
    for j = 2,s[1]-3 do begin
        <span class="comments">; The correlation value at some position</span>
        thisvalue = somearea[i,j]
        <span class="comments">; Check to see if it's less than the surrounding 8 pixels</span>
        if thisvalue lt threshold  and thisvalue gt fidfloor then begin
            if thisvalue lt somearea[i,j+1] and $
            thisvalue lt somearea[i,j-1] and $
            thisvalue lt somearea[i+1,j] and $
            thisvalue lt somearea[i-1,j] and $
            thisvalue lt somearea[i-1,j-1] and $
            thisvalue lt somearea[i-1,j+1] and $
            thisvalue lt somearea[i+1,j-1] and $
            thisvalue lt somearea[i+1,j+1] then begin
                <span class="comments">; Well it's not really picking it up</span>
                <span class="comments">; print,i,j</span>
                <span class="comments">; Look in the 16 pixels around the 8 pixels</span>
                if thisvalue lt somearea[i,j+2] and $
                thisvalue lt somearea[i,j-2] and $
                thisvalue lt somearea[i+2,j] and $
                thisvalue lt somearea[i-2,j] and $
                thisvalue lt somearea[i-2,j-1] and $
                thisvalue lt somearea[i-2,j+1] and $
                thisvalue lt somearea[i-1,j+2] and $
                thisvalue lt somearea[i+1,j+2] and $
                thisvalue lt somearea[i+2,j-1] and $
                thisvalue lt somearea[i+1,j+1] and $
                thisvalue lt somearea[i-1,j-2] and $
                thisvalue lt somearea[i+2,j-2] and $
                thisvalue lt somearea[i-2,j-2] and $
                thisvalue lt somearea[i-2,j+2] and $
                thisvalue lt somearea[i+2,j-2] and $
                thisvalue lt somearea[i+2,j+2] then begin
                    atmp[i,j] = 200000
                endif
            endif
        endif
    endfor
endfor


<span class="comments">; Where the fuck did this number come from</span>
<span class="comments">; .002 s to run for-loop</span>
<span class="comments">; 10x faster than old method</span>


loadct,15
cgimage,atmp,/k

<span class="comments">; Looking into alternative method instead of nested for loop</span>

tic
a=localmax(somearea,fidfloor,threshold)
toc

<span class="comments">; cgimage,im*tyim,/k</span>

<span class="comments">; 54,108</span>
<span class="comments">; 101,124</span>
<span class="comments">; 117,55</span>
<span class="comments">; 151,139</span>
<span class="comments">; 167,70</span>








stop

RETURN,1
end
</code>
    </div>
  </body>
</html>