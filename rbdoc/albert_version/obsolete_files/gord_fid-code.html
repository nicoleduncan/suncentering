<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Fri Jun 21 16:58:51 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gord_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gord_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION gord_fid, inputimage, inputstruct
<span class="comments">; Takes .01s</span>
crop = FLOAT(inputimage[inputstruct.limbxpos - !param.crop_box:inputstruct.limbxpos + !param.crop_box,inputstruct.limbypos - !param.crop_box:inputstruct.limbypos + !param.crop_box])

yt = total(crop,1)
xt = total(crop,2)

ysums = yt - smooth(yt,15)
xsums = xt - smooth(xt,15)

yfids = where(ysums le -150)
xfids = where(xsums le -150)

<span class="comments">; I can either eliminate adjacent piels (easier in the long run?) or just ignore them (faster)</span>

<span class="comments">; construct each pair, look to see if there is a nearby fiducial</span>
<span class="comments">; what qualifies a nearby fiducial?</span>
<span class="comments">; Probably needs to look at pixel values and do some sort of comparison of surroundig pixels</span>

<span class="comments">; 54,108</span>
<span class="comments">; 101,124</span>
<span class="comments">; 117,55</span>
<span class="comments">; 151,139</span>
<span class="comments">; 167,70</span>

<span class="comments">; 10:</span>
<span class="comments">; 54  55          70         101         102         116         117         118 136         151         152         166         167</span>
<span class="comments">; 54          55          70          71         108         123         124         139 140         155         199</span>

<span class="comments">; 15</span>
<span class="comments">; 54          55          70         101         102         116 117         118         136         151         152         166 167</span>
<span class="comments">; 24          39          54          55          70          71 108         123         124         139         140         155 199         215</span>


<span class="comments">; 20:</span>
<span class="comments">; 20          21          22          23          24          25          26          54 55          70         101         102         116         117         118         151 152         166         167         216         217         218         219         220</span>
<span class="comments">; 19          20          21          22          23          24          54          55 70          71         107         108         109         123         124         139 140         199         214         215         216         218</span>

<span class="comments">; Look at each looped coords</span>
<span class="comments">; Leftovers:</span>
<span class="comments">; x:</span>
<span class="comments">; y:</span>
<span class="comments">; 24 155 199</span>

<span class="comments">; im = crop</span>

<span class="comments">; fff = crop</span>

<span class="comments">; im[54-1:54+1,108-1:108+1]=255</span>
<span class="comments">; im[70-1:70+1, 39-1:39+1]=255</span>
<span class="comments">; im[101-1:101+1 , 124-1:124+1]=255</span>
<span class="comments">; im[117-1:117+1 , 55-1:55+1]=255</span>
<span class="comments">; im[151-1:151+1 , 139-1:139+1]=255</span>
<span class="comments">; im[167-1:167+1 , 70-1:70+1]=255</span>
<span class="comments">; im[136-1:136+1 , 215-1:215+1]=255</span>
<span class="comments">; ; 85 is not on the list. It's not on any list.</span>
<span class="comments">; im[86-1:86+1,199-1:199+1]=200</span>
<span class="comments">; im[208-1:208+1,155-1:155+1]=200</span>
<span class="comments">; im[237-1:237+1,24-1:24+1]=200</span>

<span class="comments">; r1 = im[54-15:54+15,108-15:108+15]</span>

<span class="comments">; ; how to id w/o convol? it'll take up a lot of time otherwise</span>
<span class="comments">; ; The problem is, the old way we found fiducials in the image as a whole</span>
<span class="comments">; ; Now we find rough locations but not really since we just have a list of coords where things look different, we'll have to look back at the data itself</span>

<span class="comments">; ; Leftover from 20 smoothed</span>
<span class="comments">; ; 23 218</span>
<span class="comments">; ; </span>

<span class="comments">; fff[54-1:54+1,108-1:108+1]=255</span>
<span class="comments">; fff[70-1:70+1, 39-1:39+1]=200</span>
<span class="comments">; fff[101-1:101+1 , 124-1:124+1]=255</span>
<span class="comments">; fff[117-1:117+1 , 55-1:55+1]=255</span>
<span class="comments">; fff[151-1:151+1 , 139-1:139+1]=255</span>
<span class="comments">; fff[167-1:167+1 , 70-1:70+1]=255</span>
<span class="comments">; fff[136-1:136+1 , 215-1:215+1]=200</span>
<span class="comments">; ; 85 is not on the list. It's not on any list.</span>
<span class="comments">; fff[86-1:86+1,199-1:199+1]=200</span>
<span class="comments">; ; fff[208-1:208+1,155-1:155+1]=200</span>
<span class="comments">; fff[237-1:237+1,24-1:24+1]=200</span>
<span class="comments">; ; fff[220-1:220+1,86-1:86+1]=200</span>

<span class="comments">; aa= [54,55,70,101,102,116,117,118,136,151,152,166,167]</span>
aa=xfids
aa= [0,aa,0]
bb = aa - shift(aa,1)
cc = aa[where(bb ne 1)]
xx = cc[1:-2]

<span class="comments">; aa = [24,39,54,55,70,71,108,123,124,139,140,155,199,215]</span>
aa=yfids
aa= [0,aa,0]
bb = aa - shift(aa,1)
cc = aa[where(bb ne 1)]
yy = cc[1:-2]

<span class="comments">; Breaks if indices aren't exactly consecutive</span>
somethresh=100
<span class="comments">; asd = crop</span>
<span class="comments">; tic</span>

fidpos = REPLICATE({fidpos,x:0.,y:0.,subx:0.,suby:0.},n_elements(xx)>n_elements(yy))

<span class="comments">; There's a better way to do this, shouldn't need to iterate through each possible combination</span>
k=0

<span class="comments">; if distance to fiducial from center of sun is > solar radius then don't use</span>
<span class="comments">; tic</span>

length = 31

for i = 0,n_elements(xx)-1 do begin
    for j = 0,n_elements(yy)-1 do begin
        <span class="comments">; To eliminate coords that are just solar pixels and not fiducials (on disk)</span>
        if crop[xx[i],yy[j]] lt 15 then begin

            aa = crop[xx[i]-15:xx[i]+15,yy[j]-15:yy[j]+15]
            <span class="comments">; do 2 1D convols on aa</span>
            <span class="comments">; length = (size(aa,/d))[0]</span>
            
            <span class="comments">; tic</span>
            <span class="comments">; gg = gaussfit(findgen(length),total(aa,1),nterms=5,chisq=achisq)</span>
            <span class="comments">; gg = gaussfit(findgen(length),total(aa,2),nterms=5,chisq=bchisq)</span>
            <span class="comments">; toc</span>

            <span class="comments">; smoothing is like 40X faster</span>
            <span class="comments">; tic</span>

            a=total(aa,1) <span class="comments">; Summing rows to get a y position profile</span>
            b=smooth(a,10)-a
            bw = where(b gt somethresh,n_bw)
            c=total(aa,2)
            d=smooth(a,10)-c
            dw = where(d gt somethresh,n_dw)

            <span class="comments">; !p.multi=[0,1,2]</span>
            <span class="comments">; ps_start,filename='1d1dsums_'+strcompress(i,/rem)+'_'+strcompress(j,/rem)+'.eps',/encap,charsize=1.2</span>
            <span class="comments">; plot,b,title='smooth(array,10)-array'</span>
            <span class="comments">; hline,100,linestyle=1</span>
            <span class="comments">; plot,d,title='smooth(array,10)-array'</span>
            <span class="comments">; hline,100,linestyle=1</span>
            <span class="comments">; ps_end</span>
            <span class="comments">; !p.multi=0</span>

            <span class="comments">; loadct,15</span>
            <span class="comments">; cgimage,aa,/k,output='1d1dcrop_'+strcompress(i,/rem)+'_'+strcompress(j,/rem)+'.eps',/nointerp</span>



            <span class="comments">; stop</span>


            <span class="comments">; if plots have elements > 100 then it's a fid</span>



            
            <span class="comments">; just look at 1D sums again</span>
            <span class="comments">; stop</span>
            <span class="comments">; print,achisq,bchisq</span>
            <span class="comments">; Need a better 'deciding' factor</span>
            <span class="comments">; if achisq gt 500 and bchisq gt 500 then begin</span>
                <span class="comments">; gg = gaussfit(findgen(length),total(aa,2),nterms=5,chisq=bchisq)</span>
            if n_bw ne 0 and n_dw ne 0 then begin
                <span class="comments">; asd[xx[i]-1:xx[i]+1,yy[j]-1:yy[j]+1] = 255 </span>
                <span class="comments">; if bchisq gt 20 then begin</span>
                <span class="comments">; stop</span>
                    fidpos[k].x=xx[i]
                    fidpos[k].y=yy[j]
                    <span class="comments">; fidpos[k].chisq = achisq</span>

                    <span class="comments">; Subpixel fitting with a gaussian, bro.</span>
                    <span class="comments">; makes the program 5X slower. CAN WE DO BETTER??</span>
                    <span class="comments">; Compared to parapeak, 10x slower</span>
                    
                    gg = gaussfit(findgen(length),total(aa,1),gga,nterms=5)
                    hh = gaussfit(findgen(length),total(aa,2),hha,nterms=5)
                    
                    <span class="comments">; [1] is the center term</span>
                    fidpos[k].subx = gga[1] + xx[i]-15
                    fidpos[k].suby = hha[1] + yy[j]-15








                    <span class="comments">; z = fltarr(3,3,/nozero)</span>
                    <span class="comments">; ; b is y position</span>
                    <span class="comments">; ; d is x</span>
                    
                    <span class="comments">; ; sometimes peak isn't the max...</span>
                    <span class="comments">; ; make pairs of rising/falling edges? Not rubust for limb fiducials.</span>

                    <span class="comments">; maxd = where(d eq max(d))</span>
                    <span class="comments">; maxb = where(b eq max(b))</span>
                    <span class="comments">; drr = d[maxd-1:maxd+1]</span>
                    <span class="comments">; brr = b[maxb-1:maxb+1]</span>
                    
                    <span class="comments">; z[0:2] = drr * brr[2]</span>
                    <span class="comments">; z[3:5] = drr * brr[1]</span>
                    <span class="comments">; z[6:8] = drr * brr[0]</span>
                    
                    <span class="comments">; result = parapeak(z)</span>
                    
                    <span class="comments">; ; let's go through and order these correctly, shall we</span>
                    <span class="comments">; ; think I added results in wrong order?</span>
                    <span class="comments">; subx = maxd + result[1] + xx[i] - 15</span>
                    <span class="comments">; suby = maxb + result[0] + yy[j] - 15</span>

                    <span class="comments">; print,''</span>
                    <span class="comments">; print,subx</span>
                    <span class="comments">; print,suby</span>
                    
                    k++
                    if k eq n_elements(xx)>n_elements(yy) then break
                <span class="comments">; endif</span>
            endif
        endif
    endfor
endfor
<span class="comments">; toc</span>

<span class="comments">; cgimage,asd,/k</span>
<span class="comments">; stop</span>




<span class="comments">; best5 = (fidpos[reverse(sort(fidpos.chisq))])[0:4]</span>
<span class="comments">; so the 5 most correlated aren't the best in reality</span>

<span class="comments">; this part is meant to work with a convolution...</span>
<span class="comments">; Now what?</span>
<span class="comments">; z = crop[xx[i]-1:xx[i]+1,yy[j]-1:yy[j]+1]</span>
<span class="comments">; result = paradip(z)</span>
<span class="comments">; fidpos[k].subpx = xx[i] + result[0]</span>
<span class="comments">; fidpos[k].subpy = yy[j] + result[1]</span>






<span class="comments">; ps_start,filename='gaussfitcomp.eps',/encap,xsize=6,ysize=7,/inches</span>
<span class="comments">; !p.multi=[0,1,4]</span>
<span class="comments">; qq = gaussfit(findgen(n_elements(total(q,1))),total(q,1),nterms=5,chisq=chisq)</span>
<span class="comments">; plot,total(q,1),title=textoidl("\chi^2/N=") + strcompress(chisq/length,/rem),/ys,/xs</span>
<span class="comments">; oplot,qq,linestyle=3,psym=-4</span>

<span class="comments">; qq = gaussfit(findgen(n_elements(total(q,2))),total(q,2),nterms=5,chisq=chisq)</span>
<span class="comments">; plot,total(q,2),title=textoidl("\chi^2/N=") + strcompress(chisq/length,/rem),/ys,/xs</span>
<span class="comments">; oplot,qq,linestyle=3,psym=-4</span>

<span class="comments">; qq = gaussfit(findgen(n_elements(total(ww,1))),total(ww,1),nterms=5,chisq=chisq)</span>
<span class="comments">; plot,total(ww,1),title=textoidl("\chi^2/N=") + strcompress(chisq/wl,/rem),/ys,/xs</span>
<span class="comments">; oplot,qq,linestyle=3,psym=-4</span>

<span class="comments">; qq = gaussfit(findgen(n_elements(total(ww,2))),total(ww,2),nterms=5,chisq=chisq)</span>
<span class="comments">; plot,total(ww,2),title=textoidl("\chi^2/N=") + strcompress(chisq/wl,/rem),/ys,/xs</span>
<span class="comments">; oplot,qq,linestyle=3,psym=-4</span>
<span class="comments">; ps_end</span>
<span class="comments">; !p.multi=0</span>



<span class="comments">; stop</span>
RETURN,fidpos
end
</code>
    </div>
  </body>
</html>