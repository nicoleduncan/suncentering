<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu May 23 17:43:18 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>corr_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="corr_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION corr_fid, inputimage, inputstruct
<span class="comments">; tic</span>
acrop = inputimage[inputstruct[0].limbxpos - !param.soldiskr : $
inputstruct[0].limbxpos + !param.soldiskr,$
inputstruct[0].limbypos - !param.soldiskr : inputstruct[0].limbypos + !param.soldiskr]

<span class="comments">; badcrop = acrop[0:-6,0:-4]</span>
badcrop = acrop
badcrop[where(badcrop eq max(badcrop))] = mode(badcrop)

s = size(badcrop,/dim)
kernel = [[0,1,0],[1,1,1],[0,1,0]]
kernel = [[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0]]
kernel = [[0,0,1,1,0,0],[0,0,1,1,0,0],[1,1,1,1,1,1],[1,1,1,1,1,1],[0,0,1,1,0,0],[0,0,1,1,0,0]]
<span class="comments">; image = c_correlate(badcrop,kernel,findgen(s))</span>
image = convol(float(badcrop),kernel,/edge_Truncate)

<span class="comments">; well, c++'s c_corr is like idl's convol()</span>

cgimage,image,/k
fidthresh = .5
pixelfiducials = indgen(s)
fidlength = 3
fidwidth=2
threshold = mean(image)  + fidthresh*stddev(image)
newthresh = mean(image)  + fidthresh/2*stddev(image)
<span class="comments">; wait, is their thresh thing so that the image peaks at a </span>

<span class="comments">; oh it does. /facepalm</span>

<span class="comments">; start at 1, not 0</span>
<span class="comments">; end at -2?</span>

fidpos = replicate({x:0.,y:0.,subpx:0.,subpy:0.},4)
ff=0
<span class="comments">; tic</span>
<span class="comments">; .002s to do the for-loops out of a total .003s</span>
<span class="comments">; This is actually slower than my method but doesn't need complicated functions</span>


<span class="comments">; should I make this faster in idl if I can't translate it directly to C++?</span>

<span class="comments">; so combining thisvalue lt threshold with the 4 adjacent checks makes it slower. why?</span>
tic

<span class="comments">; loop through:</span>
<span class="comments">; i s[0]-1 times</span>
<span class="comments">; j s[0]-1 times</span>
<span class="comments">; k 10+789+30+809 times</span>

<span class="comments">; shave off .0004s by moving these two lines out</span>
xpos = pixelfiducials mod s[0]
ypos = pixelfiducials/s[1]

for i = 1, s[0]-2 do begin
    for j = 1,s[1]-2 do begin
        thisvalue = image[i,j]
        if thisvalue lt threshold then begin
        <span class="comments">; print,'maybe a point'</span>
        <span class="comments">; 866 times thisvalue is lt threshold</span>
        <span class="comments">; c++</span>
        <span class="comments">; this condition below filters out a bunch of the stuff</span>
            if thisvalue lt image[i,j+1] and $
            thisvalue lt image[i,j-1] and $
            thisvalue lt image[i+1,j] and $
            thisvalue lt image[i-1,j] then begin
                <span class="comments">; print,'maybe a point' </span>
                <span class="comments">; 4 times!</span>
                redundant=0
                for k = 0, N_ELEMENTS(pixelfiducials)-1 do begin
                <span class="comments">; This part is being super-iterated</span>
                    if ABS(xpos[k] - i) lt fidlength*2 and $
                    ABS(ypos[k] - j) lt fidlength*2 then begin
                        redundant=1
                        thatvalue = image[xpos[k],ypos[k]]
                        if thisvalue lt thatvalue then begin
                            fidpos[ff].x = i
                            fidpos[ff].y = j
                            ff++
                            break 
                        endif
                    endif
                endfor
            endif
        endif
    endfor
endfor
toc

<span class="comments">; let's interp to subpixel values, yo.</span>
<span class="comments">; Let's try to do it Albert's way first</span>

<span class="comments">; It's already stupid fast as it is.</span>
<span class="comments">; tic</span>
<span class="comments">; for k = 0,n_elements(fidpos)-1 do begin</span>
<span class="comments">;     caa=0</span>
<span class="comments">;     cbb=0</span>
<span class="comments">;     avg=0</span>
<span class="comments">;     xrange = [fidpos[k].x - fidwidth,fidpos[k].x + fidwidth + 1]</span>
<span class="comments">;     yrange = [fidpos[k].y - fidwidth,fidpos[k].y + fidwidth + 1]</span>
<span class="comments">;     for aa = 0,xrange[1]-xrange[0] do begin</span>
<span class="comments">;         for bb = 0,yrange[1]-yrange[0] do begin</span>
<span class="comments">;             thisvalue = image[aa+xrange[0],bb+yrange[0]]</span>
<span class="comments">;             ; stop</span>
<span class="comments">;             if thisvalue lt newthresh then begin</span>
<span class="comments">;             ; print,"lawls"</span>
<span class="comments">;                 caa += aa*thisvalue</span>
<span class="comments">;                 cbb += bb*thisvalue</span>
<span class="comments">;                 avg += thisvalue</span>
<span class="comments">;             endif</span>
<span class="comments">;         endfor</span>
<span class="comments">;     endfor</span>
<span class="comments">;     fidpos[k].subpx=caa/avg+xrange[0]</span>
<span class="comments">;     fidpos[k].subpy=cbb/avg+yrange[0]</span>
<span class="comments">; endfor</span>
<span class="comments">; toc</span>
<span class="comments">; print,fidpos</span>


<span class="comments">; Let's use parapeak instead of mask centroiding</span>
<span class="comments">; It doesn't actually take a long time, only because it needs to compile a few necessary programs.</span>
<span class="comments">; tic</span>
for k = 0,n_elements(fidpos)-1 do begin
    <span class="comments">; Have to do 1/z because convol() makes the highest correlation area a low value </span>
    <span class="comments">; instead of cross_correlate's high value</span>

    z = 1000/image[fidpos[k].x-1:fidpos[k].x+1,fidpos[k].y-1:fidpos[k].y+1]
    <span class="comments">; the convol values are on the order of 10^3 so we have to normalize it! Makes sense. But this</span>
    <span class="comments">; means we have to normalzie it all the time?</span>
    result = parapeak(z)
    fidpos[k].subpx = fidpos[k].x + z[0]
    fidpos[k].subpy = fidpos[k].y + z[1]
endfor
<span class="comments">; toc</span>

<span class="comments">; How to deal with edge fiducials?</span>

RETURN,fidpos
END
</code>
    </div>
  </body>
</html>