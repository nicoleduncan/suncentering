<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.0 on Tue Feb 19 12:40:08 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>centerv4.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="centerv4.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">; At the end of the day this should find the center of the sun using a variety of (working) methods</span>
<span class="comments">;</span>
<span class="comments">; Compiled the doc with idldoc,root='/Users/jerensuzuki/Documents/suncentering', $</span>
<span class="comments">; output='rbdoc',format_style='rst',/user,/quiet,markup_style='rst'</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   JEREN SUZUKI::</span>
<span class="comments">;</span>
<span class="comments">;       Space Sciences Laboratory</span>
<span class="comments">;       7 Gauss Way</span>
<span class="comments">;       Berkeley, CA 94720 USA</span>
<span class="comments">;       E-mail: jsuzuki@ssl.berkeley.edu</span>
<span class="comments">;-</span>

PRO centerv4,file=file,ministrip_length=ministrip_length,scan_width=scan_width,time=time,order=order, $
    plot=plot,sigmavalue=sigmavalue,savstep=savstep,saveonly=saveonly,storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;       Finds the centroid using a variety of compression levels</span>
<span class="comments">;</span>
<span class="comments">;       Different from v2 in that this one is slightly more organized and uses a different version of</span>
<span class="comments">;       comp2v2.</span>
<span class="comments">;       </span>
<span class="comments">;       Important!:</span>
<span class="comments">;       IDL uses the origin to be the top left corner for 2d arrays and a column is indexed from 0</span>
<span class="comments">;       starting from the top. You have been WARNED.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='gauss1pix.tiff'</span>
<span class="comments">;       File to be read in      </span>
<span class="comments">;   ministrip_length: in, optional, type=byte, default=9</span>
<span class="comments">;       How long the cut-down strip is</span>
<span class="comments">;   scan_width: in, optional, type=byte, default = 10   </span>
<span class="comments">;       How far apart the scans are</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   order: in, optional, type=integer, default=3</span>
<span class="comments">;       What order polynomial to use for POLY_FIT()</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       If set, makes some nice plots.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be:: </span>
<span class="comments">;           </span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; :TODO: </span>
<span class="comments">;</span>
<span class="comments">;   More Keywords/parameters    </span>
<span class="comments">;</span>
<span class="comments">;   How strict are we going to be for the outputs of each compression file?</span>
<span class="comments">;</span>
<span class="comments">;   Deal with fiducials hitting the limb (Does it even matter?)</span>
<span class="comments">;</span>
<span class="comments">;   Deal with scan_width; scan_width=5 seems to produce some pretty good results.</span>
<span class="comments">;</span>
<span class="comments">;   I fixed the values being stuck, it was because I added to the index where the image value > thresh,</span>
<span class="comments">;   I should've subtracted instead. Note: Don't do that again.</span>
<span class="comments">;</span>
<span class="comments">;   Threshold value doesn't have a safety in terms of cosmic rays or single pixels with absurdly high</span>
<span class="comments">;   values. Got to have some sort of catch here just in case. </span>
<span class="comments">;-</span>

IF ~keyword_set(ministrip_length)   THEN    ministrip_length = 9
IF ~keyword_set(scan_width)         THEN    scan_width = 10
IF ~keyword_set(file)               THEN    file = 'Sun_Images_000000.bmp'
IF ~keyword_set(sigmavalue)         THEN    sigmavalue = 1
IF ~keyword_set(savstep)            THEN    savstep = 4
IF ~keyword_set(order)              THEN    order = 3

comp2v2,xpos,ypos,thresh,time=time,sigmavalue=sigmavalue,file=file
print,'Summing each point and average the X and Y positions:'
print,'X Center is ',xpos
print,'Y Center is ',ypos
print,'Threshold is ', thresh
print,''
xcs = xpos
ycs = ypos

comp3,xpos,ypos,thresh,time=time,sigmavalue=sigmavalue,file=file
print,'Looking at just the mask:'
print,'X Center is ',xpos
print,'Y Center is ',ypos
print,'Threshold is ', thresh
print,''
xcsn = xpos
ycsn = ypos

comp6v2,xpos,ypos,time=time,order=order,scan_width=scan_width,file=file,plot=plot,sigmavalue=sigmavalue,$
    ministrip_length=ministrip_length,savstep=savstep,saveonly=saveonly,storestruct=storestruct
print,'Limb-fitting:'
print,'X Center is ',xpos
print,'Y Center is ',ypos
print,''
print,'Difference in X Position from comp2v2',xcs-xpos
print,'Difference in Y Position from comp2v2',ycs-ypos
print,'Difference in X Position from comp3',xcsn-xpos
print,'Difference in Y Position from comp3',ycsn-ypos

<span class="comments">; writefits,'test.fits',[xpos,ypos]</span>
<span class="comments">; a=readfits('test.fits',header)</span>
restore,'bigstruct.sav'
<span class="comments">; stop</span>
<span class="comments">; writefits,'bigstruct.fits',[bigstruct]</span>
<span class="comments">; hdr = ['Some values','poo']</span>
<span class="comments">; mwrfits,(bigstruct.longxstrips)[0].ARRAY,'bigstruct.fits',/create</span>
<span class="comments">; writefits,'bigstruct.fits',(bigstruct.longxstrips)[0].ARRAY; b=readfits('bigstruct.fits')</span>
<span class="comments">; writefits,'bigstruct.fits',(bigstruct.longxstrips)[0].ARRAY</span>
<span class="comments">; writefits,'bigstruct.fits',(bigstruct.longxstrips)[0].ROWINDEX,/append</span>
<span class="comments">; writefits,'bigstruct.fits',(bigstruct.longxstrips)[0].SCAN_WIDTH,/append</span>
<span class="comments">; c=mrdfits('bigstruct.fits')</span>
<span class="comments">; f=readfits('bigstruct.fits')</span>
<span class="comments">; help,c</span>
<span class="comments">; help,f</span>
<span class="comments">; d=mrdfits('test.fits')</span>

<span class="comments">; This works, but only because I use readfits instead of mrdfits? Does it have something to </span>
<span class="comments">; do with the syntax of using mwrfits? </span>
<span class="comments">; mwrfits,[xpos,ypos],'e.fits',/create</span>
<span class="comments">; e=readfits('e.fits')</span>


<span class="comments">; ; so not even this works</span>
<span class="comments">; str = {garlic,x:0}</span>
<span class="comments">; ; str = findgen(100) ;if str is an array and not a structure, writefits doesn't complain</span>

<span class="comments">; writefits,'myfile.fits',str</span>
<span class="comments">; mwrfits,str,'myfile.fits',/create</span>
<span class="comments">; a=readfits('myfile.fits')</span>
<span class="comments">; help,a</span>


<span class="comments">; So I think I've figured our the source of the problem, it's maybe something to do with FXADDPAR</span>
<span class="comments">; not being up to date enough, but I haven't figured out a place to download a more recent </span>
<span class="comments">; version online. </span>

<span class="comments">; Also, I can't use writefits to write structures because that's something I can't do with </span>
<span class="comments">; writefits, unfortunately. There is only the capability to save arrays? Lame.</span>

<span class="comments">; So my options are to either find a more recent version of FXADDPAR (if that's even the problem)</span>
<span class="comments">; or find another way to save fits files. </span>

stop
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

FUNCTION scanboxv2,file=file,time=time,meanthresh=meanthresh,scan_width=scan_width,$
    savstep=savstep,saveonly=saveonly,sigmavalue=sigmavalue,storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description: </span>
<span class="comments">;       Boxit was too computation-intensive, this is more a rough boxing program. </span>
<span class="comments">;   Compared to scanbox, scanboxv2 uses knowledge of approx size of sun to only scan</span>
<span class="comments">;   until it hits the sun then moves the crop borders based on the given parameters.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file : in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Print the elapsed time</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;       max(image) - sigmavalue*stddev(image)</span>

<span class="comments">;   scan_width : in, optional, type=integer, default=5</span>
<span class="comments">;       How far apart the scanning should be. Fine tuned compared to scanbox</span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;       cropped = scanboxv2(file='$PWD/sep11_postit/104533_20120912_124300_353097_0.bin',/time)</span>
<span class="comments">;</span>
<span class="comments">;-</span>
IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scanwidth)  THEN scan_width = 5
IF ~keyword_set(sigmavalue)  THEN sigmavalue = 1

start = systime(1,/seconds)

<span class="comments">; Setting some parameters</span>
rowscan = 0
colscan = 0

IF STRPOS(file, 'tiff') NE -1  THEN BEGIN
    <span class="comments">; Read the tiff file</span>
    tmpimage = read_tiff(file)
    <span class="comments">; Get height AND width</span>
    s = size(tmpimage,/dimensions)
    n_col = s[1]
    n_row = s[2]
    <span class="comments">; Let's use vectors to reize the 3xn_colxn_row array</span>
    image = reform(tmpimage[0,*,*])
    sundiam = max(TOTAL(image gt max(image)/2, 1))+10
ENDIF

IF STRPOS(file, 'bmp') NE -1  THEN BEGIN
    tmpimage = read_bmp(file)
    s = size(tmpimage,/dimensions)
    n_col = s[1]
    n_row = s[2]
    image = reform(tmpimage[0,*,*])
    sundiam = 70 <span class="comments">;at it's widest, sun is 61 pixels across</span>
ENDIF

IF STRPOS(file, 'bin') NE -1  THEN BEGIN
    n_row       = 960
    n_col       = 1280
    <span class="comments">; These values are fixed for the model Prosilica GC 1290, we don't have to worry about making this </span>
    <span class="comments">; variable</span>
    tmpimage    = bytarr(n_col,n_row)
    image       = bytarr(n_col,n_row)

    openr,lun,file,/get_lun
    readu,lun,image
    free_lun,lun

    FOR i=0,n_row-1 DO BEGIN
        tmpimage[*,i] = image[*,n_row-1-i]
    ENDFOR

    image = flipimage
ENDIF


<span class="comments">; IF keyword_set(sigmavalue) THEN thresh = max(image) - sigmavalue*stddev(image) ELSE $</span>
<span class="comments">;     thresh = max(image) - stddev(image)</span>

<span class="comments">; Can't use above since it makes the thresh=190 which is way too high. Mean = 7.22, which is</span>
<span class="comments">; too low? max(image)/2. = 107 which is reasonable, imo.</span>
thresh = max(image)/2.
<span class="comments">; thresh = max(image) - 2*sigmavalue*stddev(image)</span>

<span class="comments">;Cmon Jeren you didn't dominate Radio Lab for nothing</span>

<span class="comments">; A counter to see how many rows/cols it takes to hit the sun</span>
WHILE n_elements(where(image[*,rowscan*scan_width] GT thresh)) EQ 1 DO BEGIN
    rowscan++
ENDWHILE
WHILE n_elements(where(image[colscan*scan_width,*] GT thresh)) EQ 1 DO BEGIN
    colscan++
ENDWHILE
    
rowendscan = rowscan + sundiam/scan_width <span class="comments">; Jumping to other side of sun</span>
colendscan = colscan + sundiam/scan_width

rowscan     -= 2
colscan     -= 2

cropped_image=image[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:rowendscan*scan_width]

<span class="comments">;for novelty purposes</span>
finish = systime(1,/seconds)
IF keyword_set(time) THEN  print, 'Elapsed Time for scanboxv2(): ' + $
    strcompress(finish-start,/remove)+ ' seconds'
<span class="comments">; save,cropped_image,filename='cropped_image.sav',/compress</span>
IF n_elements(saveonly) EQ 0 AND keyword_set(storestruct) THEN BEGIN
    bigstruct = {crop:cropped_image}
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
RETURN,cropped_image
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp2v2,xpos,ypos,thresh,file=file,time=time,plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Finds the centroid by summing all values over a certain threshold and averaging them.</span>
<span class="comments">;       Differs from comp2 in that this one uses a much, much more beautiful way to create the mask</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       Makes a nice plot</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=2</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;       max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       Having a sigmavalue=2 makes the pixels chosen from the sun more circular than sigmavalue=1</span>
<span class="comments">;</span>
<span class="comments">;           </span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required,type=float</span>
<span class="comments">;       X center</span>
<span class="comments">;   ypos: out, required,type=float</span>
<span class="comments">;       Y center</span>
<span class="comments">;   thresh: out, required,type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp2v2,xpos,ypos,thresh,time=time,sigmavalue=sigmavalue,file=file</span>
<span class="comments">;</span>
<span class="comments">;-</span>
IF ~keyword_set(file)   THEN file   = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(sigmavalue)  THEN sigmavalue = 2

cropped_image = scanboxv2(file=file,time=time)
start = systime(1,/seconds)

<span class="comments">; BEWARE:</span>
<span class="comments">; comp2v2 takes into account all pixels above acertain threshold, including fiducial marks. comp6v2 </span>
<span class="comments">; doesn't deal with what's going on in the non-limb parts of the sun. But in the case of a </span>
<span class="comments">; fiducial mark hitting the limb, what do we do?</span>


<span class="comments">; Allocating an array where values are above the threshold</span>
<span class="comments">; Funny thing, it's .0003 seconds faster to only run 1 instance of size()</span>
s = size(cropped_image,/dimensions)
n_col = s[0]
n_row = s[1]

<span class="comments">; LE TEMP</span>
<span class="comments">; **************</span>
<span class="comments">; thresh = max(cropped_image)/2</span>
thresh = max(cropped_image)-sigmavalue*stddev(cropped_image)
<span class="comments">; **************</span>

<span class="comments">;THIS IS BEAUTIFUL</span>
sunonly = cropped_image*(cropped_image gt thresh)
<span class="comments">;God damit this isn't fair how fast this is.</span>
sum     = TOTAL(sunonly)
xpos    = TOTAL( TOTAL(sunonly, 2) * Indgen(n_col) ) / sum
ypos    = TOTAL( TOTAL(sunonly, 1) * Indgen(n_row) ) / sum 

IF keyword_set(plot) THEN BEGIN
    cropped_image[*,ypos] = 0
    cropped_image[xpos,*] = 0
    cgimage,cropped_image,/keep_asp
    print,'X center is ',xpos
    print,'Y center is ',ypos
ENDIF

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print, 'Elapsed Time for comp2v2: ',strcompress(finish-start,/remove),' seconds'
RETURN
END 

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp3,xpos,ypos,thresh,file=file,time=time,plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Looks only at the positions of pixels above a threshold and doen't care</span>
<span class="comments">;       About their actual values, like in comp2v2. More "accurate" to find the</span>
<span class="comments">;       center than comp2v2 since this gives all solar pixels equal weighting.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       Makes a nice plot</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=2</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;       max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       Having a sigmavalue=2 makes the pixels chosen from the sun more circular than sigmavalue=1</span>
<span class="comments">;</span>
<span class="comments">;           </span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required,type=float</span>
<span class="comments">;       X center</span>
<span class="comments">;   ypos: out, required,type=float</span>
<span class="comments">;       Y center</span>
<span class="comments">;   thresh: out, required,type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp3,xpos,ypos,thresh,time=time,sigmavalue=sigmavalue,file=file</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)   THEN file   = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(sigmavalue)  THEN sigmavalue = 2

cropped_image = scanboxv2(file=file,time=time)

start = systime(1,/seconds)

thresh = max(cropped_image)-sigmavalue*stddev(cropped_image)

s = size(cropped_image,/dimensions)
n_col = s[0]
n_row = s[1]

suncheck = cropped_image gt thresh

xpos = TOTAL( TOTAL(suncheck, 2) * Indgen(n_col) ) / total(suncheck)
ypos = TOTAL( TOTAL(suncheck, 1) * Indgen(n_row) ) / total(suncheck)

finish = systime(1,/s)
IF keyword_set(time) THEN  print, 'Elapsed Time for comp3: ',strcompress(finish-start,/remove),' seconds'
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>


PRO comp3v2,xpos,ypos,thresh,file=file,time=time,plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Looks only at the positions of pixels above a threshold and doen't care</span>
<span class="comments">;       about their actual values, like in comp2v2. Different from comp3 in that this</span>
<span class="comments">;       version uses sort instead of the 2d array where</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       Makes a nice plot</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=2</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;       max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       Having a sigmavalue=2 makes the pixels chosen from the sun more circular than sigmavalue=1</span>
<span class="comments">;</span>
<span class="comments">;           </span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required,type=float</span>
<span class="comments">;       X center</span>
<span class="comments">;   ypos: out, required,type=float</span>
<span class="comments">;       Y center</span>
<span class="comments">;   thresh: out, required,type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp3,xpos,ypos,thresh,time=time,sigmavalue=sigmavalue,file=file</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(sigmavalue) THEN sigmavalue = 2
cropped_image = scanboxv2(file=file,time=time)

start = systime(1,/seconds)

thresh = max(cropped_image)-sigmavalue*stddev(cropped_image)

s = size(cropped_image,/dimensions)
n_col = s[0]
n_row = s[1]


start = systime(1,/seconds)
<span class="comments">; This seems super ineffective.</span>

<span class="comments">; Convert 2D to 1D</span>
a = cropped_image
<span class="comments">; Sort them by increasing values</span>
places = a[sort(a)]
<span class="comments">; Combine reindexed array with index values</span>
<span class="comments">; combined = [[places],[indices]]</span>
<span class="comments">; xloc = indices mod width_of_cropped_image</span>
<span class="comments">; yloc = indices/width_of_cropped_image</span>

<span class="comments">; This is just a really ineffcient method. Will do the other thing now. </span>
finish = systime(1,/s)
<span class="comments">; print,finish-start</span>

<span class="comments">; stop</span>

xpos = TOTAL( TOTAL(suncheck, 2) * Indgen(n_col) ) / total(suncheck)
ypos = TOTAL( TOTAL(suncheck, 1) * Indgen(n_row) ) / total(suncheck)

finish = systime(1,/s)
IF keyword_set(time) THEN  print, 'Elapsed Time for comp3: ',strcompress(finish-start,/remove),' seconds'
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp4, xstrips,ystrips,thresh,file=file,time=time,scan_width=scan_width,sigmavalue=sigmavalue,$
    savstep=savstep,saveonly=saveonly,storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Only used to save the strips into structures. </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;        max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xstrips: out, required, type=structure </span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips: out, required, type=structure </span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;   thresh: out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp4,xstrips,ystrips,thresh,/time,scan_width=10</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scan_width) THEN scan_width = 10
IF ~keyword_set(sigmavalue) THEN sigmavalue = 1

cropped_image = scanboxv2(file=file,time=time,savstep=savstep,saveonly=saveonly)

start = systime(1,/seconds)

thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue 
s = size(cropped_image,/dimensions)
length = s[0]
height = s[1]

rowchord_endpoints = fltarr(2,height/scan_width)
colchord_endpoints = fltarr(2,length/scan_width)

<span class="comments">; Counting the lenGTh of chords where cropped_image > thresh</span>
FOR i = 0,length/scan_width-1 DO BEGIN
    col_where = where(cropped_image[i*scan_width,*] GT thresh)
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,height/scan_width -1 DO BEGIN
    row_where = where(cropped_image[*,i*scan_width] GT thresh)
    <span class="comments">; beginning of chord</span>
    rowchord_endpoints[0,i] = row_where[0]
    <span class="comments">; end of chord</span>
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

xstrips = REPLICATE({ROWINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(length)},height/scan_width)
ystrips = REPLICATE({COLINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(height)},length/scan_width)

FOR i = 0,height/scan_width - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = cropped_image[*,i*scan_width]
ENDFOR

FOR k = 0,length/scan_width - 1 DO BEGIN
    ystrips[k].COLINDEX = k
    ystrips[k].ARRAY = cropped_image[k*scan_width,*]
ENDFOR

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for comp4: ',strcompress(finish-start,/rem),' seconds'
<span class="comments">; save,xstrips,ystrips,thresh,filename='comp4strips.sav',/compress</span>
IF savstep GE 2 AND n_elements(saveonly) EQ 0 AND keyword_set(storestruct) THEN BEGIN
    restore,'bigstruct.sav'
    longstrips = {longxstrips:xstrips,longystrips:ystrips,thresh:thresh}
    bigstruct = create_struct(bigstruct,longstrips)
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
IF savstep GE 2 AND n_elements(saveonly) NE 0 AND keyword_set(storestruct) THEN BEGIN
    bigstruct = {longxstrips:xstrips,longystrips:ystrips,thresh:thresh}
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp4v2, xstrips,ystrips,thresh,file=file,time=time,scan_width=scan_width,sigmavalue=sigmavalue,$
    savstep=savstep,saveonly=saveonly,nstrips=nstrips,storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Only used to save the strips into structures. Different from comp4 in that comp4v2</span>
<span class="comments">;           only saves 5 strips centered around the solar diameter to reduce the amount of limb-</span>
<span class="comments">;           darkened pixels and to make the polynomial-fitted limbs more-or-less look similar.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;        max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   nstrips: in, optional, type=byte, default=5</span>
<span class="comments">;       How many strips to select, centered around the row/col diameter</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xstrips: out, required, type=structure </span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips: out, required, type=structure </span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;   thresh: out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp4v2,xstrips,ystrips,thresh,/time,scan_width=10</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scan_width) THEN scan_width = 10
IF ~keyword_set(nstrips)    THEN nstrips = 5

cropped_image = scanboxv2(file=file,time=time,savstep=savstep,saveonly=saveonly)
comp3,xpos,ypos,time=time,sigmavalue=sigmavalue,file=file

start = systime(1,/seconds)

IF ~keyword_set(sigmavalue)  THEN sigmavalue = 1
thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue 

s = size(cropped_image,/dimensions)
length = s[0]
height = s[1]

rowchord_endpoints = fltarr(2,nstrips)
colchord_endpoints = fltarr(2,nstrips)

xstrips = REPLICATE({ROWINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(length)},nstrips)
ystrips = REPLICATE({COLINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(height)},nstrips)

FOR i = 0,nstrips - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = cropped_image[*, round(xpos)+(i-nstrips/2)*scan_width]
ENDFOR

FOR k = 0,nstrips - 1 DO BEGIN
    ystrips[k].COLINDEX = k
    ystrips[k].ARRAY = cropped_image[round(ypos)+(k-nstrips/2)*scan_width,*]
ENDFOR

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for comp4v2: ',strcompress(finish-start,/rem),' seconds'
<span class="comments">; save,xstrips,ystrips,thresh,filename='comp4v2strips.sav',/compress</span>
IF savstep GE 2 AND n_elements(saveonly) EQ 0 AND keyword_set(storestruct) THEN BEGIN
    restore,'bigstruct.sav'
    longstrips = {longxstrips:xstrips,longystrips:ystrips,thresh:thresh}
    bigstruct = create_struct(bigstruct,longstrips)
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
IF savstep GE 2 AND n_elements(saveonly) NE 0 AND keyword_set(storestruct) THEN BEGIN
    bigstruct = {longxstrips:xstrips,longystrips:ystrips,thresh:thresh}
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF

RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp5v3, xstrips,ystrips,thresh,file=file,time=time,ministrip_length=ministrip_length,$
        scan_width=scan_width,sigmavalue=sigmavalue,savstep=savstep,saveonly=saveonly,$
        storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Only used to save the cut-down strips into structures. Differs from comp5v2</span>
<span class="comments">;           in that this one uses comp4v2. That's it. </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   ministrip_length: in, optional, type=byte, default=13</span>
<span class="comments">;       How long the total array of the cut-down strip will be</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;   </span>
<span class="comments">;    max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;   </span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xstrips: out, required, type=structure</span>
<span class="comments">;       Contains the row sctructures of strips</span>
<span class="comments">;   ystrips: out, required, type=structure</span>
<span class="comments">;       Contains the col sctructures of strips</span>
<span class="comments">;   thresh: out, required, type=float</span>
<span class="comments">;       Threshold value used </span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp5v3,xstrips,ystrips,thresh</span>
<span class="comments">;</span>
<span class="comments">; :TODO:</span>
<span class="comments">;</span>
<span class="comments">;   Exactly how much data should be stored in a structure? Since we're interested in saving space,</span>
<span class="comments">;   doesn't make sense to repeat any data in the structures.</span>
<span class="comments">;-</span>

IF ~keyword_set(file)               THEN file               = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scan_width)         THEN scan_width         = 10 
IF ~keyword_set(ministrip_length)   THEN ministrip_length   = 9 

comp4v2,c4xstrips,c4ystrips,thresh,file=file,time=time,sigmavalue=sigmavalue,scan_width=scan_width,$
    savstep=savstep,saveonly=saveonly

start = systime(1,/seconds)

ministrip_side_buffer = ministrip_length/2 
rowchord_endpoints = fltarr(2,n_elements(c4xstrips))
colchord_endpoints = fltarr(2,n_elements(c4ystrips))

<span class="comments">;   Seeing where the array starts to be greater than the thresh</span>
FOR i = 0,n_elements(c4ystrips)-1 DO BEGIN
    col_where = where(c4ystrips[i].ARRAY GT thresh)
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,n_elements(c4xstrips) -1 DO BEGIN
    row_where = where(c4xstrips[i].ARRAY GT thresh)
    rowchord_endpoints[0,i] = row_where[0]
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

<span class="comments">; Preallocating the array, replicating it by the number of strips there are</span>
xstrips = REPLICATE({ROWINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},n_elements(c4xstrips))
ystrips = REPLICATE({COLINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},n_elements(c4ystrips))


<span class="comments">;Filling out structure with cut-down strip information</span>
FOR i = 0,n_elements(c4xstrips) - 1 DO BEGIN
    xstrips[i].ROWINDEX     = c4xstrips[i].ROWINDEX
    <span class="comments">; If there is no strip that cuts through the sun, set things to 0</span>
    IF rowchord_endpoints[0,i] EQ -1 THEN BEGIN
        xstrips[i].STARTPOINTS  = fltarr(ministrip_length) 
        xstrips[i].BEGINDEX     = 0
    ENDIF ELSE BEGIN
        <span class="comments">; STARTPOINTS is the cut down strip with length = ministrip_length and contains</span>
        <span class="comments">; the indices from rowchord_endpoints[0,i] +/- ministrip_side_buffer</span>
        xstrips[i].STARTPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[0,i]-ministrip_side_buffer: $
            rowchord_endpoints[0,i]+ministrip_side_buffer]   
        <span class="comments">; BEGINDEX is the index of the strip where it begins. </span>
        <span class="comments">; e.g., the array is 5 long, starts from index 9 and is centered around index 11</span>
        xstrips[i].BEGINDEX     = fix(rowchord_endpoints[0,i] - ministrip_side_buffer)
    ENDELSE
    IF rowchord_endpoints[1,i] EQ -1 THEN BEGIN
        xstrips[i].ENDPOINTS    = fltarr(ministrip_length)
        xstrips[i].ENDINDEX    = 0
    ENDIF ELSE BEGIN
        xstrips[i].ENDPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[1,i]-ministrip_side_buffer: $
            rowchord_endpoints[1,i]+ministrip_side_buffer]   
        xstrips[i].ENDINDEX     = fix(rowchord_endpoints[1,i] - ministrip_side_buffer)
    ENDELSE
ENDFOR

FOR k = 0,n_elements(c4ystrips) - 1 DO BEGIN
    ystrips[k].COLINDEX     = c4ystrips[k].COLINDEX
    IF colchord_endpoints[0,k] EQ -1 THEN BEGIN
        ystrips[k].STARTPOINTS  = fltarr(ministrip_length) 
        ystrips[k].BEGINDEX     = 0
    ENDIF ELSE BEGIN 
        ystrips[k].STARTPOINTS  = (c4ystrips[k].ARRAY)[colchord_endpoints[0,k]- $
            ministrip_side_buffer:colchord_endpoints[0,k]+ministrip_side_buffer]
        ystrips[k].BEGINDEX     = fix(colchord_endpoints[0,k] - ministrip_side_buffer)
    ENDELSE
    IF colchord_endpoints[1,k] EQ -1 THEN BEGIN
        ystrips[k].ENDPOINTS    = fltarr(ministrip_length) 
        ystrips[k].ENDINDEX     = 0        
    ENDIF ELSE BEGIN
        ystrips[k].ENDPOINTS    = (c4ystrips[k].ARRAY)[colchord_endpoints[1,k]- $
        ministrip_side_buffer:colchord_endpoints[1,k]+ministrip_side_buffer]
        ystrips[k].ENDINDEX     = fix(colchord_endpoints[1,k] - ministrip_side_buffer) 
    ENDELSE
ENDFOR
finish = systime(1,/seconds)

IF keyword_set(time) THEN  print,'Elapsed Time for comp5v3: ',strcompress(finish-start,/rem),' seconds'
IF savstep GE 3 AND n_elements(saveonly) EQ 0 AND keyword_set(storestruct) THEN BEGIN
    shortstrips = {shortxstrips:xstrips,shortystrips:ystrips,scan_width:scan_width,sigmavalue:sigmavalue,$
        ministrip_length:ministrip_length}
    restore,'bigstruct.sav'
    bigstruct = create_struct(bigstruct,shortstrips)
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
IF savstep GE 3 AND n_elements(saveonly) NE 0 AND keyword_set(storestruct) THEN BEGIN
    bigstruct = {shortxstrips:xstrips,shortystrips:ystrips,scan_width:scan_width,sigmavalue:sigmavalue,$
        ministrip_length:ministrip_length}
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp6v2,xpos,ypos,file=file,order=order,time=time,scan_width=scan_width,$
    ministrip_length=ministrip_length,plot=plot,sigmavalue=sigmavalue,savstep=savstep,$
    saveonly=saveonly,storestruct=storestruct
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;       Uses the data from comp5v3 and draws a linear/quadratic/cubic/etc. function to find midpoint.</span>
<span class="comments">;       Order is the power of the function. Different from comp6 in that this method uses fz_roots()</span>
<span class="comments">;       and comp6 uses spline to interpolate where the limb crosses a threshold. Imports the strips</span>
<span class="comments">;       from comp5v3.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Ondicates how far apart to scan</span>
<span class="comments">;   order: in, optional, type=integer, default=3</span>
<span class="comments">;       What order polynomial to use for POLY_FIT()</span>
<span class="comments">;   ministrip_length: in, optional, default=9</span>
<span class="comments">;       How long the trimmed down strip will be</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       If set, makes some nice plots.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;    max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;   savstep: in, required, type=integer, default=4</span>
<span class="comments">;       The number of steps to include in the fits file. </span>
<span class="comments">;       savstep = 1: cropped image</span>
<span class="comments">;       savstep = 2: long strips</span>
<span class="comments">;       savstep = 3: limb strips</span>
<span class="comments">;       savstep = 4: center of mask</span>
<span class="comments">;   saveonly: in, optional</span>
<span class="comments">;       Determines whether or not savstep saves steps leading up to savstep or just savstep</span>
<span class="comments">;   storestruct: in, optional</span>
<span class="comments">;       Toggles whether or not we want to save data at all</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required, type=float</span>
<span class="comments">;       X Center</span>
<span class="comments">;   ypos: out, required, type=float</span>
<span class="comments">;       Y Center</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp6,xpos,ypos,order=3     </span>
<span class="comments">;</span>
<span class="comments">;-</span>

<span class="comments">; Setting default values</span>
IF ~keyword_set(file)               THEN file = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(order)              THEN order = 3
IF ~keyword_set(ministrip_length)   THEN ministrip_length = 9

<span class="comments">; Run the program to get our structures</span>
comp5v3,xstrips,ystrips,thresh,file=file,time=time,ministrip_length=ministrip_length,$
    sigmavalue=sigmavalue,scan_width=scan_width,savstep=savstep,saveonly=saveonly

start = systime(1,/seconds)

ministrip_side_length = ministrip_length/2
xlen    = 0
xsum    = 0
xnum    = 0   
ylen    = 0
ysum    = 0
ynum    = 0
xarr    = findgen(n_elements(xstrips[4].STARTPOINTS))
yarr    = findgen(n_elements(ystrips[4].STARTPOINTS))
tx      = findgen(n_elements(xstrips[4].STARTPOINTS) * 1000)/100
ylenarr = findgen(n_elements(ystrips))
xlenarr = findgen(n_elements(xstrips))

<span class="comments">;Deal with rows</span>
FOR n=0,n_elements(xstrips)-1 DO BEGIN
    <span class="comments">; Using fz_roots instead of spline interpolating. Saving lines and making code more readable</span>
    startresult     = reform(poly_fit(xarr,xstrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(xarr,xstrips[n].ENDPOINTS,order))

    <span class="comments">; Solving for roots but want to include threshold value</span>
    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF xstrips[n].BEGINDEX GT 0 THEN BEGIN
        <span class="comments">; Get roots (complex)</span>
        begroots    = fz_roots(startresult)
        <span class="comments">; Take only roots with no imaginary components</span>
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        <span class="comments">; Find smallest root (apparently I have to choose the smaller one)</span>
        <span class="comments">; Or i can find the midpoints using the other two roots then take the average of the two,</span>
        <span class="comments">; that way works too, but why would I do that?</span>
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = xstrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF xstrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = xstrips[n].ENDINDEX + endusable
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    <span class="comments">; Stick the midpoints in an array to take the mean of later</span>
    xlenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

FOR n=0,n_elements(ystrips)-1 DO BEGIN
    startresult     = reform(poly_fit(yarr,ystrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(yarr,ystrips[n].ENDPOINTS,order))

    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF ystrips[n].BEGINDEX GT 0 THEN BEGIN
        begroots    = fz_roots(startresult)
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = ystrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF ystrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = ystrips[n].ENDINDEX + endusable
        
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    ylenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = mean(xlenarr[where(xlenarr ne 0)])
ypos = mean(ylenarr[where(ylenarr ne 0)])

IF keyword_set(plot) THEN BEGIN
    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,0
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>

    wn = 5
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,3
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,1
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>


    
ENDIF
<span class="comments">; Just an aside, but plotting adds ~ .1 seconds to bring it up to .22 seconds total</span>

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for comp6v2: ',strcompress(finish-start,/rem),' seconds'
<span class="comments">; save,xpos,ypos,thresh,sigmavalue,order,file, ministrip_length,scan_width,$</span>
<span class="comments">;     filename='comp6results.sav',/compress</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>

<span class="comments">; OPENW,1,'comp6results.dat' </span>
<span class="comments">; PRINTF,1,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,1</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>
<span class="comments">; OPENW,2,'comp6results.txt' </span>
<span class="comments">; PRINTF,2,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,2</span>

IF savstep EQ 4 AND n_elements(saveonly) EQ 0 AND keyword_set(storestruct) THEN BEGIN
    restore,'bigstruct.sav'
    stuff = {xpos:xpos,ypos:ypos,order:order}
    bigstruct = create_struct(stuff,bigstruct)
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF
IF savstep EQ 4 AND n_elements(saveonly) NE 0 AND keyword_set(storestruct) THEN BEGIN
    bigstruct = {xpos:xpos,ypos:ypos,order:order}
    save,bigstruct,filename='bigstruct.sav',/compress
ENDIF

RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
</code>
    </div>
  </body>
</html>