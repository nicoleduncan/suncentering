<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.0 on Thu Dec  6 10:37:49 2012 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>rb.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="rb.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">; At the end of the day this should find the center of the sun using a variety of (working) methods</span>
<span class="comments">;</span>
<span class="comments">; Compiled the doc with idldoc,root='/Users/jerensuzuki/Documents/suncentering', $</span>
<span class="comments">; output='rbdoc',format_style='rst',/user,/quiet,markup_style='rst'</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   JEREN SUZUKI::</span>
<span class="comments">;</span>
<span class="comments">;       Space Sciences Laboratory</span>
<span class="comments">;       7 Gauss Way</span>
<span class="comments">;       Berkeley, CA 94720 USA</span>
<span class="comments">;       E-mail: jsuzuki@ssl.berkeley.edu</span>
<span class="comments">;-</span>

FUNCTION scanbox,file=file,time=time,meanthresh=meanthresh,scan_width=scan_width
<span class="comments">;+</span>
<span class="comments">; :Description: </span>
<span class="comments">;       Boxit was too computation-intensive, this is more a rough boxing program</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file : in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Print the elapsed time</span>
<span class="comments">;   meanthresh : in, optional</span>
<span class="comments">;       Use the average of the image as the threshold value. Otherwise, use half of max</span>
<span class="comments">;   scan_width : in, optional, type=integer, default=20</span>
<span class="comments">;       How far apart the scanning should be</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;       cropped = scanbox(file='$PWD/sep11_postit/104533_20120912_124300_353097_0.bin',/time)</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; for novelty</span>
start = systime(1,/seconds)
IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scanwidth)  THEN scan_width = 20

<span class="comments">; Setting some parameters</span>
newi    = 0
newj    = 0
xpos    = 0
ypos    = 0

<span class="comments">; Using this statement so we don't need a bmp keyword</span>
<span class="comments">; Actually, let's use a better switch. </span>
<span class="comments">; tiff, bin, bmp, should be able to accept any of these no-problemo.</span>
IF STRPOS(file, 'tiff') NE -1  THEN BEGIN
    <span class="comments">; Read the bmp file</span>
    tmpimage = read_tiff(file)
    <span class="comments">; Get height AND width</span>
    n_col = (size(tmpimage,/dimensions))[1]
    n_row = (size(tmpimage,/dimensions))[2]
    
    <span class="comments">; Let's use vectors to reize the 3xn_colxn_row array</span>
    image = reform(tmpimage[0,*,*])

    <span class="comments">;Just some thresholds</span>
    themean = mean(image)
    halfmax = max(image)/2
    IF keyword_set(meanthresh) THEN thresh = themean ELSE thresh = halfmax

    <span class="comments">;Cmon Jeren you didn't dominate Radio Lab for nothing</span>

    <span class="comments">; A counter to see how many rows/cols it takes to hit the sun</span>
    rowscan = 0
    colscan = 0
    WHILE n_elements(where(image[*,rowscan*scan_width] GT thresh)) EQ 1 DO BEGIN
        rowscan+=1
    ENDWHILE
    WHILE n_elements(where(image[colscan*scan_width,*] GT thresh)) EQ 1 DO BEGIN
        colscan+=1
    ENDWHILE
    <span class="comments">; print,'Picked up sun on ',strcompress(rowscan,/rem),'rd row'</span>
    <span class="comments">; print,'Picked up sun on ',strcompress(colscan,/rem),'rd col'</span>

    <span class="comments">; Now using a counter to see how many rows/cols it takes to get off the sun</span>
    rowendscan = rowscan
    colendscan = colscan

    WHILE n_elements(where(image[*,rowendscan*scan_width] GT thresh)) GT 1 DO BEGIN
        rowendscan+=1
    ENDWHILE
    WHILE n_elements(where(image[colendscan*scan_width,*] GT thresh)) GT 1 DO BEGIN
        colendscan+=1
    ENDWHILE    

    <span class="comments">; print,rowendscan,' more rows until no more Sun'</span>
    <span class="comments">; print,colendscan,' more cols until no more Sun'</span>

    <span class="comments">; image[*,scan_width*findgen(n_row/scan_width)] = 0</span>
    <span class="comments">; image[scan_width*findgen(n_col/scan_width),*] = 0</span>
    <span class="comments">; cgimage,image,/keep_asp</span>

    <span class="comments">; Giving ourself a little leeway</span>
    <span class="comments">; Gives inconsistent image sizes</span>
    rowendscan  += 1
    rowscan     -= 1
    colendscan  += 1
    colscan     -= 1

    <span class="comments">; Preallocating a cropped array that we'll fill with values based on limits</span>
    cropped_image = bytarr((colendscan-colscan)*scan_width,(rowendscan-rowscan)*scan_width)

    <span class="comments">; Is the i,j index between the cropped limits? If so, assign image[i,j] value to cropped_image</span>
    FOR j=0,n_row-1 DO BEGIN
        FOR i = 0,n_col-1 DO BEGIN
            IF (i GT colscan*scan_width) AND $
            (i lt colendscan*scan_width) AND $
            (j GT rowscan*scan_width) AND $
            (j lt rowendscan*scan_width) THEN BEGIN
                cropped_image[newi,newj] = image[i,j]
                newi+=1 
            ENDIF
            IF newi EQ (colendscan-colscan)*scan_width-1 THEN BEGIN
                newj+=1
                newi=0
            ENDIF
        ENDFOR
    ENDFOR
    <span class="comments">; And we're done with that.</span>
ENDIF ELSE BEGIN

    <span class="comments">; Haven't touched this since I started with the new bmp file</span>
    n_row       = 960
    n_col       = 1280
    flipimage   = bytarr(n_col,n_row)
    image       = bytarr(n_col,n_row)

    <span class="comments">; These values are fixed for the model Prosilica GC 1290, we don't have to worry about making this </span>
    <span class="comments">; variable</span>
    openr,lun,file,/get_lun
    readu,lun,image
    free_lun,lun

    FOR i=0,n_row-1 DO BEGIN
        flipimage[*,i] = image[*,n_row-1-i]
    ENDFOR

    <span class="comments">; Only here so I keep consistent</span>
    image = flipimage

    themean = mean(flipimage)
    halfmax = max(flipimage)/2
    IF keyword_set(meanthresh) THEN thresh = themean ELSE thresh = halfmax

    <span class="comments">; A counter to see how many rows/cols it takes to hit the sun</span>
    rowscan = 0
    colscan = 0
    WHILE n_elements(where(image[*,rowscan*scan_width] GT thresh)) EQ 1 DO BEGIN
        rowscan+=1
    ENDWHILE
    WHILE n_elements(where(image[colscan*scan_width,*] GT thresh)) EQ 1 DO BEGIN
        colscan+=1
    ENDWHILE

    <span class="comments">; Now using a counter to see how many rows/cols it takes to get off the sun</span>
    rowendscan = rowscan
    colendscan = colscan

    WHILE n_elements(where(image[*,rowendscan*scan_width] GT thresh)) GT 1 DO BEGIN
        rowendscan+=1
    ENDWHILE
    WHILE n_elements(where(image[colendscan*scan_width,*] GT thresh)) GT 1 DO BEGIN
        colendscan+=1
    ENDWHILE    

    <span class="comments">; Giving ourself a little leeway</span>
    <span class="comments">; Gives inconsistent image sizes, need to change</span>
    rowendscan  += 1
    rowscan     -= 1
    colendscan  += 1
    colscan     -= 1

    <span class="comments">; Preallocating a cropped array that we'll fill with values based on limits</span>
    cropped_image = bytarr((colendscan-colscan)*scan_width,(rowendscan-rowscan)*scan_width)

    <span class="comments">; Is the i,j index between the cropped limits? If so, assign image[i,j] value to cropped_image</span>
    FOR j=0,n_row-1 DO BEGIN
        FOR i = 0,n_col-1 DO BEGIN
            IF (i GT colscan*scan_width) AND $
            (i lt colendscan*scan_width) AND $
            (j GT rowscan*scan_width) AND $
            (j lt rowendscan*scan_width) THEN BEGIN
                cropped_image[newi,newj] = image[i,j]
                newi+=1 
            ENDIF
            IF newi EQ (colendscan-colscan)*scan_width-1 THEN BEGIN
                newj+=1
                newi=0
            ENDIF
        ENDFOR
    ENDFOR
ENDELSE

<span class="comments">;for novelty purposes</span>
finish = systime(1,/seconds)
IF keyword_set(time) THEN  print, 'Elapsed Time for scanbox(): ' + $
    strcompress(finish-start,/remove)+ ' seconds'
RETURN,cropped_image
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp2,xpos,ypos,thresh,file=file,time=time,plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Finds the centroid by summing all values over a certain threshold and averaging them </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       Makes a nice plot</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;           </span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required,type=float</span>
<span class="comments">;       X center</span>
<span class="comments">;   ypos: out, required,type=float</span>
<span class="comments">;       Y center</span>
<span class="comments">;   thresh: out, required,type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp2,xpos,ypos,/plot</span>
<span class="comments">;</span>
<span class="comments">;-</span>
IF ~keyword_set(file)   THEN file   = '104533_20120911_153147_254618_0.bin'
cropped_image = scanbox(file='nogauss.tiff',time=time)
IF keyword_set(sigmavalue)  THEN thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue ELSE $
thresh = max(cropped_image) - stddev(cropped_image)


start = systime(1,/seconds)

<span class="comments">; Allocating an array where values are above the threshold</span>
<span class="comments">; Funny thing, it's .0003 seconds faster to only run 1 instance of size()</span>
s = size(cropped_image,/dimensions)
n_col = s[0]
n_row = s[1]
sunonly = bytarr(n_col,n_row)

<span class="comments">; Doing the thing I just allocated for</span>
FOR i = 0,n_col-1 DO BEGIN
    FOR j = 0,n_row - 1 DO BEGIN
        IF cropped_image[i,j] GT thresh THEN sunonly[i,j] = cropped_image[i,j]
    ENDFOR
ENDFOR

sum     = Total(sunonly)
xpos    = Total( Total(sunonly, 2) * Indgen(n_col) ) / sum
ypos    = Total( Total(sunonly, 1) * Indgen(n_row) ) / sum 

IF keyword_set(plot) THEN BEGIN
    cropped_image[*,ypos] = 0
    cropped_image[xpos,*] = 0
    cgimage,cropped_image,/keep_asp
    print,'X center is ',xpos
    print,'Y center is ',ypos
ENDIF

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print, 'Elapsed Time for comp2: ',strcompress(finish-start,/remove),' seconds'
RETURN
END 

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp4, xstrips,ystrips,thresh,file=file,time=time,scan_width=scan_width,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Only used to save the strips into structures. </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xstrips: out, required, type=structure </span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips: out, required, type=structure </span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;   thresh: out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp4,xstrips,ystrips,thresh,/time,scan_width=10,/thalf</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scan_width) THEN scan_width = 10 ELSE scan_width = scan_width

cropped_image = scanbox(file='Sun_Images_000000.bmp',time=time)
IF keyword_set(sigmavalue)  THEN thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue ELSE $
thresh = max(cropped_image) - stddev(cropped_image)

start = systime(1,/seconds)

<span class="comments">; cgimage,cropped_image,/keep_asp</span>
s = size(cropped_image,/dimensions)
length = s[0]
height = s[1]

<span class="comments">; Getting some values</span>
col_chords = fltarr(length/scan_width)
row_chords = fltarr(height/scan_width)

rowchord_endpoints = fltarr(2,height/scan_width)
colchord_endpoints = fltarr(2,length/scan_width)

<span class="comments">; Counting the lenGTh of chords where cropped_image > thresh</span>
FOR i = 0,length/scan_width-1 DO BEGIN
    col_where = where(cropped_image[i*scan_width,*] GT thresh,col_num)
    col_chords[i] = col_num
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,height/scan_width -1 DO BEGIN
    row_where = where(cropped_image[*,i*scan_width] GT thresh,row_num)
    row_chords[i] = row_num
    <span class="comments">; beginning of chord</span>
    rowchord_endpoints[0,i] = row_where[0]
    <span class="comments">; end of chord</span>
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

xstrips = REPLICATE({ROWINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(length)},height/scan_width)
ystrips = REPLICATE({COLINDEX:0,SCAN_WIDTH:scan_width,ARRAY:bytarr(height)},length/scan_width)

FOR i = 0,height/scan_width - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = cropped_image[*,i*scan_width]
ENDFOR

FOR k = 0,length/scan_width - 1 DO BEGIN
    ystrips[k].COLINDEX = k
    ystrips[k].ARRAY = cropped_image[k*scan_width,*]
ENDFOR

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for comp4: ',strcompress(finish-start,/rem),' seconds'
save,xstrips,ystrips,thresh,filename='comp4strips.sav',/compress
<span class="comments">; Holy shit this is 2 KB. So much unnecessary data</span>
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp5, xstrips,ystrips,thresh,file=file,time=time,ministrip_length=ministrip_length,$
        scan_width=scan_width,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;           Only used to save the cut-down strips into structures. </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   ministrip_length: in, optional, type=byte, default=23</span>
<span class="comments">;       How long the total array of the cut-down strip will be</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xstrips: out, required, type=structure</span>
<span class="comments">;       Contains the row sctructures of strips</span>
<span class="comments">;   ystrips: out, required, type=structure</span>
<span class="comments">;       Contains the col sctructures of strips</span>
<span class="comments">;   thresh: out, required, type=float</span>
<span class="comments">;       Threshold value used </span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp5,xstrips,ystrips,thresh</span>
<span class="comments">;</span>
<span class="comments">;-</span>

IF ~keyword_set(file)       THEN file       = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(scan_width) THEN scan_width = 10 ELSE scan_width = scan_width
<span class="comments">; cropped_image = scanbox(file='Sun_Images_000000.bmp',time=time)</span>
cropped_image = scanbox(file=file,time=time)

<span class="comments">; Trying a new threshold instead of the mean</span>
IF keyword_set(sigmavalue)  THEN thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue ELSE $
thresh = max(cropped_image) - stddev(cropped_image)

start = systime(1,/seconds)

<span class="comments">; cgimage,cropped_image,/keep_asp</span>
s = size(cropped_image,/dimensions)
length = s[0]
height = s[1]

<span class="comments">; Getting some values</span>
col_chords = fltarr(length/scan_width)
row_chords = fltarr(height/scan_width)

rowchord_endpoints = fltarr(2,height/scan_width)
colchord_endpoints = fltarr(2,length/scan_width)

<span class="comments">; Counting the length of chords where cropped_image > thresh</span>
FOR i = 0,length/scan_width-1 DO BEGIN
    col_where = where(cropped_image[i*scan_width,*] GT thresh,col_num)
    col_chords[i] = col_num
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
    <span class="comments">; if i eq 2 then stop</span>
ENDFOR

FOR i = 0,height/scan_width -1 DO BEGIN
    row_where = where(cropped_image[*,i*scan_width] GT thresh,row_num)
    row_chords[i] = row_num
    <span class="comments">; beginning of chord</span>
    rowchord_endpoints[0,i] = row_where[0]
    <span class="comments">; end of chord</span>
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

<span class="comments">; Setting the length of the cut dowen array</span>
IF ~keyword_set(ministrip_length) THEN ministrip_length = 23
ministrip_side_buffer = ministrip_length/2 

<span class="comments">; Preallocating the array, replicating it by the number of strips there are</span>
xstrips = REPLICATE({ROWINDEX:0,SCAN_WIDTH:scan_width, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},height/scan_width)
ystrips = REPLICATE({COLINDEX:0,SCAN_WIDTH:scan_width, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},length/scan_width)

<span class="comments">;Filling out structure with cut-down strip information</span>
FOR i = 0,height/scan_width - 1 DO BEGIN
    xstrips[i].ROWINDEX     = i
    <span class="comments">; If there is no strip that cuts through the sun, set things to 0</span>
    IF rowchord_endpoints[0,i] EQ -1 THEN BEGIN
        xstrips[i].STARTPOINTS  = fltarr(ministrip_length) 
        xstrips[i].BEGINDEX     = 0
    ENDIF ELSE BEGIN
        <span class="comments">; STARTPOINTS is the cut down strip with length = ministrip_length and contains</span>
        <span class="comments">; the indices from rowchord_endpoints[0,i] +/- ministrip_side_length </span>
        xstrips[i].STARTPOINTS  = $
            cropped_image[rowchord_endpoints[0,i]-ministrip_side_buffer: $
            rowchord_endpoints[0,i]+ministrip_side_buffer,i*scan_width]
        <span class="comments">; BEGINDEX is the index of the strip where it begins. </span>
        <span class="comments">; e.g., the array is 5 long, starts from index 9 and is centered around index 11</span>
        xstrips[i].BEGINDEX     = fix(colchord_endpoints[0,i] - ministrip_side_buffer)  
    ENDELSE
    IF rowchord_endpoints[1,i] EQ -1 THEN BEGIN
        xstrips[i].ENDPOINTS    = fltarr(ministrip_length)
        xstrips[i].ENDINDEX    = 0
    ENDIF ELSE BEGIN
        xstrips[i].ENDPOINTS    = $
            cropped_image[rowchord_endpoints[1,i]-ministrip_side_buffer: $
            rowchord_endpoints[1,i]+ministrip_side_buffer,i*scan_width]
        xstrips[i].ENDINDEX     = fix(colchord_endpoints[1,i] - ministrip_side_buffer)
    ENDELSE
ENDFOR

FOR k = 0,length/scan_width - 1 DO BEGIN
    ystrips[k].COLINDEX     = k
    IF colchord_endpoints[0,k] EQ -1 THEN BEGIN
        ystrips[k].STARTPOINTS  = fltarr(ministrip_length) 
        ystrips[k].BEGINDEX     = 0
    ENDIF ELSE BEGIN 
        ystrips[k].STARTPOINTS  = cropped_image[k*scan_width,colchord_endpoints[0,k]-ministrip_side_buffer: $
            colchord_endpoints[0,k]+ministrip_side_buffer]
        ystrips[k].BEGINDEX     = fix(colchord_endpoints[0,k] - ministrip_side_buffer)
    ENDELSE
    IF colchord_endpoints[1,k] EQ -1 THEN BEGIN
        ystrips[k].ENDPOINTS    = fltarr(ministrip_length) 
        ystrips[k].ENDINDEX     = 0        
    ENDIF ELSE BEGIN
        ystrips[k].ENDPOINTS    = cropped_image[k*scan_width,colchord_endpoints[1,k]-ministrip_side_buffer: $
            colchord_endpoints[1,k]+ministrip_side_buffer]
        ystrips[k].ENDINDEX     = fix(colchord_endpoints[1,k] - ministrip_side_buffer) 
    ENDELSE
ENDFOR

<span class="comments">; oops, x and y indices were switched</span>
<span class="comments">; array = cropped_image[*,3*scan_width]</span>
<span class="comments">; la = xstrips[3].STARTPOINTS</span>
<span class="comments">; ra = xstrips[3].ENDPOINTS</span>
<span class="comments">; lep = rowchord_endpoints[0,3]</span>
<span class="comments">; rep = rowchord_endpoints[1,3]</span>

<span class="comments">; stop</span>
finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for comp5: ',strcompress(finish-start,/rem),' seconds'
save,xstrips,ystrips,thresh,filename='comp5strips.sav',/compress
<span class="comments">; Just did a quick sanity check and with a ministrip_length = 23, the compressed savfile is </span>
<span class="comments">; 975 bytes. That's about 46*10 points per strip with 120 strips -> The pdf says about 2 bytes per strip </span>
<span class="comments">; but I'm getting about 8 bytes per strip. </span>
<span class="comments">;</span>
<span class="comments">; Using 5 points per strip instead of 23 cuts us down to 656 bytes, which is 5.4 bytes per strip.</span>
<span class="comments">; How am I supposed to cut it down to 2?</span>
<span class="comments">; Using bytarr instead of fltarr saves me 40 bytes. </span>
<span class="comments">; Using a scan_width of 20 instead of 10 gets me to 536 bytes (4.4 bytes per strip, 2.2 bytes per </span>
<span class="comments">; cut-down strip. Is this the value we want?</span>
<span class="comments">;</span>
<span class="comments">; Not anymore since I added BEGINDEX and ENDINDEX. Oh well.</span>
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO comp6,xpos,ypos,file=file,order=order,time=time,scan_width=scan_width,$
    ministrip_length=ministrip_length,plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;       Uses the data from comp5 and draws a linear/quadratic/cubic function to find midpoint.</span>
<span class="comments">;       Order is the power of the function.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='104533_20120911_153147_254618_0.bin'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   scan_width: in, optional, type=integer, default=10</span>
<span class="comments">;       Ondicates how far apart to scan</span>
<span class="comments">;   order: in, optional, type=integer, default=3</span>
<span class="comments">;       What order polynomial to use for POLY_FIT()</span>
<span class="comments">;   ministrip_length: in, optional, default=9</span>
<span class="comments">;       How long the trimmed down strip will be</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       If set, makes some nice plots.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   xpos: out, required, type=float</span>
<span class="comments">;       X Center</span>
<span class="comments">;   ypos: out, required, type=float</span>
<span class="comments">;       Y Center</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;           comp6,xpos,ypos,order=3     </span>
<span class="comments">;</span>
<span class="comments">;-</span>

<span class="comments">; Setting default values</span>
IF ~keyword_set(file)   THEN file = '104533_20120911_153147_254618_0.bin'
IF ~keyword_set(order)  THEN order = 3 ELSE order = order

xlen    = 0
xsum    = 0
xnum    = 0

ylen    = 0
ysum    = 0
ynum    = 0
<span class="comments">; For novelty purposes</span>
start = systime(1,/seconds)

<span class="comments">; How many points should we use? Paper says 2-6 so I'll do 5</span>
IF ~keyword_set(ministrip_length) THEN ministrip_length = 9 ELSE ministrip_length=ministrip_length
ministrip_side_length = ministrip_length/2

<span class="comments">; Run the program to get our structures</span>
comp5,xstrips,ystrips,thresh,file=file,time=time,ministrip_length=ministrip_length,sigmavalue=sigmavalue,$
    scan_width=scan_width

xarr = findgen(n_elements(xstrips[4].STARTPOINTS))
yarr = findgen(n_elements(ystrips[4].STARTPOINTS))
<span class="comments">; Have to set to be this large or else min(abs()) will be fragmented</span>
tx = findgen(n_elements(xstrips[4].STARTPOINTS) * 1000)/100
ty = findgen(n_elements(ystrips[4].STARTPOINTS) * 1000)/100

<span class="comments">;Deal with rows</span>
FOR n=0,n_elements(xstrips)-1 DO BEGIN
    <span class="comments">; Need to run POLY_FIT() to get an equation for SPLINE()</span>
    startresult = poly_fit(xarr,xstrips[n].STARTPOINTS,order)
    endresult   = poly_fit(xarr,xstrips[n].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        <span class="comments">; Spline to get better interpolated values</span>
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
            startresult[3]*xarr^3,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
            endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
            startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
            endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
            startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
            endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        startresult = reform(startresult)
        endresult = reform(endresult)
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
            startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
            startresult[6]*xarr^6,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
            endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
            endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        startresult = reform(startresult)
        endresult = reform(endresult)
        startz  = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
            startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
            startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        endz    = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
            endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
            endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; Find where chord intersects threshold through interpolated values</span>
    a=min(abs(startz-thresh),bindex)
    b=min(abs(endz-thresh),eindex)

    <span class="comments">; Where does the strip begin? Where does it end?</span>
    stripbeg = xstrips[n].BEGINDEX + tx[bindex]
    stripend = xstrips[n].ENDINDEX + tx[eindex]

    <span class="comments">; xlen = (stripend - stripbeg)/2. + stripbeg</span>
    xlen = mean([[stripend],[stripbeg]])
    
<span class="comments">; print,xlen</span>

    <span class="comments">; if n eq 3 then stop</span>
    <span class="comments">; It looks like it's correctly indexing the threshold, how else could it be fucking up the xcenter?</span>
    <span class="comments">; print,'1 before',startz[bindex-1]</span>
    <span class="comments">; print,startz[bindex]</span>
    <span class="comments">; print,'1 after',startz[bindex+1]</span>
    <span class="comments">; print,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span>
    <span class="comments">; print,'1 before',endz[eindex-1]</span>
    <span class="comments">; print,endz[eindex]</span>
    <span class="comments">; print,'1 after',endz[eindex+1]</span>

    <span class="comments">;Sum chord midpoints and then finds the average at the end</span>
    IF xlen NE 0. THEN BEGIN
        xsum += xlen 
        xnum += 1
    ENDIF
ENDFOR    

FOR n=0,n_elements(ystrips)-1 DO BEGIN
    startresult = poly_fit(yarr,ystrips[n].STARTPOINTS,order)
    endresult   = poly_fit(yarr,ystrips[n].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr,ty)
        END
    2: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2,ty)
        END
    3: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2 + $
            startresult[3]*yarr^3,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2 + $
            endresult[3]*yarr^3,ty)
        END
    4: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2 + $
            startresult[3]*yarr^3 + startresult[4]*yarr^4,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2 + $
            endresult[3]*yarr^3 + endresult[4]*yarr^4,ty)
        END
    5: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2 + $
            startresult[3]*yarr^3 + startresult[4]*yarr^4 + startresult[5]*yarr^5,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2 + $
            endresult[3]*yarr^3 + endresult[4]*yarr^4 + endresult[5]*yarr^5,ty)
        END    
    6: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2 + $
            startresult[3]*yarr^3 + startresult[4]*yarr^4 + startresult[5]*yarr^5 + $
            startresult[6]*yarr^6,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2 + $
            endresult[3]*yarr^3 + endresult[4]*yarr^4 + endresult[5]*yarr^5 + $
            endresult[6]*yarr^6,ty)
        END
    7: BEGIN
        startz  = spline(yarr,startresult[0] + startresult[1]*yarr + startresult[2]*yarr^2 + $
            startresult[3]*yarr^3 + startresult[4]*yarr^4 + startresult[5]*yarr^5 + $
            startresult[6]*yarr^6 + startresult[7]*yarr^7,ty)
        begz    = spline(yarr,endresult[0] + endresult[1]*yarr + endresult[2]*yarr^2 + $
            endresult[3]*yarr^3 + endresult[4]*yarr^4 + endresult[5]*yarr^5 + $
            endresult[6]*yarr^6 + endresult[7]*yarr^7,ty)
        END
    ENDCASE

    a=min(abs(startz-thresh),bindex)
    a=min(abs(begz-thresh),eindex)

    stripbeg = ystrips[n].BEGINDEX + ty[bindex]
    stripend = ystrips[n].ENDINDEX + ty[eindex]
    <span class="comments">; ylen = (stripend - stripbeg)/2. + stripbeg</span>
    ylen = mean([[stripend],[stripbeg]])

    IF ylen NE 0. THEN BEGIN
        ysum += ylen 
        ynum += 1
    ENDIF
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = xsum/xnum
ypos = ysum/ynum

IF keyword_set(plot) THEN BEGIN
    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)
    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2,yr=[0,1.1*max(xtmp)]
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,0
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2,yr=[0,1.1*max(xtmp)]
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
ENDIF
<span class="comments">; Just an aside, but plotting adds ~ .18 seconds to bring it up to .36 seconds total</span>

finish = systime(1,/seconds)
<span class="comments">; stop</span>
IF keyword_set(time) THEN  print,'Elapsed Time for comp6: ',strcompress(finish-start,/rem),' seconds'
RETURN
END

<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO cc

restore,'comp4strips.sav',/v
plot,ystrips[5].ARRAY,xs=3,ys=3,/nodata
FOR i=0,n_elements(ystrips) - 1 DO BEGIN
    oplot,ystrips[i].ARRAY,color=i
    <span class="comments">; print,closest((ystrips[i].ARRAY)[0:59],thresh),closest((ystrips[i].ARRAY)[60:119],thresh)</span>
    <span class="comments">; wait,1</span>
ENDFOR   

<span class="comments">; It's okay that we have non-zero values for 1st,2nd,and last 2 rows because those aren't counted anyways</span>

stop
END
<span class="comments">;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

PRO rb,file=file,ministrip_length=ministrip_length,scan_width=scan_width,time=time,order=order, $
    plot=plot,sigmavalue=sigmavalue
<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;       Finds the centroid using a variety of compression levels</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   file: in, optional, type=string, default='gauss1pix.tiff'</span>
<span class="comments">;       File to be read in      </span>
<span class="comments">;   ministrip_length: in, optional, type=byte, default=9</span>
<span class="comments">;       How long the cut-down strip is</span>
<span class="comments">;   scan_width: in, optional, type=byte, default = 10</span>
<span class="comments">;       How far apart the scans are</span>
<span class="comments">;   time: in, optional</span>
<span class="comments">;       Prints the elapsed time</span>
<span class="comments">;   order: in, optional, type=integer, default=3</span>
<span class="comments">;       What order polynomial to use for POLY_FIT()</span>
<span class="comments">;   plot: in, optional</span>
<span class="comments">;       If set, makes some nice plots.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :TODO: </span>
<span class="comments">;</span>
<span class="comments">;   More Keywords/parameters    </span>
<span class="comments">;</span>
<span class="comments">;   How strict are we going to be for the outputs of each compression file?</span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

IF ~keyword_set(ministrip_length)   THEN    ministrip_length = 9
IF ~keyword_set(scan_width)         THEN    scan_width = 10
IF ~keyword_set(file)               THEN    file = 'gauss1pix.tiff'
IF ~keyword_set(sigmavalue)         THEN    sigmavalue = 1

comp2,xpos,ypos,thresh,time=time
print,'X Center is ',xpos
print,'Y Center is ',ypos
print,'Threshold is ', thresh
print,''
xcs = xpos
ycs = ypos
<span class="comments">; comp4,xstrips,ystrips,thresh,scan_width=scan_width</span>
<span class="comments">; print,'Threshold is ', thresh</span>
<span class="comments">; help,xstrips,/str</span>
<span class="comments">; print,''</span>
<span class="comments">; comp5,xstrips,ystrips,thresh,scan_width=scan_width,ministrip_length=ministrip_length</span>
<span class="comments">; print,'Threshold is ', thresh</span>
<span class="comments">; help,xstrips,/str</span>
<span class="comments">; print,''</span>
comp6,xpos,ypos,time=time,order=order,scan_width=scan_width,file=file,plot=plot,sigmavalue=sigmavalue
print,'X Center is ',xpos
print,'Y Center is ',ypos
print,''
print,xcs-xpos
print,ycs-ypos
<span class="comments">; cropped_image = scanbox(file='Sun_Images_000000.bmp',time=time)</span>
<span class="comments">; window,0</span>
<span class="comments">; cropped_image[*,ypos] = 0</span>
<span class="comments">; cropped_image[xpos,*] = 0</span>
<span class="comments">; cgimage,cropped_image,/keep_asp</span>


<span class="comments">; cropped_image = scanbox(file='Sun_Images_000000.bmp',time=time)</span>
<span class="comments">; window,1</span>
<span class="comments">; cropped_image[*,ycs] = 0</span>
<span class="comments">; cropped_image[xcs,*] = 0</span>
<span class="comments">; cgimage,cropped_image,/keep_asp</span>

<span class="comments">; cropped_image = scanbox(file=file,time=time)</span>
<span class="comments">; window,0</span>
<span class="comments">; cropped_image[*,ypos] = 0</span>
<span class="comments">; cropped_image[xpos,*] = 0</span>
<span class="comments">; cgimage,cropped_image,/keep_asp</span>


<span class="comments">; cropped_image = scanbox(file=file,time=time)</span>
<span class="comments">; window,1</span>
<span class="comments">; cropped_image[*,ycs] = 0</span>
<span class="comments">; cropped_image[xcs,*] = 0</span>
<span class="comments">; cgimage,cropped_image,/keep_asp</span>



<span class="comments">; From the looks of it, comp6 returns a bad center. why? What could cause the program to shift the</span>
<span class="comments">; xpos left by 3 indices?</span>
<span class="comments">; I tested it on a perfect sun test image and it works fine... something to do with the bmp image,</span>
<span class="comments">; I'm sure.</span>
stop
END
</code>
    </div>
  </body>
</html>