<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu May 23 17:43:21 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>kahuna.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="kahuna.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO makelimbstrips, thresh, xstrips, ystrips, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Makes limb strips from full-length strips</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xstrips : out, required, type=structure</span>
<span class="comments">;           Structure containing row strips</span>
<span class="comments">;       ystrips : out, required, type=structure</span>
<span class="comments">;           Structure containing column strips</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; IF n_elements(region) EQ 0 THEN region = 1</span>
IF region EQ !null THEN region = 1

COMMON vblock, wholeimage

<span class="comments">; Going through and doing a little commenting, think I forgot how this works:</span>

makestrips, thresh, c4xstrips, c4ystrips, region=region, time=time

start = SYSTIME(1,/seconds)

ministrip_side_buffer = byte(!param.ministrip_length)/2 
<span class="comments">; have to byte it since we read the ministrip_length as a float</span>

<span class="comments">; Contains coordinates of chord enpoints</span>
rowchord_endpoints = FLTARR(2,N_ELEMENTS(c4xstrips))
colchord_endpoints = FLTARR(2,N_ELEMENTS(c4ystrips))
<span class="comments">;   Seeing where the array starts to be greater than the thresh</span>
FOR i = 0,N_ELEMENTS(c4ystrips)-1 DO BEGIN
    col_where = WHERE(c4ystrips[i].ARRAY GT thresh)
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,N_ELEMENTS(c4xstrips) -1 DO BEGIN
    row_where = WHERE(c4xstrips[i].ARRAY GT thresh)
    rowchord_endpoints[0,i] = row_where[0]
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

<span class="comments">; Preallocating the array, replicating it by the number of strips there are</span>
xstrips = REPLICATE({ROWINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:BYTARR(!param.ministrip_length), $
        ENDPOINTS:BYTARR(!param.ministrip_length), $
        xoffset:c4xstrips.xoffset},N_ELEMENTS(c4xstrips))
ystrips = REPLICATE({COLINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:BYTARR(!param.ministrip_length), $
        ENDPOINTS:BYTARR(!param.ministrip_length), $
        yoffset:c4ystrips.yoffset},N_ELEMENTS(c4ystrips))

<span class="comments">;Filling out structure with cut-down strip information</span>
FOR i = 0,N_ELEMENTS(c4xstrips) - 1 DO BEGIN
    xstrips[i].ROWINDEX     = c4xstrips[i].ROWINDEX
    <span class="comments">; If there is no strip that cuts through the sun, set things to 0</span>
    IF rowchord_endpoints[0,i] EQ -1 THEN BEGIN
        xstrips[i].STARTPOINTS  = BYTARR(!param.ministrip_length) 
        xstrips[i].BEGINDEX     = 0
    ENDIF ELSE BEGIN
        <span class="comments">; STARTPOINTS is the cut down strip with length = ministrip_length and contains</span>
        <span class="comments">; the indices from rowchord_endpoints[0,i] +/- ministrip_side_buffer</span>
        xstrips[i].STARTPOINTS  = $
        <span class="comments">; IF chord is too long, it tries to crop from outside of image file</span>
            (c4xstrips[i].ARRAY)[rowchord_endpoints[0,i]-ministrip_side_buffer:$
            rowchord_endpoints[0,i]+ministrip_side_buffer]   
        <span class="comments">; BEGINDEX is the index of the strip where it begins. </span>
        <span class="comments">; e.g., the array is 5 long, starts from index 9 and is centered around index 11</span>
        xstrips[i].BEGINDEX     = FIX(rowchord_endpoints[0,i] - ministrip_side_buffer)
    ENDELSE

    IF rowchord_endpoints[1,i] EQ -1 THEN BEGIN
        xstrips[i].ENDPOINTS    = BYTARR(!param.ministrip_length)
        xstrips[i].ENDINDEX    = 0
    ENDIF ELSE BEGIN
        xstrips[i].ENDPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[1,i]-ministrip_side_buffer:$
            rowchord_endpoints[1,i]+ministrip_side_buffer]   
        xstrips[i].ENDINDEX     = FIX(rowchord_endpoints[1,i] - ministrip_side_buffer)
    ENDELSE
ENDFOR


FOR k = 0,N_ELEMENTS(c4ystrips) - 1 DO BEGIN
    ystrips[k].COLINDEX     = c4ystrips[k].COLINDEX
    IF colchord_endpoints[0,k] EQ -1 THEN BEGIN
        ystrips[k].STARTPOINTS  = BYTARR(!param.ministrip_length) 
        ystrips[k].BEGINDEX     = 0
    ENDIF ELSE BEGIN 
        ystrips[k].STARTPOINTS  = (c4ystrips[k].ARRAY)[colchord_endpoints[0,k]- $
            ministrip_side_buffer:colchord_endpoints[0,k]+ministrip_side_buffer]
        ystrips[k].BEGINDEX     = FIX(colchord_endpoints[0,k] - ministrip_side_buffer)
    ENDELSE

    IF colchord_endpoints[1,k] EQ -1 THEN BEGIN
        ystrips[k].ENDPOINTS    = BYTARR(!param.ministrip_length) 
        ystrips[k].ENDINDEX     = 0        
    ENDIF ELSE BEGIN
        ystrips[k].ENDPOINTS    = (c4ystrips[k].ARRAY)[colchord_endpoints[1,k]- $
        ministrip_side_buffer:colchord_endpoints[1,k]+ministrip_side_buffer]
        ystrips[k].ENDINDEX     = FIX(colchord_endpoints[1,k] - ministrip_side_buffer) 
    ENDELSE
ENDFOR


finish = SYSTIME(1,/seconds)

IF KEYWORD_SET(time) THEN  print,'Elapsed Time for makelimbstrips: ', $
    STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

 
FUNCTION quickmask, input_image, thresh
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds center of mask where pixels are above a given threshold</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       input_image : in, required, type=byte</span>
<span class="comments">;           2D array of pixels to mask with threshold</span>
<span class="comments">;       thresh : in, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;-</span>


a = input_image[SORT(input_image)]
niceimage = a[0:(1-!param.elim_perc/100)*(N_ELEMENTS(a)-1)]
<span class="comments">; Eliminating the highest 1% of data</span>
IF thresh eq !null then thresh = !param.reg1thresh*MAX(niceimage)
<span class="comments">; IF n_elements(thresh) EQ 0 THEN thresh = 0.25*MAX(image)</span>

s = SIZE(input_image,/dimensions)
n_col = s[0]
n_row = s[1]

suncheck = input_image gt thresh

xpos = TOTAL( TOTAL(suncheck, 2) * INDGEN(n_col) ) / TOTAL(suncheck)
ypos = TOTAL( TOTAL(suncheck, 1) * INDGEN(n_row) ) / TOTAL(suncheck)
RETURN, {xpos:xpos,ypos:ypos}
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


FUNCTION whichcropmethod, region
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Crops differently according to which region is selected. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       region : in, required, type=integer</span>
<span class="comments">;           1) main sun</span>
<span class="comments">;           2) 50% brightness sun</span>
<span class="comments">;           3) 25% brightness sun</span>
<span class="comments">;-</span>
COMMON vblock, wholeimage

<span class="comments">; crop_box = BYTE(!param.crop_box)</span>
a = wholeimage[SORT(wholeimage)]
niceimage = a[0:(1-!param.elim_perc/100)*(N_ELEMENTS(a)-1)]

thresh = !param.reg1thresh_mult*max(niceimage)
ducks = quickmask(wholeimage,thresh)

image = wholeimage[ducks.xpos- !param.crop_box:ducks.xpos+ !param.crop_box, $
    ducks.ypos- !param.crop_box:ducks.ypos+ !param.crop_box]

mainxpos = ducks.xpos
mainypos = ducks.ypos
xoffset = ducks.xpos- !param.crop_box
yoffset = ducks.ypos- !param.crop_box

IF REGION NE 1 THEN BEGIN
    circscancrop, mainxpos, mainypos, image, thresh, xpos, ypos, xoffset, yoffset, region=region, time=time
ENDIF

<span class="comments">; There is a strong fiducial at image[*,53], but it's not on the limb. It's pretty darn close though. </span>
<span class="comments">; Now, need to replicate those conditions</span>

<span class="comments">; plot,image[40,*],/nodata</span>

<span class="comments">; i=0</span>
<span class="comments">; while get_kbrd(0) EQ '' do BEGIN</span>
<span class="comments">; oplot, image[*,i]</span>
<span class="comments">; wait,.2</span>
<span class="comments">; i++</span>
<span class="comments">; ENDWHILE</span>
<span class="comments">; plot,image[0:20,53]</span>
<span class="comments">; stop</span>

<span class="comments">; stop</span>
RETURN,{image:image, xoffset:xoffset, yoffset:yoffset, thresh:thresh}
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO makestrips, thresh, xstrips, ystrips, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Only saves 5 strips centered around the solar diameter to reduce the amount of limb-</span>
<span class="comments">;           darkened pixels and to make the polynomial-fitted limbs more-or-less look similar. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;   thresh : out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;   xstrips : out, required, type=structure</span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips : out, required, type=structure</span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;   region : in, required, type=integer, default=1</span>
<span class="comments">;       Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Prints elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; IF n_elements(region) EQ 0 THEN region = 1</span>
IF region eq !null then region = 1

COMMON vblock, wholeimage

struct = whichcropmethod(region)
ducks = quickmask(struct.image)
thresh = struct.thresh

start = SYSTIME(1,/seconds)

animage = struct.image
s = SIZE(animage,/dimensions)
length = s[0]
height = s[1]

rowchord_endpoints = FLTARR(2,!param.nstrips)
colchord_endpoints = FLTARR(2,!param.nstrips)

xstrips = REPLICATE({ROWINDEX:0, ARRAY:BYTARR(length), xoffset:struct.xoffset}, !param.nstrips)
ystrips = REPLICATE({COLINDEX:0, ARRAY:BYTARR(height), yoffset:struct.yoffset}, !param.nstrips)

FOR i = 0,!param.nstrips - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = animage[*, ROUND(ducks.xpos)+(i-!param.nstrips/2)* !param.scan_width]
    ystrips[i].COLINDEX = i
    ystrips[i].ARRAY = animage[ROUND(ducks.ypos)+(i-!param.nstrips/2)* !param.scan_width,*]
ENDFOR

finish = SYSTIME(1,/seconds)
IF KEYWORD_SET(time) THEN  print,'Elapsed Time for makestrips: ', $
    STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO circscancrop, mainxpos, mainypos, image, thresh, xpos, ypos, xoffset, yoffset, region=region, $
     time=time
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Quickly finds the center of the main sun, scans in a circle, and locates the two secondary </span>
<span class="comments">;       suns' centers. Crops either of the secondary suns based on what region specified.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       mainxpos : in, required</span>
<span class="comments">;           X position of 100% brightness sun to scan in a circle around</span>
<span class="comments">;       mainypos : in, required</span>
<span class="comments">;           Y position of 100% brightness sun to scan in a circle around</span>
<span class="comments">;       image : out, required</span>
<span class="comments">;           Cropped area</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used in finding center</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           Computed X position of center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Computed Y position of center</span>
<span class="comments">;       xoffset : out, required</span>
<span class="comments">;           X offset of cropped region's bottom left corner</span>
<span class="comments">;       yoffset : out, required</span>
<span class="comments">;           Y offset of cropped region's bottom left corner</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Print the elapsed time</span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
ON_ERROR,2

COMMON vblock, wholeimage

start = SYSTIME(1,/s)

arr=(FINDGEN(!param.deg_num*!param.res)/!param.res + 90)*!dtor
<span class="comments">; only adding 90 so that it starts from 12 o'clock assuming there is</span>
<span class="comments">; no dim sun at that location</span>

radius = 129  <span class="comments">; well this is rather arbitrary</span>
r2bit = 2

<span class="comments">; The way we have it scanning now is if it doesn't find the aux sun, it scans at a radius interval of </span>
<span class="comments">; 10 so that it looks at the r_orig - interval and r_orig + interval radii. Now, what if the sun isn't there? </span>

r2 = radius + 20*r2bit              <span class="comments">;20 is an arbitrary number, can be anything, really</span>
x = radius*COS(arr) + mainxpos
y = radius*SIN(arr) + mainypos
x2 = r2*COS(arr)    + mainxpos
y2 = r2*SIN(arr)    + mainypos


loop: BEGIN
    IF !param.file EQ 'dimsun1.fits' THEN radius = BYTE( !param.scan_radius ) 

    <span class="comments">; Have to use .3 instead of .25 for dimsun2, don't know why</span>

    sorted =  wholeimage[sort(wholeimage)]
    thresh = !param.reg2thresh_mult*MAX( sorted[0:(1-!param.elim_perc/100)*(N_ELEMENTS(sorted)-1)] )
    <span class="comments">; ^^</span>
    <span class="comments">; Well this doesn't work.</span>
    
    thresh = !param.reg2thresh_mult*MAX(wholeimage)
    <span class="comments">; Alright, for some reason, clipping out the top 1% changes the thresh from 53.7 to 64.5</span>
    <span class="comments">; which makes the centerx,centery go from 337,76 (correct)</span>
    <span class="comments">; to</span>
    <span class="comments">; 144,19 (so, so wrong)</span>
    <span class="comments">; now, how to deal with it?</span>

    pri_scan = WHERE(wholeimage[x,y] GT thresh,pri_where)
    aux_scan = WHERE(wholeimage[x2,y2] GT thresh,aux_where)

    <span class="comments">; print,aux_where, ' aux_where before if statement'</span>
    IF aux_where NE 0 THEN BEGIN
    <span class="comments">; stop</span>
        in_inner  = ((WHERE(wholeimage[x,y]     GT thresh))[0])/!param.res - !param.circscan_buffer
        out_inner = ((WHERE(wholeimage[x,y]     GT thresh))[-1])/!param.res + !param.circscan_buffer
        in_outer  = ((WHERE(wholeimage[x2,y2]   GT thresh))[0])/!param.res - !param.circscan_buffer
        out_outer = ((WHERE(wholeimage[x2,y2]   GT thresh))[-1])/!param.res + !param.circscan_buffer
    ENDIF ELSE BEGIN
        r2bit*=-1
        GOTO, loop
    ENDELSE
END

otherloop: BEGIN
    IF REGION EQ 3 THEN BEGIN
        thresh = 0.2*MAX(wholeimage) <span class="comments">;dimsun2 works if i set the thresh to .2 instead of .15</span>
        <span class="comments">; The other sun is so dim that weird parts are being picked up. How to fix? Is being dim a problem?</span>

        sorted =  wholeimage[sort(wholeimage)]
        thresh = !param.reg3thresh_mult*MAX( sorted[0:(1-!param.elim_perc/100)*(N_ELEMENTS(sorted)-1)] )
        <span class="comments">; ^^</span>
        <span class="comments">; Well this doesn't work.</span>
    
        thresh = !param.reg3thresh_mult*MAX(wholeimage)

        <span class="comments">; check to make sure we're scanning at the right radius</span>
        n_check = WHERE((wholeimage[x2,y2] GT thresh) EQ 1,n_where)

        IF n_where NE 0 THEN BEGIN
            part1 = wholeimage[x[0:in_inner*!param.res],y[0:in_inner*!param.res]]
            part2 = wholeimage[x[out_inner*!param.res:N_ELEMENTS(x)-1],y[out_inner*!param.res:N_ELEMENTS(x)-1]]
            part1b = wholeimage[x2[0:in_outer*!param.res],y2[0:in_outer*!param.res]]
            part2b = wholeimage[x[out_outer*!param.res:N_ELEMENTS(x)-1],y[out_outer*!param.res:N_ELEMENTS(x)-1]]

            in_inner  = ((WHERE([part1,part2]   gt thresh))[0])/!param.res - !param.circscan_buffer
            out_inner = ((WHERE([part1,part2]   gt thresh))[-1])/!param.res + !param.circscan_buffer
            in_outer  = ((WHERE([part1b,part2b] gt thresh))[0])/!param.res - !param.circscan_buffer
            out_outer = ((WHERE([part1b,part2b] gt thresh))[-1])/!param.res + !param.circscan_buffer

        ENDIF ELSE BEGIN
            r2bit*=-1
            GOTO, otherloop
        ENDELSE

        <span class="comments">; Setting this to 0 actually messes up fitting. use only to show what pixels are being circscanned</span>
        <span class="comments">; wholeimage[x[in_inner:out_inner],y[in_inner:out_inner]] = 0</span>
        <span class="comments">; wholeimage[x2[in_outer:out_outer],y2[in_outer:out_outer]] = 0</span>
    ENDIF
END


centerangle = !dtor*(90 + MEAN([in_inner,out_inner]))
centerx = mainxpos + radius*COS(centerangle)
centery = mainypos + radius*SIN(centerangle)

image = wholeimage[centerx - !param.crop_box:centerx + !param.crop_box,$
    centery - !param.crop_box:centery + !param.crop_box]
xoffset = centerx- !param.crop_box
yoffset = centery- !param.crop_box

finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'getstruct took: '+STRCOMPRESS(finish-start)+$
    ' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO limbfit, thresh, xpos, ypos, plot=plot, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Uses the data from makelimbstrips and fits an n-th order polynomial to the limb to find where</span>
<span class="comments">;       it crosses the threshold.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           X center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Y center</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region : in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       plot : in, optional</span>
<span class="comments">;           Makes some nice plots</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

if region eq !null then region = 1

COMMON vblock, wholeimage

<span class="comments">; Run the program to get our structures</span>
makelimbstrips, thresh, xstrips, ystrips, region=region, time=time

start = SYSTIME(1,/seconds)

xlen    = 0
xsum    = 0
xnum    = 0   
ylen    = 0
ysum    = 0
ynum    = 0
xarr    = FINDGEN(N_ELEMENTS(xstrips[4].STARTPOINTS))
yarr    = FINDGEN(N_ELEMENTS(ystrips[4].STARTPOINTS))
tx      = FINDGEN(N_ELEMENTS(xstrips[4].STARTPOINTS) * 1000)/100
ylenarr = FINDGEN(N_ELEMENTS(ystrips))
xlenarr = FINDGEN(N_ELEMENTS(xstrips))

<span class="comments">;Deal with rows</span>
FOR n=0,N_ELEMENTS(xstrips)-1 DO BEGIN
    <span class="comments">; Using fz_roots instead of SPLINE interpolating. Saving lines and making code more readable</span>

    startresult     = REFORM(POLY_FIT(xarr,xstrips[n].STARTPOINTS, !param.order))
    endresult       = REFORM(POLY_FIT(xarr,xstrips[n].ENDPOINTS, !param.order))

    <span class="comments">; Solving for roots but want to include threshold value</span>
    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF xstrips[n].BEGINDEX GT 0 THEN BEGIN
        <span class="comments">; Get roots (complex)</span>
        begroots    = FZ_ROOTS(startresult)
        <span class="comments">; Take only roots with no imaginary components</span>
        begusable   = (REAL_PART(begroots))[WHERE(IMAGINARY(begroots) eq 0.)]
        <span class="comments">; Find smallest root (apparently I have to choose the smaller one)</span>
        <span class="comments">; Or i can find the midpoints using the other two roots then take the average of the two,</span>
        <span class="comments">; that way works too, but why would I do that?</span>
        begusable   = (begusable[WHERE(begusable gt 0)])[0]
        stripbeg    = xstrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF xstrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = FZ_ROOTS(endresult)
        endusable   = (REAL_PART(endroots))[WHERE(IMAGINARY(endroots) eq 0.)]
        endusable   = (endusable[WHERE(endusable gt 0)])[0]
        stripend    = xstrips[n].ENDINDEX + endusable
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    <span class="comments">; Stick the midpoints in an array to take the mean of later</span>
    xlenarr[n] = MEAN([[stripend],[stripbeg]])
ENDFOR    

FOR n=0,N_ELEMENTS(ystrips)-1 DO BEGIN
    startresult     = REFORM(POLY_FIT(yarr,ystrips[n].STARTPOINTS, !param.order))
    endresult       = REFORM(POLY_FIT(yarr,ystrips[n].ENDPOINTS, !param.order))

    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF ystrips[n].BEGINDEX GT 0 THEN BEGIN
        begroots    = FZ_ROOTS(startresult)
        begusable   = (REAL_PART(begroots))[WHERE(IMAGINARY(begroots) eq 0.)]
        begusable   = (begusable[WHERE(begusable gt 0)])[0]
        stripbeg    = ystrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF ystrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = FZ_ROOTS(endresult)
        endusable   = (REAL_PART(endroots))[WHERE(IMAGINARY(endroots) eq 0.)]
        endusable   = (endusable[WHERE(endusable gt 0)])[0]
        stripend    = ystrips[n].ENDINDEX + endusable
        
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    ylenarr[n] = MEAN([[stripend],[stripbeg]])
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = MEAN(xlenarr[WHERE(xlenarr ne 0)]) + (xstrips.xoffset)[0]
ypos = MEAN(ylenarr[WHERE(ylenarr ne 0)]) + (ystrips.yoffset)[0]

IF KEYWORD_SET(plot) THEN BEGIN
    wn = 3
    startresult = POLY_FIT(xarr,xstrips[wn].STARTPOINTS, !param.order)
    endresult = POLY_FIT(xarr,xstrips[wn].ENDPOINTS, !param.order)

    CASE !param.order OF
    1: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = SPLINE(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = SPLINE(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','SPLINEd Data'],linestyle=[0,1],/bottom,/right,charsize=2

    window,0
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','SPLINEd Data'],linestyle=[0,1],/bottom,/left,charsize=2
ENDIF

finish = SYSTIME(1,/seconds)

IF KEYWORD_SET(time) THEN  print,'Elapsed Time for limbfit: ',STRCOMPRESS(finish-start,/rem),' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


PRO getstruct, struct, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds the centers of a triple-sun image and loads all relevant information</span>
<span class="comments">;       including offsets and angles into a new structure.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       struct : out, required, type=structure</span>
<span class="comments">;           Structure containing the centers and cropped images of all 3 suns</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
ON_ERROR,2

COMMON vblock, wholeimage

start = SYSTIME(1,/s)


center1 = {center1,xpos:0d,ypos:0d,thresh:0d}
center2 = {center2,xpos:0d,ypos:0d,thresh:0d}
center3 = {center3,xpos:0d,ypos:0d,thresh:0d}

limbfit, thresh, xpos, ypos, plot=plot, region=1, time=time
center1.xpos = xpos
center1.ypos = ypos
center1.thresh = thresh

limbfit, thresh, xpos, ypos, plot=plot, region=2, time=time
center2.xpos = xpos
center2.ypos = ypos
center2.thresh = thresh

limbfit, thresh, xpos, ypos, plot=plot, region=3, time=time
center3.xpos = xpos
center3.ypos = ypos
center3.thresh = thresh


theta = !radeg*atan((center3.ypos - center2.ypos)/(center3.xpos - center2.xpos))
hypot = sqrt((center3.ypos - center2.ypos)^2 + (center3.xpos - center2.xpos)^2)
offset = ((center1.xpos - center2.xpos)*(center3.ypos - center2.ypos) - $
    (center1.ypos - center2.ypos)*(center3.xpos - center2.xpos))/hypot

struct = {KAHUNA, center1:center1, center2:center2, center3:center3, $
    theta:theta, offset:offset}
finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'getstruct took: '+STRCOMPRESS(finish-start)+$
    ' seconds'
RETURN
END


<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<a id="cropme:source"></a>function cropme, input, pix

    s = size(input,/d)
    nrow = s[0]
    ncol = s[1]
    output = input[(nrow-1)/2 - pix:(nrow-1)/2 + pix,(ncol-1)/2 - pix:(ncol-1)/2 + pix]

return, output
end

<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="bordercheck:source"></a>function bordercheck, input

s = SIZE(input,/dim)
wn_row = s[0]
wn_col = s[1]
datmask = BYTARR(wn_row,wn_col) + 1
datmask[(1/!param.mask_border_perc)*wn_row:(1-(1/!param.mask_border_perc))*wn_row,$
    (1/!param.mask_border_perc)*wn_col:(1-(1/!param.mask_border_perc))*wn_col] = 0

<span class="comments">; min_val should be a really low number, the mode of input is 3</span>
min_val = MODE(input)

if TOTAL(datmask*input) gt N_ELEMENTS(datmask[WHERE(datmask eq 1)])*min_val then okaybit=0 else okaybit=1

return, okaybit
end

<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>

<a id="edgefidcheck:source"></a>function edgefidcheck, input, thresh

xpb = SHIFT_DIFF(EMBOSS(input),dir=3) lt thresh
ypb = SHIFT_DIFF(EMBOSS(input,az=90),dir=1) lt thresh

tmpcrop = input[10:43,8:42]
xpb = xpb[10:43,8:42]
ypb = ypb[10:43,8:42]

s = SIZE(tmpcrop,/dim)
ncol = s[0]
nrow = s[1]
ind_col = WHERE(xpb eq 1) mod ncol
ind_row = WHERE(ypb eq 1)/nrow


a = MODE(ind_col)
b = MODE(ind_col[WHERE(ind_col ne a)])

c = MODE(ind_row)
d = MODE(ind_row[WHERE(ind_row ne c)])

<span class="comments">; Just to make it sorted</span>
xpos = [a,b]
ypos = [c,d]
xpos = xpos[SORT(xpos)]
ypos = ypos[SORT(ypos)]

xmcrop = mcrop * xpb
ymcrop = mcrop * ypb

ind_col = WHERE(xpb eq 1) mod ncol
ind_row = WHERE(ypb eq 1)/nrow

if ind_row eq !null then row_border = WHERE(HISTOGRAM(ind_row) ne 0)+1
if ind_col eq !null then col_border = WHERE(HISTOGRAM(ind_col) ne 0)+1

if N_ELEMENTS(row_border) eq 1 then row_border = MODE(ind_row)
if N_ELEMENTS(col_border) eq 1 then col_border = MODE(ind_col)

row_slice_a = tmpcrop[*,row_border[0]]
row_slice_b = tmpcrop[*,row_border[1]]
col_slice = tmpcrop[col_border,*]

if N_ELEMENTS(FLOAT(col_slice[0:6]) - MODE(tmpcrop) lt somevalue) lt 6 then okaybit=0 else okaybit=1

return,okaybit
end
<span class="comments">;**************************************************************************************************</span>
<span class="comments">;*                                                                                                *</span>
<span class="comments">;**************************************************************************************************</span>


<span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;   KAHUNA</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Finds the center of 3 suns in a single image. Currently limited to a .bmp test image. Instead</span>
<span class="comments">;   of scanning rows to crop, scans in a circle. Using solar centers, identifies fiducial positions.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   JEREN SUZUKI::</span>
<span class="comments">;</span>
<span class="comments">;       Space Sciences Laboratory</span>
<span class="comments">;       7 Gauss Way</span>
<span class="comments">;       Berkeley, CA 94720 USA</span>
<span class="comments">;       E-mail: jsuzuki@ssl.berkeley.edu</span>
<span class="comments">;-</span>

<span class="comments">; PRO kahuna, file, time=time</span>
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       This version uses limb fitting opposed to masking (tricenter). </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;</span>
<span class="comments">;   :TODO: </span>
<span class="comments">;       Find and ISOLATE fiducials, not just mask them out</span>
<span class="comments">;</span>
<span class="comments">;       Ignore center if sun is too close to edge (or if when cropping, we cro outside wholeimage)</span>
<span class="comments">;</span>
<span class="comments">;       Use 25% of median(image)</span>
<span class="comments">;</span>
<span class="comments">;       Make sure program doesn't freak out when sun isn't in POV</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
ON_ERROR,2

start=SYSTIME(1,/s)

<span class="comments">; profiler,/system</span>
<span class="comments">; profiler</span>

<span class="comments">; DEATH TO THE COMMON BLOCK (or not)</span>
COMMON vblock, wholeimage
file = 'dimsun1.fits'
readcol,'pblock.txt',var,num,format='A,F',delimiter=' '
    for i=0,N_ELEMENTS(var)-1 do (SCOPE_VARFETCH(var[i],/enter,level=0))=num[i]

c = CREATE_STRUCT(var[0],num[0])

<span class="comments">;This takes, like, no time.</span>
for i=1,N_ELEMENTS(var)-1 do begin
    c = CREATE_STRUCT(c,var[i],num[i])
endfor

c = CREATE_STRUCT(c,'file','dimsun1.fits')

defsysv,'!param',c

<span class="comments">; print,'Parameters:'</span>
<span class="comments">; for i=0,N_ELEMENTS(var)-1 do print,var[i],num[i],format='(A,A)'</span>

wholeimage = mrdfits(file)

getstruct, struct, time=time

<span class="comments">; profiler,/report,data=data</span>
<span class="comments">; profiler,/reset,/clear</span>

<span class="comments">; print,data[sort(-data.time)],format='(A-20, I7, F12.5, F10.5, I9)'</span>

print,'Main sun x pos:',struct.center1.xpos
print,'Main sun y pos:',struct.center1.ypos
print,'50% sun x pos: ',struct.center2.xpos
print,'50% sun y pos: ',struct.center2.ypos
print,'25% sun x pos: ',struct.center3.xpos
print,'25% sun y pos: ',struct.center3.ypos

<span class="comments">; wholeimage2 = wholeimage</span>
<span class="comments">; wholeimage3 = wholeimage</span>

<span class="comments">; wholeimage[struct.center1.xpos,*]=20</span>
<span class="comments">; wholeimage[*,struct.center1.ypos]=20</span>
<span class="comments">; wholeimage2[struct.center2.xpos,*]=20</span>
<span class="comments">; wholeimage2[*,struct.center2.ypos]=20</span>
<span class="comments">; wholeimage3[struct.center3.xpos,*]=20</span>
<span class="comments">; wholeimage3[*,struct.center3.ypos]=20</span>

<span class="comments">; ; window,0</span>
<span class="comments">; ; cgimage,wholeimage,/k,output=strmid(file,0,7)+'_'+'region1.png'</span>
<span class="comments">; ; ; window,2</span>
<span class="comments">; ; cgimage,wholeimage2,/k,output=strmid(file,0,7)+'_'+'region2.png'</span>
<span class="comments">; ; ; window,3</span>
<span class="comments">; ; cgimage,wholeimage3,/k,output=strmid(file,0,7)+'_'+'region3.png'</span>

<span class="comments">; window,0</span>
<span class="comments">; cgimage,wholeimage,/k</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,wholeimage2,/k</span>
<span class="comments">; window,3</span>
<span class="comments">; cgimage,wholeimage3,/k</span>

<span class="comments">; Here we make the assumption that the darker regions are linearly darker so we can just divide by 2 and 4</span>
<span class="comments">; Works pretty well</span>

wholeimage = MRDFITS(file)
ideal = BYTSCL( READ_TIFF('plots_tables_images/dimsun_ideal.tiff',channels=1) )

crop = wholeimage[struct.center1.xpos-!param.safecrop:struct.center1.xpos+!param.safecrop,$
    struct.center1.ypos-!param.safecrop:struct.center1.ypos+!param.safecrop]

icrop = ideal[struct.center1.xpos-!param.safecrop:struct.center1.xpos+!param.safecrop,$
    struct.center1.ypos-!param.safecrop:struct.center1.ypos+!param.safecrop]

p = icrop[SORT(icrop)]
idealthresh = !param.idealthresh_mult*MAX( p[0:(1-!param.elim_perc/100)*(N_ELEMENTS(p)-1)] )

imask = icrop lt idealthresh
<span class="comments">; dim50 = .5*crop</span>
dim50 = wholeimage[struct.center2.xpos-!param.safecrop:struct.center2.xpos+!param.safecrop,$
    struct.center2.ypos-!param.safecrop:struct.center2.ypos+!param.safecrop]
<span class="comments">; dim25 = .25*crop</span>
dim25 = wholeimage[struct.center3.xpos-!param.safecrop:struct.center3.xpos+!param.safecrop,$
    struct.center3.ypos-!param.safecrop:struct.center3.ypos+!param.safecrop]

<span class="comments">; Actually using the wholeimage cropped areas reveal little difference than with the cheating method</span>
<span class="comments">; Doesn't really matter which one we use, practically same result</span>


<span class="comments">; thresh was -80, now, how do I do quantify this sorcery?</span>
thresh = 0.5*MIN((SHIFT_DIFF(EMBOSS(crop),dir=3)))

s = SIZE(crop,/dim)
nrow = s[0]
ncol = s[1]

xpb = (SHIFT_DIFF(EMBOSS(crop),dir=3)) lt thresh
ypb = (SHIFT_DIFF(EMBOSS(crop, az=90),dir=1)) lt thresh

<span class="comments">;Don't need to display these anymore (or at least for now)</span>

<span class="comments">; display,byte(crop),/square,title='100%'</span>
<span class="comments">; plot_edges,xpb,thick=6,setcolor=80</span>
<span class="comments">; plot_edges,ypb,thick=6,setcolor=255</span>
<span class="comments">; -80 is about 3 stddev() above the minimum</span>
<span class="comments">; -80 is also about half the minimum of xpb/ypb</span>

<span class="comments">; xpb = (SHIFT_DIFF(EMBOSS(dim50),dir=3)) lt thresh/2</span>
<span class="comments">; ypb = (SHIFT_DIFF(EMBOSS(dim50, az=90),dir=1)) lt thresh/2</span>

<span class="comments">; ; ps_start,filename='plots_tables_images/dim50.eps',/color,/encapsulated,xsize=8,ysize=8,/inches</span>
<span class="comments">; display,byte(dim50),/square,title='50% Dim'</span>
<span class="comments">; plot_edges,xpb,thick=6,setcolor=80</span>
<span class="comments">; plot_edges,ypb,thick=6,setcolor=255</span>
<span class="comments">; ; ps_end,resize=100</span>



<span class="comments">; ; so, fixing circscancrop to not set parts of wholeimage to 0 messes up the fid finding here because </span>
<span class="comments">; ; the cropped area now includes a part of a fiducial. fixing.</span>
<span class="comments">; xpb = (SHIFT_DIFF(EMBOSS(dim25),dir=3)) lt thresh/4</span>
<span class="comments">; ypb = (SHIFT_DIFF(EMBOSS(dim25, az=90),dir=1)) lt thresh/4</span>
<span class="comments">; ; ps_start,filename='plots_tables_images/dim25.eps',/color,/encapsulated,xsize=8,ysize=8,/inches       </span>
<span class="comments">; display,byte(dim25),/square,title='25% Dim'</span>
<span class="comments">; plot_edges,xpb,thick=6,setcolor=80</span>
<span class="comments">; plot_edges,ypb,thick=6,setcolor=255</span>
<span class="comments">; ; ps_end,resize=100</span>


<span class="comments">; ; Working with image of blank sun with real fiducials:</span>
<span class="comments">; whitecrop = bytarr(s) + 198  ;198 is the mode of the not-fiducial-maskt</span>
<span class="comments">; fakesun = imask*crop + whitecrop*(icrop gt idealthresh)</span>
<span class="comments">; ; cgsurface,(SHIFT_DIFF(EMBOSS(fakesun),dir=3))</span>
<span class="comments">; a = SHIFT_DIFF(EMBOSS(fakesun),dir=3)</span>
<span class="comments">; cgimage,a,/k</span>
<span class="comments">; cgimage,a*(a gt 10),/k</span>








<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

wn_row = (SIZE(wholeimage,/dim))[0]
wn_col = (SIZE(wholeimage,/dim))[1]
datmask = BYTARR(wn_row,wn_col) + 1
datmask[(1/!param.mask_border_perc)*wn_row:(1-(1/!param.mask_border_perc))*wn_row,$
    (1/!param.mask_border_perc)*wn_col:(1-(1/!param.mask_border_perc))*wn_col] = 0


<span class="comments">; min_val should be a really low number, the mode of wholeimage is 3</span>
min_val = MODE(wholeimage)
if TOTAL(datmask*wholeimage) gt N_ELEMENTS(datmask[WHERE(datmask eq 1)])*min_val then begin
   <span class="comments">; Don't use this image, bro.</span>
endif

<span class="comments">; If in the case where we want the above picture still... then....</span>


<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; #       #     #     #####         #   #</span>
<span class="comments">; #       #    # #    #   #         #   #</span>
<span class="comments">; # #   # #   #   #   ####          #   #</span>
<span class="comments">; #  # #  #   #####   #   #         #   #</span>
<span class="comments">; #   #   #  #     #  #    #        #   #</span>

<span class="comments">; Trying to make a complete paraeter table - more intensive than I thought</span>


<span class="comments">; Current parameters</span>
<span class="comments">; scan_width          5</span>
<span class="comments">; sundiam             70</span>
<span class="comments">; nstrips             5</span>
<span class="comments">; order               2</span>
<span class="comments">; ministrip_length    13</span>
<span class="comments">; sundiam             70</span>
<span class="comments">; rad                 20</span>
<span class="comments">; scan_radius         149</span>
<span class="comments">; crop_box            60</span>
<span class="comments">; reg1thresh_mult     .65</span>


<span class="comments">; Ghost parameters (in program but not in pblock.txt)</span>
<span class="comments">; These variable names do not exist in the program so don't bother searching for them</span>


<span class="comments">; reg1thresh          0.25        ; Thresh used when running quickmask on region 1</span>
<span class="comments">; circscan_buffer     10          ; After scanning for aux suns in a circle, how pany pixels to step back/forward</span>
<span class="comments">;                                 ; from start/stop</span>
<span class="comments">; elim_perc           1           ; How many pixels to eliminate from masks to find maximums for thresholds</span>
<span class="comments">; mask_border_perc    10          ; What percentage of width/height should we make a NPZ (no pixel zone) when </span>
<span class="comments">;                                 ; deciding whether or not to use image for sun centering</span>
<span class="comments">; idealthresh_mult    .25         ; Multiplier of ideal image maximum</span>
<span class="comments">; reg2thresh_mult     .3          ; Multiplier of image maximum for circscancrop region 2</span>
<span class="comments">; reg3thresh_mult     .2          ; Multiplier of image maximum for circscancrop region 3</span>
<span class="comments">; scanflip            10          ; If no sun is found when running circscancrop, scan at -2*scanflip radius units</span>
<span class="comments">; deg_num             360         ; Number of elements in circle array - can be 720 to scan at a finer resolution</span>



<span class="comments">; Maybe defining system variables would be better for this... I read in a txt file, make a structure of</span>
<span class="comments">; n_elements(), name them like struct.'name' = 'val' or something, then call it !params.scan_width or something</span>

<span class="comments">; Cleaner than a common block!</span>

<span class="comments">;pasting copy at beginning of code so we can actually use this:</span>
<span class="comments">; p = create_struct(var[0],num[0])</span>
<span class="comments">; </span>
<span class="comments">; for i=0,n_elements(var)-2 do begin</span>
<span class="comments">;     p = create_struct(p,var[i+1],num[i+1])</span>
<span class="comments">; endfor</span>
<span class="comments">; </span>
<span class="comments">; defsysv,'!param',p</span>

<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

<span class="comments">; #       #     #     #####         #   ###</span>
<span class="comments">; #       #    # #    #   #         #      #</span>
<span class="comments">; # #   # #   #   #   ####          #   ###</span>
<span class="comments">; #  # #  #   #####   #   #         #      #</span>
<span class="comments">; #   #   #  #     #  #    #        #   ###</span>

<span class="comments">; Fiducial cropping, let's get this down</span>

<span class="comments">; bordermask = bytarr(nrow,ncol) + 1</span>
<span class="comments">; bordermask[(2:nrow-2,2:ncol-2] = 0</span>

<span class="comments">; min_val = mode(crop)</span>
<span class="comments">; if total(bordermask*crop) gt n_elements(bordermask[where(bordermask eq 1)])*min_val then begin</span>
   
<span class="comments">;    ; Look at another 2 pixels in in</span>
<span class="comments">;     bordermask = bytarr(nrow,ncol) + 1</span>
<span class="comments">;     bordermask[(4:nrow-4,4:ncol-4] = 0</span>
<span class="comments">;     if total(bordermask*crop) gt n_elements(bordermask[where(bordermask eq 1)])*min_val then begin</span>
<span class="comments">;         new_crop = crop[(2:nrow-2,2:ncol-2]</span>
<span class="comments">;     endif else begin</span>
<span class="comments">;         new_crop = crop[(4:nrow-4,4:ncol-4]</span>
<span class="comments">;     endelse</span>
<span class="comments">; endif</span>

<span class="comments">; Now, this is direction independent, what if we have good fiducials on one edge but not the other?</span>
<span class="comments">; We need to look at each edge independently</span>

big = MRDFITS(file)
p_crop = big[struct.center1.xpos-!param.safecrop:struct.center1.xpos+!param.safecrop,$
    struct.center1.ypos-!param.safecrop:struct.center1.ypos+!param.safecrop]


<span class="comments">;Not sure why, but the 2d arrays are turning into array[*]</span>

leftedge    = p_crop[0:2,*]
topedge     = p_crop[*,nrow-3:nrow-1]
rightedge   = p_crop[ncol-3:ncol-1,*]
botedge     = p_crop[*,0:2]

if (TOTAL(leftedge) gt N_ELEMENTS(leftedge)*MODE(p_crop)) then begin
    <span class="comments">; another 2 pix p_crop check</span>
    if TOTAL(p_crop[0:5,*]) gt N_ELEMENTS(p_crop[0:5,*])*MODE(p_crop) then p_cropleft=1 else p_cropleft=2
    <span class="comments">; newleftedge = p_crop[0:2,*]</span>
    <span class="comments">; endif else begin</span>
    <span class="comments">;     newleftedge = p_crop[0:5,*]</span>
    <span class="comments">; endelse</span>
endif else p_cropleft=0

<span class="comments">; Now do I do this for all sides?</span>

<span class="comments">; the thing right after the if statement is wrong</span>

if (TOTAL(topedge) gt N_ELEMENTS(topedge)*MODE(p_crop)) then begin
    if TOTAL(p_crop[*,nrow-5:nrow-1]) gt N_ELEMENTS(p_crop[*,nrow-5:nrow-1])*MODE(p_crop) then $
        p_croptop=1 else p_croptop=2
endif else p_croptop=0

if (TOTAL(rightedge) gt N_ELEMENTS(rightedge)*MODE(p_crop)) then begin
    if TOTAL(p_crop[ncol-5:ncol-1,*]) gt N_ELEMENTS(p_crop[ncol-5:ncol-1,*])*MODE(p_crop) then $
        p_cropright=1 else p_cropright=2
endif else p_cropright=0

if (TOTAL(botedge) gt N_ELEMENTS(botedge)*MODE(p_crop)) then begin
    if TOTAL(p_crop[*,0:5]) gt N_ELEMENTS(p_crop[*,0:5])*MODE(p_crop) then p_cropbot=1 else p_cropbot=2
endif else p_cropbot=0



<span class="comments">; newp_crop = p_crop[p_cropleft*3:ncol-1-p_cropright*3,p_cropbot*3:nrow-1-p_croptop*3]</span>


<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>


<span class="comments">; #       #     #     #####         #     #</span>
<span class="comments">; #       #    # #    #   #         #    ## </span>
<span class="comments">; # #   # #   #   #   ####          #   # #</span>
<span class="comments">; #  # #  #   #####   #   #         #  #####</span>
<span class="comments">; #   #   #  #     #  #    #        #     #</span>


<span class="comments">; convolving a larger image then cropping down</span>
print, 'stop stop stop'
stop

truecrop50 = cropme(dim50,!param.truecrop)

xpb = shift_diff(emboss(crop),dir=3) lt thresh
ypb = shift_diff(emboss(crop,az=90),dir=1) lt thresh

tmpcrop = crop[10:43,8:42]

<span class="comments">; window,0</span>
<span class="comments">; cgimage,tmpcrop,/k</span>
xpb = xpb[10:43,8:42]
ypb = ypb[10:43,8:42]

ncol = (size(tmpcrop,/dim))[0]
nrow = (size(tmpcrop,/dim))[1]
ind_col = WHERE(xpb eq 1) mod ncol
ind_row = WHERE(ypb eq 1)/nrow


a = MODE(ind_col)
b = MODE(ind_col[WHERE(ind_col ne a)])

c = MODE(ind_row)
d = MODE(ind_row[WHERE(ind_row ne c)])



<span class="comments">; Just to make it sorted</span>
xpos = [a,b]
ypos = [c,d]
xpos = xpos[SORT(xpos)]
ypos = ypos[SORT(ypos)]

<span class="comments">; window,1</span>
<span class="comments">; cgimage,tmpcrop*xpb,/k</span>

<span class="comments">; Results are promising! Convolving then cropping seems to be good.</span>

<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

<span class="comments">; #       #     #     #####         #   ######</span>
<span class="comments">; #       #    # #    #   #         #   # </span>
<span class="comments">; # #   # #   #   #   ####          #   ####</span>
<span class="comments">; #  # #  #   #####   #   #         #      ##</span>
<span class="comments">; #   #   #  #     #  #    #        #  #####</span>


<span class="comments">; Convolving then cropping looks good, but how to make the program to look for 2, 3, or 4 fiducials?</span>
<span class="comments">; How will will the program know?</span>

<span class="comments">; display,byte(tmpcrop),/square,title='100%'</span>
<span class="comments">; plot_edges,xpb,thick=6,setcolor=80</span>
<span class="comments">; plot_edges,ypb,thick=6,setcolor=255</span>




<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>


<span class="comments">; #       #     #     #####         #    ####</span>
<span class="comments">; #       #    # #    #   #         #   #    #</span>
<span class="comments">; # #   # #   #   #   ####          #    ####</span>
<span class="comments">; #  # #  #   #####   #   #         #   #    #</span>
<span class="comments">; #   #   #  #     #  #    #        #    ####</span>


<span class="comments">; After convol, crop, then check bordres - if detect fiducial, look 6 pixels inside of position</span>
<span class="comments">; if N_pixels &lt; 6, then crop that part out</span>

<span class="comments">; Issue is how to threshold it - only a fraction below shape of gaussian</span>

<span class="comments">; can't use median unless I median the whole image</span>
d = size(tmpcrop,/d)
bordermask = bytarr(d[0],d[1]) + 1
bordermask[1:d[0]-2,1:d[1]-2] = 0

mcrop = bordermask * tmpcrop

duhcrop = [reform(mcrop[*,d[1]-1]),reverse(reform(mcrop[d[0]-1,*])),reverse(reform(mcrop[*,0])),$
    reform(mcrop[0,*])]

<span class="comments">; I feel like I've dome something like this before... then I ended up resorting to using mode</span>
<span class="comments">; ...</span>
<span class="comments">; ...</span>

<span class="comments">; Looking at outermost pixel, what is best way to identify a fiducial?</span>

<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

<span class="comments">; #       #     #     #####         #    ####</span>
<span class="comments">; #       #    # #    #   #         #   #    #</span>
<span class="comments">; # #   # #   #   #   ####          #    ####</span>
<span class="comments">; #  # #  #   #####   #   #         #       #</span>
<span class="comments">; #   #   #  #     #  #    #        #     #</span>

<span class="comments">; So, we have several ways to get peaks from our *duhcrop* array</span>

<span class="comments">; duhcrop - duhcrop[1:n_elements(duhcrop)-2]</span>
<span class="comments">; - See where the difference between elements is highest</span>

<span class="comments">; duhcrop - ts_smooth(duhcrop,5)</span>
<span class="comments">; - Take time series average of array and see where difference is highest</span>

<span class="comments">; duhcrop - median(duhcrop,5) </span>
<span class="comments">; - same dif</span>

<span class="comments">; threshold it with mean(duhcrop) - 2*stddev(duhcrop)</span>
<span class="comments">; - why? Using a threshold is arbitrary</span>

<span class="comments">; Can't we just keep the convolution thing and not have to worry about individual pixel detection?</span>

<span class="comments">; ...</span>

xmcrop = mcrop * xpb
ymcrop = mcrop * ypb


ind_col = WHERE(xpb eq 1) mod ncol
ind_row = WHERE(ypb eq 1)/nrow

if ind_row eq !null then row_border = WHERE(HISTOGRAM(ind_row) ne 0)+1
if ind_col eq !null then col_border = WHERE(HISTOGRAM(ind_col) ne 0)+1

<span class="comments">; apparently histogram doesn't like it when there is only 1 value</span>
if N_ELEMENTS(row_border) eq 1 then row_border = MODE(ind_row)
if N_ELEMENTS(col_border) eq 1 then col_border = MODE(ind_col)

<span class="comments">; now that I've identified pixels, have to look inside positions</span>

<span class="comments">; Step 1: Look inside pixels</span>
<span class="comments">; Step 2: Figure out what I'm looking for</span>

row_slice_a = tmpcrop[*,row_border[0]]
row_slice_b = tmpcrop[*,row_border[1]]
col_slice = tmpcrop[col_border,*]

<span class="comments">; Can't identify with a minimum</span>

if N_ELEMENTS(FLOAT(col_slice[0:6]) - MODE(tmpcrop) lt somevalue) lt 6 then print, 'Lol'<span class="comments">;It's cut off</span>
<span class="comments">; Instead of modeling a fiducial shape, counting where the difference between fiducial values</span>
<span class="comments">; and mode is above a certain threshold</span>

<span class="comments">; Is this it?</span>


<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

stop

<span class="comments">; Dickin' around with convol()</span>
kernel = [[-1,1,-1],[1,1,1],[-1,1,-1]]
cgimage,CONVOL(crop,kernel),output='kerneltest.png',/k

stop

<span class="comments">; Testing out with diagonals</span>
wholeimage = BYTSCL( READ_TIFF('plots_tables_images/diag.tiff',channels=1) )
crop = wholeimage[struct.center1.xpos-!param.safecrop:struct.center1.xpos+!param.safecrop,$
    struct.center1.ypos-!param.safecrop:struct.center1.ypos+!param.safecrop]
cgimage,EMBOSS(crop,az=45),/k



<span class="comments">; Big ass kernel is not good</span>
kernel=[[1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1],$
        [-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1],$
        [-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1],$
        [-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,-1],$
        [-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1],$
        [-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1],$
        [-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1],$
        [-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1],$
        [-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,-1],$
        [-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1],$
        [-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1],$
        [1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1]]
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>
<span class="comments">; ******************************************************************************************</span>

stop
<span class="comments">; The sunthetic image has too-nice edges that they end up being edge-detected </span>
<span class="comments">; So I actually didn't anticipate this.</span>

<span class="comments">; window,0</span>
<span class="comments">; !p.multi=[0,2,1]</span>
<span class="comments">; cgimage,xpb*crop,/k</span>
<span class="comments">; cgimage,ypb*crop,/k</span>
<span class="comments">; !p.multi=0</span>

ind_col = WHERE(xpb eq 1) mod ncol
ind_row = WHERE(ypb eq 1)/nrow


a = MODE(ind_col)
b = MODE(ind_col[WHERE(ind_col ne a)])

c = MODE(ind_row)
d = MODE(ind_row[WHERE(ind_row ne f)])



<span class="comments">; Just to make it sorted</span>
xpos = [a,b]
ypos = [c,d]
xpos = xpos[SORT(xpos)]
ypos = ypos[SORT(ypos)]

<span class="comments">; Because fiducials are 2 pixels wide </span>
xmask = [xpos[0]-1,xpos[0],xpos[1]-1,xpos[1]]
ymask = [ypos[0]-1,ypos[0],ypos[1]-1,ypos[1]]

finish = SYSTIME(1,/s)
IF KEYWORD_SET(time) THEN print, 'merrygotrace took: '+strcompress(finish-start)+$
    ' seconds'

end
</code>
    </div>
  </body>
</html>