<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu May 23 17:43:27 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>trilimbcenter.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="trilimbcenter.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO makelimbstrips, thresh, xstrips, ystrips, file, ministrip_length, scan_width, sigmavalue, $
    sundiam, nstrips=nstrips, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Makes limb strips from full-length strips</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file: in, required, type=string, default='triplesun.bmp'</span>
<span class="comments">;           File to be read in</span>
<span class="comments">;       ministrip_length: in, required, type=byte, default=13</span>
<span class="comments">;           How long the total array of the cut-down strip will be</span>
<span class="comments">;       scan_width: in, required, type=integer, default=5</span>
<span class="comments">;           Indicates how far apart to scan</span>
<span class="comments">;       sigmavalue: in, required, type=integer, default=2</span>
<span class="comments">;           Sets the threshold to be::</span>
<span class="comments">;   </span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       nstrips : in, optional, type=byte, default=5</span>
<span class="comments">;           How many strips to select, centered around the row/col diameter</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;</span>
<span class="comments">;   :TODO:</span>
<span class="comments">;</span>
<span class="comments">;   Exactly how much data should be stored in a structure? Since we're interested in saving space,</span>
<span class="comments">;   doesn't make sense to repeat any data in the structures.</span>
<span class="comments">;-</span>

IF n_elements(file)             EQ 0    THEN file               = 'triplesun.bmp'
IF n_elements(ministrip_length) EQ 0    THEN ministrip_length   = 9
IF n_elements(nstrips)          EQ 0    THEN nstrips            = 5 
IF n_elements(scan_width)       EQ 0    THEN scan_width         = 5 
IF n_elements(sigmavalue)       EQ 0    THEN sigmavale          = 2
IF n_elements(sundiam)          EQ 0    THEN sundiam            = 70
IF n_elements(region)           EQ 0    THEN region             = 1

makestrips, thresh, c4xstrips, c4ystrips, file, scan_width, sigmavalue, sundiam, nstrips=nstrips, $
    region=region, time=time

start = systime(1,/seconds)

ministrip_side_buffer = ministrip_length/2 
rowchord_endpoints = fltarr(2,n_elements(c4xstrips))
colchord_endpoints = fltarr(2,n_elements(c4ystrips))
<span class="comments">;   Seeing where the array starts to be greater than the thresh</span>
FOR i = 0,n_elements(c4ystrips)-1 DO BEGIN
    col_where = where(c4ystrips[i].ARRAY GT thresh)
    <span class="comments">; beginning of chord</span>
    colchord_endpoints[0,i] = col_where[0]
    <span class="comments">; end of chord</span>
    colchord_endpoints[1,i] = col_where[-1]
ENDFOR

FOR i = 0,n_elements(c4xstrips) -1 DO BEGIN
    row_where = where(c4xstrips[i].ARRAY GT thresh)
    rowchord_endpoints[0,i] = row_where[0]
    rowchord_endpoints[1,i] = row_where[-1]
ENDFOR

<span class="comments">; Preallocating the array, replicating it by the number of strips there are</span>
xstrips = REPLICATE({ROWINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},n_elements(c4xstrips))
ystrips = REPLICATE({COLINDEX:0, BEGINDEX:0, ENDINDEX:0, $
        STARTPOINTS:bytarr(ministrip_length), $
        ENDPOINTS:bytarr(ministrip_length)},n_elements(c4ystrips))

<span class="comments">;Filling out structure with cut-down strip information</span>
FOR i = 0,n_elements(c4xstrips) - 1 DO BEGIN
    xstrips[i].ROWINDEX     = c4xstrips[i].ROWINDEX
    <span class="comments">; If there is no strip that cuts through the sun, set things to 0</span>
    IF rowchord_endpoints[0,i] EQ -1 THEN BEGIN
        xstrips[i].STARTPOINTS  = fltarr(ministrip_length) 
        xstrips[i].BEGINDEX     = 0
    ENDIF ELSE BEGIN
        <span class="comments">; STARTPOINTS is the cut down strip with length = ministrip_length and contains</span>
        <span class="comments">; the indices from rowchord_endpoints[0,i] +/- ministrip_side_buffer</span>
        xstrips[i].STARTPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[0,i]-ministrip_side_buffer:$
            rowchord_endpoints[0,i]+ministrip_side_buffer]   
        <span class="comments">; BEGINDEX is the index of the strip where it begins. </span>
        <span class="comments">; e.g., the array is 5 long, starts from index 9 and is centered around index 11</span>
        xstrips[i].BEGINDEX     = fix(rowchord_endpoints[0,i] - ministrip_side_buffer)
    ENDELSE
    IF rowchord_endpoints[1,i] EQ -1 THEN BEGIN
        xstrips[i].ENDPOINTS    = fltarr(ministrip_length)
        xstrips[i].ENDINDEX    = 0
    ENDIF ELSE BEGIN
        xstrips[i].ENDPOINTS  = $
            (c4xstrips[i].ARRAY)[rowchord_endpoints[1,i]-ministrip_side_buffer:$
            rowchord_endpoints[1,i]+ministrip_side_buffer]   
        xstrips[i].ENDINDEX     = fix(rowchord_endpoints[1,i] - ministrip_side_buffer)
    ENDELSE
ENDFOR

FOR k = 0,n_elements(c4ystrips) - 1 DO BEGIN
    ystrips[k].COLINDEX     = c4ystrips[k].COLINDEX
    IF colchord_endpoints[0,k] EQ -1 THEN BEGIN
        ystrips[k].STARTPOINTS  = fltarr(ministrip_length) 
        ystrips[k].BEGINDEX     = 0
    ENDIF ELSE BEGIN 
        ystrips[k].STARTPOINTS  = (c4ystrips[k].ARRAY)[colchord_endpoints[0,k]- $
            ministrip_side_buffer:colchord_endpoints[0,k]+ministrip_side_buffer]
        ystrips[k].BEGINDEX     = fix(colchord_endpoints[0,k] - ministrip_side_buffer)
    ENDELSE
    IF colchord_endpoints[1,k] EQ -1 THEN BEGIN
        ystrips[k].ENDPOINTS    = fltarr(ministrip_length) 
        ystrips[k].ENDINDEX     = 0        
    ENDIF ELSE BEGIN
        ystrips[k].ENDPOINTS    = (c4ystrips[k].ARRAY)[colchord_endpoints[1,k]- $
        ministrip_side_buffer:colchord_endpoints[1,k]+ministrip_side_buffer]
        ystrips[k].ENDINDEX     = fix(colchord_endpoints[1,k] - ministrip_side_buffer) 
    ENDELSE
ENDFOR

finish = systime(1,/seconds)

IF keyword_set(time) THEN  print,'Elapsed Time for makelimbstrips: ', $
    strcompress(finish-start,/rem),' seconds'
RETURN
END



PRO makestrips, thresh, xstrips, ystrips, file, scan_width, sigmavalue, sundiam, nstrips=nstrips, $
    region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Only saves 5 strips centered around the solar diameter to reduce the amount of limb-</span>
<span class="comments">;           darkened pixels and to make the polynomial-fitted limbs more-or-less look similar. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;   file: in, required, type=string, default='triplesun.bmp'</span>
<span class="comments">;       File to be read in</span>
<span class="comments">;   scan_width: in, required, type=integer, default=5</span>
<span class="comments">;       Indicates how far apart to scan</span>
<span class="comments">;   sigmavalue: in, required, type=integer, default=2</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;   </span>
<span class="comments">;       max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;   sundiam : in, required, type=byte, default=70</span>
<span class="comments">;       Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;   thresh : out, required, type=float</span>
<span class="comments">;       Threshold used to select pixels</span>
<span class="comments">;   xstrips : out, required, type=structure</span>
<span class="comments">;       Structure containing row strips</span>
<span class="comments">;   ystrips : out, required, type=structure</span>
<span class="comments">;       Structure containing column strips</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;   nstrips : in, optional, type=byte, default=5</span>
<span class="comments">;       How many strips to select, centered around the row/col diameter</span>
<span class="comments">;   region : in, required, type=integer, default=1</span>
<span class="comments">;       Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Prints elapsed time</span>
<span class="comments">;-</span>

IF n_elements(file)         EQ 0    THEN file       = 'triplesun.bmp'
IF n_elements(nstrips)      EQ 0    THEN nstrips    = 5
IF n_elements(region)       EQ 0    THEN region     = 1
IF n_elements(scan_width)   EQ 0    THEN scan_width = 5
IF n_elements(sigmavalue)   EQ 0    THEN sigmavalue = 2
IF n_elements(sundiam)      EQ 0    THEN sundiam    = 70

struct = tribox(file, scan_width, sigmavalue, sundiam, region=region, time=time)
<span class="comments">; trimask, file, xpos, ypos, scan_width, sigmavalue, sundiam, thresh, region=region, time=time</span>

start = systime(1,/seconds)

cropped_image = struct.image
thresh = max(cropped_image) - stddev(cropped_image)*sigmavalue 

colscan = 0

WHILE total(where(cropped_image[colscan,*] GT thresh/2)) EQ -1 DO BEGIN
    colscan++
ENDWHILE
rowscan = fix(((where(cropped_image[colscan,*] GT thresh/2))[0] - sundiam/2 + $
        n_elements(where(cropped_image[colscan,*] GT thresh/2))/2 ))

rowendscan = rowscan + sundiam
colendscan = colscan + sundiam

xpos = (colscan + colendscan)/2.<span class="comments">; + struct.xoffset</span>
ypos = (rowscan + rowendscan)/2.<span class="comments">; + struct.yoffset</span>

s = size(cropped_image,/dimensions)
length = s[0]
height = s[1]

rowchord_endpoints = fltarr(2,nstrips)
colchord_endpoints = fltarr(2,nstrips)

xstrips = REPLICATE({ROWINDEX:0,ARRAY:bytarr(length)},nstrips)
ystrips = REPLICATE({COLINDEX:0,ARRAY:bytarr(height)},nstrips)

FOR i = 0,nstrips - 1 DO BEGIN
    xstrips[i].ROWINDEX = i
    xstrips[i].ARRAY = cropped_image[*, round(xpos)+(i-nstrips/2)*scan_width]
ENDFOR

FOR k = 0,nstrips - 1 DO BEGIN
    ystrips[k].COLINDEX = k
    ystrips[k].ARRAY = cropped_image[round(ypos)+(k-nstrips/2)*scan_width,*]
ENDFOR

finish = systime(1,/seconds)
IF keyword_set(time) THEN  print,'Elapsed Time for makestrips: ', $
    strcompress(finish-start,/rem),' seconds'

RETURN
END


PRO limbfit, thresh, xpos, ypos, file, ministrip_length, order, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, plot=plot, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;   Uses the data from makelimbstrips and fits an n-th order polynomial to the limb to find where</span>
<span class="comments">;       it crosses the threshold.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file : in, required, type=string, default='triplesun.bmp'</span>
<span class="comments">;           File to be read in</span>
<span class="comments">;       ministrip_length : in, required, default=9</span>
<span class="comments">;           How long the trimmed down strip will be</span>
<span class="comments">;       order : in, required, type=integer, default=3</span>
<span class="comments">;           What order polynomial to use for POLY_FIT()</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           Indicates how far apart to scan</span>
<span class="comments">;       sigmavalue : in, required, type=integer, default=2</span>
<span class="comments">;           Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           X center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Y center</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       nstrips : in, optional, type=byte, default=5</span>
<span class="comments">;           How many strips to select, centered around the row/col diameter</span>
<span class="comments">;       region : in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       plot : in, optional</span>
<span class="comments">;           Makes some nice plots</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; Setting default values</span>
IF n_elements(file)                 EQ 0    THEN file              = 'triplesun.bmp'
IF n_elements(ministrip_length)     EQ 0    THEN ministrip_length  = 9
IF n_elements(nstrips)              EQ 0    THEN nstrips           = 5
IF n_elements(order)                EQ 0    THEN order             = 2
IF n_elements(region)               EQ 0    THEN region            = 1
IF n_elements(scan_width)           EQ 0    THEN scan_width        = 5
IF n_elements(sigmavalue)           EQ 0    THEN sigmavalue        = 2
IF n_elements(sundiam)              EQ 0    THEN sundiam           = 70

<span class="comments">; Run the program to get our structures</span>
makelimbstrips, thresh, xstrips, ystrips, file, ministrip_length, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, region=region, time=time

start = systime(1,/seconds)

ministrip_side_length = ministrip_length/2
xlen    = 0
xsum    = 0
xnum    = 0   
ylen    = 0
ysum    = 0
ynum    = 0
xarr    = findgen(n_elements(xstrips[4].STARTPOINTS))
yarr    = findgen(n_elements(ystrips[4].STARTPOINTS))
tx      = findgen(n_elements(xstrips[4].STARTPOINTS) * 1000)/100
ylenarr = findgen(n_elements(ystrips))
xlenarr = findgen(n_elements(xstrips))

<span class="comments">;Deal with rows</span>
FOR n=0,n_elements(xstrips)-1 DO BEGIN
    <span class="comments">; Using fz_roots instead of spline interpolating. Saving lines and making code more readable</span>
    startresult     = reform(poly_fit(xarr,xstrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(xarr,xstrips[n].ENDPOINTS,order))

    <span class="comments">; Solving for roots but want to include threshold value</span>
    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF xstrips[n].BEGINDEX GT 0 THEN BEGIN
        <span class="comments">; Get roots (complex)</span>
        begroots    = fz_roots(startresult)
        <span class="comments">; Take only roots with no imaginary components</span>
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        <span class="comments">; Find smallest root (apparently I have to choose the smaller one)</span>
        <span class="comments">; Or i can find the midpoints using the other two roots then take the average of the two,</span>
        <span class="comments">; that way works too, but why would I do that?</span>
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = xstrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF xstrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = xstrips[n].ENDINDEX + endusable
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    <span class="comments">; Stick the midpoints in an array to take the mean of later</span>
    xlenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

FOR n=0,n_elements(ystrips)-1 DO BEGIN
    startresult     = reform(poly_fit(yarr,ystrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(yarr,ystrips[n].ENDPOINTS,order))

    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF ystrips[n].BEGINDEX GT 0 THEN BEGIN
        begroots    = fz_roots(startresult)
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = ystrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF ystrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = ystrips[n].ENDINDEX + endusable
        
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    ylenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = mean(xlenarr[where(xlenarr ne 0)])
ypos = mean(ylenarr[where(ylenarr ne 0)])

struct = tribox(file, scan_width, sigmavalue, sundiam, region=region, time=time)
xpos+=struct.xoffset
ypos+=struct.yoffset

IF keyword_set(plot) THEN BEGIN
    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,0
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>

    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,3
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,1
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'    </span>
ENDIF

finish = systime(1,/seconds)

IF keyword_set(time) THEN  print,'Elapsed Time for limbfit: ',strcompress(finish-start,/rem),' seconds'
<span class="comments">; save,xpos,ypos,thresh,sigmavalue,order,file, ministrip_length,scan_width,$</span>
<span class="comments">;     filename='comp6results.sav',/compress</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>

<span class="comments">; OPENW,1,'comp6results.dat' </span>
<span class="comments">; PRINTF,1,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,1</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>
<span class="comments">; OPENW,2,'comp6results.txt' </span>
<span class="comments">; PRINTF,2,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,2</span>
RETURN
END



PRO getstruct, file, struct, scan_width, sigmavalue, sundiam, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds the centers of a triple-sun image and loads all relevant information</span>
<span class="comments">;       including offsets and angles into a new structure.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file: in, required, type = string, default = 'triplesun.bmp'</span>
<span class="comments">;           What file to find 3 centers for</span>
<span class="comments">;       struct : out, required, type=structure</span>
<span class="comments">;           Structure containing the centers and cropped images of all 3 suns</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           How apart the scans are for minicrop(). </span>
<span class="comments">;       sigmavalue : in, required, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

start = systime(1,/s)

center1 = {center1,xpos:0d,ypos:0d,thresh:0d}
center2 = {center2,xpos:0d,ypos:0d,thresh:0d}
center3 = {center3,xpos:0d,ypos:0d,thresh:0d}

nstrips=5

<span class="comments">; trimask, file, xpos, ypos, scan_width, sigmavalue, sundiam, thresh, region=1, time=time</span>
limbfit, thresh, xpos, ypos, file, ministrip_length, order, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, plot=plot, region=1, time=time
<span class="comments">; struct = tribox(file, scan_width, sigmavalue, sundiam, region=1, time=time)</span>
<span class="comments">; xpos+=struct.xoffset</span>
<span class="comments">; ypos+=struct.yoffset</span>
center1.xpos = xpos
center1.ypos = ypos
center1.thresh = thresh
<span class="comments">;trimask, file, xpos, ypos, scan_width, sigmavalue, sundiam, thresh, region=2, time=time</span>
limbfit, thresh, xpos, ypos, file, ministrip_length, order, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, plot=plot, region=2, time=time
<span class="comments">; struct = tribox(file, scan_width, sigmavalue, sundiam, region=2, time=time)</span>
<span class="comments">; xpos+=struct.xoffset</span>
<span class="comments">; ypos+=struct.yoffset</span>
center2.xpos = xpos
center2.ypos = ypos
center2.thresh = thresh
<span class="comments">;trimask, file, xpos, ypos, scan_width, sigmavalue, sundiam, thresh, region=3, time=time</span>
limbfit, thresh, xpos, ypos, file, ministrip_length, order, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, plot=plot, region=3, time=time
<span class="comments">; struct = tribox(file, scan_width, sigmavalue, sundiam, region=3, time=time)</span>
<span class="comments">; xpos+=struct.xoffset</span>
<span class="comments">; ypos+=struct.yoffset</span>
center3.xpos = xpos
center3.ypos = ypos
center3.thresh = thresh

theta = !radeg*atan((center3.ypos - center2.ypos)/(center3.xpos - center2.xpos))
hypot = sqrt((center3.ypos - center2.ypos)^2 + (center3.xpos - center2.xpos)^2)
offset = ((center1.xpos - center2.xpos)*(center3.ypos - center2.ypos) - $
    (center1.ypos - center2.ypos)*(center3.xpos - center2.xpos))/hypot

struct = {KAHUNA, center1:center1, center2:center2, center3:center3, $
    theta:theta, offset:offset}
finish = systime(1,/s)
IF keyword_set(time) THEN print, 'getstruct took: '+strcompress(finish-start)+$
    ' seconds'
RETURN
END


FUNCTION cropit, inputarr, location, scan_width, sigmavalue, sundiam, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Loads a triple-sun image and crops out selected regions one-by-one.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputarr : in, required, type=byte</span>
<span class="comments">;           Starting image to crop</span>
<span class="comments">;       location : out, required, type=structure</span>
<span class="comments">;           Structure containing the cropped image along with the X and Y distances from origin</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           How apart the scans are for minicrop(). </span>
<span class="comments">;       sigmavalue : in, required, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam: in, required, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;         Print the elapsed time</span>
<span class="comments">;</span>
<span class="comments">;   :Examples:</span>
<span class="comments">;       cropped = cropit(inputarr,scan_width,sigmavalue,sundiam,region=1)</span>
<span class="comments">;</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

IF n_elements(scan_width) EQ 0 THEN scan_width = 5
IF n_elements(sigmavalue) EQ 0 THEN sigmavalue = 2
IF n_elements(sundiam)    EQ 0 THEN sundiam = 70
IF n_elements(region)     EQ 0 THEN region = 1

start = systime(1,/s)

thresh = max(inputarr) - sigmavalue*stddev(inputarr)
temparr = inputarr * (inputarr gt thresh)

minicrop, temparr, rowscan, colscan, rowendscan, colendscan, scan_width, sundiam, thresh,time=time


<span class="comments">;***************************************************************************************************</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">; Making a big fuss over sort(), let's figure out how it can reduce/remove the multiple scanning   *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;                                                                                                  *</span>
<span class="comments">;***************************************************************************************************</span>


<span class="comments">; a=inputarr</span>
<span class="comments">; b = where(a gt thresh, n_gt,complement=leftout)</span>
<span class="comments">; c = array_indices(a,b)</span>
<span class="comments">; ; These are x and y positions where a gt thresh</span>
<span class="comments">; d = array_indices(a,leftout)</span>
<span class="comments">; ; These are the x and y positions of everywhere else</span>


<span class="comments">; stop</span>
CASE region OF

1: BEGIN
    cropped=inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:$
        rowendscan*scan_width]
    END

2: BEGIN
    inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:rowendscan*scan_width] = 0
    
    <span class="comments">;****************************************************************************************</span>

    temparr = inputarr * (inputarr lt thresh)

    minicrop,temparr, rowscan, colscan, rowendscan, colendscan, scan_width,$
        sundiam, thresh,time=time

    cropped=inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:$
        rowendscan*scan_width]
    END

3: BEGIN
    inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>

    <span class="comments">; Step 2: Black out the first dimsum</span>
    temparr = inputarr * (inputarr lt thresh)

    minicrop,temparr, rowscan, colscan, rowendscan, colendscan, scan_width,$
        sundiam, thresh,time=time

    inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>

    <span class="comments">; Step 3: Crop what's left</span>
    temparr = inputarr * (inputarr lt thresh)

    minicrop,temparr, rowscan, colscan, rowendscan, colendscan, scan_width,$
        sundiam, thresh,time=time

    cropped=inputarr[colscan*scan_width:colendscan*scan_width,rowscan*scan_width:$
        rowendscan*scan_width]

    END
ENDCASE
<span class="comments">; window,region</span>
<span class="comments">; cgimage,cropped,/k</span>
location = {image:cropped,xoffset:colscan*scan_width,yoffset:rowscan*scan_width}
finish = systime(1,/s)
IF keyword_set(time) THEN print,' cropit() took '+strcompress(finish-start,/remove)+' seconds'
RETURN,location
END




PRO minicrop, temparr, rowscan, colscan, rowendscan, colendscan, scan_width,$
        sundiam, thresh,time=time
<span class="comments">;+</span>
<span class="comments">;   :Description: </span>
<span class="comments">;       Small function to keep code small in cropit. Finds the row where the threshold is crossed</span>
<span class="comments">;       and then steps back in the x-direction to find the left side of the cropping box. Skips </span>
<span class="comments">;       over the sun by a predetermined value then crops out the sun. </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       temparr : in, required, type=byte</span>
<span class="comments">;           2D array to check boundary limits of</span>
<span class="comments">;       rowscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the rows from</span>
<span class="comments">;       colscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the columns from</span>
<span class="comments">;       rowendscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the rows to</span>
<span class="comments">;       colendscan : out, required, type=integer</span>
<span class="comments">;           Where to crop the columns to</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           How apart the scans are for minicrop(). </span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;       temparr : in, required, type=byte</span>
<span class="comments">;           2D array to check boundary limits of</span>
<span class="comments">;       thresh : in, required, type=float</span>
<span class="comments">;           What the minimum threshold will be for scanning</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Print the elapsed time</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

start = systime(1,/s)

<span class="comments">;rowscan=0</span>
<span class="comments">;WHILE total(where(temparr[*,rowscan*scan_width] GT thresh/2)) EQ -1 DO BEGIN</span>
<span class="comments">;    rowscan++</span>
<span class="comments">;ENDWHILE</span>
<span class="comments">;; Doing it this way so that if in the case of 3 suns, if 1 sun is more left than the sun which </span>
<span class="comments">;; is the most bottom, the cropping will correctly choose the right sun.</span>
<span class="comments">;colscan = fix(((where(temparr[*,rowscan*scan_width] GT thresh/2))[0] - sundiam/2 + $</span>
<span class="comments">;        n_elements(where(temparr[*,rowscan*scan_width] GT thresh/2))/2 )/scan_width)</span>
<span class="comments">;</span>

<span class="comments">; Redoing it so that we scan left to right before bottom to top</span>

colscan = 0
WHILE total(where(temparr[colscan*scan_width,*] GT thresh/2)) EQ -1 DO BEGIN
    colscan++
ENDWHILE
rowscan = fix(((where(temparr[colscan*scan_width,*] GT thresh/2))[0] - sundiam/2 + $
        n_elements(where(temparr[colscan*scan_width,*] GT thresh/2))/2 )/scan_width)




rowendscan = rowscan + sundiam/scan_width <span class="comments">; Jumping to other side of sun</span>
colendscan = colscan + sundiam/scan_width

<span class="comments">;Since the column scanning is rough, have to give the ends a little room.</span>
rowscan     -= 3
colscan     -= 3
rowendscan  += 3
colendscan  += 3

finish = systime(1,/s)
IF keyword_set(time) THEN print,' minicrop took '+strcompress(finish-start,/remove)+' seconds'

RETURN
END



<span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;   TRICENTER</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Finds the center of 3 suns in a single image. Currently limited to a .bmp test image. </span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   JEREN SUZUKI::</span>
<span class="comments">;</span>
<span class="comments">;       Space Sciences Laboratory</span>
<span class="comments">;       7 Gauss Way</span>
<span class="comments">;       Berkeley, CA 94720 USA</span>
<span class="comments">;       E-mail: jsuzuki@ssl.berkeley.edu</span>
<span class="comments">;-</span>

<span class="comments">; PRO trilimbcenter, file, scan_width, sigmavalue, sundiam, time=time</span>
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       This version uses limb fitting opposed to masking (tricenter). </span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file: in, required, type = string, default = 'triplesun.bmp'</span>
<span class="comments">;           What file to find 3 centers for</span>
<span class="comments">;       scan_width: in, required, type = integer, default = 5</span>
<span class="comments">;           How apart the scans are for minicrop(). Overrides defaults in crop().</span>
<span class="comments">;       sigmavalue: in, required, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;</span>
<span class="comments">;   :TODO: </span>
<span class="comments">;       Make it use limb-fitting instead of simple masking</span>
<span class="comments">;   </span>
<span class="comments">;       Can't use .run tricenter anymore since it's broken up. resolve_all won't solve it</span>
<span class="comments">;-</span>
COMPILE_OPT idl2 
on_error,2

IF n_elements(file)         EQ 0 THEN   file = 'yetanothertriplesun.bmp'
IF n_elements(scan_width)   EQ 0 THEN   scan_width = 5
IF n_elements(sigmavalue)   EQ 0 THEN   sigmavalue = 2
IF n_elements(sundiam)      EQ 0 THEN   sundiam = 70

start=systime(1,/s)

getstruct, file, struct, scan_width, sigmavalue, sundiam, time=time

tmpimage = read_bmp(file) 
s = size(tmpimage,/dimensions)
n_col = s[1]
n_row = s[2]
image = reform(tmpimage[0,*,*])
image2 = image
image3 = image

image[struct.center1.xpos,*]=20
image[*,struct.center1.ypos]=20
image2[struct.center2.xpos,*]=20
image2[*,struct.center2.ypos]=20
image3[struct.center3.xpos,*]=20
image3[*,struct.center3.ypos]=20

<span class="comments">; window,0</span>
<span class="comments">; cgimage,image,/k</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,image2,/k</span>
<span class="comments">; window,3</span>
<span class="comments">; cgimage,image3,/k</span>

finish = systime(1,/s)
IF keyword_set(time) THEN print, 'tricenter took: '+strcompress(finish-start)+$
    ' seconds'
stop
END

</code>
    </div>
  </body>
</html>