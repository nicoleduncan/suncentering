<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Wed Aug 21 14:11:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>horiz.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="horiz.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; horiz.pro</span>

READ_JPEG,'plots_tables_images/100kft/notilt.jpg',image
redc = reform(image[0,*,*])

spacethresh = 110
mask = redc gt spacethresh
spacemask = (redc lt 100)*redc
rmask = mask*redc
s = size(redc,/dim)
n_col = s[0]
n_row = s[1]

thresh = 60

yspot = where(shift_diff(rmask,dir=1) gt thresh)/n_row
cline = fltarr(n_col)
reg1limb = fltarr(n_col)
reg2limb = fltarr(n_col)

for i = 0,n_col-1 do begin
    cline[i] = mean(where(rmask[i,*] lt thresh))
endfor

height = mean(cline)

<span class="comments">; The only thing we care about from the fit is the y intercept </span>
result=linfit(findgen(n_col),cline)
ama = rmask

for i = 0,n_col-1 do begin
    reg2limb[i] = (where(rmask[i,0:height] gt thresh))[-1]
    reg1limb[i] = (where(rmask[i,height:n_row-1] gt thresh))[0]
    ama[i,reg2limb[i]] = 200
    ama[i,reg1limb[i]+height] = 200
endfor

xarr = findgen(n_col)
tx = findgen(n_col * 100)/100
a=poly_fit(xarr,reg2limb,2)
spl = spline(xarr,a[0] + a[1]*xarr + a[2]*xarr^2,tx)


loadct,0

<span class="comments">; window,0</span>
ps_start,filename='earth_limb.eps',/encapsulated
plot,xarr,reg2limb,xs=3,ys=3,psym=3,ytitle='Y-Position',xtitle='X-Position',title='Earth Limb Pixel Position'
oplot,tx,spl,linestyle=1
ps_end

phi = tan((spl[-1]-spl[0])/n_col)*!radeg

print,'Angle from looking at ends of polyfitted indices',phi
print,'Angle from looking at linear fit slope of midpoints of limbs',result[1]*!radeg
print,'^^ Realistically, this should be 0'
<span class="comments">; It's a coincidence they are close, right?</span>

<span class="comments">; Imagine if the camera was completely level, in that case the slope from linfit=0 but </span>
<span class="comments">; then there could be roll, so phi can be non-zero</span>
<span class="comments">; window,1</span>
<span class="comments">; cgimage,rmask,/k,output='plots_tables_images/rmask.eps'</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,ama,/k,output='plots_tables_images/ama.eps'</span>

cgimage,spacemask,/k,output='plots_tables_images/spacemask.eps'

window,0
plot,xarr,reg2limb,xs=3,ys=3,psym=4,ytitle='Y-Position',xtitle='X-Position',title='Earth Limb Pixel Position'
oplot,tx,spl,linestyle=1
window,1
cgimage,rmask,/k
window,2
cgimage,ama,/k

<span class="comments">;************************************************************************************************</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;************************************************************************************************</span>

s = size(spacemask,/dimensions)
n_col = s[0]
n_row = s[1]

xpos = TOTAL( TOTAL(spacemask, 2) * Indgen(n_col) ) / total(spacemask)
ypos = TOTAL( TOTAL(spacemask, 1) * Indgen(n_row) ) / total(spacemask)

spredc = redc
spredc[xpos-1:xpos+1,*]=255
spredc[*,ypos-1:ypos+1]=255

<span class="comments">; adding 2 1 pix buffer to make it easier to see</span>

spredc[n_col/2,*] = 100

window,3
cgimage,spredc,/k<span class="comments">;';,output='maskcenter.eps'</span>


<span class="comments">;************************************************************************************************</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;                                                                                               *</span>
<span class="comments">;************************************************************************************************</span>



<span class="comments">; now going to try some GEOMETRY </span>

<span class="comments">; arclen / (2*R) = asin(half_chord_length/R)</span>

<span class="comments">; main_chord_length = theta/alpha * 2 * sin(theta/2.)     solve for theta</span>

<span class="comments">; reg2limbend_1 = []</span>
<span class="comments">; reg2limbend_2 = []</span>

clength = sqrt((n_col - 0)^2 + (spl[-1] - spl[0])^2)
alpha = crvlength(tx,spl)

<span class="comments">; clength = theta/alpha * 2 * sin(theta/2)</span>

<span class="comments">; wolfram alpha gives theta = 5.769 i +/- 21.954 j  Taking on the real out, so we're looking at an anfle of 5.76?</span>
theta = 5.76924*!dtor
radius = alpha/theta

anglearr = findgen(1e6)/1e6 * 2*!pi
x = radius*cos(anglearr)
y = radius*sin(anglearr)

<span class="comments">; tvcircle,radius,x,y</span>
















stop

end
</code>
    </div>
  </body>
</html>