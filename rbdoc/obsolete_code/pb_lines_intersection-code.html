<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jun 11 15:09:41 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pb_lines_intersection.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pb_lines_intersection.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">; PB_LINES_INTERSECTION</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">; Use this function to find the intersection point of two lines </span>
<span class="comments">; defined as segments (start and endpoints are provided).  For</span>
<span class="comments">; now the lines must be coplanar (i.e. 2D).</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">; result = PB_LINES_INTERSECTION(LineA, LineB, $</span>
<span class="comments">;   [UA = variable], [UB = variable], $</span>
<span class="comments">;   [PARALLEL = variable], [COINCIDENT = variable], $</span>
<span class="comments">;   [ONSEGMENT = variable], $</span>
<span class="comments">;   [ANGLE = angle])</span>
<span class="comments">;</span>
<span class="comments">; RETURNED VALUE:</span>
<span class="comments">; A two element array of the intersection [X, Y].  If the </span>
<span class="comments">; lines are parallel or coincident then the returned </span>
<span class="comments">; value contains NANs and the appropriate output keyword is</span>
<span class="comments">; returned as TRUE(non-zero).</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">; LINEA and LINEB  4 element arrays that define the start and </span>
<span class="comments">;   end points of the lines in the form [x0,y0,x1,y1] or </span>
<span class="comments">;   [[x0,y0],[x1,y1]]</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">; ANGLE Set equal to a named variable to retrieve the angle (in radians) between</span>
<span class="comments">;   A and B as swept from A to B positive CCW.  The angle is between -pi and +pi </span>
<span class="comments">; UA and UB  The parametric scaling constants calculated from the input</span>
<span class="comments">;   points.</span>
<span class="comments">; PARALLEL Set this equal to a named variable which is returned</span>
<span class="comments">;   as TRUE (non-zero) if the lines are parallel</span>
<span class="comments">; COINCIDENT Set this equal to a named variable which is returned</span>
<span class="comments">;   as TRUE (non-zero) if the lines are coincident (and parallel, too!)</span>
<span class="comments">; ONSEGMENT Set this equal to anamed variable to retrieve a two</span>
<span class="comments">;   element flag indicating the point lies within the corresponding </span>
<span class="comments">;   segments.  For example, [1,0] indicates that the point is within</span>
<span class="comments">;   the two points defining the A line but it is outside the endpoints </span>
<span class="comments">;   of the B line (but lines A and B still intersect somewhere).</span>
<span class="comments">;</span>
<span class="comments">; REFERENCE:</span>
<span class="comments">; Paul Bourke's Geometry Resources located at</span>
<span class="comments">; http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/</span>
<span class="comments">; http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">; A = [1.0,1.0,2.0,2.0]</span>
<span class="comments">; B = [1.0,2.0,2.0,1.0]</span>
<span class="comments">; xy = PB_LINES_INTERSECTION(A,B)</span>
<span class="comments">; plot, A[[0,2]],A[[1,3]]</span>
<span class="comments">; oplot, B[[0,2]],B[[1,3]]</span>
<span class="comments">; plots, xy[0],xy[1],psym = 6</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 2007-07-15 BT adapted from description in reference.</span>
<span class="comments">; 2012-02-13 BT switched to cg* graphics</span>
<span class="comments">;-</span>
<span class="comments">;</span>
PRO TESTLINES2, waitInterval

	if (n_elements(waitInterval) EQ 0) then waitInterval = 3
	
	A=[[0.0, 0.0], [5.0, 5.0]] & B = [[5.0, 0.0], [0.0, 5.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[1.0, 3.0], [9.0, 3.0]] & B = [[0.0, 1.0], [2.0, 1.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[1.0, 5.0], [6.0, 8.0]] & B = [[0.5, 3.0], [6.0, 4.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[1.0, 1.0], [3.0, 8.0]] & B = [[0.5, 2.0], [4.0, 7.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[1.0, 2.0], [3.0, 6.0]] & B = [[2.0, 4.0], [4.0, 8.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[3.5, 9.0], [3.5, 0.5]] & B = [[3.0, 1.0], [9.0, 1.0]]<span class="comments">;</span>
    TESTLINES, A, B
    WAIT,waitInterval
    A=[[2.0, 3.0], [7.0, 9.0]] & B = [[1.0, 2.0], [5.0, 7.0]]<span class="comments">;</span>
END
PRO TESTLINES, A, B

  if n_params() NE 2 then begin
    A= [[1.0,1.0], [2.0,3.0]]
    B =[[4.0, 1.0],[1.5,1.4]]
  endif
  
  XY=PB_LINES_INTERSECTION(A,B, UA = ua, UB = ub, ONSEG = onseg, ANGLE = angle)
  
  cgPLOT, [A[0,*]&lt<span class="comments">;B[0,*], A[0,*]>B[0,*]],$</span>
        [A[1,*]&lt<span class="comments">;B[1,*], A[1,*]>B[1,*]], $</span>
        PSYM = -4,/NODATA, XSTYLE = 2, YSTYLE = 2
  cgPLOTS, A[0,*],A[1,*],color = cgCOLOR('red')
  cgPLOTS, A[0,1],A[1,1],color = cgCOLOR('red'), PSYM = 4
  cgPLOTS, B[0,*], B[1,*],color = cgCOLOR('blue')
  cgPLOTS, B[0,1], B[1,1],color = cgCOLOR('blue'), PSYM = 5
  cgPLOTS, XY[0],XY[1], PSYM = 6, SYMSIZE = 2, color = cgColor("black")
  
  print, 'XY = ', XY
  PRINT, 'UA = ', UA
  PRINT, 'UB = ', UB
  PRINT, 'ONSEG = ', onseg
  <span class="comments">;PRINT, !RADEG*angle</span>
END


FUNCTION L_I_ANGLE, h1,v1,h2,v2, PI
  <span class="comments">;h1 and h2   horizontal sizes of segments</span>
  <span class="comments">;v1 and v2   vertical sizes of segments</span>
  theta1 = ATAN(v1,h1)
  theta2 = ATAN(v2,h2)
  dtheta = theta2-theta1
  While (dtheta GT PI) do dtheta -= (2*PI)
  While (dtheta LT PI) do dtheta += (2*PI)
RETURN, dtheta
END


FUNCTION PB_LINES_INTERSECTION, AA, BB, $
  UA = ua, UB = ub,$
  PARALLEL = parallel, $
  COINCIDENT = coincident, $
  ONSEGMENT = onSegment,$
  ANGLE = angle, DOUBLE = double
  
  if (SIZE(aa,/TYPE) EQ 5) OR (SIZE(bb,/TYPE) EQ 5) OR KEYWORD_SET(double) then begin
    PI = !DPI
    NAN = !VALUES.D_NAN
    ZERO = 0.0d0
    ONE = 1.0d0
    ANGLE = !VALUES.D_NAN
  endif else begin
    PI = !PI
    NAN = !VALUES.F_NAN
    ZERO = 0.0
    ONE = 1.0
    ANGLE = !VALUES.D_NAN
  endelse
  
  <span class="comments">;LineA or LineB must be [x0,y0,x1,y1]</span>
   
  PARALLEL = 0
  COINCIDENT = 0
  onSegment  = [0B,0B]
  
  <span class="comments">;A = AA[*, BSORT(AA[0,*])]</span>
  <span class="comments">;B = BB[*, BSORT(BB[0,*])]</span>
  
  A = AA
  B = BB
  
  x1 = A[0] & x2 = A[2] & x3 = B[0] & x4 = B[2]
  y1 = A[1] & y2 = A[3] & y3 = B[1] & y4 = B[3]
  
  <span class="comments">;denom = (B[3]-B[1])*(A[2]-A[0]) - (B[2]-B[0])*(A[3]-A[1])</span>
  denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
  
  <span class="comments">;ua = (B[2]-B[0])*(A[1]-B[3]) - (B[3]-B[1])*(A[0]-B[2])</span>
  ua = (x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)
  
  <span class="comments">;ub = (A[2]-A[0])*(A[1]-B[3]) - (A[3]-A[1])*(A[0]-B[2])</span>
  ub = (x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)
  
  <span class="comments">;if denom EQ 0 then parallel lines</span>
  if denom EQ 0 then begin
    PARALLEL = 1
    if (PB_POINT_SAME(ua, zero) AND PB_POINT_SAME(ub,zero)) $
     then COINCIDENT = 1
    RETURN, [NAN,NAN]
  endif

  ua = ua/denom
  ub = ub/denom

  onSegment = [ (ua GE ZERO) AND (ua LE ONE), (ub GE ZERO) AND (ub LE ONE)]
  <span class="comments">;onSegment = [ (ua GT ZERO) AND (ua LT ONE), (ub LT ZERO) AND (ub GT -(ONE))]</span>
  x = x1 + ua*(x2-x1)
  y = y1 + ua*(y2-y1)
  
  <span class="comments">;the following is not needed (I think)</span>
<span class="comments">;  dxA = PB_POINT_SAME(A[0], A[2]) ? !VALUES.F_NAN : (A[2]-A[0])</span>
<span class="comments">;  dxB = PB_POINT_SAME(B[0], B[2]) ? !VALUES.F_NAN : (B[2]-B[0])</span>
<span class="comments">;  mA = (A[3]-A[1])/dxA</span>
<span class="comments">;  mB = (B[3]-B[1])/dyA</span>

  angle = L_I_ANGLE(AA[2]-AA[0], AA[3]-AA[1], BB[2]-BB[0], BB[3]-BB[1], PI)
  
  RETURN, [[x],[y]]
END
</code>
    </div>
  </body>
</html>