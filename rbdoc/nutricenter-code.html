<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Sat Dec  8 17:12:50 2012 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>nutricenter.pro (Documentation for /Users/safusu/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="nutricenter.pro (Documentation for /Users/safusu/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION data::init
COMPILE_OPT idl2 
on_error,2
<span class="comments">;-- allocate memory to pointer when initializing object</span>
 self.ptr=ptr_new(/allocate)  
 RETURN,1
end 

<span class="comments">;****************************************************************************************</span>

PRO data::set,value
<span class="comments">;-- if data value exists, then insert into pointer location</span>
 if n_elements(value) ne 0 then *(self.ptr)=value
 RETURN 
end

<span class="comments">;****************************************************************************************</span>

FUNCTION data::get,value
<span class="comments">;-- if data value is stored in object pointer, then copy it out</span>
 if n_elements(*(self.ptr)) ne 0 then value=*(self.ptr)
 RETURN,value
end

<span class="comments">;****************************************************************************************</span>

PRO data__define
 void={data,ptr:ptr_new()}
 RETURN 
end

<span class="comments">;****************************************************************************************</span>

FUNCTION minicrop::init, scan_width=scan_width, sundiam=sundiam, thresh=thresh, temparr=temparr, time=time
COMPILE_OPT idl2 
on_error,2

if self->data::init() eq 0 then RETURN, 0

rowscan=0

WHILE total(where(temparr[*,rowscan*scan_width] GT thresh/2)) EQ -1 DO BEGIN
    rowscan++
ENDWHILE
<span class="comments">; Doing it this way so that if in the case of 3 suns, if 1 sun is more left than the sun which </span>
<span class="comments">; is the most bottom, the cropping will correctly choose the right sun.</span>
colscan = fix(((where(temparr[*,rowscan*scan_width] GT thresh/2))[0] - sundiam/2 + $
        n_elements(where(temparr[*,rowscan*scan_width] GT thresh/2))/2 )/scan_width)


rowendscan = rowscan + sundiam/scan_width <span class="comments">; Jumping to other side of sun</span>
colendscan = colscan + sundiam/scan_width

<span class="comments">;Since the column scanning is rough, have to give the ends a little room.</span>
*self.ptr = {minicropped,rowscan:rowscan-2, colscan:colscan-2, rowendscan:rowendscan+2, colendscan:colendscan+2}

finish = systime(1,/s)
IF keyword_set(time) THEN print,' minicrop took '+strcompress(finish-start,/remove)+' seconds'
RETURN,1

END

<span class="comments">;****************************************************************************************</span>

PRO boundaries::cleanup
    IF ptr_valid(self.ptr)    THEN ptr_free, self.ptr
END

<span class="comments">;****************************************************************************************</span>

PRO minicrop__define
COMPILE_OPT idl2

def = {minicrop, INHERITS data}

END

<span class="comments">;****************************************************************************************</span>

FUNCTION boundaries::init, region=region, inputarr=inputarr, scan_width=scan_width, $
    sundiam=sundiam, sigmavalue=sigmavalue, time=time
<span class="comments">;+</span>
<span class="comments">; :Description: </span>
<span class="comments">;   Loads a triple-sun image and crops out selected regions one-by-one.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Print the elapsed time</span>
<span class="comments">;   scan_width : in, optional, type=integer, default=5</span>
<span class="comments">;       How far apart the scanning should be.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;       cropped = boundaries(region=1,inputarr=image,sundiam=sundiam,scan_width=scan_width,$</span>
<span class="comments">;           thresh=thresh)</span>
<span class="comments">;</span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
on_error,2

if self->data::init() eq 0 then RETURN, 0

start = systime(1,/s)

thresh = max(inputarr) - sigmavalue*stddev(inputarr)
temparr = inputarr * (inputarr gt thresh)

chunk = obj_new('minicrop',thresh=thresh,scan_width=scan_width,sundiam=sundiam,$
    temparr=temparr,time=time)

CASE region OF

1: BEGIN
    limits = chunk->get()
    cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
    END

2: BEGIN
    limits = chunk->get()

    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
    limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0
    
    <span class="comments">;****************************************************************************************</span>

    temparr = inputarr * (inputarr lt thresh)

    chunk = obj_new('minicrop',thresh=thresh,scan_width=scan_width,sundiam=sundiam,$
        temparr=temparr,time=time)

    limits = chunk->get()

    cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
    END

3: BEGIN
    limits = chunk->get()
    
    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
    limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>

    <span class="comments">; Step 2: Black out the first dimsum</span>
    temparr = inputarr * (inputarr lt thresh)

    chunk = obj_new('minicrop',thresh=thresh,scan_width=scan_width,sundiam=sundiam,$
        temparr=temparr,time=time)

    limits = chunk->get()

    inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width] = 0

    <span class="comments">;****************************************************************************************</span>

    <span class="comments">; Step 3: Crop what's left</span>
    temparr = inputarr * (inputarr lt thresh)

    chunk = obj_new('minicrop',thresh=thresh,scan_width=scan_width,sundiam=sundiam,$
        temparr=temparr,time=time)

    limits = chunk->get()

    cropped=inputarr[limits.colscan*scan_width:limits.colendscan*scan_width,$
        limits.rowscan*scan_width:limits.rowendscan*scan_width]
    END
ENDCASE

*self.ptr = {POSTCROP,image:cropped,xoffset:limits.colscan*scan_width,$
    yoffset:limits.rowscan*scan_width}
finish = systime(1,/s)
IF keyword_set(time) THEN print,' boundaries() took '+strcompress(finish-start,/remove)+' seconds'

RETURN,1
END

<span class="comments">;********************************************************************************</span>

PRO boundaries::cleanup

    IF ptr_valid(self.ptr)    THEN ptr_free, self.ptr

END

<span class="comments">;********************************************************************************</span>

PRO boundaries__define
    COMPILE_OPT idl2
    def={boundaries,INHERITS data}
END

<span class="comments">;****************************************************************************************</span>

FUNCTION cropit::init, region=region, scan_width=scan_width, $
    sundiam=sundiam, sigmavalue=sigmavalue, time=time
<span class="comments">;+</span>
<span class="comments">; :Description: </span>
<span class="comments">;   Loads a triple-sun image and crops out selected regions one-by-one.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   time : in, optional</span>
<span class="comments">;       Print the elapsed time</span>
<span class="comments">;   scan_width : in, optional, type=integer, default=5</span>
<span class="comments">;       How far apart the scanning should be.</span>
<span class="comments">;   sigmavalue: in, optional, type=integer, default=1</span>
<span class="comments">;       Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;       cropped = cropit(region=1,inputarr=image,sundiam=sundiam,scan_width=scan_width,$</span>
<span class="comments">;           thresh=thresh)</span>
<span class="comments">;</span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
on_error,2

if self->data::init() eq 0 then RETURN, 0

IF ~keyword_set(file)       THEN file       = 'triplesun.bmp'
IF ~keyword_set(scanwidth)  THEN scan_width = 5
IF ~keyword_set(sigmavalue) THEN sigmavalue = 2
IF ~keyword_set(region)     THEN region = 1

start = systime(1,/seconds)

IF STRPOS(file, 'tiff') NE -1  THEN BEGIN
    <span class="comments">; Read the tiff file</span>
    tmpimage = read_tiff(file)
    <span class="comments">; Get height AND width</span>
    s = size(tmpimage,/dimensions)
    n_col = s[1]
    n_row = s[2]
    <span class="comments">; Let's use vectors to reize the 3xn_colxn_row array</span>
    image = reform(tmpimage[0,*,*])
    sundiam = max(TOTAL(image gt max(image)/2, 1))+10
ENDIF

IF STRPOS(file, 'bmp') NE -1  THEN BEGIN
    tmpimage = read_bmp(file)
    s = size(tmpimage,/dimensions)
    n_col = s[1]
    n_row = s[2]
    image = reform(tmpimage[0,*,*])
    sundiam = 70 <span class="comments">;at it's widest, sun is 61 pixels across</span>
ENDIF

IF STRPOS(file, 'bin') NE -1  THEN BEGIN
    n_row       = 960
    n_col       = 1280
    <span class="comments">; These values are fixed for the model Prosilica GC 1290, we don't have </span>
    <span class="comments">; to worry about making this variable</span>
    tmpimage    = bytarr(n_col,n_row)
    image       = bytarr(n_col,n_row)

    openr,lun,file,/get_lun
    readu,lun,image
    free_lun,lun

    FOR i=0,n_row-1 DO BEGIN
        tmpimage[*,i] = image[*,n_row-1-i]
    ENDFOR

    image = flipimage
ENDIF

CASE region of
    1: temp=obj_new('boundaries',region=1,inputarr=image,sundiam=sundiam,scan_width=scan_width,$
            sigmavalue=sigmavalue,time=time)
    2: temp=obj_new('boundaries',region=2,inputarr=image,sundiam=sundiam,scan_width=scan_width,$
            sigmavalue=sigmavalue,time=time)
    3: temp=obj_new('boundaries',region=3,inputarr=image,sundiam=sundiam,scan_width=scan_width,$
            sigmavalue=sigmavalue,time=time)
ENDCASE
obj = temp->get() 
*self.ptr = obj
finish = systime(1,/seconds)
IF keyword_set(time) THEN  print, 'Elapsed Time for tribox(): ' + $
    strcompress(finish-start,/remove)+ ' seconds'

RETURN,1
END

<span class="comments">;********************************************************************************</span>

PRO cropit::cleanup

    IF ptr_valid(self.ptr)    THEN ptr_free, self.ptr

END

<span class="comments">;********************************************************************************</span>

PRO cropit__define
    COMPILE_OPT idl2
    def={cropit,INHERITS data}
END

<span class="comments">;****************************************************************************************</span>
FUNCTION centerit::init,file=file,time=time,sigmavalue=sigmavalue,region=region
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Had to make a new version of comp3 because the old one called scanbox() by default</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       file: in, optional, type='string', default='triplesun.bmp'</span>
<span class="comments">;           What file to load in</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Print the elapsed time</span>
<span class="comments">;       sigmavalue: in, optional, type=integer, default=2</span>
<span class="comments">;           Sets the threshold to be::</span>
<span class="comments">;   </span>
<span class="comments">;               max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;   </span>
<span class="comments">;       region: in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
on_error,2

if self->data::init() eq 0 then RETURN, 0

IF ~keyword_set(file)           THEN file   = 'triplesun.bmp'
IF ~keyword_set(sigmavalue)     THEN sigmavalue = 2
IF ~keyword_set(region)         THEN region = 1

start = systime(1,/seconds)

block = obj_new('cropit',region=region, scan_width=scan_width, $
    sundiam=sundiam, sigmavalue=sigmavalue, time=time)
struct = block->get()

cropped = struct.image

thresh = max(cropped)-sigmavalue*stddev(cropped)

s = size(cropped,/dimensions)
n_col = s[0]
n_row = s[1]

suncheck = cropped gt thresh

xpos = TOTAL( TOTAL(suncheck, 2) * Indgen(n_col) ) / total(suncheck) + struct.xoffset
ypos = TOTAL( TOTAL(suncheck, 1) * Indgen(n_row) ) / total(suncheck) + struct.yoffset

finish = systime(1,/s)
IF keyword_set(time) THEN  print, 'Elapsed Time for trimask: ',strcompress(finish-start,/remove),$
    ' seconds'

*self.ptr = {CENTER, xpos:xpos, ypos:ypos, thresh:thresh}
RETURN,1
END

<span class="comments">;********************************************************************************</span>

PRO centerit::cleanup

    IF ptr_valid(self.ptr)    THEN ptr_free, self.ptr

END

<span class="comments">;********************************************************************************</span>

PRO centerit__define
    COMPILE_OPT idl2
    def={centerit,INHERITS data}
END

<span class="comments">;********************************************************************************</span>

FUNCTION getstruct::init,scan_width=scan_width, file=file,sigmavalue=sigmavalue, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds the centers of a triple-sun image and loads all relevant information</span>
<span class="comments">;       including offsets and angles into a new structure.</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       scan_width: in, optional, type = integer, default = 5</span>
<span class="comments">;           How apart the scans are for minicrop(). Overrides defaults in tribox().</span>
<span class="comments">;       file: in, optional, type = string, default = 'triplesun.bmp'</span>
<span class="comments">;           What file to find 4 centers for</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;       sigmavalue: in, optional, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
on_error,2

if self->data::init() eq 0 then RETURN, 0


start=systime(1,/s)

c1block = obj_new('centerit',time=time,sigmavalue=sigmavalue,file=file,region=1)
center1 = c1block->get()
c2block = obj_new('centerit',time=time,sigmavalue=sigmavalue,file=file,region=2)
center2 = c2block->get()
c3block = obj_new('centerit',time=time,sigmavalue=sigmavalue,file=file,region=3)
center3 = c3block->get()

theta = !radeg*atan((center3.ypos - center2.ypos)/(center3.xpos - center2.xpos))
hypot = sqrt((center3.ypos - center2.ypos)^2 + (center3.xpos - center2.xpos)^2)
offset = ((center1.xpos - center2.xpos)*(center3.ypos - center2.ypos) - $
    (center1.ypos - center2.ypos)*(center3.xpos - center2.xpos))/hypot

*self.ptr = {KAHUNA, center1:center1, center2:center2, center3:center3, $
    theta:theta, offset:offset}
finish = systime(1,/s)
IF keyword_set(time) THEN print, 'getstruct took: '+strcompress(finish-start)+$
    ' seconds'
RETURN,1
END

<span class="comments">;********************************************************************************</span>

FUNCTION getstruct::minicrop, scan_width=scan_width, sundiam=sundiam, thresh=thresh, temparr=temparr, time=time

IF self->data::init() EQ 0 THEN RETURN, 0

rowscan=0

WHILE total(where(temparr[*,rowscan*scan_width] GT thresh/2)) EQ -1 DO BEGIN
    rowscan++
ENDWHILE
<span class="comments">; Doing it this way so that if in the case of 3 suns, if 1 sun is more left than the sun which </span>
<span class="comments">; is the most bottom, the cropping will correctly choose the right sun.</span>
colscan = fix(((where(temparr[*,rowscan*scan_width] GT thresh/2))[0] - sundiam/2 + $
        n_elements(where(temparr[*,rowscan*scan_width] GT thresh/2))/2 )/scan_width)


rowendscan = rowscan + sundiam/scan_width <span class="comments">; Jumping to other side of sun</span>
colendscan = colscan + sundiam/scan_width

<span class="comments">;Since the column scanning is rough, have to give the ends a little room.</span>
limits = {minicropped,rowscan:rowscan-2, colscan:colscan-2, rowendscan:rowendscan+2, colendscan:colendscan+2}

finish = systime(1,/s)
IF keyword_set(time) THEN print,' minicrop took '+strcompress(finish-start,/remove)+' seconds'

RETURN, limits
END

<span class="comments">;********************************************************************************</span>

PRO getstruct::cleanup
    IF ptr_valid(self.ptr)    THEN ptr_free, self.ptr
END

<span class="comments">;********************************************************************************</span>

PRO getstruct__define
    COMPILE_OPT idl2
    def={getstruct,INHERITS data}
END

<span class="comments">;********************************************************************************</span>

PRO nutricenter,scan_width=scan_width, file=file,sigmavalue=sigmavalue, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Finds the centers of a triple-sun image and loads all relevant information</span>
<span class="comments">;       including offsets and angles into a new structure.</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       scan_width: in, optional, type = integer, default = 5</span>
<span class="comments">;           How apart the scans are for minicrop(). Overrides defaults in tribox().</span>
<span class="comments">;       file: in, optional, type = string, default = 'triplesun.bmp'</span>
<span class="comments">;           What file to find 4 centers for</span>
<span class="comments">;       time: in, optional</span>
<span class="comments">;           Outputs how much time the program takes</span>
<span class="comments">;       sigmavalue: in, optional, type = integer, default = 2</span>
<span class="comments">;          Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

COMPILE_OPT idl2 
on_error,2

IF ~keyword_set(scan_width)         THEN    scan_width = 5
IF ~keyword_set(file)               THEN    file = 'triplesun.bmp'
IF ~keyword_set(sigmavalue)         THEN    sigmavalue = 2

start=systime(1,/s)

block = obj_new('getstruct',scan_width=scan_width, file=file, sigmavalue=sigmavalue)
struct = block->get()
tmpimage = read_bmp(file) 
s = size(tmpimage,/dimensions)
n_col = s[1]
n_row = s[2]
image = reform(tmpimage[0,*,*])
image2 = image
image3 = image

image[struct.center1.xpos,*]=20
image[*,struct.center1.ypos]=20
image2[struct.center2.xpos,*]=20
image2[*,struct.center2.ypos]=20
image3[struct.center3.xpos,*]=20
image3[*,struct.center3.ypos]=20

<span class="comments">; window,0</span>
<span class="comments">; cgimage,image,/k</span>
<span class="comments">; window,2</span>
<span class="comments">; cgimage,image2,/k</span>
<span class="comments">; window,3</span>
<span class="comments">; cgimage,image3,/k</span>

finish = systime(1,/s)
IF keyword_set(time) THEN print, 'tricenter took: '+strcompress(finish-start)+$
    ' seconds'

END


</code>
    </div>
  </body>
</html>