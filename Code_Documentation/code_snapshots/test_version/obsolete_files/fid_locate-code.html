<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:52 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fid_locate.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fid_locate.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION fid_locate, inputimage, inputstruct,mcenter=mcenter
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Locates the whole and sub-pixel positions of fiducials in a cropped solar image</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputimage: in, required</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       inputstruct: in, required</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       mcenter: in, optional</span>
<span class="comments">;           Finds the center of the local maxima using a binary mask instead of parabolic peak fitting. </span>
<span class="comments">;</span>
<span class="comments">;-</span>

<span class="comments">; badcrop = inputimage[inputstruct[0].limbxpos - !param.soldiskr : inputstruct[0].limbxpos + !param.soldiskr,inputstruct[0].limbypos - !param.soldiskr : inputstruct[0].limbypos + !param.soldiskr]</span>

badcrop = inputimage[inputstruct[0].limbxpos - !param.crop_box : inputstruct[0].limbxpos + !param.crop_box,inputstruct[0].limbypos - !param.crop_box : inputstruct[0].limbypos + !param.crop_box]

badcrop[WHERE(badcrop eq MAX(badcrop))] = MODE(badcrop)

s = SIZE(badcrop,/dim)
<span class="comments">; kernel = [$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],$</span>
<span class="comments">; [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],$</span>
<span class="comments">; [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],$</span>
<span class="comments">; [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0]]</span>

fidwidth = 3
fidlength = 15
kernel = fltarr(fidlength,fidlength)
kernel[0:fidwidth-1,*]=1
kernel[*,0:fidwidth-1]=1
kernel = SHIFT(kernel,2*fidwidth,2*fidwidth)

image = CONVOL(FIX(badcrop),kernel,/edge_truncate)

tmp=image
fidthresh = .1

threshold = MEAN(image) + fidthresh*STDDEV(image)
fidfloor = .2*MAX(image)
fidpos = {x:0.,y:0.,subpx:0.,subpy:0.}
basestr = fidpos
ff = 0
n_fid = 5

<span class="comments">; pixelfiducials = FINDGEN(s)</span>
<span class="comments">; shave off .0004s by moving these two lines out</span>
<span class="comments">; xpos = FIX(pixelfiducials mod s[0])</span>
<span class="comments">; ypos = FIX(pixelfiducials/s[1])</span>

<span class="comments">; shaved off .1 seconds by removing the many abs() statements</span>
<span class="comments">; That's a motherfucking 33%</span>


for i = 1, s[0]-2 do begin
    for j = 1,s[1]-2 do begin
        <span class="comments">; The correlation value at some position</span>
        thisvalue = image[i,j]
        <span class="comments">; Check to see if it's less than the surrounding 8 pixels</span>
        if thisvalue lt threshold and thisvalue gt fidfloor then begin
            if thisvalue lt image[i,j+1] and $
            thisvalue lt image[i,j-1] and $
            thisvalue lt image[i+1,j] and $
            thisvalue lt image[i-1,j] and $
            thisvalue lt image[i-1,j-1] and $
            thisvalue lt image[i-1,j+1] and $
            thisvalue lt image[i+1,j-1] and $
            thisvalue lt image[i+1,j+1] then begin
                <span class="comments">; Redundant is to mark if we find something in the next for loop</span>
                redundant = 0
                fidpos[ff].x = i
                fidpos[ff].y = j
                tmp[i,j]=255
                ff++
                <span class="comments">; Only need this if statement because it doesn't like starting at 0</span>
                if n_elements(fidpos) ne 1 then begin
                    for k = 0,n_elements(fidpos) - 1 do begin
                        <span class="comments">; We iterate through previous fiducial positions and if we find one within 2 fiducial lengths of another fiducial we use the stronger correlated one</span>
                        if ABS(fidpos[k].x - i) lt fidlength*2 and ABS(fidpos[k].y - j) lt fidlength*2 then begin
                            <span class="comments">; Hey look it's redundant, something's about to happen</span>
                            redundant = 1
                            <span class="comments">; Correlation value at a position in question</span>
                            thatvalue = image[fidpos[k].x,fidpos[k].y]
                            <span class="comments">; If the peak is contested, give it to the stronger one</span>
                            if thisvalue lt thatvalue then begin
                                fidpos[k].x = i
                                fidpos[k].y = j
                            endif
                        endif
                        <span class="comments">; Get out of here, if there are any contestants it should only happen once</span>
                        break   
                    endfor
                    <span class="comments">; Regardless of whether it was replaced, get out of here</span>
                    if redundant eq 1 then break
                endif
                <span class="comments">; Keep extending fidpos until we have n_fid fiducials</span>
                if n_elements(fidpos) lt n_fid then fidpos = [fidpos,basestr]
            endif
        endif
    endfor
endfor

<span class="comments">; stop</span>
<span class="comments">; not picking up the fiducials on the VERY edge</span>

<span class="comments">; let's interp to subpixel values, yo.</span>
<span class="comments">; Let's try to do it Albert's way first</span>
<span class="comments">; Let's stick with Albert's way</span>

if KEYWORD_SET(mcenter) then begin
    newthresh = MEAN(image) + fidthresh/2*STDDEV(image)
<span class="comments">; It's already stupid fast as it is.</span>
    for k = 0,N_ELEMENTS(fidpos)-1 do begin
        caa=0
        cbb=0
        avg=0
        xrange = [fidpos[k].x - fidwidth,fidpos[k].x + fidwidth + 1]
        yrange = [fidpos[k].y - fidwidth,fidpos[k].y + fidwidth + 1]
        for aa = 0,xrange[1]-xrange[0] do begin
            for bb = 0,yrange[1]-yrange[0] do begin
                thisvalue = image[aa+xrange[0],bb+yrange[0]]
                if thisvalue lt newthresh then begin
                    caa += aa*thisvalue
                    cbb += bb*thisvalue
                    avg += thisvalue
                endif
            endfor
        endfor
        fidpos[k].subpx=caa/avg+xrange[0]
        fidpos[k].subpy=cbb/avg+yrange[0]
    endfor
endif else begin
    for k = 0,N_ELEMENTS(fidpos)-1 do begin
        z = image[fidpos[k].x-1:fidpos[k].x+1,fidpos[k].y-1:fidpos[k].y+1]
        result = paradip(z)
        <span class="comments">; result = parapeak(1/z)</span>
        fidpos[k].subpx = fidpos[k].x + result[0]
        fidpos[k].subpy = fidpos[k].y + result[1]
    endfor
endelse
<span class="comments">; stop</span>
RETURN,fidpos
END
</code>
    </div>
  </body>
</html>