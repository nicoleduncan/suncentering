<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:49 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>makestrips.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="makestrips.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION makestrips, inputstruct, inputimage, fixfid
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Makes strips using approx centroiding method to make cropped areas</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputstruct: in, required,type=structure</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;       inputimage: in, required,type=structure</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       fixfid : in, optional</span>
<span class="comments">;           If set, marks the second run of centroidwholesuns and attempts to fix any chord slicing if the chord edge crosses a fiducial.</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;-</span>

im=inputimage
s = SIZE(inputimage,/dim)

for i = 0, N_ELEMENTS(inputstruct)-1 do begin
    <span class="comments">; If center is too close to edge, pad it</span>
    if inputstruct[i].xpos + !param.crop_box gt s[0] or inputstruct[i].ypos + !param.crop_box gt s[1] or inputstruct[i].xpos - !param.crop_box lt 0 or inputstruct[i].ypos - !param.crop_box lt 0  then begin
        
        paddedimage = BYTARR(s+ !param.crop_box*2) + MODE(inputimage)
        paddedimage[ !param.crop_box, !param.crop_box]=inputimage

        crop = paddedimage[inputstruct[i].xpos : inputstruct[i].xpos + 2* !param.crop_box, inputstruct[i].ypos : inputstruct[i].ypos + 2* !param.crop_box]
        
        for j = 0, !param.nstrips - 1 do begin
        <span class="comments">;This part hasn't been updated to work with chord thicknessses</span>
            inputstruct[i].xstrips[j].rowwhere = j
            <span class="comments">; inputstruct[i].xstrips[j].array = REFORM(crop[*,( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width])</span>
            inputstruct[i].xstrips[j].array = (crop[*,( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width])
            inputstruct[i].ystrips[j].colwhere = j
            <span class="comments">; inputstruct[i].ystrips[j].array = REFORM(crop[( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width,*])</span>
            inputstruct[i].ystrips[j].array = (crop[( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width,*])
        endfor
    endif else begin
    <span class="comments">; Otherwise, crop it normally</span>
        crop = im[inputstruct[i].xpos - !param.crop_box : inputstruct[i].xpos + !param.crop_box,inputstruct[i].ypos - !param.crop_box : inputstruct[i].ypos + !param.crop_box]
        
        for j = 0, !param.nstrips - 1 do begin
        <span class="comments">; stop</span>
            inputstruct[i].xstrips[j].rowwhere = [ !param.crop_box + (j - !param.nstrips/2) * !param.scan_width, !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1]
            <span class="comments">; Using an average of chords now, defined by !param.chord_thickness</span>

            <span class="comments">; inputstruct[i].xstrips[j].array = REFORM(MEAN(crop[*,( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width: !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1],dim=2))</span>
            inputstruct[i].xstrips[j].array = (MEAN(crop[*,( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width: !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1],dim=2))
            
            inputstruct[i].ystrips[j].colwhere = [ !param.crop_box + (j - !param.nstrips/2) * !param.scan_width, !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1]
            <span class="comments">; inputstruct[i].ystrips[j].array = REFORM(MEAN(crop[( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width: !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1,*],dim=1))</span>
            inputstruct[i].ystrips[j].array = (MEAN(crop[( !param.crop_box)+(j - !param.nstrips/2) * !param.scan_width: !param.crop_box + (j - !param.nstrips/2) * !param.scan_width + !param.chord_thickness - 1,*],dim=1))
            <span class="comments">; stop</span>
        endfor
    endelse
endfor

<span class="comments">; if n_elements(fixfid) ne 0 then begin</span>
<span class="comments">;     ; Check each row for fiducials</span>
<span class="comments">;     for i = 0, N_ELEMENTS(inputstruct)-1 do begin</span>
<span class="comments">;         for j = 0, !param.nstrips - 1 do begin</span>
<span class="comments">;             for k = 0,n_elements((*fixfid[0]).fidarr) - 1 do begin</span>
<span class="comments">;                     ; !param.fidarm is to make sure that no part of the fiducial is in the part we care about, not even the fiducial arm. </span>
<span class="comments">;                 if (((*fixfid[0]).fidarr).subx)[k] gt (inputstruct[i].limbxstrips[j].startloc)[0] - !param.fidarm and (((*fixfid[0]).fidarr).subx)[k] lt (inputstruct[i].limbxstrips[j].startloc)[0] + !param.ministrip_length - 1 + !param.fidarm and (((*fixfid[0]).fidarr).suby)[k] gt (inputstruct[i].limbxstrips[j].rowwhere)[0] - !param.fidarm and (((*fixfid[0]).fidarr).suby)[k] lt (inputstruct[i].limbxstrips[j].rowwhere)[1] + !param.fidarm then begin</span>

<span class="comments">;                     print,(((*fixfid[0]).fidarr).subx)[k]</span>
<span class="comments">;                     print,' is between'</span>
<span class="comments">;                     print, (inputstruct[i].limbxstrips[j].startloc)[0]</span>
<span class="comments">;                     print,'and'</span>
<span class="comments">;                     print, (inputstruct[i].limbxstrips[j].startloc)[0] + !param.ministrip_length - 1</span>
<span class="comments">;                     print,' in addition '</span>
<span class="comments">;                     print,(((*fixfid[0]).fidarr).suby)[k]</span>
<span class="comments">;                     print,' is between'</span>
<span class="comments">;                     print, (inputstruct[i].limbxstrips[j].rowwhere)[0]</span>
<span class="comments">;                     print,'and'</span>
<span class="comments">;                     print, (inputstruct[i].limbxstrips[j].rowwhere)[1]</span>

<span class="comments">;                     ; make new chord -> check new chord</span>
<span class="comments">;                     ; or</span>
<span class="comments">;                     ; make new chord and include chord check</span>
<span class="comments">;                     ; or</span>
<span class="comments">;                     ; make new chord -> don't check since we know there aren't any nearby fiducials</span>

<span class="comments">;                 endif</span>
<span class="comments">;             endfor</span>
<span class="comments">;             ; print, inputstruct[i].xstrips[j].rowwhere</span>
<span class="comments">;             ; print, inputstruct[i].limbxstrips[j].startpoints</span>
<span class="comments">;         endfor</span>
<span class="comments">;         ; stop</span>
<span class="comments">;     endfor</span>
<span class="comments">; endif</span>
<span class="comments">; stop</span>
RETURN,inputstruct
end
</code>
    </div>
  </body>
</html>