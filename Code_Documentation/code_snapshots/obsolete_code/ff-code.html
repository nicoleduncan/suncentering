<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:36 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ff.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ff.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="ff:source"></a>pro ff

    xpos = 210
    ypos = 153

    a=READ_TIFF('plots_tables_images/dimsun1.tiff',channels=1)


    wholeimage = BYTSCL(a)
    rad = 22

    crop = wholeimage[xpos-rad:xpos+rad,ypos-rad:ypos+rad]

    s = SIZE(crop,/dim)
    nrow = s[0]
    ncol = s[1]

    xpb = (SHIFT_DIFF(EMBOSS(crop),dir=3)) lt -80
    ypb = (SHIFT_DIFF(EMBOSS(crop, az=90),dir=1)) lt -80

    <span class="comments">; The sunthetic image has too-nice edges that they end up being edge-detected </span>
    <span class="comments">; So I actually didn't anticipate this.</span>

    window,0
    !p.multi=[0,2,1]
    cgimage,xpb*crop,/k
    cgimage,ypb*crop,/k
    !p.multi=0


    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = mode(ind_col)
    b = ind_col[WHERE(ind_col ne a)]
    c = mode(b)

    f = mode(ind_row)
    g = ind_row[WHERE(ind_row ne f)]
    h = mode(g)


    <span class="comments">; Just to make it sorted</span>
    xpos = [a,c]
    ypos = [f,h]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    <span class="comments">; Because fiducials are 2 pixels wide </span>
    xmask = [xpos[0]-1,xpos[0],xpos[1]-1,xpos[1]]
    ymask = [ypos[0]-1,ypos[0],ypos[1]-1,ypos[1]]

    ftest = crop
    <span class="comments">; ftest[a,*] = 100</span>
    <span class="comments">; ftest[c,*] = 100</span>

    ps_start,filename='mask_outline.eps',/color,/encapsulated,xsize=6,ysize=6,/inches
        display,ftest,/square
        plot_edges,xpb,thick=6,setcolor=80
        plot_edges,ypb,thick=6,setcolor=255
    ps_end,resize=100

    stop
END


<a id="dim3:source"></a>pro dim3
    <span class="comments">;Reads parameters from csv file and converts strings into varilables. BRILLIANT.</span>
    readcol,'param.txt',var,num,format='A,F',delimiter=' '
    for i=0,N_ELEMENTS(var)-1 do (SCOPE_VARFETCH(var[i],/enter,level=0))=num[i]
    
    <span class="comments">; Here we make the assumption that the darker regions are linearly darker so we can just divide by 2 and 4</span>
    <span class="comments">; Works pretty well</span>
    wholeimage = BYTSCL( READ_TIFF('plots_tables_images/dimsun1.tiff',channels=1) )
    ideal = BYTSCL( READ_TIFF('plots_tables_images/dimsun_ideal.tiff',channels=1) )
    crop = wholeimage[xpos-rad:xpos+rad,ypos-rad:ypos+rad]
    icrop = ideal[xpos-rad:xpos+rad,ypos-rad:ypos+rad]
    imask = icrop lt idealthresh
    <span class="comments">; dim50 = .5*crop</span>
    dim50 = wholeimage[xpos50-rad:xpos50+rad,ypos50-rad:ypos50+rad]
    <span class="comments">; dim25 = .25*crop</span>
    dim25 = wholeimage[xpos25-rad:xpos25+rad,ypos25-rad:ypos25+rad]
    <span class="comments">; Actually using the wholeimage cropped areas reveal little difference than with the cheating method</span>

    s = SIZE(crop,/dim)
    nrow = s[0]
    ncol = s[1]

    xpb = (SHIFT_DIFF(EMBOSS(crop),dir=3)) lt thresh
    ypb = (SHIFT_DIFF(EMBOSS(crop, az=90),dir=1)) lt thresh

    <span class="comments">; -80 is about 3 stddev() above the minimum</span>
    <span class="comments">; -80 is also about half the minimum of xpb/ypb</span>

    xpb = (SHIFT_DIFF(EMBOSS(dim50),dir=3)) lt thresh/2
    ypb = (SHIFT_DIFF(EMBOSS(dim50, az=90),dir=1)) lt thresh/2
    
    <span class="comments">; ps_start,filename='plots_tables_images/dim50.eps',/color,/encapsulated,xsize=8,ysize=8,/inches</span>
    display,byte(dim50),/square,title='50% Dim'
    plot_edges,xpb,thick=6,setcolor=80
    plot_edges,ypb,thick=6,setcolor=255
    <span class="comments">; ps_end,resize=100</span>

    xpb = (SHIFT_DIFF(EMBOSS(dim25),dir=3)) lt thresh/4
    ypb = (SHIFT_DIFF(EMBOSS(dim25, az=90),dir=1)) lt thresh/4
    <span class="comments">; ps_start,filename='plots_tables_images/dim25.eps',/color,/encapsulated,xsize=8,ysize=8,/inches       </span>
    display,byte(dim25),/square,title='25% Dim'
    plot_edges,xpb,thick=6,setcolor=80
    plot_edges,ypb,thick=6,setcolor=255
    <span class="comments">; ps_end,resize=100</span>
    
    
    <span class="comments">; Working with image of blank sun with real fiducials:</span>
    whitecrop = bytarr(s) + 198  <span class="comments">;198 is the mode of the not-fiducial-maskt</span>
    fakesun = imask*crop + whitecrop*(icrop gt idealthresh)
    <span class="comments">; cgsurface,(SHIFT_DIFF(EMBOSS(fakesun),dir=3))</span>
    a = SHIFT_DIFF(EMBOSS(fakesun),dir=3)
    cgimage,a,/k
    cgimage,a*(a gt 10),/k
    stop
    <span class="comments">; The sunthetic image has too-nice edges that they end up being edge-detected </span>
    <span class="comments">; So I actually didn't anticipate this.</span>

    <span class="comments">; window,0</span>
    <span class="comments">; !p.multi=[0,2,1]</span>
    <span class="comments">; cgimage,xpb*crop,/k</span>
    <span class="comments">; cgimage,ypb*crop,/k</span>
    <span class="comments">; !p.multi=0</span>

    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/nrow


    a = mode(ind_col)
    b = ind_col[WHERE(ind_col ne a)]
    c = mode(b)

    f = mode(ind_row)
    g = ind_row[WHERE(ind_row ne f)]
    h = mode(g)


    <span class="comments">; Just to make it sorted</span>
    xpos = [a,c]
    ypos = [f,h]
    xpos = xpos[SORT(xpos)]
    ypos = ypos[SORT(ypos)]

    <span class="comments">; Because fiducials are 2 pixels wide </span>
    xmask = [xpos[0]-1,xpos[0],xpos[1]-1,xpos[1]]
    ymask = [ypos[0]-1,ypos[0],ypos[1]-1,ypos[1]]

    <span class="comments">; ps_start,filename='mask_outline.eps',/color,/encapsulated,xsize=6,ysize=6,/inches</span>
    <span class="comments">;     display,crop,/square</span>
    <span class="comments">;     plot_edges,xpb,thick=6,setcolor=80</span>
    <span class="comments">;     plot_edges,ypb,thick=6,setcolor=255</span>
    <span class="comments">; ps_end,resize=100</span>
end    
</code>
    </div>
  </body>
</html>