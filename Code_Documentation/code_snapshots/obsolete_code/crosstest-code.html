<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>crosstest.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="crosstest.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION crosstest, inputimage, inputstruct

for kk = 0,N_ELEMENTS(inputstruct)-1 do begin
tic
    acrop = inputimage[inputstruct[kk].limbxpos - !param.soldiskr : inputstruct[kk].limbxpos + !param.soldiskr,$
    inputstruct[kk].limbypos - !param.soldiskr : inputstruct[kk].limbypos + !param.soldiskr]

    <span class="comments">; badcrop = acrop[0:-6,0:-4]</span>
    badcrop=acrop

    <span class="comments">; badcrop to remove high pixels</span>
    badcrop[where(badcrop eq max(badcrop))] = mode(badcrop)

    <span class="comments">; this is the worst-case scenario, so how does it hold up?</span>
    <span class="comments">; so thresh is a different thresh altogether, it's the thresh at which the fiducials dip below</span>

    thresh = .3

    <span class="comments">; for i = 1,9 do begin</span>
    <span class="comments">; thresh = .1*i</span>
    a = SCALE_VECTOR(SHIFT_DIFF(EMBOSS(badcrop,/edge_truncate,az=0),dir=3,/edge_truncate),0,1)
    b = SCALE_VECTOR(SHIFT_DIFF(EMBOSS(badcrop,az=90,/edge_truncate),dir=1,/edge_truncate),0,1)

    xpb = a lt thresh
    ypb = b lt thresh

    s = SIZE(badcrop,/d)

    ncol = s[0]
    nrow = s[1]
    ind_col = WHERE(xpb eq 1) mod ncol
    ind_row = WHERE(ypb eq 1)/ncol

    <span class="comments">; Unique addresses</span>
    uniq_col = ind_col[UNIQ(ind_col,SORT(ind_col))]
    uniq_row = ind_row[UNIQ(ind_row,SORT(ind_row))]
    n_col_indices = N_ELEMENTS(uniq_col)
    n_row_indices = N_ELEMENTS(uniq_row)
    xpos = FLTARR(n_col_indices)
    ypos = FLTARR(n_row_indices)
    uniq_col_stack = FLTARR(n_col_indices)
    uniq_row_stack = FLTARR(n_row_indices)

    <span class="comments">; For each unique col/row index, how many indices are there</span>
    for i = 0,n_col_indices-1 do begin
        uniq_col_stack[i] = N_ELEMENTS(WHERE(ind_col eq uniq_col[i] eq 1))
    endfor

    for i = 0,n_row_indices-1 do begin
        uniq_row_stack[i] = N_ELEMENTS(WHERE(ind_row eq uniq_row[i] eq 1))
    endfor

    <span class="comments">; CGIMAGE,badcrop,/k,/axes</span>
    <span class="comments">; PLOT_EDGES,xpb,x0=.5,y0=.5,dcolor=220,thick=3</span>
    <span class="comments">; PLOT_EDGES,ypb,x0=.5,y0=.5,dcolor=0,thick=3</span>
    <span class="comments">; PLOT_EDGES,xpb*ypb,x0=.5,y0=.5,dcolor=100,thick=3</span>

    <span class="comments">; can't incorporate loops because we call max</span>
    for i = 0,n_col_indices-1 do begin
        xpos[i] = uniq_col[(WHERE(uniq_col_stack eq max(uniq_col_stack)))[0]]
    endfor
    for i = 0,n_row_indices-1 do begin
        ypos[i] = uniq_row[(WHERE(uniq_row_stack eq max(uniq_row_stack)))[0]]
    endfor

    cross_col = WHERE(xpb*ypb eq 1) mod ncol
    cross_row = WHERE(xpb*ypb eq 1)/ncol

    <span class="comments">; buffer for SHIFT</span>
    uniq_col = [0,uniq_col,0]
    uniq_col_stack = [0,uniq_col_stack,0]
    uniq_row = [0,uniq_row,0]
    uniq_row_stack = [0,uniq_row_stack,0]


    <span class="comments">; FOR YPOS ONLY</span>
    adjacent = WHERE(uniq_row-SHIFT(uniq_row,1) eq 1,num_adj)
    qq=0
    rr=0
    
    if num_adj gt 0 then begin
        while qq lt num_adj do begin
            <span class="comments">; must redo?</span>
            <span class="comments">; stop</span>
            c = WHERE( [uniq_row_stack[adjacent[qq]-1],uniq_row_stack[adjacent[qq]]] eq $
                MIN([uniq_row_stack[adjacent[qq]-1],uniq_row_stack[adjacent[qq]]]))
            <span class="comments">; look where it's adjacent</span>
            <span class="comments">; find less pupulous one</span>
            <span class="comments">; set the less populous one to 0</span>
            bin_row = (FLTARR(N_ELEMENTS(uniq_row)) +1)
            bin_row[c+adjacent[qq]-1] = 0
            uniq_row = (uniq_row*bin_row)
            uniq_row_stack = (uniq_row_stack*bin_row)
            qq++
        endwhile
    endif else begin
        adjacent = WHERE(uniq_row-SHIFT(uniq_row,1) eq -1)
        while rr lt num_adj do begin
            c = WHERE( [uniq_row_stack[adjacent[rr]-1],uniq_row_stack[adjacent[rr]]] eq $
                MIN([uniq_row_stack[adjacent[rr]-1],uniq_row_stack[adjacent[rr]]]))
            bin_row = (FLTARR(N_ELEMENTS(uniq_row)) +1)
            bin_row[c+adjacent[rr]-1] = 0
            uniq_row = uniq_row*bin_row
            uniq_row_stack = uniq_row_stack*bin_row
            rr++
        endwhile
    endelse

    <span class="comments">; THIS IS FOR XPOS ONLY</span>
    adjacent = WHERE(uniq_col-SHIFT(uniq_col,1) eq 1,num_adj)
    mm=0
    nn=0
    if num_adj gt 0 then begin
        while mm lt num_adj do begin
            c = WHERE( [uniq_col_stack[adjacent[mm]-1],uniq_col_stack[adjacent[mm]]] eq $
                MIN([uniq_col_stack[adjacent[mm]-1],uniq_col_stack[adjacent[mm]]]))
            bin_col = (FLTARR(N_ELEMENTS(uniq_col)) +1)
            bin_col[c+adjacent[mm]-1] = 0
            uniq_col = (uniq_col*bin_col)
            uniq_col_stack = (uniq_col_stack*bin_col)
            mm++
        endwhile
    endif else begin
        adjacent = WHERE(uniq_col-SHIFT(uniq_col,1) eq -1)
        while nn lt num_adj do begin
            c = WHERE( [uniq_col_stack[adjacent[nn]-1],uniq_col_stack[adjacent[nn]]] eq $
                MIN([uniq_col_stack[adjacent[nn]-1],uniq_col_stack[adjacent[nn]]]))
            bin_col = (FLTARR(N_ELEMENTS(uniq_col)) +1)
            bin_col[c+adjacent[nn]-1] = 0
            uniq_col = uniq_col*bin_col
            uniq_col_stack = uniq_col_stack*bin_col
            nn++
        endwhile
    endelse

    uniq_col = (uniq_col*bin_col)[WHERE(uniq_col*bin_col ne 0)]
    uniq_col_stack = (uniq_col_stack*bin_col)[WHERE(uniq_col_stack*bin_col ne 0)]
    uniq_row = (uniq_row*bin_row)[WHERE(uniq_row*bin_row ne 0)]
    uniq_row_stack = (uniq_row_stack*bin_row)[WHERE(uniq_row_stack*bin_row ne 0)]

    xpos = uniq_col
    ypos = uniq_row
    <span class="comments">; stop</span>

    <span class="comments">; shit.</span>

    <span class="comments">; how to deal with pixels part of the overlap mask but not in the fiducial???</span>

    xsuperset = [cross_col,xpos]
    if N_ELEMENTS(xsuperset[UNIQ(xsuperset,SORT(xsuperset))]) gt 0 then xpos = xpos
    ysuperset = [cross_row,ypos]
    if N_ELEMENTS(ysuperset[UNIQ(ysuperset,SORT(ysuperset))]) gt 0 then ypos = ypos

toc
stop
    <span class="comments">; 3 no longer works for startimage=wholeimage</span>
    coords = FLTARR(3,3)

    coords[0,*] = cross_col
    coords[1,*] = cross_row

    places = 0
    for jj=0,2 do begin
        if TOTAL(coords[0,jj] eq xpos) ne 0 and TOTAL(coords[1,jj] eq ypos) ne 0 then begin
            places = [places,coords[0:1,jj]]
        endif
    endfor
    
    places=REFORM(places[WHERE(places ne 0)],2,N_ELEMENTS(places)/2)
endfor



stop
return,places
end
































</code>
    </div>
  </body>
</html>