<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:42 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>errorlogger__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="errorlogger__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger__Define</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The purpose of this program is to log program errors or text messages during</span>
<span class="comments">;       program execution as an aid to debugging such a program at a later date. The</span>
<span class="comments">;       ErrorLogger program is written as an object so that it will persist in the IDL</span>
<span class="comments">;       session until it is destroyed.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Utilities</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger = Obj_New("ErrorLogger")</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename:    The name of the error log file. If not provided, a default name</span>
<span class="comments">;                    will be created, based on the current system time. (Optional)</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       ALERT:       The default behavior of the error logger is simply to write text to a file.</span>
<span class="comments">;                    But if the ALERT keyword is set, the program will alert the user via a</span>
<span class="comments">;                    message dialog that an error has occurred when using the AddError method. </span>
<span class="comments">;                    Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;      DELETE_ON_DESTROY: If this keyword is set, the error log file will be deleted when the</span>
<span class="comments">;                    ErrorLogger object is destroyed, but only if the ErrorLogger object is not</span>
<span class="comments">;                    in an error state at that time (error status = 2). Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       NOCLUTTER:   Believe it or not, some people who use an ErrorLogger prefer that an error log</span>
<span class="comments">;                    file is never left behind. (They prefer that the program act like ERROR_MESSAGE.)</span>
<span class="comments">;                    For those people, the NOCLUTTER keyword provides a way for them to automatically</span>
<span class="comments">;                    set the ALERT and DESTROY_ON_DELETE keywords to 1. It also prevents the error </span>
<span class="comments">;                    logger from ever setting the error status to 2. Thus, when the ErrorLogger is</span>
<span class="comments">;                    destroyed, the file is always deleted. Default is 0. When set, overrides ALERT</span>
<span class="comments">;                    and DELETE_ON_DESTROY settings. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       NOTRACEBACK: Set this keyword to suppress traceback information in the error log output</span>
<span class="comments">;                    and in any alerts issued by the program. Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       TIMESTAMP:   Set this keyword if you wish a time stamp to be appended to the provided</span>
<span class="comments">;                    filename. Otherwise, the filename is used as defined. Default filenames</span>
<span class="comments">;                    always have a timestamp appended to the file name. (Input)</span>
<span class="comments">;</span>
<span class="comments">; METHODS:</span>
<span class="comments">;</span>
<span class="comments">;        AddError:   Adds an error text string or array to the error log file. By default,</span>
<span class="comments">;                    it will add the HELP, LAST_MESSAGE=1, /TRACEBACE traceback </span>
<span class="comments">;                    information to the file. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        AddText:    Adds a text string or array to the error log file. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        ClearLog:   Erases all the text currently in the error log file. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        CloseFile:  Closes the currently open error log file. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        Flush:      Forces a write of any current information to the disk (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        GetProperty: Gets properties of the object. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        LastMessage: Returns the last message text written into the error log file. (Function)</span>
<span class="comments">;</span>
<span class="comments">;        OpenFile:   Opens the error log file for writing. (Function)</span>
<span class="comments">;</span>
<span class="comments">;        PrintLastMessage: Writes the last message text written into the error log file to </span>
<span class="comments">;                    standard output. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        Status:     Returns the current status of the error logger. (0 - waiting for input, </span>
<span class="comments">;                    1 - normal operation, 2 - error operation.) (Function)</span>
<span class="comments">;</span>
<span class="comments">;        SetProperty: Sets properties of the object. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">;        SetStatus:  Sets the current status of the error logger. Normally not used by the</span>
<span class="comments">;                    user, but used internally. (Procedure)</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;       Written by David W. Fanning, November 2009.</span>
<span class="comments">;       Modified and expanded the way errors are written into the log file and displayed.</span>
<span class="comments">;          Also made it possible to automatically delete the log file when the object is</span>
<span class="comments">;          destroyed, if the error logger is not in an error state at the time. Added</span>
<span class="comments">;          DELETE_ON_DESTROY and NOTRACEBACK keywords to the INIT and SetProperty</span>
<span class="comments">;          methods. 28 Jan 2010. DWF.</span>
<span class="comments">;        Modified default filenames so that I am now guaranteed to get unique file names </span>
<span class="comments">;           by using cgTimestamp program from the Coyote Library. 8 Feb 2010. DWF.</span>
<span class="comments">;        Added NOCLUTTER keyword. 15 February 2010. DWF.</span>
<span class="comments">;        Added PRINT keyword to AddText method to allow users to log statements that should</span>
<span class="comments">;           also be printed easily to a file. 17 February 2010. DWF.</span>
<span class="comments">;        Small documentation changes to the program. 22 June 2010. DWF.</span>
<span class="comments">;        Made a change so that the file is not opened until something needs to be written </span>
<span class="comments">;            to it. 22 June 2010. DWF.</span>
<span class="comments">;        Added FLUSH method and keyword IMMEDIATE to the INIT method (defaults to 1) which</span>
<span class="comments">;            will immediately flush the log information to disk when log information is</span>
<span class="comments">;            added to the object. This will prevent missing information that is buffered</span>
<span class="comments">;            when a program crashes. Matt Savoie suggestion. DWF, 10 Sept 2010.</span>
<span class="comments">;        Now calling cgTimeStamp rather than TimeStamp to avoid problems with IDL code. 6 Feb 2013. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2009-2010, by Fanning Software Consulting, Inc.                           ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::AddError</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Adds error text to the error log file and sets the error log status to 2 (error</span>
<span class="comments">;       condition). If the error logger alert flag is set to 1, the method will alert</span>
<span class="comments">;       the user to the error with a pop-up message dialog as well as writing the output</span>
<span class="comments">;       to standard output.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> AddError, theText</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       theText :    The error message text you wish to add to the file. If not provided,</span>
<span class="comments">;                    the text of the last error message (Help, /LAST_MESSAGE) is used and</span>
<span class="comments">;                    written to the file.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::AddError, theText

 
   <span class="comments">; The text will equal the ERROR_STATE messsage string if not available.</span>
   IF N_Elements(theText) EQ 0 THEN theText = !Error_State.Msg
   
   <span class="comments">; Get the call stack and the calling routine's name.</span>
   callStack = Scope_Traceback()
   callingRoutine = (StrSplit(StrCompress(callStack[1])," ", /Extract))[0]
   
   <span class="comments">; Are widgets supported?</span>
   IF !D.Name EQ 'PS' THEN BEGIN
      widgetsSupported = 1
   ENDIF ELSE BEGIN
      widgetsSupported = ((!D.Flags AND 65536L) NE 0)
   ENDELSE

   <span class="comments">; No dialogs, unless alert is set.</span>
   IF ~Keyword_Set(self.alert) THEN widgetsSupported = 0
   
   <span class="comments">; It is not enough to know if widgets are supported. In CRON jobs, widgets are</span>
   <span class="comments">; supported, but there is no X connection and pop-up dialogs are not allowed.</span>
   <span class="comments">; Here is a quick test to see if we can connect to a windowing system. If not,</span>
   <span class="comments">; then we are going to assume widgets are not supported.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      widgetsSupported = 0
      GOTO, testWidgetSupport
   ENDIF
   theWindow = !D.Window
   IF (!D.Flags AND 256) NE 0 THEN Window, /FREE, XSIZE=5, YSIZE=5, /PIXMAP
   Catch, /CANCEL
   
   testWidgetSupport: <span class="comments">; Come here if you choke on creating a window.</span>
   IF !D.Window NE theWindow THEN BEGIN
      WDelete, !D.Window
      IF theWindow GE 0 THEN WSet, theWindow
   ENDIF
   
   IF widgetsSupported && self.alert THEN BEGIN
   
      <span class="comments">; If this is an error produced with the MESSAGE command, it is a trapped</span>
      <span class="comments">; error and will have the name "IDL_M_USER_ERR".</span>
      IF !ERROR_STATE.NAME EQ "IDL_M_USER_ERR" THEN BEGIN
   
         IF N_Elements(title) EQ 0 THEN title = 'Trapped Error'
   
            <span class="comments">; If the message has the name of the calling routine in it,</span>
            <span class="comments">; it should be stripped out. Can you find a colon in the string?</span>
   
         <span class="comments">; Is the calling routine an object method? If so, special processing</span>
         <span class="comments">; is required. Object methods will have two colons together.</span>
         doublecolon = StrPos(theText, "::")
         IF doublecolon NE -1 THEN BEGIN
   
            prefix = StrMid(theText, 0, doublecolon+2)
            submessage = StrMid(theText, doublecolon+2)
            colon = StrPos(submessage, ":")
            IF colon NE -1 THEN BEGIN
   
               <span class="comments">; Extract the text up to the colon. Is this the same as</span>
               <span class="comments">; the callingRoutine? If so, strip it.</span>
               IF StrMid(theText, 0, colon+StrLen(prefix)) EQ callingRoutine THEN $
                  theText = StrMid(theText, colon+1+StrLen(prefix))
            ENDIF
         ENDIF ELSE BEGIN
   
            colon = StrPos(theText, ":")
            IF colon NE -1 THEN BEGIN
   
               <span class="comments">; Extract the text up to the colon. Is this the same as</span>
               <span class="comments">; the callingRoutine? If so, strip it.</span>
               IF StrMid(theText, 0, colon) EQ callingRoutine THEN $
                  theText = StrMid(theText, colon+1)
            ENDIF
   
         ENDELSE
   
         <span class="comments">; Add the calling routine's name.</span>
         void = Dialog_Message(StrUpCase(callingRoutine) + ": " + theText, Title=title)
   
      ENDIF ELSE BEGIN
   
         <span class="comments">; Otherwise, this is an IDL system error.</span>
         IF N_Elements(title) EQ 0 THEN title = 'System Error'
   
         IF StrUpCase(callingRoutine) EQ "$MAIN$" THEN BEGIN
            void = Dialog_Message(theText, Title=title) 
         ENDIF ELSE BEGIN
             void = Dialog_Message(StrUpCase(callingRoutine) + "--> " + theText, Title=title)
         ENDELSE
      ENDELSE
   ENDIF ELSE BEGIN
         Message, theText, /Continue, /NoPrint, /NoName, /NoPrefix
         self -> AddText, '%' + callingRoutine + ': ' + theText 
   ENDELSE
   
   <span class="comments">; Provide traceback information if requested.</span>
   Help, /Last_Message, Output=traceback
   traceback = ['Traceback Report from ' + StrUpCase(callingRoutine) + ':', $
                 '', "     " + traceback]
   IF self.alert THEN BEGIN
       IF Keyword_Set(self.traceback) THEN BEGIN
          FOR j=0,N_Elements(traceback)-1 DO Print, "     " + traceback[j]
       ENDIF
   ENDIF 
   IF Keyword_Set(self.traceback) THEN self -> AddText, traceback

    <span class="comments">; Set the status to error condition.</span>
    self -> SetStatus, 2
    
END


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::AddText</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Adds text to the error log file and sets the error log status to 1 (normal</span>
<span class="comments">;       condition). </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> AddText, theText</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       theText :    The message text you wish to add to the file. </span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">; </span>
<span class="comments">;       ADD_CALLER:   If this keyword is set, the name of the caller routine is</span>
<span class="comments">;                     prepended to the text message.</span>
<span class="comments">;</span>
<span class="comments">;       PRINT:        If this keyword is set, the added text is also sent to standard</span>
<span class="comments">;                     output.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::AddText, theText, PRINT=print, ADD_CALLER=add_caller
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Have to have text to do anything.</span>
    IF N_Elements(theText) EQ 0 THEN RETURN
    
    <span class="comments">; Make sure these are strings we are writing.</span>
    thisType = Size(theText, /TNAME)
    IF thisType NE 'STRING' THEN Message, 'Only strings can be written into the error log file.'
    
    IF Keyword_Set(add_caller) THEN BEGIN
        <span class="comments">; Get the call stack and the calling routine's name.</span>
        Help, Calls=callStack
        callingRoutine = (StrSplit(StrCompress(callStack[1])," ", /Extract))[0]
        theText = callingRoutine + ': ' + theText
    ENDIF
    
    <span class="comments">; Write the text to the file and to standard output, if requested.</span>
    IF self.lun EQ 0 THEN BEGIN
            success = self -> OpenFile(self.filename)
            IF ~success THEN Message, 'Cannot successfully open the error log file.'
    ENDIF
    numLines = N_Elements(theText)
    FOR j=0L, N_Elements(theText) -1 DO BEGIN
        PrintF, self.lun, theText[j]
        IF Keyword_Set( print ) THEN Print, theText[ j ]
    ENDFOR
    
    <span class="comments">; Write to disk immediately?</span>
    IF self.immediate NE 0  THEN self -> Flush

    <span class="comments">; Update the error logger status to normal. If this method is called</span>
    <span class="comments">; from AddError, then when we return to AddError, the status will be</span>
    <span class="comments">; set to 2, or error status. But setting to 1 here allows us to add</span>
    <span class="comments">; text to the file whenever we like.</span>
    self -> SetStatus, 1
    
    <span class="comments">; Save the last message for later recall.</span>
    *self.lastMessage = theText
    
END 


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::ClearLog</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Clears the error log file of text.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> ClearLog</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::ClearLog

    <span class="comments">; Close the current error log file and delete it.</span>
    self -> CloseFile
    File_Delete, self.filename, /ALLOW_NONEXISTENT
    
    <span class="comments">; Open a new error log file with the same name.</span>
    self -> OpenFile, self.filename
    
    <span class="comments">; Set the error logger status to waiting.</span>
    self -> SetStatus, 0
    
END 

<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::Flush</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Flushes the current error logger information to the file in case of crash.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> Flush</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::Flush
   IF self.lun GE 100 THEN Flush,  self.lun
END 

<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::CloseFile</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Closes the currently open error log file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> CloseFile</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::CloseFile
    IF self.lun GE 100 THEN Free_Lun, self.lun ELSE IF self.lun GT 0 THEN Close, self.lun
END 


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::GetFileName</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Returns the file name of the error log file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       filename =  errorLogger -> GetFileName()</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;       filename:     The name of the error log file.</span>
<span class="comments">; </span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ErrorLogger::GetFileName
    RETURN, self.filename
END 



<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::Status</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Returns the current status of the error logger.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       status = errorLogger -> Status()</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;       status:     The error log status: </span>
<span class="comments">;                      0 - waiting for input</span>
<span class="comments">;                      1 - normal operation</span>
<span class="comments">;                      2 - error operation</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ErrorLogger::Status
    RETURN, self.status
END 


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::SetStatus</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Sets the current status of the error logger.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> SetStatus, status</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       status:     The error log status: </span>
<span class="comments">;                      0 - waiting for input</span>
<span class="comments">;                      1 - normal operation</span>
<span class="comments">;                      2 - error operation</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::SetStatus, status
    IF N_Elements(status) NE 0 THEN BEGIN
        IF (self.noclutter AND (status EQ 2)) THEN BEGIN
            self.status = 1 
        ENDIF ELSE BEGIN
            self.status = 0 > status &lt<span class="comments">; 2</span>
        ENDELSE
    ENDIF
END 



<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::OpenFile</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Opens the error log file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> OpenFile, filename</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename:     The name of the error log file.</span>
<span class="comments">; </span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       DELETE_CURRENT_FILE:  If this keyword is set, the current error log file is closed</span>
<span class="comments">;                      and deleted before the new file is opened for writing.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ErrorLogger::OpenFile, newLogFilename, DELETE_CURRENT_FILE=delete_current_file
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(lun) NE 0 THEN BEGIN
            Free_Lun, lun
            File_Delete, newLogFilename, /ALLOW_NONEXISTENT
        ENDIF
        RETURN, 0
    ENDIF
    
    <span class="comments">; Can we write into the specified directory?</span>
    basename = cgRootName(newLogFilename, EXTENSION=ext, DIRECTORY=dir)
    IF File_Test(dir, /DIRECTORY) EQ 0 THEN Message, 'Specified directory (' + dir + ') does not exist.' 
    
    <span class="comments">; Close the current file (if any) before opening a new one.</span>
    self -> CloseFile
    
    <span class="comments">; Need to delete the current file?</span>
    IF Keyword_Set(delete_current_file) THEN File_Delete, self.filename, /ALLOW_NONEXISTENT

    <span class="comments">; Open the file for writing.</span>
    OpenW, lun, newLogFilename, /GET_LUN
    self.lun = lun
    
    <span class="comments">; Write a header into the file.</span>
    PrintF, self.lun, 'Error log file created: ' + Systime()
    PrintF, self.lun, ""
    
    <span class="comments">; Store the filename</span>
    self.filename = newLogFilename
    
    RETURN, 1
    
END


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::LastMessage</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Returns the last text message written to the error logger.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       message = errorLogger -> LastMessage()</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;       message:     The last text written to the error log file.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ErrorLogger::LastMessage
    
    <span class="comments">; Returns the last message added to the file.</span>
    IF N_Elements(*self.lastMessage) NE 0 THEN RETURN, *self.lastMessage ELSE RETURN, ""
    
END 


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::PrintLastMessage</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Prints the last text message written to the error logger to standard output.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> PrintLastMessage</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::PrintLastMessage
    
    <span class="comments">; Prints the last message in the error logger.</span>
    lastMessage = self -> LastMessage()
    FOR j=0, N_Elements(lastMessage)-1 DO Print, lastMessage[j]
    
END 



<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::GetProperty</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Allows the user to get properties from the object via keywords.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> GetProperty, ...</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       ALERT:          The alert flag in the object. (Output)</span>
<span class="comments">;</span>
<span class="comments">;       DELETE_ON_DESTROY:  The delete on destroy flag in the object. (Output)</span>
<span class="comments">;       </span>
<span class="comments">;       FILENAME:       The name of the error log file. (Output)</span>
<span class="comments">;</span>
<span class="comments">;       LAST_MESSAGE:   The last message written into the error log file. (Output)</span>
<span class="comments">;</span>
<span class="comments">;       LUN:            The logical unit number of the open error log file. (Output)</span>
<span class="comments">;</span>
<span class="comments">;       STATUS:         The current error log status. (Output)</span>
<span class="comments">;</span>
<span class="comments">;       NOTRACEBACK:    The notraceback flag in the object. (Output)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::GetProperty, $
    ALERT=alert, $
    DELETE_ON_DESTROY=delete_on_destroy, $
    FILENAME=filename, $
    LAST_MESSAGE=last_message, $
    LUN=lun, $
    NOCLUTTER=noclutter, $
    NOTRACEBACK=notraceback, $
    STATUS=status
    
    alert = self.alert
    delete_on_destroy = self.delete_on_destroy
    filename = self.filename
    last_message = self -> LastMessage()
    lun = self.lun
    noclutter = self.noclutter
    notraceback = ~self.traceback
    status = self.status

END 



<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::SetProperty</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Allows the user to set properties of the object via keywords.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       errorLogger -> SetProperty, ...</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       ALERT:          The alert flag in the object. (Input)</span>
<span class="comments">;       </span>
<span class="comments">;       DELETE_ON_DESTROY:  The delete on destroy flag in the object. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       NOCLUTTER:      Set the object up for no file cluttering. (Input).</span>
<span class="comments">;       </span>
<span class="comments">;       NOTRACEBACK:    The notraceback flag in the object. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       STATUS:         The current error log status. (Input)</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::SetProperty, $
    ALERT=alert, $
    DELETE_ON_DESTROY=delete_on_destroy, $
    NOCLUTTER=noclutter, $
    NOTRACEBACK=notraceback, $
    STATUS=status
    
    IF N_Elements(alert) NE 0 THEN self.alert = Keyword_Set(alert)
    IF N_Elements(delete_on_destroy) NE 0 THEN $
        self.delete_on_destroy = Keyword_Set(delete_on_destroy)
    IF N_Elements(notraceback) NE 0 THEN self.tracebace = 1 - Keyword_Set(notraceback)
    IF N_Elements(status) NE 0 THEN self -> SetStatus, status
    IF N_Elements(noclutter) NE 0 THEN BEGIN
        self.noclutter = Keyword_Set(noclutter)
        IF self.noclutter THEN BEGIN
            self.alert = 1
            self.delete_on_destroy = 1
        ENDIF
    ENDIF

END 



<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::CLEANUP</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       Cleans up the object.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       Called automatically when the object is destroyed.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ErrorLogger::CLEANUP

    <span class="comments">; Be sure the file is closed. Otherwise, it can't be deleted.</span>
    self -> CloseFile

    <span class="comments">; If the file is not in an error state, and the delete_on_destroy flag</span>
    <span class="comments">; is set, delete the error log file.</span>
    IF self.delete_on_destroy THEN BEGIN
        IF self.status NE 2 THEN File_Delete, self.filename, /ALLOW_NONEXISTENT
    ENDIF
    
    <span class="comments">; Free the last message pointer.</span>
    Ptr_Free, self.lastMessage
    
END 


<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ErrorLogger::INIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The initialization method for the object.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       check = Obj_New('ErrorLogger', filename)</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename:    The name of the error log file. If not provided, a default name</span>
<span class="comments">;                    will be created based on the current system time. (Optional)</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       ALERT:       The default behavior of the error logger is simply to write text to a file.</span>
<span class="comments">;                    But if the ALERT keyword is set, the program will alert the user via a</span>
<span class="comments">;                    message dialog that an error has occurred when using the AddError method. </span>
<span class="comments">;                    Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;      DELETE_ON_DESTROY: If this keyword is set, the error log file will be deleted when the</span>
<span class="comments">;                    ErrorLogger object is destroyed, but only if the ErrorLogger object is not</span>
<span class="comments">;                    in an error state at that time (error status = 2. Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;      IMMEDIATE:    All messages will flush to disk as soon as they are</span>
<span class="comments">;                    logged. Default is 1 (Input)</span>
<span class="comments">;</span>
<span class="comments">;       NOCLUTTER:   Believe it or not, some people who use an ErrorLogger prefer that an error log</span>
<span class="comments">;                    file is never left behind. (They prefer that the program act like ERROR_MESSAGE.)</span>
<span class="comments">;                    For those people, the NOCLUTTER keyword provides a way for them to automatically</span>
<span class="comments">;                    set the ALERT and DESTROY_ON_DELETE keywords to 1. It also prevents the error </span>
<span class="comments">;                    logger from ever setting the error status to 2. Thus, when the ErrorLogger is</span>
<span class="comments">;                    destroyed, the file is always deleted. Default is 0. When set, overrides ALERT</span>
<span class="comments">;                    and DELETE_ON_DESTROY settings. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       NOTRACEBACK: Set this keyword to suppress traceback information in the error log output</span>
<span class="comments">;                    and in any alerts issued by the program. Default is 0. (Input)</span>
<span class="comments">;</span>
<span class="comments">;       TIMESTAMP:   Set this keyword if you wish a time stamp to be appended to the provided</span>
<span class="comments">;                    filename. Otherwise, the filename is used as defined. Default filenames</span>
<span class="comments">;                    always have a timestamp appended to the file name. (Input)                  </span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ErrorLogger::INIT, filename, $
    ALERT=alert, $
    DELETE_ON_DESTROY=delete_on_destroy, $
    IMMEDIATE = immediate, $
    NOCLUTTER=noclutter, $
    NOTRACEBACK=notraceback, $
    TIMESTAMP=timestamp
    
    COMPILE_OPT idl2

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(lun) NE 0 THEN BEGIN
            Free_Lun, lun
            File_Delete, logFilename, /ALLOW_NONEXISTENT
        ENDIF
        RETURN, 0
    ENDIF

    <span class="comments">; Flushing should always be turned on unless there is a good reason</span>
    <span class="comments">; not to do it.</span>
    SetDefaultValue,  immediate,  1

    <span class="comments">; Does the filename exist?</span>
    IF N_Elements(filename) EQ 0 THEN BEGIN
       CD, CURRENT=currentDir
       logFilename = FilePath(ROOT_DIR=currentDir, 'logger' + $
            cgTimestamp(RANDOM_DIGITS=6, /VALID) + '.log')
       filename = logFilename
       timestamp = 0
    ENDIF
    
    <span class="comments">; Is this a fully qualified filename?</span>
    baseName = File_BaseName(filename)
    IF baseName EQ filename THEN BEGIN
        CD, CURRENT=currentDir
        logFilename = FilePath(ROOT_DIR=currentDir, filename)
    ENDIF ELSE logFilename = filename
    
    <span class="comments">; Does the name need a time stamp?</span>
    IF Keyword_Set(timestamp) THEN BEGIN
       basename = cgRootName(logFilename, EXTENSION=ext, DIRECTORY=dir)
       time = Systime(1)
       randomdigits =  StrMid(StrTrim(time - Long(time),2), 2)
       logFilename = Filepath(ROOT_DIR=dir, basename +  cgTimestamp(RANDOM_DIGITS=6, /VALID))
       IF ext NE "" THEN logFilename = logFilename + '.' + ext
    END

    <span class="comments">; Store the filename.</span>
    self.filename = logFilename
    
    <span class="comments">; Initialize the last message pointer.</span>
    self.lastMessage = Ptr_New(/ALLOCATE_HEAP)
    
    <span class="comments">; Need alerts?</span>
    self.alert = Keyword_Set(alert)
    
    <span class="comments">; Need traceback?</span>
    self.traceback = 1 - Keyword_Set(notraceback)
    
    <span class="comments">; Delete file on destroy?</span>
    self.delete_on_destroy = Keyword_Set(delete_on_destroy)
    
    <span class="comments">; No clutter desired?</span>
    IF Keyword_Set(noclutter) THEN BEGIN
        self.alert = 1
        self.delete_on_destroy = 1
        self.noclutter = 1
     ENDIF

    <span class="comments">; Flushing?</span>
    self.immediate = immediate
    
    <span class="comments">; Successful completion.</span>
    RETURN, 1
    
END 


PRO ErrorLogger__Define, class

   class = { ERRORLOGGER, $
             filename: "", $            <span class="comments">; The error log filename.</span>
             lun: 0L, $                 <span class="comments">; The file logical unit number.</span>
             alert: 0L, $               <span class="comments">; A flag, if set, will give user alerts on errors.</span>
             traceback: 0L, $           <span class="comments">; If set, will include traceback information into the log file.</span>
             lastMessage: Ptr_New(), $  <span class="comments">; The last message written into the file.</span>
             immediate: 0L, $           <span class="comments">; A flag causing messages to flush to disk immediately</span>
             delete_on_destroy: 0L, $   <span class="comments">; A flag causing log file to be deleted when object is destroyed.</span>
             noclutter: 0L, $           <span class="comments">; A flag that sets up file deletion on destroy.</span>
             status: 0L }               <span class="comments">; The current status of the error logger. 0-waiting, 1-normal, 2-error.</span>
             
END
</code>
    </div>
  </body>
</html>