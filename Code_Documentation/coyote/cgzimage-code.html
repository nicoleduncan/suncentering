<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:37 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgzimage.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgzimage.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgZImage</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Allows the user to interactively zoom into an image. Program controls are available</span>
<span class="comments">;   by right-clicking in the full-sized image window. Zoom factors from 2x to 16x are</span>
<span class="comments">;   available. Use the left mouse button to draw a box on the full-sized image to locate</span>
<span class="comments">;   the region of the image to zoom.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;+</span>
<span class="comments">; Allows the user to interactively zoom into an image. Program controls are available</span>
<span class="comments">; by right-clicking in the full-sized image window. Zoom factors from 2x to 16x are</span>
<span class="comments">; available. Use the left mouse button to draw a box on the full-sized image to locate</span>
<span class="comments">; the region of the image to zoom.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Code examples::</span>
<span class="comments">;       IDL> image = cgDemoData(7)</span>
<span class="comments">;       IDL> cgZImage, image ; 2D image</span>
<span class="comments">;       IDL> image = cgDemoData(16)</span>
<span class="comments">;       IDL> cgZImage, image ; True-Color image</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 20 September 2012 from previous FSC_ZImage program. DWF.</span>
<span class="comments">;        Modernized the info structure handling to reflect modern sensibilities. 3 Oct 2012. DWF.</span>
<span class="comments">;        Changes to allow this to work with very large images. Can now zoom to actual pixel values.</span>
<span class="comments">;           Also fixed a problem that left zoom windows lying around unused if scroll bars were </span>
<span class="comments">;           needed. 18 October 2012. DWF.</span>
<span class="comments">;        The color palette was not always being included when images were zoomed. Fixed. 17 Nov 2012. DWF.</span>
<span class="comments">;        Added ZoomFactor keyword to allow the zoom factor to be set on start-up. 28 Nov 2012. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Event handler for the motion events coming from the zoom window. Find the location</span>
<span class="comments">; and value of the image at the cursor location and report it to the status bar in the</span>
<span class="comments">; main image window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_ZoomWindow_Events, event

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Get the info structure.</span>
    Widget_Control, event.top, Get_UValue=tlb
    Widget_Control, tlb, Get_UValue=info
    
    <span class="comments">; Create the proper vectors to locate the cursor in the image.</span>
    xvec = cgScaleVector(Findgen((*info).zxsize), (*info).xrange[0], (*info).xrange[1])
    yvec = cgScaleVector(Findgen((*info).zysize), (*info).yrange[0], (*info).yrange[1])
    xloc = 0 > Round(xvec[event.x]) &lt<span class="comments">; ((*info).xsize-1)</span>
    yloc = 0 > Round(yvec[event.y]) &lt<span class="comments">; ((*info).ysize-1)</span>
    
    <span class="comments">; Create the text for the status bar.</span>
    dims = Image_Dimensions((*info).image, XSize=xsize, YSize=ysize, TrueIndex=trueindex)
    CASE trueIndex OF
       -1: value = ((*info).image)[xloc, yloc]
        0: BEGIN
          image = Transpose((*info).image, [1,2,0])
          value = [(image[*,*,0])[xloc, yloc], (image[*,*,1])[xloc, yloc], (image[*,*,1])[xloc, yloc]]
          Undefine, image
          END
        1: BEGIN
          image = Transpose((*info).image, [0,2,1])
          value = [(image[*,*,0])[xloc, yloc], (image[*,*,1])[xloc, yloc], (image[*,*,1])[xloc, yloc]]
          Undefine, image
          END
        2: BEGIN
          value = [((*info).image[*,*,0])[xloc, yloc], ((*info).image[*,*,1])[xloc, yloc], ((*info).image[*,*,1])[xloc, yloc]]
          END
    ENDCASE
    
    <span class="comments">; Create the text for the statusbar widget and update the status bar.</span>
    IF Obj_Valid(*(*info).map) THEN BEGIN
        *(*info).map -> GetProperty, XRANGE=xrange, YRANGE=yrange
        xvec = cgScaleVector(Findgen((*info).xsize), xrange[0], xrange[1])
        yvec = cgScaleVector(Findgen((*info).ysize), yrange[0], yrange[1])
        ll = *(*info).map -> Inverse(xvec[xloc], yvec[yloc])
        loctext = 'Lat: ' + String(ll[1], Format='(F0.3)') + '  Lon: ' + String(ll[0], Format='(F0.3)')
    ENDIF ELSE BEGIN
       loctext = 'XLoc: ' + Strtrim(xloc,2) + '  YLoc: ' + Strtrim(yloc,2)
    ENDELSE
    imageType = Size(value, /TNAME)
    IF imageType EQ 'BYTE' THEN value = Fix(value)
    IF N_Elements(value) EQ 1 THEN BEGIN
        valuetext = '  Value: ' + StrTrim(value,2)
    ENDIF ELSE BEGIN
        valuetext = '  RGB Value: (' + StrTrim(value[0],2) + ', ' + $
             StrTrim(value[1],2) + ', ' + StrTrim(value[2],2) + ')'
    ENDELSE
    Widget_Control, (*info).statusbar, Set_Value=loctext + valuetext
     
    <span class="comments">; Draw the box and a small circle to locate the cursor on the</span>
    <span class="comments">; larger image.</span>
    WSet, (*info).drawIndex
    Device, Copy=[0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).pixIndex]    
    xvec = cgScaleVector(Findgen(!D.X_Size), 0, (*info).xsize)
    yvec = cgScaleVector(Findgen(!D.Y_Size), 0, (*info).ysize)
    xdloc = Value_Locate(xvec, xloc)
    ydloc = Value_Locate(yvec, yloc)
    cgPlotS, [(*info).xs, (*info).xs, (*info).xd, (*info).xd, (*info).xs], $
             [(*info).ys, (*info).yd, (*info).yd, (*info).ys, (*info).ys], $
              /Device, Color=(*info).boxcolor
    cgPlotS, xdloc, ydloc, /Device, PSYM='OpenCircle', Color=(*info).boxcolor, SymSize=1.5
    
END


<span class="comments">;+</span>
<span class="comments">; A clean-up routine for the zoom window, if the zoom window is killed.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     zoomID: in, required, type=long</span>
<span class="comments">;        The zoom widget identifier</span>
<span class="comments">;-</span>
PRO cgZImage_ZoomDied, zoomID

    <span class="comments">; Come here when the zoom window dies. Basically, you </span>
    <span class="comments">; want to erase the zoom box in the full-size window.</span>
  
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message(/Quiet)
        RETURN
    ENDIF

    <span class="comments">; Get the TLB of the full-sized window.</span>
    Widget_Control, zoomID, GET_UVALUE=tlb
    
    <span class="comments">; If that base is gone, disappear!</span>
    IF Widget_Info(tlb, /VALID_ID) EQ 0 THEN RETURN
    
    <span class="comments">; Get the information you need to redisplay the image.</span>
    Widget_Control, tlb, Get_UValue=info
    
    <span class="comments">; Redisplay the image.</span>
    WSet, (*info).drawIndex
    cgImage, (*info).image, $
       BETA=*(*info).beta, $
       BOTTOM=*(*info).bottom, $
       CLIP=*(*info).clip, $
       EXCLUDE=*(*info).exclude, $
       EXPONENT=*(*info).exponent, $
       GAMMA=*(*info).gamma, $
       INTERPOLATE=*(*info).interpolate, $
       MAXVALUE=*(*info).max, $
       MEAN=*(*info).mean, $
       MISSING_COLOR=*(*info).missing_color, $
       MISSING_INDEX=*(*info).missing_index, $
       MISSING_VALUE=*(*info).missing_value, $
       NEGATIVE=*(*info).negative, $
       MINVALUE=*(*info).min, $
       MULTIPLIER=*(*info).multiplier, $
       NCOLORS=*(*info).ncolors, $
       PALETTE=*(*info).palette, $
       SCALE=*(*info).scale, $
       SIGMA=*(*info).sigma, $
       STRETCH=*(*info).stretch, $
       TOP=*(*info).top
       
    WSet, (*info).pixIndex
    Device, Copy=[0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).drawIndex]
    
    <span class="comments">; Clear the statusbar widget.</span>
    Widget_Control, (*info).statusbar, Set_Value=""
    
END <span class="comments">; ----------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Event handler for changing the rubber-band box color.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_BoxColor, event

    <span class="comments">; Come here to change the selector box color.</span>
  
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
       RETURN
    ENDIF

    <span class="comments">; Get the information you need to redisplaythe image.</span>
    Widget_Control, event.top, Get_UValue=info
    
    boxcolor = cgPickColorName((*info).boxColor, Group_Leader=event.top)
    (*info).boxColor = boxColor
    
    <span class="comments">; Redisplay the image.</span>
    WSet, (*info).drawIndex
    cgImage, (*info).image, $      
       BETA=*(*info).beta, $
       BOTTOM=*(*info).bottom, $
       CLIP=*(*info).clip, $
       EXCLUDE=*(*info).exclude, $
       EXPONENT=*(*info).exponent, $
       GAMMA=*(*info).gamma, $
       INTERPOLATE=*(*info).interpolate, $
       MAXVALUE=*(*info).max, $
       MEAN=*(*info).mean, $
       MISSING_COLOR=*(*info).missing_color, $
       MISSING_INDEX=*(*info).missing_index, $
       MISSING_VALUE=*(*info).missing_value, $
       NEGATIVE=*(*info).negative, $
       MINVALUE=*(*info).min, $
       MULTIPLIER=*(*info).multiplier, $
       NCOLORS=*(*info).ncolors, $
       PALETTE=*(*info).palette, $
       SCALE=*(*info).scale, $
       SIGMA=*(*info).sigma, $
       STRETCH=*(*info).stretch, $
       TOP=*(*info).top

    WSet, (*info).pixIndex
    Device, Copy=[0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).drawIndex]
    
    <span class="comments">; Unmap the controls.</span>
    Widget_Control, (*info).controlID, Map=0
    (*info).mapcontrols = 0    
    
END <span class="comments">; ----------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Event handler for changing the colors the image is displayed in.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_LoadColors, event

    <span class="comments">; Come here to load colors or to respond to color loading events.</span>

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    Widget_Control, event.top, Get_UValue=info
    
    <span class="comments">; What kind of event is this?</span>
    thisEvent = Tag_Names(event, /Structure)
    
    <span class="comments">; Do the right thing.</span>
    CASE thisEvent OF
    
        'WIDGET_BUTTON': BEGIN
            TVLCT, (*info).r, (*info).g, (*info).b, *(*info).bottom
            XColors, Group=event.top, NColors = *(*info).ncolors, $
                Bottom=*(*info).bottom, NotifyID=[event.id, event.top], $
                Title='ZImage Colors (' + StrTrim((*info).drawIndex,2) + ')'
            Widget_Control, (*info).controlID, Map=0
            (*info).mapcontrols = 0
            END
            
        'XCOLORS_LOAD':BEGIN
    
                <span class="comments">; Extract the new color table vectors from XCOLORS.</span>
    
            (*info).r = event.r(*(*info).bottom:*(*info).bottom+*(*info).ncolors-1)
            (*info).g = event.g(*(*info).bottom:*(*info).bottom+*(*info).ncolors-1)
            (*info).b = event.b(*(*info).bottom:*(*info).bottom+*(*info).ncolors-1)
    
            <span class="comments">; Redisplay the image.</span>
            WSet, (*info).drawIndex
            cgImage, (*info).image, $      
               BETA=*(*info).beta, $
               BOTTOM=*(*info).bottom, $
               CLIP=*(*info).clip, $
               EXCLUDE=*(*info).exclude, $
               EXPONENT=*(*info).exponent, $
               GAMMA=*(*info).gamma, $
               INTERPOLATE=*(*info).interpolate, $
               MAXVALUE=*(*info).max, $
               MEAN=*(*info).mean, $
               MISSING_COLOR=*(*info).missing_color, $
               MISSING_INDEX=*(*info).missing_index, $
               MISSING_VALUE=*(*info).missing_value, $
               NEGATIVE=*(*info).negative, $
               MINVALUE=*(*info).min, $
               MULTIPLIER=*(*info).multiplier, $
               NCOLORS=*(*info).ncolors, $
               PALETTE=*(*info).palette, $
               SCALE=*(*info).scale, $
               SIGMA=*(*info).sigma, $
               STRETCH=*(*info).stretch, $
               TOP=*(*info).top

            WSet, (*info).pixIndex
            Device, Copy=[0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).drawIndex]
    
            <span class="comments">; Is a zoom window open? If so, redisplay it as well.</span>
            IF Widget_Info((*info).zoomDrawID, /Valid_ID) THEN BEGIN
               WSet, (*info).zoomWindowID
               IF Ptr_Valid((*info).zoomedImage) THEN BEGIN
                  cgImage, *(*info).zoomedImage, $      
                       BETA=*(*info).beta, $
                       BOTTOM=*(*info).bottom, $
                       CLIP=*(*info).clip, $
                       EXCLUDE=*(*info).exclude, $
                       EXPONENT=*(*info).exponent, $
                       GAMMA=*(*info).gamma, $
                       INTERPOLATE=*(*info).interpolate, $
                       MAXVALUE=*(*info).max, $
                       MEAN=*(*info).mean, $
                       MISSING_COLOR=*(*info).missing_color, $
                       MISSING_INDEX=*(*info).missing_index, $
                       MISSING_VALUE=*(*info).missing_value, $
                       NEGATIVE=*(*info).negative, $
                       MINVALUE=*(*info).min, $
                       MULTIPLIER=*(*info).multiplier, $
                       NCOLORS=*(*info).ncolors, $
                       PALETTE=*(*info).palette, $
                       SCALE=*(*info).scale, $
                       SIGMA=*(*info).sigma, $
                       STRETCH=*(*info).stretch, $
                       TOP=*(*info).top
               ENDIF
            ENDIF
    
            END
    ENDCASE
END <span class="comments">; ----------------------------------------------------------------------</span>





<span class="comments">;+</span>
<span class="comments">; Event handler for quiting the program.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_Quit, event
    Widget_Control, event.top, /Destroy
END <span class="comments">; ----------------------------------------------------------------------</span>





<span class="comments">;+</span>
<span class="comments">; The clean-up routine for the program. Come here to release pointers and</span>
<span class="comments">; memory.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     tlb: in, required, type=long</span>
<span class="comments">;        The identifier of the top-level base of the widget program.</span>
<span class="comments">;-</span>
PRO cgZImage_Cleanup, tlb

   <span class="comments">; The purpose of this program is to delete the pixmap window</span>
   <span class="comments">; when the program cgZImage is destroyed. Get the info structure,</span>
   <span class="comments">; which holds the pixmap window index number and delete the window.</span>

    Widget_Control, tlb, Get_UValue=info
    IF N_Elements(info) NE 0 THEN BEGIN
        WDelete, (*info).pixIndex
        Ptr_Free, (*info).zoomedImage
        Ptr_Free, (*info).beta
        Ptr_Free, (*info).bottom
        Ptr_Free, (*info).clip
        Ptr_Free, (*info).exclude
        Ptr_Free, (*info).exponent
        Ptr_Free, (*info).gamma
        Ptr_Free, (*info).interpolate
        IF (*info).createdmap THEN BEGIN
           mapObj = *(*info).map
           Obj_Destroy, mapObj
           Ptr_Free, (*info).map 
        ENDIF ELSE BEGIN
           mapObj = *(*info).map
           Ptr_Free, (*info).map
        ENDELSE
        Ptr_Free, (*info).max
        Ptr_Free, (*info).mean
        Ptr_Free, (*info).missing_color
        Ptr_Free, (*info).missing_index
        Ptr_Free, (*info).missing_value
        Ptr_Free, (*info).negative
        Ptr_Free, (*info).min
        Ptr_Free, (*info).multiplier
        Ptr_Free, (*info).ncolors
        Ptr_Free, (*info).palette
        Ptr_Free, (*info).scale
        Ptr_Free, (*info).sigma
        Ptr_Free, (*info).stretch
        Ptr_Free, (*info).top
    ENDIF

END <span class="comments">; ----------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Event handler for changing the zoom factor.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_Factor, event

   <span class="comments">; The purpose of this event handler is to set the zoom factor.</span>

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
         
        <span class="comments">; Put the info structure back.</span>
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info
        RETURN
    ENDIF
    
    Widget_Control, event.top, Get_UValue=info
    Widget_Control, event.id, Get_UValue=factor
    (*info).zoomfactor = factor[event.index]
    Widget_Control, (*info).controlID, Map=0
    (*info).mapcontrols = 0
END <span class="comments">; ----------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Event handler for handling the rubber-band box events to create</span>
<span class="comments">; the zoom window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure passed to the program by the window manager.</span>
<span class="comments">;-</span>
PRO cgZImage_DrawEvents, event

   <span class="comments">; This event handler continuously draws and erases the zoom box until it</span>
   <span class="comments">; receives an UP event from the draw widget. Then it turns draw widget</span>
   <span class="comments">; motion events OFF.</span>

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
         
        <span class="comments">; Turn motion events off.</span>
        Widget_Control, event.id, Draw_Motion_Events=0        
        RETURN
    ENDIF

   <span class="comments">; Get the info structure out of the top-level base.</span>
    Widget_Control, event.top, Get_UValue=info
    
   <span class="comments">; What type of an event is this?</span>
    possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL' ]
    thisEvent = possibleEventTypes[event.type]
    buttons = ['NONE', 'LEFT', 'MIDDLE', 'NONE', 'RIGHT']
    
    CASE thisEvent OF
    
       'DOWN': BEGIN
    
       <span class="comments">; Is this the left or right button?</span>
       <span class="comments">; If RIGHT, then map or unmap controls.</span>
       buttonPressed = buttons[event.press]
       IF buttonPressed EQ 'RIGHT' THEN BEGIN
          IF (*info).mapcontrols EQ 1 THEN BEGIN
             Widget_Control, (*info).controlID, Map=0
             (*info).map = 0
          ENDIF ELSE BEGIN
             Widget_Control, (*info).controlID, Map=1
             (*info).mapcontrols = 1
          ENDELSE
          RETURN
       ENDIF

      <span class="comments">; Set the static corners of the box to current</span>
      <span class="comments">; cursor location.</span>
      (*info).xs = event.x
      (*info).ys = event.y

      <span class="comments">; Turn draw MOTION events ON.</span>
      Widget_Control, event.id, Draw_Motion_Events=1
    
      ENDCASE
    
      'UP': BEGIN
    
       <span class="comments">; Is this the left or right button?</span>
       <span class="comments">; If RIGHT, then do nothing.</span>
       buttonReleased = buttons[event.release]
       IF buttonReleased EQ 'RIGHT' THEN RETURN

      <span class="comments">; If this is an UP event, you need to erase the zoombox, turn motion events OFF, and</span>
      <span class="comments">; draw the "zoomed" plot in both the draw widget and the pixmap.</span>


      <span class="comments">; Turn motion events off.</span>
      Widget_Control, event.id, Draw_Motion_Events=0

      <span class="comments">; Draw the "zoomed" image. Start by getting the LAST zoom</span>
      <span class="comments">; box outline. These are indices into image array.</span>
      event.x = 0 > event.x &lt<span class="comments">; ((*info).xsize - 1)</span>
      event.y = 0 > event.y &lt<span class="comments">; ((*info).ysize - 1)</span>
      x = [(*info).xs, event.x]
      y = [(*info).ys, event.y]
      
      <span class="comments">; Make sure the user didn't just click in the window.</span>
      IF (*info).xs EQ event.x OR (*info).ys EQ event.y THEN BEGIN
      
          <span class="comments">; Erase the zoombox.</span>
          WSet, (*info).drawIndex
          TVLCT, (*info).r, (*info).g, (*info).b
          
          <span class="comments">; Copy from the pximap.</span>
          Device, Copy = [0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).pixIndex]
          RETURN
          
      ENDIF

      <span class="comments">; Make sure the x and y values are ordered as [min, max].</span>
      IF (*info).xs GT event.x THEN x = [event.x, (*info).xs]
      IF (*info).ys GT event.y THEN y = [event.y, (*info).ys]
      
      <span class="comments">; Make sure these are in image pixel coordinates, not just</span>
      <span class="comments">; window pixel coordinates.</span>
      xvec = cgScaleVector(Indgen((*info).xsize), 0, !D.X_Size-1)
      yvec = cgScaleVector(Indgen((*info).ysize), 0, !D.Y_Size-1)
      x = Value_Locate(xvec, x)
      y = Value_Locate(yvec, y)
      (*info).xrange = x
      (*info).yrange = y

      <span class="comments">; Set the zoom factor and determine the new X and Y</span>
      <span class="comments">; sizes of the Zoom Window.</span>
      zoomXSize = (x[1] - x[0] + 1) * (*info).zoomFactor
      zoomYSize = (y[1] - y[0] + 1) * (*info).zoomFactor
      (*info).zxsize = zoomXSize
      (*info).zysize = zoomYSize

      <span class="comments">; Subset the image, and apply the zoom factor to it.</span>
      CASE (*info).trueIndex OF
          -1: imageSubset = (*info).scaled[x[0]:x[1], y[0]:y[1]]
           0: imageSubset = (*info).scaled[*, x[0]:x[1], y[0]:y[1]]
           1: imageSubset = (*info).scaled[x[0]:x[1], *, y[0]:y[1]]
           2: imageSubset = (*info).scaled[x[0]:x[1], y[0]:y[1], *]
      ENDCASE
      
      zoomedImage = cgResizeImage(imageSubset, zoomXSize, zoomYSize, Interp=0)
      IF Ptr_Valid((*info).zoomedImage) $
        THEN *(*info).zoomedImage = zoomedImage $
        ELSE (*info).zoomedImage = Ptr_New(zoomedImage, /No_Copy)

      <span class="comments">; If the Zoom Window exists, make it the proper size and load</span>
      <span class="comments">; the zoomed image into it. If it does not exists, create it.</span>
      IF Widget_Info((*info).zoomDrawID, /Valid_ID) THEN BEGIN

         <span class="comments">; If the new zoomed image needs scroll bars, or the window has</span>
         <span class="comments">; scroll bars, destroy it and recreate it.</span>
         dims = Image_Dimensions(*(*info).zoomedimage, XSIZE=ixsize, YSIZE=iysize)
         IF (ixsize GT (*info).maxSize) OR (iysize GT (*info).maxSize) OR ((*info).hasScrollBars) THEN BEGIN
         
             <span class="comments">; Get offset positions for the non-existing zoom window.</span>
             Widget_Control, (*info).zoomDrawID, TLB_Get_Offset=offsets
             xpos = offsets[0] 
             ypos = offsets[1]
             
             Widget_Control, (*info).zoomtlb, /Destroy
             
             <span class="comments">; Calculate a window size. Maximum window size is 800.</span>
             dims = Image_Dimensions(*(*info).zoomedimage, XSIZE=ixsize, YSIZE=iysize)
             aspect = Float(ixsize)/iysize
             MAXSIZE = 800
             IF ixsize GT MAXSIZE OR iysize GT MAXSIZE THEN BEGIN
                 x_scroll_size = MAXSIZE &lt<span class="comments">; ixsize</span>
                 y_scroll_size = MAXSIZE &lt<span class="comments">; iysize</span>
                 (*info).hasScrollBars = 1
                 
                 <span class="comments">; Make sure window is not off the display.</span>
                 maxwinsize = MaxWindowSize()
                 IF (xpos + x_scroll_size) GT maxwinsize[0] THEN $
                    xpos = maxwinsize[0] - x_scroll_size
                 IF (ypos + y_scroll_size) GT maxwinsize[1] THEN $
                    ypos = maxwinsize[1] - y_scroll_size
             ENDIF ELSE (*info).hasScrollBars = 0
             
             <span class="comments">; Zoom window does not exist. Create it.</span>
             zoomTLB = Widget_Base(Title='Zoomed Image', Group=event.top, $
                 XOffset=xpos, YOffset=ypos, KILL_NOTIFY='cgZImage_ZoomDied', $
                 UVALUE=event.top, X_Scroll_Size=x_scroll_size, Y_Scroll_Size=y_scroll_size)
             zoomdraw = Widget_Draw(zoomtlb, XSize=zoomXSize, YSize=zoomYSize, $
                /MOTION_EVENTS, Event_Pro='cgZImage_ZoomWindow_Events')
             Widget_Control, zoomtlb, /Realize
             Widget_Control, zoomdraw, Get_Value=windowID
             (*info).zoomDrawID = zoomdraw
             (*info).zoomWindowID = windowID
             (*info).zoomTLB = zoomTLB
             WSet, windowID
             IF Ptr_Valid((*info).zoomedImage) THEN cgImage, *(*info).zoomedImage, PALETTE=*(*info).palette
     
          ENDIF ELSE BEGIN
         
         <span class="comments">; Zoomed window exists. Make it correct size and load image.</span>
         Widget_Control, (*info).zoomDrawID, XSize=zoomXSize, YSize=zoomYSize
         WSet, (*info).zoomWindowID
         IF Ptr_Valid((*info).zoomedImage) THEN cgImage, *(*info).zoomedImage, PALETTE=*(*info).palette
         
         ENDELSE
      ENDIF ELSE BEGIN

         <span class="comments">; Get offset positions for the non-existing zoom window.</span>
         Widget_Control, event.top, TLB_Get_Size=sizes, TLB_Get_Offset=offsets
         xpos = sizes[0] + offsets[0] + 20
         ypos = offsets[1] + 40
         
         <span class="comments">; Calculate a window size. Maximum window size is 800.</span>
         dims = Image_Dimensions(*(*info).zoomedimage, XSIZE=ixsize, YSIZE=iysize)
         aspect = Float(ixsize)/iysize
         MAXSIZE = 800
         IF ixsize GT MAXSIZE OR iysize GT MAXSIZE THEN BEGIN
             x_scroll_size = MAXSIZE &lt<span class="comments">; ixsize</span>
             y_scroll_size = MAXSIZE &lt<span class="comments">; iysize</span>
             (*info).hasScrollBars = 1
                 
             <span class="comments">; Make sure window is not off the display.</span>
             maxwinsize = MaxWindowSize()
             IF (xpos + x_scroll_size) GT maxwinsize[0] THEN $
                xpos = maxwinsize[0] - x_scroll_size
             IF (ypos + y_scroll_size) GT maxwinsize[1] THEN $
                ypos = maxwinsize[1] - y_scroll_size
         ENDIF ELSE (*info).hasScrollBars = 0
         
         <span class="comments">; Zoom window does not exist. Create it.</span>
         zoomtlb = Widget_Base(Title='Zoomed Image', Group=event.top, TLB_Frame_Attr=1, $
             XOffset=xpos, YOffset=ypos, KILL_NOTIFY='cgZImage_ZoomDied', $
             UVALUE=event.top, X_Scroll_Size=x_scroll_size, Y_Scroll_Size=y_scroll_size)
         zoomdraw = Widget_Draw(zoomtlb, XSize=zoomXSize, YSize=zoomYSize, $
                /MOTION_EVENTS, Event_Pro='cgZImage_ZoomWindow_Events')
         Widget_Control, zoomtlb, /Realize
         Widget_Control, zoomdraw, Get_Value=windowID
         (*info).zoomDrawID = zoomdraw
         (*info).zoomWindowID = windowID
         (*info).zoomTLB = zoomTLB
         WSet, windowID
         IF Ptr_Valid((*info).zoomedImage) THEN cgImage, *(*info).zoomedImage, PALETTE=*(*info).palette
         
      ENDELSE

      <span class="comments">; If the controls were mapped, unmap them.</span>
      IF (*info).mapcontrols EQ 1 THEN BEGIN
          Widget_Control, (*info).controlID, Map=0
          (*info).mapcontrols = 0
      ENDIF
    
      ENDCASE

    'MOTION': BEGIN

    <span class="comments">; Most of the action in this event handler occurs here while we are waiting</span>
    <span class="comments">; for an UP event to occur. As long as we don't get it, keep erasing the</span>
    <span class="comments">; old zoom box and drawing a new one.</span>

    <span class="comments">; Erase the old zoom box.</span>
    WSet, (*info).drawIndex
    TVLCT, (*info).r, (*info).g, (*info).b, *(*info).bottom
    Device, Copy = [0, 0, (*info).xsize, (*info).ysize, 0, 0, (*info).pixIndex]

    <span class="comments">; Update the dynamic corner of the zoom box to the current cursor location.</span>
    (*info).xd = event.x
    (*info).yd = event.y

    <span class="comments">; Draw the zoom box. </span>
    Device, Get_Decomposed=theState
    Device, Decomposed=1
    PlotS, [(*info).xs, (*info).xs, (*info).xd, (*info).xd, (*info).xs], $
       [(*info).ys, (*info).yd, (*info).yd, (*info).ys, (*info).ys], $
       /Device, Color=cgColor((*info).boxcolor)
    Device, Decomposed=theState
       
    ENDCASE

ENDCASE

END <span class="comments">; ----------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Allows the user to interactively zoom into an image. Program controls are available</span>
<span class="comments">; by right-clicking in the full-sized image window. Zoom factors from 2x to 16x are</span>
<span class="comments">; available. Use the left mouse button to draw a box on the full-sized image to locate</span>
<span class="comments">; the region of the image to zoom.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    image: in, required, type=any</span>
<span class="comments">;        A 2D or true-color image of any normal data type. If not a BYTE array,</span>
<span class="comments">;        cgImage keywords for proper image scaling must be used to provide image</span>
<span class="comments">;        scaling parameters.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    beta: in, optional, type=float, default=3.0</span>
<span class="comments">;         The beta factor in a Hyperpolic Sine stretch. Available only with 2D images.</span>
<span class="comments">;    bottom: in, optional, type=integer, default=0</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP. Available only with 2D images.</span>
<span class="comments">;    boxcolor: in, optional, type=string, default='gold'</span>
<span class="comments">;         The name of the color of the rubber-band selection box.</span>
<span class="comments">;    clip: in, optional, type=float, default=2</span>
<span class="comments">;         A number between 0 and 50 that indicates the percentage of pixels to clip</span>
<span class="comments">;         off either end of the image histogram before performing a linear stretch.</span>
<span class="comments">;         Available only with 2D images.</span>
<span class="comments">;    exclude: in, optional, type=numeric</span>
<span class="comments">;         The value to exclude in a standard deviation stretch.</span>
<span class="comments">;    exponent: in, optional, type=float, default=4.0</span>
<span class="comments">;         The logarithm exponent in a logarithmic stretch. Available only with 2D images.</span>
<span class="comments">;    filename: in, optional, type=string</span>
<span class="comments">;         The name of a file that IDL can read with READ_IMAGE (e.g, GEOTIFF, TIF, JPEG, PNG, etc.).</span>
<span class="comments">;    gamma: in, optional, type=float, default=1.5</span>
<span class="comments">;         The gamma factor in a gamma stretch. Available only with 2D images.</span>
<span class="comments">;    group_leader: in, optional, type=long</span>
<span class="comments">;         The widget identifier of the group leader for this program. When the group leader</span>
<span class="comments">;         dies, this program will be destroyed, too.</span>
<span class="comments">;    interpolate: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to interpolate with bilinear interpolation the display image as it </span>
<span class="comments">;         is sized to its final position in the display window. Interpolation will potentially </span>
<span class="comments">;         create image values that do not exist in the original image. The default is to do no</span>
<span class="comments">;         interpolation, so that image values to not change upon resizing. Interpolation can</span>
<span class="comments">;         result in smoother looking final images.</span>
<span class="comments">;    map: in, optional, type=structure</span>
<span class="comments">;         A cgMap object for navigating the input image.</span>
<span class="comments">;    maxvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and MAXVALUE. MAXVALUE is set to MAX(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets `SCALE` to 1. If the maximum value of the </span>
<span class="comments">;         image is greater than 255, this keyword is defined and SCALE=1.</span>
<span class="comments">;    mean: in, optional, type=float, default=0.5</span>
<span class="comments">;         The mean factor in a logarithmic stretch. Available only with 2D images.</span>
<span class="comments">;    minvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and `MAXVALUE`. MINVALUE is set to MIN(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets SCALE=1. If the minimum value of the </span>
<span class="comments">;         image is less than 0, this keyword is defined and SCALE=1.</span>
<span class="comments">;    missing_color: in, optional, type=string, default='white'</span>
<span class="comments">;         The color name of the missing value. Available only with 2D images.</span>
<span class="comments">;    missing_index: in, optional, type=integer, default=255 </span>
<span class="comments">;         The index of the missing color in the final byte scaled image. Available only with 2D images.</span>
<span class="comments">;    missing_value: in, optional, type=integer</span>
<span class="comments">;         The number that represents the missing value in the image. Available only with 2D images.</span>
<span class="comments">;    multiplier: in, optional, type=float</span>
<span class="comments">;         The multiplication factor in a standard deviation stretch. The standard deviation</span>
<span class="comments">;         is multiplied by this factor to produce the thresholds for a linear stretch.</span>
<span class="comments">;    ncolors: in, optional, type=integer, default=256</span>
<span class="comments">;         If this keyword is supplied, the `TOP` keyword is ignored and the TOP keyword </span>
<span class="comments">;         is set equal to  NCOLORS-1. This keyword is provided to make cgImage easier </span>
<span class="comments">;         to use with the color-loading programs such as cgLOADCT::</span>
<span class="comments">;</span>
<span class="comments">;              cgLoadCT, 5, NColors=100, Bottom=100</span>
<span class="comments">;              cgImage, image, NColors=100, Bottom=100</span>
<span class="comments">;                  </span>
<span class="comments">;         Setting this keyword to a value automatically sets SCALE=1. Available only with 2D images.</span>
<span class="comments">;    negative: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want to display the image with a negative or reverse stretch.</span>
<span class="comments">;         Available only with 2D images.</span>
<span class="comments">;    palette: in, optional, type=byte</span>
<span class="comments">;         Set this keyword to a 3x256 or 256x3 byte array containing the RGB color </span>
<span class="comments">;         vectors to be loaded before the image is displayed. Such vectors can be </span>
<span class="comments">;         obtained, for example, from cgLoadCT with the RGB_TABLE keyword::</span>
<span class="comments">;               </span>
<span class="comments">;                cgLoadCT, 4, /BREWER, /REVERSE, RGB_TABLE=palette</span>
<span class="comments">;                cgImage, cgDemoData(7), PALETTE=palette</span>
<span class="comments">;    scale: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to byte scale the image before display. If this keyword is not set, </span>
<span class="comments">;         the image is not scaled before display. This keyword will be set automatically by using</span>
<span class="comments">;         any of the keywords normally associated with byte scaling an image. Available only with </span>
<span class="comments">;         2D images. If set, STRETCH is set to 1, unless it is set to another value.</span>
<span class="comments">;    stretch: in, optional, type=integer/string, default=1</span>
<span class="comments">;         The type of scaling performed prior to display. May be specified as a number </span>
<span class="comments">;         or as a string (e.g, 3 or "Log"). Available only with 2D images.</span>
<span class="comments">;</span>
<span class="comments">;           Number   Type of Stretch</span>
<span class="comments">;             0         None           No scaling whatsoever is done.</span>
<span class="comments">;             1         Linear         scaled = BytScl(image, MIN=minValue, MAX=maxValue)</span>
<span class="comments">;             2         Clip           A histogram stretch, with a percentage of pixels clipped at both the top and bottom</span>
<span class="comments">;             3         Gamma          scaled = GmaScl(image, MIN=minValue, MAX=maxValue, Gamma=gamma)</span>
<span class="comments">;             4         Log            scaled = LogScl(image, MIN=minValue, MAX=maxValue, Mean=mean, Exponent=exponent)</span>
<span class="comments">;             5         Asinh          scaled = AsinhScl(image, MIN=minValue, MAX=maxValue, Beta=beta)</span>
<span class="comments">;             6         SquareRoot     A linear stretch of the square root histogram of the image values.</span>
<span class="comments">;             7         Equalization   A linear stretch of the histogram equalized image histogram.</span>
<span class="comments">;             8         Gaussian       A Gaussian normal function is applied to the image histogram.</span>
<span class="comments">;             9         MODIS          Scaling done in the differential manner of the MODIS Rapid Response Team</span>
<span class="comments">;                                      and implemented in the Coyote Library routine ScaleModis.</span>
<span class="comments">;    sigma: in, optional, type=float, default=1.0</span>
<span class="comments">;         The sigma scale factor in a Gaussian stretch. Available only with 2D images.</span>
<span class="comments">;    title: in, optional, type=string, default=""</span>
<span class="comments">;         Set this keyword to the title of the plot window.</span>
<span class="comments">;    top: in, optional, type=integer, default=255</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP. Available only with 2D images.</span>
<span class="comments">;    zoomfactor: in, optional, type=string, default=3</span>
<span class="comments">;         Use this keyword to set the starting zoom factor. The values you can use are as follows::</span>
<span class="comments">;              0: 'Actual'</span>
<span class="comments">;              1: '2x'</span>
<span class="comments">;              2: '3x'</span>
<span class="comments">;              3: '4x'</span>
<span class="comments">;              4: '5x'</span>
<span class="comments">;              5: '6x'</span>
<span class="comments">;              6: '7x'</span>
<span class="comments">;              7: '8x'</span>
<span class="comments">;              8: '12x'</span>
<span class="comments">;              9: '16x'</span>
<span class="comments">;</span>
<span class="comments">;-</span>
PRO cgZImage, image, $
   BETA=beta, $
   BOTTOM=bottom, $
   BOXCOLOR=sboxcolor, $
   CLIP=clip, $
   EXCLUDE=exclude, $
   EXPONENT=exponent, $
   FILENAME=filename, $
   GAMMA=gamma, $
   GROUP_LEADER=group_leader, $
   INTERPOLATE=interpolate, $
   MAP=map, $
   MAXVALUE=max, $
   MEAN=mean, $
   MISSING_COLOR=missing_color, $
   MISSING_INDEX=missing_index, $
   MISSING_VALUE=missing_value, $
   NEGATIVE=negative, $
   MINVALUE=min, $
   MULTIPLIER=multiplier, $
   NCOLORS=ncolors, $
   PALETTE=palette, $
   SCALE=scale, $
   SIGMA=sigma, $
   STRETCH=stretch, $
   TITLE=title, $
   TOP=top, $
   ZOOMFACTOR=zoomfactor
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Was a filename used to pass in an image filename? Check to see if this is a GeoTiff image</span>
    <span class="comments">; before doing anything else. If it is, use cgGeoMap to read it. Otherwise, read the image</span>
    <span class="comments">; file with READ_IMAGE.</span>
    IF N_Elements(filename) NE 0 THEN BEGIN
        check = Query_Tiff(filename, GEOTIFF=geo)
        IF (check EQ 1) && (Size(geo, /TNAME) EQ 'STRUCT') THEN BEGIN
           map = cgGeoMap(filename, IMAGE=image, Palette=palette)
           createdMap = 1
        ENDIF ELSE BEGIN
           image = Read_Image(filename, r, g, b)
           IF N_Elements(r) NE 0 THEN palette = [[r],[g],[b]]
        ENDELSE
    ENDIF 
    IF N_Elements(createdMap) EQ 0 THEN createdMap = 0
    
    <span class="comments">; Was an image passed into the procedure?</span>
    <span class="comments">; If not, find one in the IDL examples/data directory.</span>
    IF N_Elements(image) EQ 0 THEN BEGIN
       image = ImageSelect(FILENAME='marsglobe.jpg', CANCEL=cancelled, /EXAMPLES)
       IF cancelled THEN RETURN
    ENDIF
    
    <span class="comments">; Make sure this is a 2D or true-color image.</span>
    ndims = Size(image, /N_DIMENSIONS)
    IF (ndims LT 2) || (ndims GT 3) THEN Message, 'Only 2D or True-Color images are allowed in cgZImage.'
    
    <span class="comments">; Get image size.</span>
    dims = Image_Dimensions(image, XSize=ixsize, YSize=iysize, $
        XIndex=xindex, YIndex=yindex, TrueIndex=trueindex)
    IF trueIndex NE -1 THEN nframes = dims[trueIndex] ELSE nframes = 1 
    IF nframes GT 3 THEN BEGIN
        Help, image
        Message, 'Image does not have the correct dimensions for cgZImage.'
    ENDIF
    
    <span class="comments">; Check for keywords. </span>
    IF N_Elements(sboxcolor) EQ 0 THEN boxcolor = 'gold' ELSE boxcolor = sboxcolor
    IF N_Elements(stretch) EQ 0 THEN BEGIN
       maxValue = Max(image, MIN=minValue)
       IF (minValue LT 0) || (maxValue GT 255) THEN stretch=1
    ENDIF
    IF N_Elements(zoomfactor) EQ 0 THEN zoomfactor = 3 ELSE zoomfactor = 0 > zoomfactor &lt<span class="comments">; 9</span>
    
    <span class="comments">; Calculate a window size. Maximum window size is 600.</span>
     aspect = Float(ixsize)/iysize
     MAXSIZE = 600
     IF ixsize GT MAXSIZE OR iysize GT MAXSIZE THEN BEGIN
         IF ixsize NE iysize THEN BEGIN
            aspect = Float(iysize) / ixsize
            IF aspect LT 1 THEN BEGIN
               xsize = MAXSIZE
               ysize = (MAXSIZE * aspect) &lt<span class="comments">; MAXSIZE</span>
            ENDIF ELSE BEGIN
               ysize = MAXSIZE
               xsize = (MAXSIZE / aspect) &lt<span class="comments">; MAXSIZE</span>
            ENDELSE
         ENDIF ELSE BEGIN
            ysize = MAXSIZE
            xsize = MAXSIZE
         ENDELSE
     ENDIF ELSE BEGIN
        xsize = ixsize
        ysize = iysize
     ENDELSE

     <span class="comments">; Check cgImage keywords.</span>
     IF N_Elements(beta) EQ 0 THEN  betaptr = Ptr_New(/Allocate_Heap) ELSE betaptr = Ptr_New(beta)
     IF N_Elements(bottom) EQ 0 THEN  bottomptr = Ptr_New(/Allocate_Heap) ELSE bottomptr = Ptr_New(bottom)
     IF N_Elements(clip) EQ 0 THEN  clipptr = Ptr_New(/Allocate_Heap) ELSE clipptr = Ptr_New(clip)
     IF N_Elements(exclude) EQ 0 THEN  excludeptr = Ptr_New(/Allocate_Heap) ELSE excludeptr = Ptr_New(exclude)
     IF N_Elements(exponent) EQ 0 THEN  exponentptr = Ptr_New(/Allocate_Heap) ELSE exponentptr = Ptr_New(exponent)
     IF N_Elements(gamma) EQ 0 THEN  gammaptr = Ptr_New(/Allocate_Heap) ELSE gammaptr = Ptr_New(gamma)
     IF N_Elements(interpolate) EQ 0 THEN  interpolateptr = Ptr_New(/Allocate_Heap) ELSE interpolateptr = Ptr_New(interpolate)
     IF N_Elements(map) EQ 0 THEN mapptr = Ptr_New(/Allocate_Heap) ELSE mapptr = Ptr_New(map)
     IF N_Elements(max) EQ 0 THEN  maxptr = Ptr_New(/Allocate_Heap) ELSE maxptr = Ptr_New(max)
     IF N_Elements(mean) EQ 0 THEN  meanptr = Ptr_New(/Allocate_Heap) ELSE meanptr = Ptr_New(mean)
     IF N_Elements(missing_color) EQ 0 THEN  missing_colorptr = Ptr_New(/Allocate_Heap) ELSE missing_colorptr = Ptr_New(missing_color)
     IF N_Elements(missing_index) EQ 0 THEN  missing_indexptr = Ptr_New(/Allocate_Heap) ELSE missing_indexptr = Ptr_New(missing_index)
     IF N_Elements(missing_value) EQ 0 THEN  missing_valueptr = Ptr_New(/Allocate_Heap) ELSE missing_valueptr = Ptr_New(missing_value)
     IF N_Elements(negative) EQ 0 THEN  negativeptr = Ptr_New(/Allocate_Heap) ELSE negativeptr = Ptr_New(negative)
     IF N_Elements(min) EQ 0 THEN  minptr = Ptr_New(/Allocate_Heap) ELSE minptr = Ptr_New(min)
     IF N_Elements(multiplier) EQ 0 THEN  multiplierptr = Ptr_New(/Allocate_Heap) ELSE multiplierptr = Ptr_New(multiplier)
     IF N_Elements(ncolors) EQ 0 THEN  ncolorsptr = Ptr_New(/Allocate_Heap) ELSE ncolorsptr = Ptr_New(ncolors)
     IF N_Elements(palette) EQ 0 THEN  paletteptr = Ptr_New(/Allocate_Heap) ELSE paletteptr = Ptr_New(palette)
     IF N_Elements(scale) EQ 0 THEN  scaleptr = Ptr_New(/Allocate_Heap) ELSE scaleptr = Ptr_New(scale)
     IF N_Elements(sigma) EQ 0 THEN  sigmaptr = Ptr_New(/Allocate_Heap) ELSE sigmaptr = Ptr_New(sigma)
     IF N_Elements(stretch) EQ 0 THEN  stretchptr = Ptr_New(/Allocate_Heap) ELSE stretchptr = Ptr_New(stretch)
     IF N_Elements(top) EQ 0 THEN  topptr = Ptr_New(/Allocate_Heap) ELSE topptr = Ptr_New(top)
    
    <span class="comments">; Create a top-level base for this program. No resizing of this base.</span>
    tlb = Widget_Base(TLB_Frame_Attr=1, TITLE=title)

    <span class="comments">; Create two bases. One for controls and the other for the</span>
    <span class="comments">; draw widget. Leave the control base unmapped for now.</span>
    controlID = Widget_Base(tlb, Map=0, Column=1)
    factorString = ['Actual', '2x', '3x', '4x', '5x', '6x', '7x', '8x', '12x', '16x']
    factors = [Indgen(8) + 1, 12, 16]
    zoomfactorID = Widget_DropList(controlID, Value=factorString, $
       Event_Pro='cgZImage_Factor', UValue=factors, Title='Zoom Factor')
    IF trueindex EQ -1 THEN BEGIN
        colors = Widget_Button(controlID, Value='Load Image Colors', Event_Pro='cgZImage_LoadColors')
    ENDIF
    void = Widget_Button(controlID, Value='Change Selection Box Color', Event_Pro='cgZImage_BoxColor')
    quitter = Widget_Button(controlID, Value='Exit Program', $
       Event_Pro='cgZImage_Quit')
    
    drawbase = Widget_Base(tlb, Map=1, Column=1)
    drawID = Widget_Draw(drawbase, XSize=xsize, YSize=ysize, $
       Button_Events=1, Event_Pro='cgZImage_DrawEvents')

    statusbar = Widget_Label(drawbase, Value="Ready for Zooming", SCR_XSIZE=xsize, /Sunken_Frame)
    
    <span class="comments">; Realize the program.</span>
    Widget_Control, tlb, /Realize
    
    <span class="comments">; Set the initial default zoom factor.</span>
    Widget_Control, zoomfactorID, SET_DROPLIST_SELECT=zoomfactor
    
    <span class="comments">; Get the window index number of the draw widget.</span>
    <span class="comments">; Make the draw widget the current graphics window</span>
    <span class="comments">; and display the image in it.</span>
    Widget_Control, drawID, Get_Value=drawIndex
    WSet, drawIndex
    cgImage, image, $
       BETA=*betaptr, $
       BOTTOM=*bottomptr, $
       CLIP=*clipptr, $
       EXCLUDE=*excludeptr, $
       EXPONENT=*exponentptr, $
       GAMMA=*gammaptr, $
       INTERPOLATE=*interpolateptr, $
       MAXVALUE=*maxptr, $
       MEAN=*meanptr, $
       MISSING_COLOR=*missing_colorptr, $
       MISSING_INDEX=*missing_indexptr, $
       MISSING_VALUE=*missing_valueptr, $
       NEGATIVE=*negativeptr, $
       MINVALUE=*minptr, $
       MULTIPLIER=*multiplierptr, $
       NCOLORS=*ncolorsptr, $
       PALETTE=*paletteptr, $
       SCALE=*scaleptr, $
       SIGMA=*sigmaptr, $
       STRETCH=*stretchptr, $
       TOP=*topptr

    <span class="comments">; Set the title of the window.</span>
    IF N_Elements(title) EQ 0 THEN BEGIN
        Widget_Control, tlb, TLB_Set_Title='Full Size Image (' + StrTrim(drawIndex,2) + ') -- ' + $
           'Right Click for Controls.'
    ENDIF
    
    <span class="comments">; Set the current zoom factor</span>
    factor = factors[zoomfactor]

    <span class="comments">; Create a pixmap window the same size as the draw widget window.</span>
    <span class="comments">; Store its window index number in a local variable. Display the</span>
    <span class="comments">; image you just put in the draw widget in the pixmap window.</span>
    Window, /Free, XSize=xsize, YSize=ysize, /Pixmap
    pixIndex = !D.Window
    cgImage, image, $
       BETA=*betaptr, $
       BOTTOM=*bottomptr, $
       CLIP=*clipptr, $
       EXCLUDE=*excludeptr, $
       EXPONENT=*exponentptr, $
       GAMMA=*gammaptr, $
       INTERPOLATE=*interpolateptr, $
       MAXVALUE=*maxptr, $
       MEAN=*meanptr, $
       MISSING_COLOR=*missing_colorptr, $
       MISSING_INDEX=*missing_indexptr, $
       MISSING_VALUE=*missing_valueptr, $
       NEGATIVE=*negativeptr, $
       MINVALUE=*minptr, $
       MULTIPLIER=*multiplierptr, $
       NCOLORS=*ncolorsptr, $
       PALETTE=*paletteptr, $
       SCALE=*scaleptr, $
       SIGMA=*sigmaptr, $
       STRETCH=*stretchptr, $
       TOP=*topptr

   <span class="comments">; Get color vectors for this application.</span>
   IF N_Elements(r) EQ 0 THEN TVLCT, r, g, b, /Get
   
   <span class="comments">; Scale the data, because this is what you will show in the zoomed window.</span>
   scaled = cgImgScl(image, $
       BETA=*betaptr, $
       BOTTOM=*bottomptr, $
       CLIP=*clipptr, $
       EXCLUDE=*excludeptr, $
       EXPONENT=*exponentptr, $
       GAMMA=*gammaptr, $
       INTERPOLATE=*interpolateptr, $
       MAXVALUE=*maxptr, $
       MEAN=*meanptr, $
       MISSING_INDEX=*missing_indexptr, $
       MISSING_VALUE=*missing_valueptr, $
       NEGATIVE=*negativeptr, $
       MINVALUE=*minptr, $
       MULTIPLIER=*multiplierptr, $
       NCOLORS=*ncolorsptr, $
       SCALE=*scaleptr, $
       SIGMA=*sigmaptr, $
       STRETCH=*stretchptr, $
       TOP=*topptr)

   <span class="comments">; Create an info structure to hold information required by the program.</span>
   info = Ptr_New( { $
       image:image, $               <span class="comments">; The original image.</span>
       scaled:scaled, $             <span class="comments">; The scaled image.</span>
       zoomedimage:Ptr_New(), $     <span class="comments">; The scaled and resized subimage.</span>
       xsize:ixsize, $              <span class="comments">; The x size of the image.</span>
       ysize:iysize, $              <span class="comments">; The y size of the image.</span>
       drawIndex:drawIndex, $       <span class="comments">; The draw window index number.</span>
       pixIndex:pixIndex, $         <span class="comments">; The pixmap window index number.</span>
       boxcolor:boxcolor, $         <span class="comments">; The name of the drawing color.</span>
       xs:0, $                      <span class="comments">; X static corner of the zoom box.</span>
       ys:0, $                      <span class="comments">; Y static corner of the zoom box.</span>
       xd:0, $                      <span class="comments">; X dynamic corner of the zoom box.</span>
       yd:0, $                      <span class="comments">; Y dynamic corner of the zoom box.</span>
       zoomDrawID:-1L, $            <span class="comments">; Zoomed image draw widget ID.</span>
       zoomWindowID:-1, $           <span class="comments">; Zoomed image window index number.</span>
       zoomTLB: -1, $               <span class="comments">; The zoom window TLB.</span>
       statusbar:statusbar, $       <span class="comments">; The statusbar identifier.</span>
       r:r, $                       <span class="comments">; The red color vector.</span>
       g:g, $                       <span class="comments">; The green color vector.</span>
       b:b, $                       <span class="comments">; The blue color vector.</span>
       beta:betaptr, $
       bottom:bottomptr, $
       clip:clipptr, $
       createdMap: createdmap, $
       exclude:excludeptr, $
       exponent:exponentptr, $
       gamma:gammaptr, $
       interpolate:interpolateptr, $
       map:mapptr, $
       max:maxptr, $
       mean:meanptr, $
       missing_color:missing_colorptr, $
       missing_index:missing_indexptr, $
       missing_value:missing_valueptr, $
       negative:negativeptr, $
       min:minptr, $
       multiplier:multiplierptr, $
       ncolors:ncolorsptr, $
       palette:paletteptr, $
       scale:scaleptr, $
       sigma:sigmaptr, $
       stretch:stretchptr, $
       top:topptr, $
       xrange: [0,ixsize], $
       yrange: [0,iysize], $
       zxsize: 0, $
       zysize: 0, $
       zoomfactor:factor, $         <span class="comments">; The initial zoom factor.</span>
       mapcontrols:0, $             <span class="comments">; A flag to tell if the controls are mapped.</span>
       xindex:xindex, $             <span class="comments">; The X size index.</span>
       yindex:yindex, $             <span class="comments">; The Y size index.</span>
       trueIndex:trueIndex, $       <span class="comments">; The "true-color" index. 0 if image is 2D.</span>
       MAXSIZE:800, $               <span class="comments">; The maximum window size.</span>
       hasScrollBars: 0, $          <span class="comments">; A flag indicating the zoom window has scroll bars.</span>
       controlID:controlID}, /No_Copy)        <span class="comments">; The identifier of the control base to map.</span>

    <span class="comments">; Store the info structure in the user value of the top-level base.</span>
    Widget_Control, tlb, Set_UValue=info

    <span class="comments">; Register this program and set up the event loop.</span>
    XManager, 'cgzimage', tlb, Cleanup='cgZImage_Cleanup', Group_Leader=group_leader, /No_Block
    
END <span class="comments">; ----------------------------------------------------------------------</span>


</code>
    </div>
  </body>
</html>