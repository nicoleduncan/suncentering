<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgboxplot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgboxplot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgBoxPlot</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This is graphics routine to display a box plot, also known as a box and</span>
<span class="comments">;   whisker plot, in IDL direct graphics. The box encloses the interquartile</span>
<span class="comments">;   range (IQR), defined at IQR75-IQR25. The whiskers extend out to the maximum</span>
<span class="comments">;   or minimum value of the data, or to the 1.5 times either the IQR75 or IQR25,</span>
<span class="comments">;   if there is data beyond this range. Outliers are identified with small circles.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This is graphics routine to display a box plot, also known as a box and</span>
<span class="comments">; whisker plot, in IDL direct graphics. The box encloses the interquartile</span>
<span class="comments">; range (IQR), defined at IQR75-IQR25. The whiskers extend out to the maximum</span>
<span class="comments">; or minimum value of the data, or to the 1.5 times either the IQR75 or IQR25,</span>
<span class="comments">; if there is data beyond this range. Outliers are identified with small circles.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">; </span>
<span class="comments">; If you wish to draw multiple boxplots in a display window, it will make more sense to</span>
<span class="comments">; use cgLayout to set up your plot positions than to use !P.Multi. This is because the</span>
<span class="comments">; labels on the plot are set up independently of the plot with the XCharsize keyword and</span>
<span class="comments">; this size is not affected by !P.Multi, which normally controls not only the position of</span>
<span class="comments">; plots, but the character size of plot labels, too.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Here is an example, using data from the Michaelson-Morley speed of light experiment,</span>
<span class="comments">;    in which they made five experiments of 20 measurements of the speed of light each.</span>
<span class="comments">;    The data can be downloaded from here::</span>
<span class="comments">;       </span>
<span class="comments">;       http://www.idlcoyote.com/misc/mm_data.dat</span>
<span class="comments">;          </span>
<span class="comments">;    Here are the IDL commands to read the data and produce a box plot of it::</span>
<span class="comments">;       </span>
<span class="comments">;        OpenR, 1, Find_Resource_File('mm_data.dat')</span>
<span class="comments">;        header = Strarr(2)</span>
<span class="comments">;        Readf, 1, header</span>
<span class="comments">;        data = Intarr(5, 20)</span>
<span class="comments">;        Readf, 1, data</span>
<span class="comments">;        Close, 1</span>
<span class="comments">;        cgBoxPlot, data, XTITLE='Experiment Number', YTITLE='Speed of Light'</span>
<span class="comments">;        </span>
<span class="comments">;    Here is an example that produces a low, medium, and high box for each of</span>
<span class="comments">;    six experiments and plots them::</span>
<span class="comments">;    </span>
<span class="comments">;         data = fltarr(18, 40)</span>
<span class="comments">;         index = indgen(6)*3</span>
<span class="comments">;         for j=0,5 do data[index[j],*] = Randomu(seed, 40)*6</span>
<span class="comments">;         index = index+1</span>
<span class="comments">;         for j=0,5 do data[index[j],*] = Randomu(seed, 40)*10</span>
<span class="comments">;         index = index+1</span>
<span class="comments">;         for j=0,5 do data[index[j],*] = Randomu(seed, 40)*15</span>
<span class="comments">;         cgPlot, [0,1], /nodata, yrange=[0,16], xrange=[0,19], $</span>
<span class="comments">;            xtickformat='(A1)', ytitle='Gc(mms-1)', YStyle=1</span>
<span class="comments">;         index = indgen(6)*3</span>
<span class="comments">;         width = ((!X.CRange[1] - !X.Crange[0]) / (20)) * 0.75</span>
<span class="comments">;         cgBoxPlot, data[index, *],/overplot, XLOCATION=index+1, WIDTH=width, $</span>
<span class="comments">;            BOXCOLOR='rose', /FILLBOX</span>
<span class="comments">;         cgBoxPlot, data[index+1, *],/overplot, XLOCATION=index+2, WIDTH=width, $</span>
<span class="comments">;            BOXCOLOR='pale green', /FILLBOX</span>
<span class="comments">;         cgBoxPlot, data[index+2, *],/overplot, XLOCATION=index+3, WIDTH=width, $</span>
<span class="comments">;            BOXCOLOR='goldenrod', /FILLBOX</span>
<span class="comments">;         labels = ['AAA', 'BBB', 'CCC', 'DDD', 'EEE', 'FFF']</span>
<span class="comments">;         for j=0,5 do cgText, (index+2)[j], -1, labels[j], Alignment=0.5</span>
<span class="comments">;           </span>
<span class="comments">; .. image:: cgboxplot.png </span>
<span class="comments">;</span>
<span class="comments">;    An article about his program can be found here::</span>
<span class="comments">;       </span>
<span class="comments">;         http://www.idlcoyote.com/graphics_tips/box_whisker.html</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by David W. Fanning, 4 March 2009.</span>
<span class="comments">;        Added STATS keyword to return data statistics. 5 March 2009. DWF.</span>
<span class="comments">;        Added MISSING_DATA_VALUE keyword to identify missing values. 14 March 2009. DWF.</span>
<span class="comments">;        Removed limitation of LABELS array having no more than 28 elements. 14 March 2009. DWF.</span>
<span class="comments">;        Made it possible to pass a pointer array containing the data, if desired. 14 March 2009. DWF.</span>
<span class="comments">;        Added ROTATE keyword to rotate labels. 16 March 2009. DWF.</span>
<span class="comments">;        Added several modifications to guard against ill-formed data in the cgBoxPlot_Draw</span>
<span class="comments">;          procedure. 23 March 2009. DWF.</span>
<span class="comments">;        Added keywords FILLBOXES and BOXCOLOR. 24 March 2009. DWF.</span>
<span class="comments">;        Redefined the STATS structure to include MEAN and to store values as doubles. 25 March 2009. DWF.</span>
<span class="comments">;        Fixed in a bug that resulted in incorrect behavior when the MISSING_DATA_VALUE keyword</span>
<span class="comments">;          was used. 8 April 2009. DWF.</span>
<span class="comments">;        Fixed a typo that didn't allow a single column vector to be displayed as a box plot. 17 May 2009. DWF.</span>
<span class="comments">;        Now allow a single row vector to be passed into program and displayed. 20 May 2009. DWF.</span>
<span class="comments">;        Added NOCLIP=0 keyword to PLOTS command when drawing outliers. 15 July 2009. DWF.</span>
<span class="comments">;        Minor adjustment of the X axis label position. 28 October 2010. DWF.</span>
<span class="comments">;        Add the ability to change the label character size and thickness via the normal</span>
<span class="comments">;          XCHARSIZE and XTHICK keywords you would use for a plot. 3 Dec 2010. DWF.</span>
<span class="comments">;        Fixed a couple of typos, added ADDCMD, CHARSIZE, LAYOUT and WINDOW keywords. 2 Feb 2011. DWF.</span>
<span class="comments">;        Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;        PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2011. DWF.</span>
<span class="comments">;        Added XLOCATION and WIDTH keywords. 5 June 2012. DWF.</span>
<span class="comments">;        The XCharSize keyword was not being used correctly. 2 July 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2009, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This function prepares the data for display by removing any</span>
<span class="comments">; missing data values from further consideration.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     data: in, required</span>
<span class="comments">;        The data to be prepared.</span>
<span class="comments">;     missing_data_value: in, required</span>
<span class="comments">;        The missing data value that should be found and removed from the data.</span>
<span class="comments">;-</span>
FUNCTION cgBoxPlot_Prepare_Data, data, missing_data_value
   
      <span class="comments">; If there is no missing_data_value, then just return the data.</span>
      IF N_Elements(missing_data_value) NE 0 THEN BEGIN
      
         <span class="comments">; If the missing_data_value is a number (as opposed to NAN), then we will find</span>
         <span class="comments">; the missing values and change them to !VALUES.F_NAN for futher processing.</span>
         <span class="comments">; If the missing_data_value is a NAN, then we just return the data, since it</span>
         <span class="comments">; is already set up the way it needs to be. We *may* have to convert the data</span>
         <span class="comments">; to floating type to do this.</span>
         IF Finite(missing_data_value) EQ 1 THEN BEGIN
             dataTypeName = Size(missing_data_value, /TNAME)
             CASE dataTypeName OF
             
                'FLOAT': BEGIN
                    epsilon = (MACHAR()).eps
                    indices = Where( Abs(data - missing_data_value) LE epsilon, count)
                    END
                    
                'DOUBLE': BEGIN
                    epsilon = (MACHAR(DOUBLE=1)).eps
                    indices = Where( Abs(data - missing_data_value) LE epsilon, count)
                    END
             
                ELSE: BEGIN
                    indices = Where(data EQ missing_data_value, count)
                    END
             
             ENDCASE
             thisData = data
              
             <span class="comments">; If you found indices, then convert to !VALUES.F_NAN</span>
             IF count GT 0 THEN BEGIN
                    CASE Size(data, /TNAME) OF
                        'FLOAT': thisData[indices] = !VALUES.F_NAN
                        'DOUBLE': thisData[indices] = !VALUES.D_NAN
                        ELSE: BEGIN
                            thisData = Float(data)
                            thisData[indices] = !VALUES.F_NAN
                            END
                    ENDCASE
             ENDIF
             
             RETURN, thisData
         ENDIF ELSE RETURN, data
     ENDIF ELSE RETURN, data
      
   END <span class="comments">; ---------------------------------------------------------------------------------</span>
   
<span class="comments">;+</span>
<span class="comments">; Draws the box plot in the display window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    thisdata: in, required</span>
<span class="comments">;       The data to be draw as a box plot.</span>
<span class="comments">;       </span>
<span class="comments">;  :Keywords:</span>
<span class="comments">;    boxcolor: in, optional, type=string, default='rose'</span>
<span class="comments">;       If FILLBOXES is set, the IQR box is filled with this color. </span>
<span class="comments">;    color: in, optional, type=string, default='opposite'              </span>
<span class="comments">;       A string color name, as appropriate for the cgColor program. The boxplot </span>
<span class="comments">;       will be drawn in this color.</span>
<span class="comments">;    fillboxes: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to fill the IQR box with a color, specified by BOXCOLOR.</span>
<span class="comments">;    outliercolor, in, optional, type=string</span>
<span class="comments">;       The name of the color the outliers are drawn in. By default, the `BoxColor`.</span>
<span class="comments">;    outlinecolor: in, optional, type=string</span>
<span class="comments">;       The color the box outlines are drawn in. By default, the `BoxColor` if `FillBoxes' is</span>
<span class="comments">;       set and `Color` if not.</span>
<span class="comments">;    stats: in, optional</span>
<span class="comments">;       Set this to a named variable that will return an array of structures</span>
<span class="comments">;       for each of the columns of data. The statistics are calculated in this</span>
<span class="comments">;       routine.</span>
<span class="comments">;    width: in, optional</span>
<span class="comments">;        The width of the box.</span>
<span class="comments">;    xlocation: in, optional</span>
<span class="comments">;        The x starting location of the box.</span>
<span class="comments">;     </span>
<span class="comments">;-</span>
   PRO cgBoxPlot_Draw, thisdata, $
        BOXCOLOR=boxcolor, $
        COLOR=color, $
        FILLBOXES=fillboxes, $
        OUTLIERCOLOR=outliercolor, $
        OUTLINECOLOR=outlinecolor, $
        STATS=stats, $
        WIDTH=width, $
        XLOCATION=xlocation

      On_Error, 1

      <span class="comments">; Check the parameters.</span>
      IF N_Elements(thisdata) EQ 0 THEN Message, 'Data vector is undefined.'
      IF N_Elements(boxcolor) EQ 0 THEN boxcolor = 'rose'
      IF N_Elements(color) EQ 0 THEN color = 'opposite'
      IF N_Elements(outliercolor) EQ 0 THEN outliercolor = color
      IF N_Elements(outlinecolor) EQ 0 THEN BEGIN
         IF Keyword_Set(fillboxes) THEN outlinecolor = boxcolor ELSE outlinecolor = color
      ENDIF
      fillboxes = Keyword_Set(fillboxes)
      IF N_Elements(xlocation) EQ 0 THEN xlocation = (!X.CRange[1] - !X.Crange[0]) / 2 + Min(!X.CRange)
      IF N_Elements(width) EQ 0 THEN width = (!X.CRange[1] - !X.Crange[0]) * 0.05
      data = thisData
      
      <span class="comments">; Only work with numbers, no NANs.</span>
      indices = Where(Finite(data) EQ 1, count)
      IF count NE N_Elements(data) THEN data = data[indices]
            
      <span class="comments">; Find min, max, mean, and median values.</span>
      minData = MIN(data, MAX=maxData, /NAN)
      stats.min = minData
      stats.max = maxData
      stats.mean = Mean(data, /NAN, /DOUBLE)
      stats.median = Median(data, /EVEN, /DOUBLE)
      
      <span class="comments">; How many points are going to be used to draw the box plot?</span>
      <span class="comments">; Make sure you have some.</span>
      stats.n = N_Elements(data)
      IF stats.n EQ 0 THEN RETURN
      
      <span class="comments">; If the min is equal to the max, then draw a line and out of here.</span>
      IF (stats.min EQ stats.max) THEN BEGIN
        stats.q25 = stats.median
        stats.q75 = stats.median
        stats.iqr = 0
        stats.sdev = 0
        halfwidth = width / 2.0
        x1 = xlocation - halfwidth
        x2 = xlocation + halfwidth
        PLOTS, [x1, x2], [stats.median, stats.median], COLOR=cgColor(color)
        RETURN
      ENDIF
      
      <span class="comments">; Sort the data.</span>
      sortedData = data[Sort(data)]
      IF N_Elements(sortedData) MOD 2 EQ 0 THEN BEGIN
         index = N_Elements(sortedData)/2
         medianData = (sortedData[index-1] + sortedData[index]) / 2.0
         lowerGroup = sortedData[0:index-1]
         higherGroup = sortedData[index:N_Elements(data)-1]
      ENDIF ELSE BEGIN <span class="comments">; The middle point belongs to both upper and lower quartiles.</span>
         index = N_Elements(sortedData)/2
         medianData = sortedData[index]
         lowerGroup = sortedData[0:index]
         higherGroup = sortedData[index:N_Elements(data)-1]
      ENDELSE
      stats.median = medianData

      <span class="comments">; Find the quartiles.</span>
      quartile_25 = Median(lowerGroup, /EVEN)
      quartile_75 = Median(higherGroup, /EVEN) 
      stats.q25 = quartile_25
      stats.q75 = quartile_75
          
      <span class="comments">; Calculate IQR</span>
      iqr = quartile_75 - quartile_25
      stats.iqr = iqr
      stats.sdev = StDDev(data, /NAN, /DOUBLE)

      <span class="comments">; Color decomposition on, if allowed.</span>
      IF (!D.Flags AND 256) NE 0 THEN BEGIN
         Device, Get_Visual_Depth=theDepth
         IF theDepth GE 24 THEN Device, Decomposed=1, Get_Decomposed=theState
      ENDIF
       
      <span class="comments">; Draw the box.</span>
      halfwidth = width / 2.0
      x1 = xlocation - halfwidth
      x2 = xlocation + halfwidth
      y1 = quartile_25
      y2 = quartile_75
      IF fillboxes THEN POLYFILL, [x1,x1,x2,x2,x1], [y1,y2,y2,y1,y1], COLOR=cgColor(boxcolor)
      PLOTS, [x1,x1,x2,x2,x1], [y1,y2,y2,y1,y1], COLOR=cgColor(outlinecolor)
      PLOTS, [x1, x2], [medianData, medianData], COLOR=cgColor(outlinecolor)
      
      <span class="comments">; Are there any data greater than 1.5*iqr</span>
      imax = Where(data GT quartile_75 + (1.5 * iqr), maxcount)
      IF maxcount EQ 0 THEN BEGIN
        top = maxData 
      ENDIF ELSE BEGIN
        index = Value_Locate(sortedData, quartile_75 + (1.5 * iqr))
        top = sortedData[0 > (index) &lt<span class="comments">; (N_Elements(data)-1)]</span>
      ENDELSE
      
      <span class="comments">; Are there any data less than 1.5*iqr</span>
      imin = Where(data LT quartile_25 - (1.5 * iqr), mincount)
      IF mincount EQ 0 THEN BEGIN
         bottom = minData 
      ENDIF ELSE BEGIN
         index = Value_Locate(sortedData, quartile_25 - (1.5 * iqr))
         bottom = sortedData[0 > (index+1) &lt<span class="comments">; (N_Elements(data)-1)]</span>
      ENDELSE
      
      <span class="comments">; Draw the whiskers.</span>
      PLOTS, [xlocation, xlocation], [quartile_75, top], COLOR=cgColor(outlinecolor)
      PLOTS, [xlocation, xlocation], [quartile_25, bottom], COLOR=cgColor(outlinecolor)
      PLOTS, [xlocation - (halfwidth*0.5), xlocation + (halfwidth*0.5)], $
             [top, top], COLOR=cgColor(outlinecolor)
      PLOTS, [xlocation - (halfwidth*0.5), xlocation + (halfwidth*0.5)], $
             [bottom, bottom], COLOR=cgColor(outlinecolor)
      
      <span class="comments">; Draw outliners if there are any.</span>
      IF maxcount GT 0 THEN BEGIN
         FOR j=0,maxcount-1 DO PLOTS, xlocation, data[imax[j]], $
            PSYM=cgSymCat(9), COLOR=cgColor(outliercolor), NOCLIP=0
      ENDIF
      IF mincount GT 0 THEN BEGIN
         FOR j=0,mincount-1 DO PLOTS, xlocation, data[imin[j]], $
            PSYM=cgSymCat(9), COLOR=cgColor(outliercolor), NOCLIP=0
      ENDIF
      
      IF N_Elements(theState) NE 0 THEN Device, Decomposed=theState
   END <span class="comments">;-----------------------------------------------------------------------------------------------------</span>
   
<span class="comments">;+</span>
<span class="comments">;   This is graphics routine to display a box plot, also known as a box and</span>
<span class="comments">;   whisker plot, in IDL direct graphics. The box encloses the interquartile</span>
<span class="comments">;   range (IQR), defined at IQR75-IQR25. The whiskers extend out to the maximum</span>
<span class="comments">;   or minimum value of the data, or to the 1.5 times either the IQR75 or IQR25,</span>
<span class="comments">;   if there is data beyond this range. Outliers are identified with small circles.</span>

<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required</span>
<span class="comments">;       A two-dimensional array. The data for each box plot will be in</span>
<span class="comments">;       the columns of the data array. There will be one box plot drawn </span>
<span class="comments">;       for each column in the data array. The maximum column size is 28.</span>
<span class="comments">;       As an alternative, data can be a pointer array, in which case</span>
<span class="comments">;       there will be one box plot drawn for each valid pointer in the array.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;    axiscolor: in, optional, type=string</span>
<span class="comments">;       A string color name, as appropriate for the cgCOLOR program.</span>
<span class="comments">;       By default, the same as the COLOR keyword. Used only if OVERPLOT </span>
<span class="comments">;       keyword is not set.</span>
<span class="comments">;    background_color: in, optional, type=string, default='white'     </span>
<span class="comments">;       A string color name, as appropriate for the cgColor program.</span>
<span class="comments">;       Used only if OVERPLOT keyword is not set.</span>
<span class="comments">;    boxcolor: in, optional, type='string', default='rose'</span>
<span class="comments">;       If FILLBOXES is set, the IQR box is filled with this color. </span>
<span class="comments">;    charsize: in, optional, type=float</span>
<span class="comments">;       Set this to the character size to use on the plot. If undefined, uses</span>
<span class="comments">;       the value of cgDefCharsize().</span>
<span class="comments">;    color: in, optional, type=string, default='opposite'              </span>
<span class="comments">;       A string color name, as appropriate for the cgColor program. The boxplot </span>
<span class="comments">;       will be drawn in this color.</span>
<span class="comments">;    fillboxes: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to fill the IQR box with a color, specified by BOXCOLOR.</span>
<span class="comments">;    labels: in, optional, type=string               </span>
<span class="comments">;       A string array of the same length as the number of columns of data.</span>
<span class="comments">;       The boxplots will be labeled with these labels along the X axis.</span>
<span class="comments">;       Used only if OVERPLOT keyword is not set.</span>
<span class="comments">;    layout: in, optional, type=intarr(3)</span>
<span class="comments">;       This keyword specifies a grid with a graphics window and determines where the</span>
<span class="comments">;       graphic should appear. The syntax of LAYOUT is three numbers: [ncolumns, nrows, location].</span>
<span class="comments">;       The grid is determined by the number of columns (ncolumns) by the number of </span>
<span class="comments">;       rows (nrows). The location of the graphic is determined by the third number. The</span>
<span class="comments">;       grid numbering starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;       by row.</span>
<span class="comments">;    missing_data_value: in, optional</span>
<span class="comments">;       Set this keyword to a value that will be used to identify missing data.</span>
<span class="comments">;       Missing data is not used in the calculations of the box plot.</span>
<span class="comments">;    outfilename: in, optional, type=string</span>
<span class="comments">;       If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;       filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;       value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;       presented to the user.</span>
<span class="comments">;    outliercolor, in, optional, type=string</span>
<span class="comments">;       The name of the color the outliers are drawn in. By default, the `BoxColor`.</span>
<span class="comments">;    outlinecolor: in, optional, type=string</span>
<span class="comments">;       The color the box outlines are drawn in. By default, the `BoxColor` if `FillBoxes' is</span>
<span class="comments">;       set and `Color` if not.</span>
<span class="comments">;    output: in, optional, type=string, default=""</span>
<span class="comments">;       Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;       Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;       file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;       user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;       All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;       PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;       to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;       details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;       plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;       output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;    overplot: in, optional, type=boolean, default=0              </span>
<span class="comments">;       If this keyword is set, the boxplots will be overdrawn on the current</span>
<span class="comments">;       set of axes. The X axis will be presumed to be scaled from 0 to 1 more</span>
<span class="comments">;       than the number of columns in data.</span>
<span class="comments">;    rotate: in, optional, type=float, default=0.0               </span>
<span class="comments">;       Set to a value between -90 and 90 degree. The labels will be rotated this</span>
<span class="comments">;       amount. Positive values rotate in CCW fashion, negative values in CW fashion.</span>
<span class="comments">;    stats: out, optional</span>
<span class="comments">;       Set this to a named variable that will return an array of structures</span>
<span class="comments">;       for each of the columns of data. The structure will be defined as</span>
<span class="comments">;       this:</span>
<span class="comments">;</span>
<span class="comments">;           struct = { Median:0.0D, Mean: 0.0D, Min:0.0D, Max:0.0D, $</span>
<span class="comments">;                      Q25:0.0D, Q75:0.0D, IQR:0.0D, SDEV:0.0D, N:0L }</span>
<span class="comments">;</span>
<span class="comments">;       Where "mean" is the median value of the data, "Q25" and "Q75" are the 25th percent</span>
<span class="comments">;       quartile and 75th percent quartile of the data, repectively, "IRG" is the</span>
<span class="comments">;       Interquartile Range, SDEV is the standard deviation, and N is the number of points</span>
<span class="comments">;       used to construct the box plot.</span>
<span class="comments">;    width: in, optional, type=float</span>
<span class="comments">;        The "width" of each box plot in data units. The default is calculated from</span>
<span class="comments">;        the X axis range and the number of boxes to draw on the plot like this:</span>
<span class="comments">;        ((!X.CRange[1] - !X.Crange[0]) / (numbox+2.0)) * 0.9.</span>
<span class="comments">;    window: in, optional, type=boolean, default=0               </span>
<span class="comments">;       Set this keyword to display the plot in a resizeable graphics window (cgWindow).</span>
<span class="comments">;    xcharsize: in, optional, type=float, default=1.0</span>
<span class="comments">;       The size of the X axis labels.</span>
<span class="comments">;    xlocation: in, optional, type=integer</span>
<span class="comments">;       The X location where the data should be plotted. Can be an array the save size as </span>
<span class="comments">;       the first dimension of data. Normally, this is an integer from 1 to the number of</span>
<span class="comments">;       boxplots that are on the final plot.</span>
<span class="comments">;    xthick: in, optional, type=integer, default=1</span>
<span class="comments">;       The thickness of the X axis labels.</span>
<span class="comments">;    _ref_extra: in, optional</span>
<span class="comments">;         Any keyword appropriate for the cgPlot command is also accepted by keyword</span>
<span class="comments">;         inheritance.</span>
<span class="comments">;-</span>
   PRO cgBoxPlot, data, $
        ADDCMD=addcmd, $
        AXISCOLOR=axiscolor, $
        BACKGROUND_COLOR=background_color, $
        BOXCOLOR=boxcolor, $
        CHARSIZE=charsize, $
        COLOR=color, $
        FILLBOXES=fillboxes, $
        LABELS=labels, $
        LAYOUT=layout, $
        MISSING_DATA_VALUE=missing_data_value, $
        OUTFILENAME=outfilename, $
        OUTLIERCOLOR=outliercolor, $
        OUTLINECOLOR=outlinecolor, $
        OUTPUT=output, $
        OVERPLOT=overplot, $
        ROTATE=rotate, $
        STATS=stats, $
        XCHARSIZE=xcharsize, $
        XLOCATION=xlocation, $
        XTHICK=xthick, $
        WIDTH=width, $
        WINDOW=window, $
        _REF_EXTRA=extra
        
      <span class="comments">; Error handling.</span>
      Catch, theError
      IF theError NE 0 THEN BEGIN
         Catch, /CANCEL
         void = Error_Message()
         IF N_Elements(theState) NE 0 THEN Device, Decomposed=theState
         IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
         RETURN
      ENDIF
      
      <span class="comments">; Check parameters.</span>
      IF N_Params() EQ 0 THEN BEGIN
          Print, 'USE SYNTAX: cgBoxPlot, data'
          RETURN
      ENDIF
      
    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
            
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgBoxPlot', data, $
                AXISCOLOR=axiscolor, $
                BACKGROUND_COLOR=background_color, $
                BOXCOLOR=boxcolor, $
                CHARSIZE=charsize, $
                COLOR=color, $
                FILLBOXES=fillboxes, $
                LABELS=labels, $
                MISSING_DATA_VALUE=missing_data_value, $
                OVERPLOT=overplot, $
                OUTLIERCOLOR=outliercolor, $
                OUTLINECOLOR=outlinecolor, $
                ROTATE=rotate, $
                STATS=stats, $
                XCHARSIZE=xcharsize, $
                XLOCATION=xlocation, $
                XTHICK=xthick, $
                WIDTH=width, $
                ADDCMD=1, $
                _EXTRA=extra
             RETURN
       ENDIF
        
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        cgWindow, 'cgBoxPlot', data, $
                AXISCOLOR=axiscolor, $
                BACKGROUND_COLOR=background_color, $
                BOXCOLOR=boxcolor, $
                CHARSIZE=charsize, $
                COLOR=color, $
                FILLBOXES=fillboxes, $
                LABELS=labels, $
                MISSING_DATA_VALUE=missing_data_value, $
                OVERPLOT=overplot, $
                OUTLIERCOLOR=outliercolor, $
                OUTLINECOLOR=outlinecolor, $
                ROTATE=rotate, $
                STATS=stats, $
                XCHARSIZE=xcharsize, $
                XLOCATION=xlocation, $
                XTHICK=xthick, $
                WIDTH=width, $
                REPLACECMD=replaceCmd, $
                _Extra=extra
         RETURN
    ENDIF
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    ENDIF
   
    <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

      <span class="comments">; Arguments and keywords.</span>
      IF N_Elements(color) EQ 0 THEN color = 'opposite'
      IF N_Elements(axiscolor) EQ 0 THEN axiscolor = color
      IF N_Elements(background_color) EQ 0 THEN background_color = 'white'
      IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharsize()
      IF N_Elements(xcharsize) EQ 0 THEN xcharsize = charsize * 0.75
      IF N_Elements(boxcolor) EQ 0 THEN boxcolor = 'rose'
      fillboxes = Keyword_Set(fillboxes)
      IF N_Elements(outliercolor) EQ 0 THEN outliercolor = color
      IF N_Elements(outlinecolor) EQ 0 THEN BEGIN
          IF fillboxes THEN outlinecolor = boxcolor ELSE outlinecolor = color
      ENDIF
      IF N_Elements(rotate) EQ 0 THEN rotate = 0
      rotate = -90 > Fix(rotate) &lt<span class="comments">; 90</span>
      overplot = Keyword_Set(overplot)
      isRowVector = 0
      
      passedDataType = Size(data, /TNAME)
      
      <span class="comments">; How many box plots are there?</span>
      IF passedDataType EQ 'POINTER' THEN BEGIN
          numbox = N_Elements(data)
          *data[0] = cgBoxPlot_Prepare_Data(*data[0], missing_data_value)
          minData = Min(*data[0], Max=maxData, /NAN)
          IF numbox GT 1 THEN BEGIN
              FOR j=1,numbox-1 DO BEGIN
                 *data[j] = cgBoxPlot_Prepare_Data(*data[j], missing_data_value)
                 minptr = Min(*data[j], Max=maxptr, /NAN)
                 minData = Min([mindata, minptr], /NAN)
                 maxData = Max([maxdata, maxptr], /NAN)
              ENDFOR    
          ENDIF
      ENDIF ELSE BEGIN
          ndims = Size(data, /N_DIMENSIONS)
          IF ndims EQ 1 THEN BEGIN
            numbox = 1 
            IF N_Elements(data) GT 1 THEN isRowVector = 1 ELSE Message, 'Input data must be a vector.'
          ENDIF ELSE BEGIN
              IF ndims GT 2 THEN Message, 'Cannot work with multi-dimensional data.'
              s = Size(data, /DIMENSIONS)
              numbox = s[0]
          ENDELSE
          thisData = cgBoxPlot_Prepare_Data(data, missing_data_value)
          minData = Min(thisData, Max=maxData, /NAN)
      ENDELSE  

      <span class="comments">; If you are not overplotting, then draw a plot for the box plots.</span>
      IF ~overplot THEN BEGIN
         rr = maxData - minData
         minData = minData - (0.05 * Abs(rr))
         maxData = maxData + (0.05 * Abs(rr))
         yrange = [minData, maxData]
         xrange = [0, numbox + 1]
         IF N_Elements(labels) EQ 0 THEN BEGIN
            plotlabels = ['  ', StrCompress(String(Indgen(numbox) + 1), /REMOVE_ALL), '  ']
         ENDIF ELSE BEGIN
            plotlabels = ['  ', labels, '  ']
         ENDELSE
         IF (!D.Flags AND 256) NE 0 THEN BEGIN
            Device, Get_Visual_Depth=theDepth
            IF theDepth GE 24 THEN Device, Decomposed=1, Get_Decomposed=theState
         ENDIF
         IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
         Plot, xrange, yrange, /NODATA, _STRICT_EXTRA=extra, $
            XMINOR=1, XTICKS=numbox+1, YSTYLE=1, BACKGROUND=cgColor(background_color), $
            COLOR=cgColor(axiscolor), XTICK_GET=xloc, XTICKFORMAT='(A1)', $
            XCHARSIZE=xcharsize, XTHICK=xthick, CHARSIZE=charsize
            
         <span class="comments">; Put the labels on the plots.</span>
         CASE 1 OF
            (rotate EQ 0): alignment = 0.5
            (rotate GT 0) AND (rotate LE 45): alignment = 1.0
            (rotate LT 0) AND (rotate GE -45): alignment = 0.0
            (rotate EQ 90): alignment = 1.0
            (rotate EQ -90): alignment = 0.0
            ELSE: alignment = 0.5
         ENDCASE
         FOR j=1,numbox DO BEGIN
             xy = Convert_Coord(xloc[j], !Y.CRange[0], /DATA, /TO_NORMAL)
             chary = !D.Y_CH_SIZE / Float(!D.Y_Size) * xcharsize
             XYOUTS, xy[0], xy[1] - (1.5 * chary), /NORMAL, plotlabels[j], $
                ALIGNMENT=alignment, COLOR=cgColor(axiscolor), $
                ORIENTATION=rotate, CHARSIZE=xcharsize, CHARTHICK=xthick
         ENDFOR
         IF N_Elements(theState) NE 0 THEN Device, Decomposed=theState
      ENDIF
      
      <span class="comments">; Draw the boxes.</span>
      IF N_Elements(width) EQ 0 THEN width = ((!X.CRange[1] - !X.Crange[0]) / (numbox+2.0)) * 0.9
      s = { Median:0.0D, Mean: 0.0D, Min:0.0D, Max:0.0D, $
           Q25:0.0D, Q75:0.0D, IQR:0.0D, SDEV:0.0D, N:0L }
      IF Arg_Present(stats) THEN stats = Replicate(s, numbox)
      FOR j=1,numbox DO BEGIN
          IF passedDataType EQ 'POINTER' THEN BEGIN
             dataToBox = cgBoxPlot_Prepare_Data(*data[j-1], missing_data_value)       
          ENDIF ELSE BEGIN
             IF numBox GE 1 THEN BEGIN
                IF isRowVector THEN dataToBox = thisData ELSE dataToBox = Reform(thisData[j-1,*])
             ENDIF
          ENDELSE
          IF N_Elements(xlocation) EQ 0 THEN location=j ELSE location = xlocation[j-1]
          cgBoxPlot_Draw, dataToBox, COLOR=color, BOXCOLOR=boxcolor, FILLBOXES=fillboxes, $
             OUTLINECOLOR=outlinecolor, OUTLIERCOLOR=outliercolor, WIDTH=width, XLOCATION=location, STATS=s
          IF Arg_Present(stats) THEN stats[j-1] = s
      ENDFOR
          
      <span class="comments">; Clean up.</span>
      IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
      
    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width
              
         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
      
   END <span class="comments">;-----------------------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>