<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:23 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgncdfmap.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgncdfmap.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgNCDFMap</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of this function is to translate map projection information</span>
<span class="comments">;   found in a netCDF file into a map coordinate object (cgMap) that can be </span>
<span class="comments">;   used to georeference images with a map data coordinate system. The Coyote </span>
<span class="comments">;   Library is required.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+---------------------------------------------------------------------------------------</span>
<span class="comments">;   The purpose of this function is to translate map projection information</span>
<span class="comments">;   found in a netCDF file into a map coordinate object (cgMap) that can be </span>
<span class="comments">;   used to georeference images with a map data coordinate system. The Coyote </span>
<span class="comments">;   Library is required.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Map Projections  </span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    To create a map coordinate from a netCDF file from NSIDC::</span>
<span class="comments">;       file = 'C:\IDL\data\netCDF\jun_2004_amsr_e_bt.nc'</span>
<span class="comments">;       mapCoord = cgNCDFMap(file, /Continents, /Grid)</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive </span>
<span class="comments">;       Fort Collins, CO 80526 USA </span>
<span class="comments">;       Phone: 970-221-0438 </span>
<span class="comments">;       E-mail: david@idlcoyote.com </span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com/</span>
<span class="comments">;</span>
<span class="comments">; :File_comments:</span>
<span class="comments">;    It is not possible to have a one-to-one mapping between every netCDF file and a map projection</span>
<span class="comments">;    in IDL, since IDL has a limited number of map projections and datums available. And, even at that,</span>
<span class="comments">;    I have not implemented all of IDL's map projections or datums, only those that I thought were most</span>
<span class="comments">;    likely to be encountered in my own work. If you run into a netCDF file that does not work in this</span>
<span class="comments">;    code (either because of an error in the code or because it is not supported), please contact me.</span>
<span class="comments">;    I am interested in supporting as many netCDF files as possible and I will take pains to do so if</span>
<span class="comments">;    I know they are needed.</span>

<span class="comments">; :History:</span>
<span class="comments">;     Converted from old ncdf_Coord program in Catalyst Library to run with Coyote Graphics routines.</span>
<span class="comments">;        9 November 2011. David W. Fanning.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;----------------------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Finds the correct projected map unit from the file. Assumes meters.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    varWithMap: in, required, type=string</span>
<span class="comments">;       The name of the variable in the netCDF file that contains map </span>
<span class="comments">;       projection information.</span>
<span class="comments">;    fileObj: in, required, type=object</span>
<span class="comments">;       The netCDF file object (ncdf_file) which can parse the netCDF file.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     silent: in, optional, type=boolean, default=0</span>
<span class="comments">;        If set, do not report errors.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgNCDFMap_GetMapUnit, varWithMap, fileObj, SILENT=silent

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        IF ~Keyword_Set(silent) THEN void = Error_Message()
        RETURN, mapUnit
    ENDIF
    
    <span class="comments">; Assume meters.</span>
    mapUnit = 1.

    <span class="comments">; What kind of units are being used by the variable with the map projection?</span>
    IF fileObj -> HasVarAttr(varWithMap, 'units') THEN BEGIN
        units = fileObj -> GetVarAttrValue(varWithMap, 'units')
        CASE StrLowCase(units) OF
            'm': mapUnit = 1.
            'metre': mapUnit = 1.
            'meter': mapUnit = 1.
            'meters': mapUnit = 1.
            'km': mapUnit = 1000.
            'kilometer': mapUnit = 1000.
            'kilometers': mapUnit = 1000.
            ELSE: Message, 'Unrecognized unit of measurement: ' + units
         ENDCASE
    ENDIF

    RETURN, mapUnit
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Finds the boundary (XRANGE and YRANGE) of the map coordinate space</span>
<span class="comments">;   and assigns these to the map object.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    varWithMap: in, required, type=string</span>
<span class="comments">;       The name of the variable in the netCDF file that contains map </span>
<span class="comments">;       projection information.</span>
<span class="comments">;    thisMapVar: in, required, type=string</span>
<span class="comments">;       The name of the map projection variable identified by the </span>
<span class="comments">;       grid_mapping attribute of the varWithMap variable.</span>
<span class="comments">;    fileObj: in, required, type=object</span>
<span class="comments">;       The netCDF file object (ncdf_file) which can parse the netCDF file.</span>
<span class="comments">;    mapCoord: in, required, type=object</span>
<span class="comments">;       The map coordinate object we are creating. The XRange and YRange</span>
<span class="comments">;       of the discovered boundaries are assigned to this object.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     silent: in, optional, type=boolean, default=0</span>
<span class="comments">;        If set, do not report errors.</span>
<span class="comments">;     use_latlon: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the boundary ranges will be forced to be determined </span>
<span class="comments">;        from the latitude and longitude arrays in the file. </span>
<span class="comments">;     xrange: out, optional, type=double</span>
<span class="comments">;        The discovered X projected meter range of the map projection.</span>
<span class="comments">;     yrange: out, optional, type=double</span>
<span class="comments">;        The discovered Y projected meter range of the map projection.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgNCDFMap_FindBoundary, varWithMap, thisMapVar, fileObj, mapCoord, $
    SILENT=silent, XRANGE=xrange, YRANGE=yrange, USE_LATLON=use_latlon

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        IF ~Keyword_Set(silent) THEN void = Error_Message()
        success = 0
        RETURN, success
    ENDIF
 
    <span class="comments">; Assume success</span>
    success = 1
 
    IF ~Keyword_Set(use_latlon) THEN BEGIN
    
        <span class="comments">; Let's look for helpful values in the projection variable.</span>
        IF fileObj -> HasVarAttr(thisMapVar, 'grid_boundary_top_projected_y') THEN BEGIN
            y1 = fileObj -> GetVarAttrValue(thisMapVar, 'grid_boundary_top_projected_y')
            mapUnit = cgNCDFMap_GetMapUnit(thisMapVar, fileObj, SILENT=silent)
            y1 = y1 / mapUnit
        ENDIF
        IF fileObj -> HasVarAttr(thisMapVar, 'grid_boundary_bottom_projected_y') THEN BEGIN
            y0 = fileObj -> GetVarAttrValue(thisMapVar, 'grid_boundary_bottom_projected_y')
            mapUnit = cgNCDFMap_GetMapUnit(thisMapVar, fileObj, SILENT=silent)
            y0 = y0 / mapUnit
        ENDIF
        IF fileObj -> HasVarAttr(thisMapVar, 'grid_boundary_left_projected_x') THEN BEGIN
            x0 = fileObj -> GetVarAttrValue(thisMapVar, 'grid_boundary_left_projected_x')
            mapUnit = cgNCDFMap_GetMapUnit(thisMapVar, fileObj, SILENT=silent)
            x0 = x0 / mapUnit
        ENDIF
        IF fileObj -> HasVarAttr(thisMapVar, 'grid_boundary_right_projected_x') THEN BEGIN
            x1 = fileObj -> GetVarAttrValue(thisMapVar, 'grid_boundary_right_projected_x')
            mapUnit = cgNCDFMap_GetMapUnit(thisMapVar, fileObj, SILENT=silent)
            x1 = x1 / mapUnit
        ENDIF
        IF (Keyword_Set(x0) + Keyword_Set(x1) + Keyword_Set(y0) + Keyword_Set(y1)) EQ 4 THEN BEGIN
            xrange = [x0,x1]
            yrange = [y0,y1]
            mapCoord -> SetProperty, XRANGE=xrange, YRANGE=yrange
            RETURN, success
        ENDIF ELSE Undefine, x0, x1, y0, y1
        
    ENDIF
    
    <span class="comments">; Let's see if you can find a "latitude" and "longitude" variables.</span>
    IF (fileObj -> HasVar('latitude', OBJECT=latVar)) AND $
        (fileObj -> HasVar('longitude', OBJECT=lonVar)) THEN BEGIN
        lats = latVar -> GetValue()
        lons = lonVar -> GetValue()
        s = Size(lats, /DIMENSION)
            
        <span class="comments">; Convert to XY coords</span>
        xy = Map_Proj_Forward(-180.0 > lons &lt<span class="comments">; 180.0, -90.0 > lats &lt; 90.0, $</span>
            MAP_STRUCTURE=mapCoord->GetMapStructure())
        x = Reform(xy[0,*], s[0], s[1])
        y = Reform(xy[1,*], s[0], s[1])
            
        ygrid =  Reverse(Reform(y[0,*]))
        xgrid =  Reform(x[*,0])
        half_x_pixel = Abs(Median(xgrid - Shift(xgrid,1))) / 2.0
        half_y_pixel = Abs(Median(ygrid - Shift(ygrid,1))) / 2.0
        xrange = [xgrid[0]-half_x_pixel, xgrid[s[0]-1]+half_x_pixel]
        yrange = [ygrid[0]-half_y_pixel, ygrid[s[1]-1]+half_y_pixel]
        mapCoord -> SetProperty, XRANGE=xrange, YRANGE=yrange
        RETURN, success
    ENDIF
    
    <span class="comments">; Can we stop now?</span>
    IF (N_Elements(xrange) NE 0) AND (N_Elements(yrange) NE 0) THEN BEGIN
        mapCoord -> SetProperty, XRANGE=xrange, YRANGE=yrange
        RETURN, success
    ENDIF
        
    <span class="comments">; Look in the data variable for the attribute "coordinates"</span>
    IF fileObj -> HasVarAttr(varWithMap, 'coordinates', OBJECT=coordAttr) THEN BEGIN
        coordVars = coordAttr -> GetValue()
        
        <span class="comments">; This should be the name of two variables.</span>
        parts = StrSplit(coordVars, /Extract)
        IF N_Elements(parts) NE 2 THEN Message, 'Coordinates attribute did not yield two variable names.'
        
        FOR j=0,1 DO BEGIN
            thisCoordVar = parts[j]
            IF fileObj -> HasVarAttr(thisCoordVar, 'standard_name') THEN BEGIN
                thisCoordName = fileObj -> GetVarAttrValue(thisCoordVar, 'standard_name')
            ENDIF ELSE thisCoordName = "No Standard Name"
            IF fileObj -> HasVarAttr(thisCoordVar, 'units') THEN BEGIN
                mapUnit = cgNCDFMap_GetMapUnit(thisCoordVar, fileObj, SILENT=silent)
            ENDIF
            
            <span class="comments">; Hopefully, this is a projection coordinate.</span>
            CASE thisCoordName OF
                'projection_x_coordinate': BEGIN
                    xvec = fileObj -> GetVarData(thisCoordVar)
                    nvec = N_Elements(xvec)
                    spacing = Median(xvec - Shift(xvec, 1))
                    halfpixel = spacing/2.0
                    xrange = [xvec[0]-halfpixel, xvec[nvec-1]+halfpixel] / mapUnit
                    END
                'projection_y_coordinate': BEGIN
                    yvec = fileObj -> GetVarData(thisCoordVar)
                    nvec = N_Elements(yvec)
                    spacing = Median(yvec - Shift(yvec, 1))
                    halfpixel = spacing/2.0
                    yrange = [yvec[0]-halfpixel, yvec[nvec-1]+halfpixel] / mapUnit
                    END
                ELSE: Message, 'Do not recognize the coordinate name ' + thisCoordName + '.'
            ENDCASE
        
        ENDFOR
        
    ENDIF ELSE Return, 0 <span class="comments">; Didn't find anything.</span>
        
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; :Description:</span>
<span class="comments">;   Finds the length of the semi-major and semi-minor axes of the</span>
<span class="comments">;   ellipsoid used in the netCDF file.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    varWithMap: in, required, type=string</span>
<span class="comments">;       The name of the variable in the netCDF file that contains map </span>
<span class="comments">;       projection information.</span>
<span class="comments">;    thisMapVar: in, required, type=string</span>
<span class="comments">;       The name of the map projection variable identified by the </span>
<span class="comments">;       grid_mapping attribute of the varWithMap variable.</span>
<span class="comments">;    fileObj: in, required, type=object</span>
<span class="comments">;       The netCDF file object (ncdf_file) which can parse the netCDF file.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     silent: in, optional, type=boolean, default=0</span>
<span class="comments">;        If set, do not report errors.</span>
<span class="comments">;     semimajor_axis: out, optional, type=double</span>
<span class="comments">;        The length of the semi-major axis.</span>
<span class="comments">;     semiminor_axis: out, optional, type=double</span>
<span class="comments">;        The length of the semi-minor axis.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgNCDFMap_EllipseAxes, varWithMap, thisMapVar, fileObj, SILENT=silent, $
        SEMIMAJOR_AXIS=semimajor_axis, SEMIMINOR_AXIS=semiminor_axis
        
    <span class="comments">; varWithMap -- The name of the variable containing the grid_mapping attribute.</span>
    <span class="comments">; thisMapVar -- The map projection variable identified by the grid_mapping attribute.</span>
    <span class="comments">; fileObj --    The NCDF_FILE object for the file.</span>
    <span class="comments">;</span>
    <span class="comments">; SILENT --     If set, errors are handled silently.</span>
    <span class="comments">; SEMIMAJOR_AXIS -- Output, the semi-major axis length in meters.</span>
    <span class="comments">; SEMIMINOR_AXIS -- Output, the semi-major axis length in meters.</span>

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        IF ~Keyword_Set(silent) THEN void = Error_Message()
        success = 0
        RETURN, success
    ENDIF
 
    <span class="comments">; Assume success</span>
    success = 1
    
    <span class="comments">; Convert whatever map units are associated with this variable</span>
    <span class="comments">; into a mapUnit that I can use to divide lengths by to get meters.</span>
    mapUnit = cgNCDFMap_GetMapUnit(varWithMap, fileObj, SILENT=silent)
    
    <span class="comments">; Look for an "earth_radius" attribute.</span>
    IF fileObj -> HasVarAttr(thisMapVar, 'earth_radius') THEN BEGIN
        radius = fileObj -> GetVarAttrValue(thisMapVar, 'earth_radius')
        semimajor_axis = radius/mapUnit
        semiminor_axis = radius/mapUnit
    ENDIF 
    
    <span class="comments">; Are you done?</span>
    IF (Keyword_Set(semimajor_axis) AND Keyword_Set(semiminor_axis)) EQ 2 THEN RETURN, 1
    
    <span class="comments">; Try looking for CF 1.4 compliant attributes "semi_major_axis" and "semi_minor_axis".</span>
     IF fileObj -> HasVarAttr(thisMapVar, 'semi_major_axis') THEN BEGIN
         semimajor_axis = fileObj -> GetVarAttrValue(thisMapVar, 'semi_major_axis')
         semimajor_axis = semimajor_axis / mapUnit
     ENDIF
     IF fileObj -> HasVarAttr(thisMapVar, 'semi_minor_axis') THEN BEGIN
         semiminor_axis = fileObj -> GetVarAttrValue(thisMapVar, 'semi_minor_axis')
         semiminor_axis = semiminor_axis / mapUnit
     ENDIF ELSE BEGIN
         IF N_Elements(semimajor_axis) NE 0 THEN BEGIN
             IF fileObj -> HasVarAttr(thisMapVar, 'inverse_flattening') THEN BEGIN
                 f_inv = fileObj -> GetVarAttrValue(thisMapVar, 'inverse_flattening')
                 f = 1.0D/f_inv
                 semiminor_axis = semimajor_axis - ( f * semimajor_axis )
             ENDIF
             <span class="comments">; Perhaps this is a sphere.</span>
             IF N_Elements(semiminor_axis) EQ 0 THEN semiminor_axis = semimajor_axis
         ENDIF
     ENDELSE
        
     <span class="comments">; Are you done?</span>
     IF (Keyword_Set(semimajor_axis) AND Keyword_Set(semiminor_axis)) EQ 2 THEN RETURN, success

     <span class="comments">; Try looking for CF 1.4 non-compliant attributes.</span>
     IF fileObj -> HasVarAttr(thisMapVar, 'semimajor_radius') THEN BEGIN
         semimajor_axis = fileObj -> GetVarAttrValue(thisMapVar, 'semimajor_radius')
     ENDIF
     IF fileObj -> HasVarAttr(thisMapVar, 'semiminor_radius') THEN BEGIN
         semiminor_axis = fileObj -> GetVarAttrValue(thisMapVar, 'semiminor_radius')
     ENDIF ELSE BEGIN
         IF N_Elements(semimajor_axis) NE 0 THEN BEGIN
             IF fileObj -> HasVarAttr(thisMapVar, 'inverse_flattening') THEN BEGIN
                 f_inv = fileObj -> GetVarAttrValue(thisMapVar, 'inverse_flattening')
                 f = 1.0D/f_inv
                 semiminor_axis = semimajor_axis - ( f * semimajor_axis )
             ENDIF
             <span class="comments">; Perhaps this is a sphere.</span>
             IF N_Elements(semiminor_axis) EQ 0 THEN semiminor_axis = semimajor_axis
         ENDIF
     ENDELSE
     
     <span class="comments">; Are you done?</span>
     IF (Keyword_Set(semimajor_axis) AND Keyword_Set(semiminor_axis)) EQ 2 THEN RETURN, success

     <span class="comments">; Maybe there is an ESRI Projection Engine String we can use.</span>
     IF fileObj -> HasVarAttr(varWithMap, 'esri_pe_string') THEN BEGIN
        esri_str = fileObj -> GetVarAttrValue(varWithMap, 'esri_pe_string')
        pos = StrPos(esri_str, 'SPHEROID[')
        IF pos NE -1 THEN BEGIN
            substring = StrMid(esri_str, pos)
            closebracket = StrPos(substring, ']')
            spheroid = StrMid(substring, 9, closebracket-9)
            parts = StrSplit(spheroid, ',', /EXTRACT)
            semimajor_axis = Double(parts[1])
            IF mapUnit EQ 1000 THEN semimajor_axis = semimajor_axis / mapUnit
            f_inv = Double(parts[2])
            f = 1.0D/f_inv
            semiminor_axis = semimajor_axis - ( f * semimajor_axis )
        ENDIF
     ENDIF

     <span class="comments">; Did we find anything?</span>
     IF (Keyword_Set(semimajor_axis)EQ 0) OR $
       (Keyword_Set(semiminor_axis) EQ 0) THEN BEGIN
       
       <span class="comments">; Hells bells! Let's just issue a warning and assume WGS-84. What else</span>
       <span class="comments">; can we do!?</span>
       Message, /INFORMATIONAL, 'Cannot find any sensible datum radius in file. Assuming WGS-84 values.'
       semimajor_axis = 6378137.0D
       semiminor_axis = 6356752.31414D
       RETURN, success
       
       
     ENDIF ELSE RETURN, success

END 



<span class="comments">;+---------------------------------------------------------------------------------------</span>
<span class="comments">; :Description:</span>
<span class="comments">;   The purpose of this function is to translate map projection information</span>
<span class="comments">;   found in a netCDF file into a map coordinate object (cgMap) that can be </span>
<span class="comments">;   used to georeference images with a map data coordinate system. The Coyote </span>
<span class="comments">;   Library is required.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    ncdf_filename: in, optional, type=string  </span>
<span class="comments">;       The name of a netCDF file containing map projection information from</span>
<span class="comments">;       which a cgMap object can be created.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     ccolor: in, optional, type=string, default='Charcoal'</span>
<span class="comments">;         The name of a color the map continents should be displayed with. The default</span>
<span class="comments">;         is "charcoal". Color names are those supported by cgColor.</span>
<span class="comments">;     continents: in, optional, type=boolean, default=0</span>
<span class="comments">;         If a cgMap object is made successfully, then setting this keyword</span>
<span class="comments">;         will add a cgMapContinents object to the cgMap object.   </span>
<span class="comments">;     gcolor: in, optional, type=string, default='Gray'</span>
<span class="comments">;         The name of a color the map grid should be displayed with. The default</span>
<span class="comments">;         is "gray". Color names are those supported by cgColor.</span>
<span class="comments">;     grid: in, optional, type=boolean, default=0</span>
<span class="comments">;         If a cgMap object is made successfully, then setting this keyword</span>
<span class="comments">;         will add a cgMapGrid object to the cgMap object.  </span>
<span class="comments">;     mcolor: in, optional, type=string, default='Black'</span>
<span class="comments">;          The name of a color the map should be displayed in. (Normally the map</span>
<span class="comments">;          border and map title are displayed in this color.)</span>
<span class="comments">;     onimage: in, optional, type=boolean, default=0</span>
<span class="comments">;          Set this keword if the map object is to get its position from the last</span>
<span class="comments">;          cgImage command issued.</span>
<span class="comments">;     silent: in, optional, type=boolean, default=0</span>
<span class="comments">;          IDL cannot map every GeoTiff image to a supported map projection or datum.</span>
<span class="comments">;          Normally, if the GeoTIFF image is unsupported, an error message is issued.</span>
<span class="comments">;          Setting this keyword will suppress such error messages. If you do this, you</span>
<span class="comments">;          MUST check the SUCCESS keyword to see if the program ran successfully. (Of</span>
<span class="comments">;          course, it is a good idea to check it in any case!)</span>
<span class="comments">;     success: out, optional, type=boolean, default=0</span>
<span class="comments">;          An output variable that will contain a 1 if the map coordinate object was</span>
<span class="comments">;          created successfully. Or to a 0 if it was not created successfully.</span>
<span class="comments">;     title: in, optional, type=string, default=""                      </span>
<span class="comments">;          The title of the map projection.</span>
<span class="comments">;     use_latlon: in, optional, type=boolean, default=0</span>
<span class="comments">;          If this keyword is set, the boundary ranges will be forced to be determined </span>
<span class="comments">;          from the latitude and longitude arrays in the file. </span>
<span class="comments">;     xrange: out, optional, type=double</span>
<span class="comments">;          The discovered X projected meter range of the map projection.</span>
<span class="comments">;     yrange: out, optional, type=double</span>
<span class="comments">;          The discovered Y projected meter range of the map projection.</span>
<span class="comments">;------------------------------------------------------------------------------------</span>
FUNCTION cgNCDFMap, ncdf_filename, $
    GCOLOR=gcolor, $
    GRID=grid, $
    CONTINENTS=continents, $
    CCOLOR=ccolor, $
    MCOLOR=mcolor, $
    ONIMAGE=onimage, $
    SILENT=silent, $
    SUCCESS=success, $
    TITLE=title, $
    USE_LATLON=use_latlon, $
    XRANGE=xrange, $
    YRANGE=yrange

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, theError
        IF ~Keyword_Set(silent) THEN void = Error_Message()
        success = 0
        IF Obj_Valid(fileObj) THEN Obj_Destroy, fileObj
        RETURN, Obj_New()
    ENDIF

    <span class="comments">; Need a filename?</span>
    IF N_Elements(ncdf_filename) EQ 0 THEN BEGIN
        ncdf_filename = Dialog_Pickfile(TITLE='Select netCDF File...', FILTER=['*.nc','*.ncdf'])
        IF ncdf_filename EQ "" THEN RETURN, Obj_New()
    ENDIF
    
    <span class="comments">; Set default values of keywords.</span>
    SetDefaultValue, gcolor, 'gray'
    SetDefaultValue, ccolor, 'charcoal'
    SetDefaultValue, mcolor, 'black'
    
    <span class="comments">; Assume success</span>
    success = 1
    
    <span class="comments">; Create a NCDF_FILE object for reading the data file.</span>
    fileObj = Obj_New('NCDF_FILE', ncdf_filename, /NOCLUTTER)
    IF Obj_Valid(fileObj) EQ 0 THEN Message, 'Cannot create NCDF_FILE object for reading data file.'
    
    <span class="comments">; Get a list of the variables in the file. Check each list. The first</span>
    <span class="comments">; one that has a "grid_mapping" attribute will be the map projection we</span>
    <span class="comments">; use here.</span>
    varNames = fileObj -> GetVarNames(COUNT=varCount)
    FOR j=0,varCount-1 DO BEGIN
        IF ~fileObj->HasVarAttr(varNames[j], 'grid_mapping') THEN Continue
        varWithMap = varNames[j]
        thisMapVar = fileObj -> GetVarAttrValue(varWithMap, 'grid_mapping')
        thisMapProj = fileObj -> GetVarAttrValue(thisMapVar, 'grid_mapping_name')
        IF thisMapProj EQ "" THEN Message, 'Cannot find map projection name in file.'
        BREAK
    ENDFOR
    IF N_Elements(varWithMap) EQ 0 THEN $
        Message, 'This netCDF file has no variables with map projection information.'

    <span class="comments">; Define map projection variables you will find in netCDF files.</span>
    cf_std_names = [{name:'albers_conical_equal_area', possible:1, gctp:103}, $
                    {name:'azimuthal_equidistant', possible:1, gctp:112}, $
                    {name:'lambert_azimuthal_equal_area', possible:1, gctp:111}, $
                    {name:'lambert_conformal_conic', possible:1, gctp:104}, $
                    {name:'lambert_cylindrical_equal_area', possible:0, gctp:-1}, $
                    {name:'latitude-longitude', possible:0, gctp:-1}, $
                    {name:'mercator', possible:1, gctp:105}, $
                    {name:'orthographic', possible:1, gctp:114}, $
                    {name:'polar_stereographic', possible:1, gctp:106}, $
                    {name:'rotated_latitude_longitude', possible:0, gctp:-1}, $
                    {name:'stereographic', possible:1, gctp:110}, $
                    {name:'transverse _mercator', possible:1, gctp:109}, $
                    {name:'vertical_perspective', possible:0, gctp:-1}]
                                        
    <span class="comments">; Define the expected parameters for those netCDF projection types.</span>
    cf_std_name_parameters = [ Ptr_New(['standard parallel', $ <span class="comments">; Albers Equal Area</span>
                                      'longitude_of_central_meridian', $ 
                                      'latitude_of_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['longitude_of_projection_origin', $ <span class="comments">; Azimuthal Equidistant</span>
                                      'latitude_of_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['longitude_of_projection_origin', $ <span class="comments">; Lambert Azimutal Equal Area</span>
                                      'latitude_of_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['standard parallel', $ <span class="comments">; Lambert Conformal</span>
                                      'longitude_of_projection_origin', $
                                      'latitude_of_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['longitude_of_central_meridian', $ <span class="comments">; Lambert Cylindrical Equal Area</span>
                                      'standard parallel', $
                                      'scale_factor_at_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(), $ <span class="comments">; Latitude-Longitude</span>
                             Ptr_New(['longitude_of_projection_origin', $ <span class="comments">; Mercator</span>
                                      'standard parallel', $
                                      'latitude_of_true_scale', $
                                      'scale_factor_at_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['longitude_of_projection_origin', $ <span class="comments">; Orthographic</span>
                                      'latitude_of_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['straight_vertical_longitude_from_pole', $ <span class="comments">; Polar Stereographic</span>
                                      'longitude_of_projection_origin', $
                                      'latitude_of_projection_origin', $
                                      'standard parallel', $
                                      'latitude_of_true_scale', $
                                      'scale_factor_at_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(), $ <span class="comments">; Rotated Pole</span>
                             Ptr_New(['longitude_of_projection_origin', $ <span class="comments">; Stereographic</span>
                                      'latitude_of_projection_origin', $
                                      'scale_factor_at_projection_origin', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New(['scale_factor_at_central_meridian', $ <span class="comments">; Transverse Mercator</span>
                                      'longitude_of_central_meridian', $
                                      'latitude_of_central_meridian', $
                                      'false_easting', 'false_northing']), $
                             Ptr_New() ] <span class="comments">; Vertical Perspective</span>
                                      
    <span class="comments">; Can you locate the map projection in the list of projections you know about?</span>
    index = Where(cf_std_names.name EQ thisMapProj, count)
    IF count EQ 0 THEN Message, 'Cannot process map projection: ' + thisMapProj
    
    <span class="comments">; Is is possible to do this map projection in IDL?</span>
    IF cf_std_names[index].possible EQ 0 THEN $
        Message, 'Cannot process map projection "' + thisMapProj + '" in IDL.'
        
    <span class="comments">; Can you find values for the ellipsoid?</span>
    success = cgNCDFMap_EllipseAxes(varWithMap, thisMapVar, fileObj, SILENT=silent, $
        SEMIMAJOR_AXIS=semimajor_axis, SEMIMINOR_AXIS=semiminor_axis)
    IF ~success THEN Message, 'Cannot locate ellipsoid axes in file.'
                
    <span class="comments">; Get the attributes for this particular map projection.</span>
    attrs = *(cf_std_name_parameters[index])[0]
    nAttrs = N_Elements(attrs)
    FOR j=0,nAttrs-1 DO BEGIN
        thisAttr = attrs[j]
        IF fileObj -> HasVarAttr(thisMapVar, thisAttr, OBJECT=attrObj) THEN BEGIN
            attrValue = attrObj -> GetValue()
        ENDIF ELSE Continue
        
        CASE thisAttr OF
        
            'longitude_of_central_meridian'  : center_longitude = attrValue
            'latitude_of_central_meridian'   : center_latitude = attrValue
            'false_easting'                  : false_easting = attrValue
            'false_northing'                 : false_northing = attrValue
            'longitude_of_central_meridian'  : center_longitude = attrValue
            'latitude_of_projection_origin'  : center_latitude = attrValue
            'longitude_of_projection_origin' : center_longitude = attrValue
            'latitude_of_true_scale': BEGIN
                CASE cf_std_names[index].name OF
                    'polar_stereographic': center_latitude = attrValue
                    ELSE: true_scale_latitude = attrValue
                ENDCASE
                END
            'straight_vertical_longitude_from_pole': center_longitude = attrValue
            'standard_parallel'              : BEGIN
                IF N_Elements(attrValue) EQ 2 THEN BEGIN
                    standard_par1 = attrValue[0]
                    standard_par2 = attrValue[1]
                ENDIF ELSE standard_par1 = attrValue
                END
             'scale_factor_at_projection_origin': BEGIN
                CASE cf_std_names[index].name OF
                    'transverse _mercator': mercator_scale=attrValue
                    'mercator': mercator_scale=attrValue
                    ELSE: Message, /Informational, 'Not sure what to do with the attribute ' + $
                                '"scale_factor_at_projection_origin".'
                ENDCASE
                END
             'scale_factor_at_central_meridian': BEGIN
                CASE cf_std_names[index].name OF
                    'transverse _mercator': mercator_scale=attrValue
                    'mercator': mercator_scale=attrValue
                    ELSE: Message, /Informational, 'Not sure what to do with the attribute ' + $
                                '"scale_factor_at_central_meridian".'
                ENDCASE
                END
        ENDCASE
    
     ENDFOR
        
     mapCoord = Obj_New('cgMap', cf_std_names[index].gctp, $
            CENTER_LATITUDE=center_latitude, $
            CENTER_LONGITUDE=center_longitude, $
            COLOR=mcolor, $
            SEMIMAJOR_AXIS=semimajor_axis, $
            SEMIMINOR_AXIS=semiminor_axis, $
            NAME=name, $
            MERCATOR_SCALE=mercator_scale, $
            ONIMAGE=Keyword_Set(onimage), $
            STANDARD_PAR1=standard_par1, $
            STANDARD_PAR2=standard_par2, $
            TITLE=title, $
            TRUE_SCALE_LATITUDE=true_scale_latitude, $
            FALSE_EASTING=false_easting, $
            FALSE_NORTHING=false_northing)
            
      <span class="comments">; Now, can we find the extend of the XY Cartesian boundaries to set the range</span>
      <span class="comments">; of the coordinate object.</span>
      success = cgNCDFMap_FindBoundary(varWithMap, thisMapVar, fileObj, mapCoord, $
            SILENT=silent, USE_LATLON=use_latlon, XRANGE=xrange, YRANGE=yrange)
         
      IF ~success THEN Message, 'Cannot find XY boundary values in file.'

      <span class="comments">; Need a map outline in this cgMapCoord object?</span>
      IF Keyword_Set(continents) THEN BEGIN
           contObj = Obj_New('cgMapContinents', mapCoord, /HIRES, $
                            COLOR=ccolor, FILL=Keyword_Set(fill), NAME='MAPCONTINENTS')
           IF ~Obj_Valid(contObj) THEN $
              Message, 'Cannot successfully create a cgMapContinents object.'
           mapCoord -> SetProperty, CONTINENTS=contObj
      ENDIF
          
      <span class="comments">; Need a map grid in this cgMapCoord object?</span>
      IF Keyword_Set(grid) THEN BEGIN
           gridObj = Obj_New('cgMapGrid', mapCoord, COLOR=gcolor, /AUTODRAWGRID, NAME='MAPGRID')
           IF ~Obj_Valid(gridObj) THEN $
              Message, 'Cannot successfully create a cgMapGrid object.'
           mapCoord -> SetProperty, GRID=gridObj
      ENDIF
      
      <span class="comments">; Destroy the file object you created.</span>
      Obj_Destroy, fileObj
          
      RETURN, mapCoord                 
END
</code>
    </div>
  </body>
</html>