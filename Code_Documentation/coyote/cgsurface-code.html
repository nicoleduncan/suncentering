<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:33 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgsurface.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgsurface.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgSurface</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of cgSurface is to create a window where a surface is displayed. Surfaces</span>
<span class="comments">;   can be wire-framed, shaded surfaces, and surfaces with texture maps draped on top of</span>
<span class="comments">;   them, among other types of surfaces. LEFT mouse button rotates the surface, MIDDLE</span>
<span class="comments">;   mouse button zooms out from the surface, RIGHT mouse button zoom into the surface. </span>
<span class="comments">;   Clicking on the surface axes will allow the user to move or translate the surface, and </span>
<span class="comments">;   clicking on the plot title will allow the user to move the title.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">;   The purpose of cgSurface is to create a window where a surface is displayed. Surfaces</span>
<span class="comments">;   can be wire-framed, shaded surfaces, and surfaces with texture maps draped on top of</span>
<span class="comments">;   them, among other types of surfaces. LEFT mouse button rotates the surface, MIDDLE</span>
<span class="comments">;   mouse button zooms out from the surface, RIGHT mouse button zoom into the surface. </span>
<span class="comments">;   Clicking on the surface axes will allow the user to move or translate the surface, and </span>
<span class="comments">;   clicking on the plot title will allow the user to move the title.</span>
<span class="comments">;</span>
<span class="comments">; .. image:: cgsurface.png</span>
<span class="comments">; </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Use as you would use the IDL SURFACE of SHADE_SURF command::</span>
<span class="comments">;       data = Dist(200)</span>
<span class="comments">;       LoadCT, 33</span>
<span class="comments">;       cgSurface, data</span>
<span class="comments">;       cgSurface, data, /Elevation_Shading</span>
<span class="comments">;       cgSurface, data, /Shaded</span>
<span class="comments">;       cgSurface, data, /Shaded, Texture_Image=cgDemoData(16) </span>
<span class="comments">;       </span>
<span class="comments">;       Setting up the initial surface rotation.</span>
<span class="comments">;       IDL> T3D, /RESET, ROTATE=[0, 0, 30]</span>
<span class="comments">;       IDL> T3D, ROTATE=[-90, 0, 0]</span>
<span class="comments">;       IDL> T3D, ROTATE=[0, 30, 0]</span>
<span class="comments">;       IDL> T3D, ROTATE=[30, 0, 0]</span>
<span class="comments">;       IDL> cgSurface, cgDemoData(2), Transform=!P.T</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Completely re-written, 26 November 2010 from old cgSURFACE program. DWF.</span>
<span class="comments">;        Added ability to translate the surface by clicking on an axis. 28 Nov 2010. DWF.</span>
<span class="comments">;        Fixed a problem with light controls in which the light controls didn't show the</span>
<span class="comments">;            current light color. 28 Nov 2010. DWF.</span>
<span class="comments">;        I was ANDing [XYZ]Style keywords with 8 instead of 4 for hidded axes. Fixed. 4 Jan 2011. DWF.</span>
<span class="comments">;        Added Axes ON/OFF button. 4 Jan 2011. DWF.</span>
<span class="comments">;        Rotation is throwing underflow warnings, so switched to code that surpress </span>
<span class="comments">;            these warnings. 26 Aug 2011. DWF</span>
<span class="comments">;        Added TRANSFORM keyword to allow the initial surface to be rotated to user </span>
<span class="comments">;            specifications. 26 Sept 2011. DWF.</span>
<span class="comments">;        Changed FSC_Normalize to cgNormalize to reflect new name. 6 Feb 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2010-2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Controls light intensity by handling selection events from the Intensity Value widget.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO CW_Light_Control_Intensity_Events, event

    <span class="comments">; Handles selection events from the Intensity Value widget.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, infoCarrier, Set_UValue=info, /No_Copy
    ENDIF

    <span class="comments">; Get the info carrier.</span>
    parent = Widget_Info(event.id, /Parent)
    infoCarrier = Widget_Info(parent, Find_by_UName='CW_LIGHT_CARRIER')
    Widget_Control, infoCarrier, Get_UValue=info, /No_Copy
    
    <span class="comments">; Get the new intensity value.</span>
    info.theIntensity = *event.selection
    
    <span class="comments">; Change the intensity of the light.</span>
    info.theLight->SetProperty, Intensity=info.theIntensity
    
    <span class="comments">; Prepare to send an event that notifies the program.</span>
    event_pro = info.event_pro
    tlb = info.tlb
    top = event.top
    parent = info.parent
    name = info.name
    intensity = info.theIntensity
    color = info.theColor
    hide = info.theHide
    Widget_Control, infoCarrier, Set_UValue=info, /No_Copy
    
    <span class="comments">; Send the event.</span>
    IF event_pro NE "" THEN BEGIN
       eventStruct = {CW_LIGHT_CONTROL, ID:tlb, TOP:parent, HANDLER:0L, $
          NAME:name, INTENSITY:intensity, COLOR:color, HIDE:hide}
       Widget_Control, parent, Send_Event=eventStruct
    ENDIF
    
END <span class="comments">;------------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; Controls light properties such as color, whether the light is on or off, etc.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO CW_Light_Control_Events, event

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, infoCarrier, Set_UValue=info, /No_Copy
    ENDIF

    <span class="comments">; Get the info structure.</span>
    infoCarrier = Widget_Info(event.handler, Find_By_UName='CW_LIGHT_CARRIER')
    Widget_Control, infoCarrier, Get_UValue=info, /No_Copy
    
    <span class="comments">; What kind of event is this? Branch appropriately.</span>
    Widget_Control, event.id, Get_UValue=thisEvent
    CASE thisEvent OF
    
       'COLOR': BEGIN
          TVLCT, info.color, info.index
          DEVICE, Decomposed=0, Get_Decomposed=theDecomposedState
          setcolor_title = Widget_Info(event.id, /UNAME)
          thisColor = PickColor(CURRENTCOLOR=info.color, Group_Leader=event.top, Title=setcolor_title)
          thisColor = Reform(thisColor, 3, 1)
          info.theLight->SetProperty, Color=thisColor
          DEVICE, Decomposed=theDecomposedState
          info.color = thisColor
          END
    
       'RESET': BEGIN
          info.theColor = info.origColor
          info.theIntensity = info.origIntensity
          info.theHide = info.origHide
          info.color = info.origColor
          info.intensityID->SetSelection, info.origIntensity
          IF info.origHide THEN BEGIN
             Widget_Control, info.onButtonID, Set_Button=0
             Widget_Control, info.offButtonID, Set_Button=1
          ENDIF ELSE BEGIN
             Widget_Control, info.onButtonID, Set_Button=1
             Widget_Control, info.offButtonID, Set_Button=0
          ENDELSE
    
          info.theLight->SetProperty, Intensity=info.origIntensity, $
             Color=info.origColor, Hide=info.origHide
    
          END
    
       'ON': BEGIN
          info.theHide = 0
          info.theLight->SetProperty, Hide=0
          END
    
       'OFF': BEGIN
          info.theHide = 1
          info.theLight->SetProperty, Hide=1
          END
    
    ENDCASE
    
    <span class="comments">; Prepare to send an event if requested.</span>
    event_pro = info.event_pro
    tlb = info.tlb
    top = event.top
    parent = info.parent
    name = info.name
    intensity = info.theIntensity
    color = info.theColor
    hide = info.theHide
    Widget_Control, infoCarrier, Set_UValue=info, /No_Copy
    
    <span class="comments">; Send the event.</span>
    IF event_pro NE "" THEN BEGIN
       eventStruct = {CW_LIGHT_CONTROL, ID:tlb, TOP:parent, HANDLER:0L, $
          NAME:name, INTENSITY:intensity, COLOR:color, HIDE:hide}
       Widget_Control, parent, Send_Event=eventStruct
    ENDIF
    
END <span class="comments">;------------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This is a compound widget that allows the user to manipulate various</span>
<span class="comments">; properties of a light object via a graphical user interface.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    parent: in, required</span>
<span class="comments">;       The parent widget of this compound widget.</span>
<span class="comments">;    thelight: in, required, type=object</span>
<span class="comments">;       An object reference to a particular light object.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   color: in, optional, type=bytarr</span>
<span class="comments">;      A color triple representing the color of the light.</span>
<span class="comments">;   event_pro: in, optional, type=string</span>
<span class="comments">;      The name of an event handler that will handle events for this widget.</span>
<span class="comments">;   index: in, optional, type=integer</span>
<span class="comments">;      A color table index number. If the `Color` keyword is not used, the color</span>
<span class="comments">;      will be obtained from the colors loaded in the current color table at this</span>
<span class="comments">;      color table index number.</span>
<span class="comments">;   labelsize: in, optional, type=integer</span>
<span class="comments">;      The size of the label widget used in the compound widget in pixels.</span>
<span class="comments">;      If not specified, the "natural" size of the label widget is used.</span>
<span class="comments">;   name: in, optional, type=string, default=""</span>
<span class="comments">;      A name for this widget. Provided to help identify the widget in</span>
<span class="comments">;      event handlers.</span>
<span class="comments">;   setcolor_name: in, optional, type=string, default=""</span>
<span class="comments">;      This keyword sets the UNAME property of the Set Color button in the interface.</span>
<span class="comments">;      It's purpose is to help you identify that button in event handlers.</span>
<span class="comments">;   uvalue: in, optional</span>
<span class="comments">;       A container to store any IDL variable needed by the user of this program.</span>
<span class="comments">;-</span>
FUNCTION CW_Light_Control, parent, theLight, $
  Color=color, $
  Event_Pro=event_pro, $
  Index=index, $
  LabelSize=labelsize, $
  Name=name, $
  SetColor_Name=setColor_name, $
  UValue=uvalue

<span class="comments">; This is a compound widget that allows one to manipulate various</span>
<span class="comments">; properties of light objects.</span>

    On_Error, 2
    
    <span class="comments">; Check parameters. Define defaults if necessary.</span>
    IF N_Elements(parent) EQ 0 THEN Message, 'Parent widget parameter is required 1st parameter.'
    IF (N_Elements(theLight) EQ 0) OR (Size(theLight, /TName) NE 'OBJREF') THEN $
       Message, 'Light Object Reference is required 2nd parameter.'
    IF N_Elements(uvalue) EQ 0 THEN uvalue = "LIGHT_CONTROL"
    IF N_Elements(event_pro) EQ 0 THEN event_pro = ""
    IF N_Elements(index) EQ 0 THEN index =  !D.Table_Size-2
    IF N_Elements(setcolor_name) EQ 0 THEN setcolor_name = ""
    IF N_Elements(color) EQ 0 THEN BEGIN
       TVLCT, r, g, b, /Get
       color = Reform([r[index], g[index], b[index]], 1, 3)
    ENDIF ELSE color = Reform(color, 1, 3)
    TVLCT, color, index
    
    <span class="comments">; Set the light properties.</span>
    theLight->GetProperty, Intensity=theIntensity, Hide=theHide, Color=theColor
    IF N_Elements(name) EQ 0 THEN name = 'Light'
    
    <span class="comments">; Create the widgets.</span>
    tlb = Widget_Base(parent, Row=1, Base_Align_Center=1, $
       Event_Pro='CW_Light_Control_Events')
    IF N_Elements(labelsize) NE 0 THEN $
       labelID = Widget_Label(tlb, Value=name + ': ', UNAME='CW_LIGHT_CARRIER', XSize=labelsize) ELSE $
       labelID = Widget_Label(tlb, Value=name + ': ', UNAME='CW_LIGHT_CARRIER')
    exBaseID = Widget_Base(tlb, Row=1, /Exclusive, /Frame)
    onButtonID = Widget_Button(exBaseID, Value='On', UValue='ON')
    offButtonID = Widget_Button(exBaseID, Value='Off', UValue='OFF')
    IF theHide THEN Widget_Control, offbuttonID, /Set_Button ELSE $
       Widget_Control, onbuttonID, /Set_Button
    intensityValues = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    intensityID = FSC_Droplist(tlb, Title='Intensity:', Value = intensityValues, $
       Event_Pro='CW_Light_Control_Intensity_Events', Format='(F3.1)', Spaces=[1,1])
    intensityID->SetSelection, theIntensity
    colorID = Widget_Button(tlb, Value='Set Color', UValue='COLOR', UNAME=setcolor_name)
    resetID= Widget_Button(tlb, Value='Reset', UValue='RESET')
    Widget_Control, tlb, /Realize
    
    <span class="comments">; Create info structure with information to run the program. Store it.</span>
    info = {theLight:theLight, name:name, theIntensity:theIntensity, theHide:theHide, color:color, $
            theColor:theColor, Event_Pro:event_pro, origIntensity:theIntensity, index:index, $
            origColor:theColor, origHide:theHide, tlb:tlb, parent:parent, intensityID:intensityID, $
            onButtonID:onButtonID, offButtonID:offButtonID}
    Widget_Control, labelID, Set_UValue=info, /No_Copy
    
    RETURN, tlb
    
END <span class="comments">;------------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; An event handler that destroys the light controller in the program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Light_Done, event
    Widget_Control, event.top, /Destroy
END <span class="comments">;--------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; An event handler that renders the light controller's graphics.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Light_Controls_Event, event
    Widget_Control, event.top, Get_UValue=info
    info.theWindow->Draw, info.theView
END
<span class="comments">;-------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; An event handler that creates the graphical user interface for the</span>
<span class="comments">; light controller.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Light_Controls, event

    <span class="comments">; Place the light control beside the current widget program.</span>
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.top, TLB_Get_Size=sizes, TLB_Get_Offset=offsets
    xpos = sizes[0] + offsets[0] + 10
    ypos = offsets[1] + 100
    
    <span class="comments">; Lights only make sense with a solid surface.</span>
    info.thisSurface->SetProperty, Style=2, Shading=1
    info.thisWindow->Draw, info.thisView
    
    <span class="comments">; Create widgets.</span>
    tlb = Widget_Base(Title='cgSurface Light Controls', Column=1, Group_Leader=event.top, $
       UValue={theView:info.thisView, theWindow:info.thisWindow}, XOffset=xpos, YOffset=ypos)
    dummy = CW_Light_Control(tlb, Name='Non-Rotating Light', info.nonRotatingLight, LabelSize=130, $
       Event_Pro='cgSurface_Light_Controls_Event', Index=!D.Table_Size-18, Color=[255,255,255], $
       SetColor_Name='Color for Non-Rotating Light')
    dummy = CW_Light_Control(tlb, Name='Rotating Light', info.rotatingLight, LabelSize=130, $
       Event_Pro='cgSurface_Light_Controls_Event', Index=!D.Table_Size-19, Color=[255,255,255], $
       SetColor_Name='Color for Rotating Light')
    dummy = CW_Light_Control(tlb, Name='Fill Light', info.fillLight, LabelSize=130, $
       Event_Pro='cgSurface_Light_Controls_Event', Index=!D.Table_Size-20, Color=[255,255,255], $
       SetColor_Name='Color for Fill Light')
    dummy = CW_Light_Control(tlb, Name='Ambient Light', info.ambientLight, LabelSize=130, $
       Event_Pro='cgSurface_Light_Controls_Event', Index=!D.Table_Size-21, Color=[255,255,255], $
       SetColor_Name='Color for Ambient Light')
    quit = Widget_Button(tlb, Value='Done', Event_Pro='cgSurface_Light_Done')
    
    Widget_Control, tlb, /Realize
    
    XManager, 'cgSurface_Light_Controls', tlb, /No_Block, Event_Handler='cgSurface_Light_Controls_Event'
    Widget_Control, event.top, Set_UValue=info, /No_Copy

END
<span class="comments">;-------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler that turns the surface axes on or off.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Axes_OnOff, event

    <span class="comments">; This event handler turns the surface axes on or off.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.id, Get_Value=buttonValue, Get_UValue=uvalue
    Widget_Control, event.id, Set_Value=uvalue, Set_UValue=buttonValue
    
    CASE buttonValue OF
    
       'Turn Axes ON': BEGIN
            info.xaxis -> SetProperty, HIDE=0
            info.yaxis -> SetProperty, HIDE=0
            info.zaxis -> SetProperty, HIDE=0         
        END
        
       <span class="comments">; Not at all sure why this works!</span>
       'Turn Axes OFF': BEGIN
            info.xaxis -> SetProperty, HIDE=1
            info.yaxis -> SetProperty, HIDE=1
            info.zaxis -> SetProperty, HIDE=1         
        END
    
    ENDCASE
    
    <span class="comments">; Draw the graphic display.</span>
    info.thisWindow -> Draw, info.thisView
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler that turns the bottom color on or off.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Bottom_OnOff, event

    <span class="comments">; This event handler turns the bottom color on or off.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.id, Get_Value=buttonValue, Get_UValue=uvalue
    Widget_Control, event.id, Set_Value=uvalue, Set_UValue=buttonValue
    
    CASE buttonValue OF
    
       'Bottom Color ON': info.thisSurface -> SetProperty, Bottom=info.bottom
    
       <span class="comments">; Not at all sure why this works!</span>
       'Bottom Color OFF': info.thisSurface -> SetProperty, Bottom=info.bottomOffPtr
    
    ENDCASE
    
    <span class="comments">; Draw the graphic display.</span>
    info.thisWindow -> Draw, info.thisView
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler that changes the color tables for elevation shading.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Change_Colors, event

    <span class="comments">; This event handler changes color tables for elevation shading.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.id, Get_Value=buttonValue, Get_UValue=buttonUValue
    CASE StrUpCase(buttonValue) OF
        'TITLE COLOR': BEGIN
            title = 'Set Title Color'
            color = cgPickColorName(buttonUValue, TITLE=title, GROUP_LEADER=event.top)
            info.tcolor = cgColor(color, /Triple, /Row)
            info.plottitle -> SetProperty, COLOR=info.tcolor
            END
        'SURFACE COLOR': BEGIN
            title = 'Set Surface Color'
            color = cgPickColorName(buttonUValue, TITLE=title, GROUP_LEADER=event.top)
            info.color = cgColor(color, /Triple, /Row)
            info.thisSurface -> SetProperty, COLOR=info.color
            END
        'BACKGROUND COLOR': BEGIN
            title = 'Set Background Color'
            color = cgPickColorName(buttonUValue, TITLE=title, GROUP_LEADER=event.top)
            info.background = cgColor(color, /Triple, /Row)
            info.thisView -> SetProperty, COLOR=info.background
            END
        'AXIS COLOR': BEGIN
            title = 'Set Axis Color'
            color = cgPickColorName(buttonUValue, TITLE=title, GROUP_LEADER=event.top)
            info.axiscolor = cgColor(color, /Triple, /Row)
            info.xaxis -> SetProperty, COLOR=info.axiscolor
            info.yaxis -> SetProperty, COLOR=info.axiscolor
            info.zaxis -> SetProperty, COLOR=info.axiscolor
            END
        'BOTTOM COLOR': BEGIN
            title = 'Set Bottom Color'
            color = cgPickColorName(buttonUValue, TITLE=title, GROUP_LEADER=event.top)
            info.bottom = cgColor(color, /Triple, /Row)
            info.thisSurface -> SetProperty, BOTTOM=info.bottom
            END
    ENDCASE
    
    <span class="comments">; Set the user value to new color name.</span>
    Widget_Control, event.id, SET_UVALUE=color
    
    <span class="comments">; Draw the surface.</span>
    info.thisWindow -> Draw, info.thisView
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler for draw events such as expose events and trackball</span>
<span class="comments">; events. The trackball uses the IDL-supplied TRACKBALL_DEFINE.PRO.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Draw_Events, event

    <span class="comments">; Draw widget events handled here: expose events and trackball</span>
    <span class="comments">; events. The trackball uses RSI-supplied TRACKBALL_DEFINE.PRO.</span>

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    drawTypes = ['PRESS', 'RELEASE', 'MOTION', 'SCROLL', 'EXPOSE']
    thisEvent = drawTypes(event.type)
    
    CASE thisEvent OF
    
       'EXPOSE':  BEGIN
           <span class="comments">; Expose events are NOT blocked by modal widgets, thus, it is possible</span>
           <span class="comments">; to get an expose event here when it is not expected. This will cause</span>
           <span class="comments">; an error, since info will be undefined. Check for this condition before</span>
           <span class="comments">; processing.</span>
           IF N_Elements(info) EQ 0 THEN RETURN
           END
    
       'PRESS': BEGIN
       
           item = info.thisWindow->Select(info.thisView, [event.x, event.y])
           IF Obj_Valid(item[0]) THEN BEGIN
               IF Obj_Class(item[0]) EQ 'IDLGRTEXT' THEN BEGIN
                   Widget_Control, event.id, /CLEAR_EVENTS
                   Widget_Control, event.id, EVENT_PRO='cgSURFACE_MOVE_TITLE'
                   info.xstart = event.x
                   info.ystart = event.y
                   info.selectedItem = item[0]
                   Widget_Control, event.top, Set_UValue=info, /No_Copy
                   Widget_Control, event.id, DRAW_MOTION_EVENTS=1
                   RETURN
               ENDIF
               IF Obj_Class(item[0]) EQ 'IDLGRAXIS' THEN BEGIN
                   Widget_Control, event.id, /CLEAR_EVENTS
                   Widget_Control, event.id, EVENT_PRO='cgSURFACE_MOVE_SURFACE'
                   info.xstart = event.x
                   info.ystart = event.y
                   info.selectedItem = item[0]
                   Widget_Control, event.top, Set_UValue=info, /No_Copy
                   Widget_Control, event.id, DRAW_MOTION_EVENTS=1
                   RETURN
               ENDIF
           ENDIF
    
           <span class="comments">; Zoom out on middle, zoom in on right, rotate on left.</span>
           possibleButtons = ['NONE', 'LEFT', 'MIDDLE', 'NONE', 'RIGHT']
           thisButton = possibleButtons(event.press)
    
           CASE thisButton OF
    
             'RIGHT': BEGIN
                      info.thisView->GetProperty, Viewplane_Rect=thisRect
                      thisRect(0) = (thisRect(0) + 0.05) &lt<span class="comments">; thisRect(2)</span>
                      thisRect(1) = (thisRect(1) + 0.05) &lt<span class="comments">; thisRect(3)</span>
                      thisRect(2) = (thisRect(2) - 0.1) > thisRect(0)
                      thisRect(3) = (thisRect(3) - 0.1) > thisRect(1)
                      info.thisView->SetProperty, Viewplane_Rect=thisRect
                      END
    
             'MIDDLE': BEGIN
                      info.thisView->GetProperty, Viewplane_Rect=thisRect
                      thisRect(0) = thisRect(0) - 0.05
                      thisRect(1) = thisRect(1) - 0.05
                      thisRect(2) = thisRect(2) + 0.1
                      thisRect(3) = thisRect(3) + 0.1
                      info.thisView->SetProperty, Viewplane_Rect=thisRect
                      END
    
             'LEFT':  BEGIN
                      Widget_Control, event.id, Draw_Motion_Events=1 <span class="comments">; Motion events ON.</span>
                      info.thisWindow->SetProperty, Quality=info.dragQuality <span class="comments">; Set Drag Quality.</span>
                      END
    
             ELSE:
           ENDCASE
    
           END
       'RELEASE': BEGIN
           Widget_Control, event.id, Draw_Motion_Events=0 <span class="comments">; Motion events OFF.</span>
           info.thisWindow->SetProperty, Quality=2 <span class="comments">; Drag Quality to High.</span>
           END
       'MOTION': BEGIN <span class="comments">; Trackball events</span>
           END
           
       ELSE: <span class="comments">; Fall though, don't care.</span>
    
    ENDCASE
    
    <span class="comments">; Does the trackball need updating? If so, update.</span>
    needUpdate = info.thisTrackball -> Update(event, Transform=thisTransform)
    IF needUpdate THEN BEGIN
       info.thisModel->GetProperty, Transform=modelTransform
       info.thisModel->SetProperty, Transform=modelTransform # thisTransform
    ENDIF
    
    <span class="comments">; Draw the view. If this program STILL throws floating point exceptions,</span>
    <span class="comments">; comment this line out and uncomment the code below it. Dishonest as</span>
    <span class="comments">; all get out, but it works fine. :-)</span>
    <span class="comments">;info.thisWindow->Draw, info.thisView</span>
    currentExcept = !Except
    !Except = 0
    info.thisWindow -> Draw, info.thisView
    dummy = Check_Math()
    !Except = currentExcept
    
    <span class="comments">; Put the info structure back.</span>
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler changing the colors used in elevation shading.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Elevation_Colors, event

    <span class="comments">; This event handler changes color tables for elevation shading.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    <span class="comments">; What kind of event is this? Could be from Change Colors button</span>
    <span class="comments">; or from XCOLORS itself.</span>
    thisEvent = Tag_Names(event, /Structure_Name)
    CASE thisEvent OF
    
       "WIDGET_BUTTON": BEGIN
          IF info.colortable EQ -1 THEN BEGIN
            TVLCT, info.r, info.g, info.b
          ENDIF ELSE BEGIN
            cgLoadCT, info.colortable, BREWER=info.brewer, REVERSE=info.reverse
          ENDELSE
          XColors, Group_Leader=event.top, NotifyID=[event.id, event.top], $
             Title="cgSurface Elevation Shading Colors", BREWER=info.brewer, $
             INDEX=info.colortable, REVERSE=info.reverse
          ENDCASE
    
       "XCOLORS_LOAD": BEGIN
          info.r = event.r
          info.g = event.g
          info.b = event.b
          info.colortable = event.index
          info.brewer = event.brewer
          info.reverse = event.reversed
          IF Obj_Valid(info.colorPalette) THEN info.colorPalette->SetProperty, $
             Red=event.r, Green=event.g, Blue=event.b
          ENDCASE
    
    ENDCASE
    
    <span class="comments">; Draw the graphic display.</span>
    info.thisWindow -> Draw, info.thisView
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to set up elevation shading for the surface.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Elevation_Shading, event

    <span class="comments">; This event handler sets up elevation shading for the surface.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.id, Get_Value=buttonValue, Get_UValue=uvalue
    Widget_Control, event.id, Set_Value=uvalue, Set_UValue=buttonValue
    
    CASE buttonValue OF
    
       'Elevation Shading ON': BEGIN
          s = Size(info.data, /Dimensions)
          info.zAxis->GetProperty, CRange=zrange
          info.thisSurface->SetProperty, Palette=info.colorPalette, $
             Vert_Colors=Reform(BytScl(info.data, /NAN, Min=Min(zrange), $
             Max=Max(zrange)), s[0]*s[1]), Bottom=info.bottomOffPtr, Specular=""
          Widget_Control, info.bottomID, Set_Value='Bottom Color ON' 
          Widget_Control, info.bottomID, Set_UValue='Bottom Color OFF'
          ENDCASE
    
       'Elevation Shading OFF': BEGIN
          info.thisSurface->SetProperty, Palette=Obj_New(), Vert_Colors=0, $
            Bottom=info.bottom, SPECULAR=info.specularColor
          Widget_Control, info.bottomID, Set_Value='Bottom Color OFF'
          Widget_Control, info.bottomID, Set_UValue='Bottom Color ON'
          ENDCASE
    
    ENDCASE
    
    <span class="comments">; Draw the graphic display.</span>
    info.thisWindow->Draw, info.thisView
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to destroy the GUI for this program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Exit, event

   <span class="comments">; Exit the program. This will cause the CLEANUP</span>
   <span class="comments">; routine to be called automatically.</span>
   Widget_Control, event.top, /Destroy
   
END <span class="comments">;-----------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to allow the surface to move in the graphics window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Move_Surface, event

    <span class="comments">; This event handler moves the surface.</span>

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    drawTypes = ['PRESS', 'RELEASE', 'MOTION', 'SCROLL', 'EXPOSE']
    thisEvent = drawTypes(event.type)
    CASE thisEvent OF
    
        'RELEASE': BEGIN
            Widget_Control, event.id, /CLEAR_EVENTS
            Widget_Control, event.id, EVENT_PRO='cgSURFACE_DRAW_EVENTS'
            Widget_Control, event.id, DRAW_MOTION_EVENTS=0
            info.xstart = -1
            info.ystart = -1
            info.selectedItem = Obj_New()
            END
            
        'MOTION': BEGIN
            delta_x = (event.x - info.xstart) / Float(info.xsize) 
            delta_y = (event.y - info.ystart) / Float(info.ysize) 
            info.thisModel -> Translate, 2*delta_x, 2*delta_y, 0
            info.thisWindow -> Draw, info.thisView
            info.xstart = event.x
            info.ystart = event.y
            END
    ENDCASE
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to allow the title to move in the graphics window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Move_Title, event

    <span class="comments">; This event handler moves the surface title.</span>

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    drawTypes = ['PRESS', 'RELEASE', 'MOTION', 'SCROLL', 'EXPOSE']
    thisEvent = drawTypes(event.type)
    CASE thisEvent OF
    
        'RELEASE': BEGIN
            Widget_Control, event.id, /CLEAR_EVENTS
            Widget_Control, event.id, EVENT_PRO='cgSURFACE_DRAW_EVENTS'
            Widget_Control, event.id, DRAW_MOTION_EVENTS=0
            info.xstart = -1
            info.ystart = -1
            info.selectedItem = Obj_New()
            END
            
        'MOTION': BEGIN
            delta_x = (event.x - info.xstart) / Float(info.xsize) 
            delta_y = (event.y - info.ystart) / Float(info.ysize) 
            info.textModel -> Translate, 2*delta_x, 2*delta_y, 0
            info.thisWindow -> Draw, info.thisView
            info.xstart = event.x
            info.ystart = event.y
            END
    ENDCASE
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to allow the user to save the graphics window</span>
<span class="comments">; in a variety of output formats, including raster formats and</span>
<span class="comments">; PostScript.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Output, event

   <span class="comments">; This event handler creates GIF and JPEG files.</span>

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    <span class="comments">; Get a snapshop of window contents. (TVRD equivalent.)</span>
    info.thisWindow->GetProperty, Image_Data=snapshot
    
    <span class="comments">; What kind of file is wanted?</span>
    Widget_Control, event.id, GET_UValue=whichFileType
    CASE whichFileType OF
    
       'GIF': BEGIN
    
             <span class="comments">; Because we are using RGB color for this model, we have</span>
             <span class="comments">; a 3-m-n array. Use Color_Quan to create a 2D image and</span>
             <span class="comments">; appropriate color tables for the GIF file.</span>
    
          image2D = Color_Quan(snapshot, 1, r, g, b)
          filename = Dialog_Pickfile(/Write, File='cgsurface.gif')
          IF filename NE '' THEN Write_GIF, filename, image2d, r, g, b
          END
    
       'JPEG': BEGIN
    
          filename = Dialog_Pickfile(/Write, File='cgsurface.jpg')
          IF filename NE '' THEN Write_JPEG, filename, snapshot, True=1, Quality=100
          END
    
    
       'TIFF': BEGIN
    
          filename = Dialog_Pickfile(/Write, File='cgsurface.tif')
          IF filename NE '' THEN BEGIN
    
             <span class="comments">; TIFF files should have their Y direction reversed for</span>
             <span class="comments">; compatibility with most other software.</span>
    
             Write_TIFF, filename, Reverse(snapshot,3)
          ENDIF
          END
    
       'BMP': BEGIN
          filename = Dialog_Pickfile(/Write, File='cgsurface.bmp')
          IF filename NE '' THEN Write_BMP, filename, snapshot
          END
    
       'PNG': BEGIN
          filename = Dialog_Pickfile(/Write, File='cgsurface.png')
          IF filename NE '' THEN Write_PNG, filename, snapshot
          END
    
       'PS': BEGIN
          filename = Dialog_Pickfile(/Write, File='cgsurface.ps')
          IF filename NE '' THEN BEGIN
             resolution = [2.54, 2.54]/ 600<span class="comments">; 600 pixels per inch</span>
             viewDimensions = [info.xsize, info.ysize] / 100.0 <span class="comments">; 100 pixels in size = 1 inch</span>
             clipboard = Obj_New('IDLgrClipboard', Dimensions=viewDimensions, Resolution=resolution, Unit=1)
             clipboard->Draw, info.thisView, /Postscript, Filename=filename, /Vector
             Obj_Destroy, clipboard
          ENDIF
          END
    
    ENDCASE
    
        <span class="comments">;Put the info structure back.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to allow the user to change various surface properties.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Properties, event

    <span class="comments">; Event handler to set program properties.</span>

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    <span class="comments">; What property is wanted?</span>
    Widget_Control, event.id, Get_UValue=newProperty
    CASE newProperty OF
    
       'ORIGINAL_T3D': info.thisModel->SetProperty, Transform=info.origTransform
       
       'DRAG_LOW': BEGIN
          info.dragQuality = 0
          Widget_Control, info.dragLowID, Sensitive=0
          Widget_Control, info.dragMedID, Sensitive=1
          Widget_Control, info.dragHighID, Sensitive=1
          END
    
       'DRAG_MEDIUM': BEGIN
          info.dragQuality = 1
          Widget_Control, info.dragMedID, Sensitive=0
          Widget_Control, info.dragLowID, Sensitive=1
          Widget_Control, info.dragHighID, Sensitive=1
          END
    
       'DRAG_HIGH': BEGIN
          info.dragQuality = 2
          Widget_Control, info.dragMedID, Sensitive=1
          Widget_Control, info.dragLowID, Sensitive=1
          Widget_Control, info.dragHighID, Sensitive=0
          END
    
    ENDCASE
    
    <span class="comments">; Redraw the graphic.</span>
    info.thisWindow->Draw, info.thisView
    
    <span class="comments">;Put the info structure back.</span>
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to respond to window resizing events.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Resize, event

    <span class="comments">; The only events generated by this simple program are resize</span>
    <span class="comments">; events, which are handled here.</span>

    <span class="comments">; Get the info structure.</span>
    Widget_Control, event.top, Get_UValue=info, /No_Copy

    <span class="comments">; Resize the draw widget. This is the proper way to do this</span>
    <span class="comments">; in object graphics, but it does not always work in UNIX</span>
    <span class="comments">; versions of IDL. If it doesn't work for you, comment the</span>
    <span class="comments">; first line out and try the second. The second line is more</span>
    <span class="comments">; portable, but not exactly the proper "object" way. :-(</span>
    info.thisWindow->SetProperty, Dimension=[event.x, event.y]
    <span class="comments">;Widget_Control, info.drawID, Draw_XSize=event.x, Draw_YSize=event.y</span>
    
    <span class="comments">; Store the new size.</span>
    info.xsize = event.x
    info.ysize = event.y

    <span class="comments">; Redisplay the graphic.</span>
    info.thisWindow->Draw, info.thisView

    <span class="comments">; Update the trackball objects location in the center of the window.</span>
    info.thisTrackball->Reset, [event.x/2, event.y/2], (event.y/2) &lt<span class="comments">; (event.x/2)</span>

    <span class="comments">; Put the info structure back.</span>
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; An event handler to turn the surface skirt on and off.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Skirt_OnOff, event

    <span class="comments">; This event handler turns the skirt on or off.</span>
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    Widget_Control, event.id, Get_Value=buttonValue, Get_UValue=uvalue
    Widget_Control, event.id, Set_Value=uvalue, Set_UValue=buttonValue
    
    CASE buttonValue OF
    
       'Turn Skirt ON':  info.thisSurface -> SetProperty, SHOW_SKIRT=1
       'Turn Skirt OFF': info.thisSurface -> SetProperty, SHOW_SKIRT=0
    
    ENDCASE
    
    <span class="comments">; Draw the graphic display.</span>
    info.thisWindow -> Draw, info.thisView
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; An event handler to respond to events from the Style menu, changing</span>
<span class="comments">; style properties of the surface.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required</span>
<span class="comments">;       The event structure from the graphical user interface of the program.</span>
<span class="comments">;-</span>
PRO cgSurface_Style, event

     <span class="comments">; Event handler to select surface style.</span>

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
    ENDIF

    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    <span class="comments">; Make sure lights are turned on.</span>
    info.nonRotatingLight->SetProperty, Hide=0
    info.rotatingLight->SetProperty, Hide=0
    info.fillLight->SetProperty, Hide=0
    info.ambientLight->SetProperty, Hide=0
    info.thisSurface->SetProperty, Color=info.color
    
    <span class="comments">; What style is wanted?</span>
    Widget_Control, event.id, Get_UValue=newStyle
    CASE newStyle OF
    
       'DOTS': info.thisSurface->SetProperty, Style=0
       'MESH': info.thisSurface->SetProperty, Style=1
       'SOLID': info.thisSurface->SetProperty, Style=2, Shading=1
       'XPARALLEL': info.thisSurface->SetProperty, Style=3
       'YPARALLEL': info.thisSurface->SetProperty, Style=4
       'WIRELEGO': info.thisSurface->SetProperty, Style=5
       'SOLIDLEGO': info.thisSurface->SetProperty, Style=6
       'HIDDEN': BEGIN
           Widget_Control, event.id, Get_Value=buttonValue
           IF buttonValue EQ 'Hidden Lines OFF' THEN BEGIN
              setting = 0
              hlvalue = 'Hidden Lines ON'
           ENDIF ELSE BEGIN
              setting = 1
              hlvalue = 'Hidden Lines OFF'
           ENDELSE
           Widget_Control, event.id, Set_Value=hlvalue
           info.thisSurface->SetProperty, Hidden_Lines=setting
           ENDCASE
    
    ENDCASE
    
    <span class="comments">; Redraw the graphic.</span>
    info.thisWindow->Draw, info.thisView
    
    <span class="comments">; Put the info structure back.</span>
    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; The cleanup routine for the program. Cleans everything up when the widget dies.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    tlb: in, required</span>
<span class="comments">;       The identifier of the widget that just died.</span>
<span class="comments">;-</span>
PRO cgSurface_Cleanup, tlb

    <span class="comments">; Come here when program dies. Free all created objects.</span>
    Widget_Control, tlb, Get_UValue=info
    IF N_Elements(info) NE 0 THEN BEGIN
        Ptr_Free, info.bottomOffPtr
        Obj_Destroy, info.thisContainer
    ENDIF
    
END <span class="comments">;------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; A function for calculating the correct surface aspect ratio. A position</span>
<span class="comments">; in the window with this aspect ratio is returned.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    A four-element POSITION array, giving the position in the window for</span>
<span class="comments">;    a plot with this aspect ratio.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    aspectRatio: in, optional, type=float, default=1.0</span>
<span class="comments">;       The desired aspect ratio of the surface.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    margin: in, optional, type=float, default=0.0</span>
<span class="comments">;       The desired margin around the edges of the window.</span>
<span class="comments">;    windowaspect: in, optional, type=float</span>
<span class="comments">;       The aspect ratio of the window the graphics are to be displayed in.</span>
<span class="comments">;-</span>
FUNCTION cgSurface_Aspect, aspectRatio, MARGIN=margin, WindowAspect=wAspectRatio

    <span class="comments">; This function calculates the correct aspect ratio for display.</span>
    
    ON_ERROR, 2
    
    <span class="comments">; Check for aspect ratio parameter and possibilities.</span>
    IF N_PARAMS() EQ 0 THEN aspectRatio = 1.0
    
    IF aspectRatio EQ 0 THEN BEGIN
       MESSAGE, 'Aspect Ratio of 0. Changing to 1...', /Informational
       aspectRatio = 1.0
    ENDIF
    
    s = SIZE(aspectRatio)
    IF s(s(0)+1) NE 4 THEN $
       MESSAGE, 'Aspect Ratio is not a FLOAT. Take care...', /Informational
    
    <span class="comments">; Check for margins.</span>
    IF N_ELEMENTS(margin) EQ 0 THEN margin = 0
    
    <span class="comments">; Error checking.</span>
    IF margin LT 0 OR margin GE 0.5 THEN $
       MESSAGE, 'The MARGIN keyword value must be between 0.0 and 0.5.'
    
    <span class="comments">; Calculate the aspect ratio of the current window.</span>
    IF N_Elements(wAspectRatio) EQ 0 THEN wAspectRatio = FLOAT(!D.Y_VSIZE) / !D.X_VSIZE
    
    <span class="comments">; Calculate normalized positions in window.</span>
    IF (aspectRatio LE wAspectRatio) THEN BEGIN
       xstart = margin
       ystart = 0.5 - (0.5 - margin) * (aspectRatio / wAspectRatio)
       xend = 1.0 - margin
       yend = 0.5 + (0.5 - margin) * (aspectRatio / wAspectRatio)
    ENDIF ELSE BEGIN
       xstart = 0.5 - (0.5 - margin) * (wAspectRatio / aspectRatio)
       ystart = margin
       xend = 0.5 + (0.5 - margin) * (wAspectRatio / aspectRatio)
       yend = 1.0 - margin
    ENDELSE
    
    <span class="comments">; Return the position in the window.</span>
    RETURN, [xstart, ystart, xend, yend]
        
END <span class="comments">;-----------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">;   The purpose of cgSurface is to create a window where a surface is displayed. Surfaces</span>
<span class="comments">;   can be wire-framed, shaded surfaces, and surfaces with texture maps draped on top of</span>
<span class="comments">;   them, among other types of surfaces. LEFT mouse button rotates the surface, MIDDLE</span>
<span class="comments">;   mouse button zooms out from the surface, RIGHT mouse button zoom into the surface. </span>
<span class="comments">;   Clicking on the surface axes will allow the user to move or translate the surface, and </span>
<span class="comments">;   clicking on the plot title will allow the user to move the title.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, type=any</span>
<span class="comments">;         A two-dimensional array of data to be displayed.</span>
<span class="comments">;    x: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the X coordinates of the</span>
<span class="comments">;         surface grid.</span>
<span class="comments">;    y: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the Y coordinates of the</span>
<span class="comments">;         surface grid.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     axiscolor: in, optional, type=string, default='black'</span>
<span class="comments">;        The name of the axis color. By default, 'black'..</span>
<span class="comments">;     background: in, optional, type=string, default='white'</span>
<span class="comments">;        The name of the background color. By default, 'white'.</span>
<span class="comments">;     block: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to make the program a blocking widget program.</span>
<span class="comments">;     bottom: in, optional, type=string, default=COLOR</span>
<span class="comments">;        The name of the bottom color. By default, same as COLOR.</span>
<span class="comments">;     brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to indicate that the colortable (CTABLE) is</span>
<span class="comments">;        to use Brewer color tables rather than IDL standard color tables.</span>
<span class="comments">;     charsize: in, optional, type=float, default=1.0</span>
<span class="comments">;        The character size of the surface annotation. This value is multiplied</span>
<span class="comments">;        times a 12 point character size.</span>
<span class="comments">;     color: in, optional, type=string, default='blu6'</span>
<span class="comments">;        The name of the data color. </span>
<span class="comments">;     constrain_aspect: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to maintain the aspect ratio of the Y size</span>
<span class="comments">;        of the data to the Y size of the data. The default is to let the</span>
<span class="comments">;        sizes conform to a unit square.</span>
<span class="comments">;     ctable: in, optional, type=integer</span>
<span class="comments">;        The color table to use with the surface. The default is to use the</span>
<span class="comments">;        current color table.</span>
<span class="comments">;     elevation_shading: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to put elevation shading into effect for the surface.</span>
<span class="comments">;     font: in, optional, type=string, default="Helvetica"</span>
<span class="comments">;        The name of the true-type font desired for axis annotation and the plot title. </span>
<span class="comments">;        If undefined, the default is "Helvetica".</span>
<span class="comments">;     hidden_lines: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to turn hidden line removal on for the surface. Turned </span>
<span class="comments">;        ON by default.</span>
<span class="comments">;     group_leader: in, optional, type=long</span>
<span class="comments">;         Set this keyword to the identifier of a widget that will serve as the</span>
<span class="comments">;         group leader for this widget program. When the group leader dies, this</span>
<span class="comments">;         program will die, too.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;        A 3x256 byte array (or 256x3) representing the colors for elevation shading. An alternative</span>
<span class="comments">;        way of specifying the color table, instead of using the `CTable` keyword.</span>
<span class="comments">;     reverse: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to reverse the color table set by CTABLE.</span>
<span class="comments">;     shaded: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to display a shaded surface. The is the same as setting STYLE=2.</span>
<span class="comments">;     skirt: in, optional, type=any</span>
<span class="comments">;         Set this keyword to a Z value where a skirt will be drawn for the surface.</span>
<span class="comments">;     style: in, optional, type=integer, default=1</span>
<span class="comments">;         Sets the style of the surface::</span>
<span class="comments">;         </span>
<span class="comments">;             0 - Dot surface</span>
<span class="comments">;             1 - Wire mesh (the default)</span>
<span class="comments">;             2 - Shaded surface</span>
<span class="comments">;             3 - Parallel X lines</span>
<span class="comments">;             4 - Parallel Y line</span>
<span class="comments">;             5 - Wire mesh lego style</span>
<span class="comments">;             6 - Solid lego style</span>
<span class="comments">;             </span>
<span class="comments">;     texture_image: in, optional, type=byte</span>
<span class="comments">;         Set this keyword to a 2D or true-color image that will be overlaid on the surface</span>
<span class="comments">;         as a texture map. If a 2D image is passed, the colortable specified with CTABLE will</span>
<span class="comments">;         be used to construct a true-color image for the texture map.</span>
<span class="comments">;     tcharsize: in, optional, type=float</span>
<span class="comments">;         The title character size. By default 1.25 times the `Charsize`.</span>
<span class="comments">;     tcolor: in, optional, type=string</span>
<span class="comments">;         The name of the title color. By default, the same as `AxisColor`.</span>
<span class="comments">;     title: in, optional, type=string</span>
<span class="comments">;        The title of the plot. It will be written "flat to the screen", rather than rotated.</span>
<span class="comments">;     transform: in, optional, type=4x4 double array</span>
<span class="comments">;         A homogeneous transformation matrix to be applied to the initial surface. Such a </span>
<span class="comments">;         transformation matrix can be obtained, for example, with the T3D procedure.</span>
<span class="comments">;     xoffset: in, optional, type=integer, default=50</span>
<span class="comments">;         The number of pixels the surface window should be offset in the X direction</span>
<span class="comments">;         from the upper-left corner of the display.</span>
<span class="comments">;     xrange: in, optional, type=float</span>
<span class="comments">;         The X data range of the data. Normally, just chosen from the data itself.</span>
<span class="comments">;     xsize: in, optional, type=interger, default=640</span>
<span class="comments">;         The X size of the initial surface window. By default, 640 pixels.</span>
<span class="comments">;     xstyle: in, hidden</span>
<span class="comments">;         The normal XSTYLE keyword.</span>
<span class="comments">;     xtitle: in, optional, type=string</span>
<span class="comments">;         The text for the X axis of the surface plot.</span>
<span class="comments">;     yoffset: in, optional, type=integer, default=25</span>
<span class="comments">;         The number of pixels the surface window should be offset in the Y direction</span>
<span class="comments">;         from the upper-left corner of the display.</span>
<span class="comments">;     yrange: in, optional, type=float</span>
<span class="comments">;         The Y data range of the data. Normally, just chosen from the data itself.</span>
<span class="comments">;     ysize: in, optional, type=integer, default=512</span>
<span class="comments">;         The Y size of the initial surface window. By default, 640 pixels.</span>
<span class="comments">;     ystyle: in, hidden</span>
<span class="comments">;         The normal YSTYLE keyword.</span>
<span class="comments">;     ytitle: in, optional, type=string</span>
<span class="comments">;         The text for the Y axis of the surface plot.</span>
<span class="comments">;     zrange: in, optional, type=float</span>
<span class="comments">;         The Z data range of the data. Normally, just chosen from the data itself.</span>
<span class="comments">;     zscale: in, optional, type=float, default=1.0</span>
<span class="comments">;          A number between 0.001 and 1.0 that will "scale" the Z axis height. Default is 1.0.</span>
<span class="comments">;     zstyle: in, hidden</span>
<span class="comments">;         The normal ZSTYLE keyword.</span>
<span class="comments">;     ztitle: in, optional, type=string</span>
<span class="comments">;         The text for the Z axis of the surface plot.</span>
<span class="comments">;     _extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDLgrSurface object is allowed in the program.</span>
<span class="comments">;-</span>
PRO cgSurface, data, x, y, $
    Axiscolor=axiscolorName, $
    Background=backgroundName, $
    Block=block, $
    Bottom=bottomName, $
    Brewer=brewer, $
    Charsize=charsize, $
    Color=colorName, $
    Constrain_Aspect=constrain_aspect, $
    CTable=colortable, $
    Elevation_Shading=elevation_shading, $
    Font=font, $
    Hidden_Lines=hidden_lines, $
    Group_Leader=groupLeader, $
    Palette=palette, $
    Reverse=reverse, $
    Shaded=shaded, $
    Skirt=skirt, $
    Style=style, $
    Texture_Image=texture_image, $
    Title=plotTitleText, $
    TCharsize=tcharsize, $
    TColor=tcolorName, $
    Transform=transform, $
    XOffset=xoffset, $
    XRange=xrange_u, $
    XSize=xsize, $
    XStyle=xstyle, $
    XTitle=xtitleText, $
    YOffset=yoffset, $
    YRange=yrange_u, $
    YSize=ysize, $
    YStyle=ystyle, $
    YTitle=ytitleText, $
    ZRange=zrange_u, $
    ZScale=zscale, $
    ZStyle=zstyle, $
    ZTitle=ztitleText, $
    _Extra=extra

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
  
    <span class="comments">; Did the user pass parameters?</span>
    IF N_Params() EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgSurface, data, x, y'
        RETURN
    ENDIF
    
    <span class="comments">; We can only do this on devices that support windows.</span>
    IF (!D.Flags AND 256) EQ 0 THEN $
        Message, 'This program only works on devices that support windows.'
        
    <span class="comments">; We are going to do this in decomposed color mode.</span>
    SetDecomposedState, 1, CurrentState=currentDecomposedState
      
    <span class="comments">; Check parameters.</span>
    IF N_Elements(data) EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgSurface, data, x, y'
        Print, 'Using example data.'
        data = cgDemoData(2)
    ENDIF
    
    <span class="comments">; Get the current color table vectors. May need them later.</span>
    TVLCT, rr, gg, bb, /GET
    
    ndims = Size(data, /N_DIMENSIONS)
    IF ndims NE 2 THEN Message, 'Data must be 2D.'
    s = Size(data, /DIMENSIONS)
    IF N_Elements(x) EQ 0 THEN x = Findgen(s[0])
    IF N_Elements(y) EQ 0 THEN y = Findgen(s[1])
    
    <span class="comments">; Check keywords.</span>
    IF N_Elements(axisColorName) EQ 0 THEN axisColorName = 'black' 
    IF N_Elements(backgroundName) EQ 0 THEN backgroundName = 'white' 
    IF N_Elements(tcolorName) EQ 0 THEN tcolorName = axisColorName 
    IF N_Elements(colorName) EQ 0 THEN colorName = 'blu6' 
    IF N_Elements(bottomName) EQ 0 THEN bottomName = 'dark gray' 
    IF N_Elements(palette) EQ 0 THEN BEGIN
        IF N_Elements(colortable) EQ 0 THEN BEGIN
            colors = Transpose([[rr],[gg], [bb]])
            colortable = -1
        ENDIF ELSE BEGIN
            cgLoadCT, colortable, Reverse=Keyword_Set(reverse), Brewer=Keyword_Set(brewer), $
                RGB_TABLE=colors, /ROW
        ENDELSE
    ENDIF ELSE BEGIN
        spal = Size(palette, /Dimensions)
        IF spal[0] NE 3 THEN colors = Transpose(palette) ELSE colors = palette
        colortable = -1
    ENDELSE
    
    <span class="comments">; Create a color palette for use later.</span>
    colorPalette = Obj_New("IDLgrPalette", colors[0,*], colors[1,*], colors[2,*])

    block = Keyword_Set(block)
    brewer = Keyword_Set(brewer)
    IF N_Elements(charsize) EQ 0 THEN charsize = 1.0
    constrain_aspect = Keyword_Set(constrain_aspect)
    elevation_shading = Keyword_Set(elevation_shading)
    IF N_Elements(font) EQ 0 THEN font = 'Helvetica'
    IF N_Elements(hidden_lines) EQ 0 THEN hidden_lines = 1
    hidden_lines = Keyword_Set(hidden_lines)
    reverse = Keyword_Set(reverse)
    IF N_Elements(xoffset) EQ 0 THEN xoffset = 50
    IF N_Elements(yoffset) EQ 0 THEN yoffset = 25
    IF Keyword_Set(shaded) THEN style = 2
    IF N_Elements(style) EQ 0 THEN style = 1
    IF N_Elements(tcharsize) EQ 0 THEN tcharsize = 1.25
    IF N_Elements(zscale) EQ 0 THEN zscale = 1.0
    zscale = 0.001 > zscale &lt<span class="comments">; 1.0</span>
    shading = 1 <span class="comments">; Always do Gouraud shading when style=2.</span>
    bottomOffPtr = Ptr_New(/ALLOCATE_HEAP) <span class="comments">; Pointer to turn bottom colors off.</span>
    specularColor = [200,200,200]
    IF N_Elements(xstyle) EQ 0 THEN xstyle = 0
    IF N_Elements(ystyle) EQ 0 THEN ystyle = 0
    IF N_Elements(zstyle) EQ 0 THEN zstyle = 0
    IF N_Elements(xsize) EQ 0 THEN xsize = 640
    IF N_Elements(ysize) EQ 0 THEN ysize = 512
    IF N_Elements(xtitleText) EQ 0 THEN xtitleText = ""
    IF N_Elements(ytitleText) EQ 0 THEN ytitleText = ""
    IF N_Elements(ztitleText) EQ 0 THEN ztitleText = ""
    IF N_Elements(plotTitleText) EQ 0 THEN plotTitleText = ""
    
    <span class="comments">; If the colors are strings, they need to be converted to row vectors.</span>
    <span class="comments">; If they are LONGS, they need to be decomposed to a row vector.</span>
    <span class="comments">; If they are NOT longs, they must be indices into the color table.</span>
    IF Size(axiscolorName, /TNAME) EQ 'STRING' THEN axiscolor = cgColor(axiscolorName, /Triple, /Row)
    IF N_Elements(axiscolor) NE 3 THEN BEGIN
        IF Size(axiscolor, /TNAME) EQ 'LONG' THEN BEGIN
            axiscolor = [Byte(axiscolor), Byte(axiscolor,1), Byte(axiscolor,2)]
        ENDIF ELSE BEGIN
            axiscolor = [rr[0>axiscolor&lt<span class="comments">;255],gg[0>axiscolor&lt;255],bb[0>axiscolor&lt;255]]</span>
        ENDELSE
    ENDIF
    IF Size(backgroundName, /TNAME) EQ 'STRING' THEN background = cgColor(backgroundName, /Triple, /Row)
    IF N_Elements(background) NE 3 THEN BEGIN
        IF Size(background, /TNAME) EQ 'LONG' THEN BEGIN
            background = [Byte(background), Byte(background,1), Byte(background,2)]
        ENDIF ELSE BEGIN
            background = [rr[0>background&lt<span class="comments">;255],gg[0>background&lt;255],bb[0>background&lt;255]]</span>
        ENDELSE
    ENDIF
    IF Size(bottomName, /TNAME) EQ 'STRING' THEN bottom = cgColor(bottomName, /Triple, /Row)
    IF N_Elements(bottom) NE 3 THEN BEGIN
        IF Size(bottom, /TNAME) EQ 'LONG' THEN BEGIN
            bottom = [Byte(bottom), Byte(bottom,1), Byte(bottom,2)]
        ENDIF ELSE BEGIN
            bottom = [rr[0>bottom&lt<span class="comments">;255],gg[0>bottom&lt;255],bb[0>bottom&lt;255]]</span>
        ENDELSE
    ENDIF
    IF Size(colorName, /TNAME) EQ 'STRING' THEN color = cgColor(colorName, /Triple, /Row)
    IF N_Elements(color) NE 3 THEN BEGIN
        IF Size(color, /TNAME) EQ 'LONG' THEN BEGIN
            color = [Byte(color), Byte(color,1), Byte(color,2)]
        ENDIF ELSE BEGIN
            color = [rr[0>color&lt<span class="comments">;255],gg[0>color&lt;255],bb[0>color&lt;255]]</span>
        ENDELSE
    ENDIF
    IF Size(tcolorName, /TNAME) EQ 'STRING' THEN tcolor = cgColor(tcolorName, /Triple, /Row)
    IF N_Elements(tcolor) NE 3 THEN BEGIN
        IF Size(tcolor, /TNAME) EQ 'LONG' THEN BEGIN
            tcolor = [Byte(tcolor), Byte(tcolor,1), Byte(tcolor,2)]
        ENDIF ELSE BEGIN
            tcolor = [rr[0>tcolor&lt<span class="comments">;255],gg[0>tcolor&lt;255],bb[0>tcolor&lt;255]]</span>
        ENDELSE
    ENDIF
    
    <span class="comments">; Should we constrain the aspect ratio of the surface?</span>
    IF constrain_aspect THEN BEGIN
    
       <span class="comments">; I want the surface data to have the same aspect ratio as </span>
       <span class="comments">; the data itself in the X and Y directions.</span>
       s = Size(data, /DIMENSIONS)
       surfaceAspect = Float(s[1]) / s[0]
       windowAspect = Float(ysize) / xsize
       pos = cgSurface_Aspect(surfaceAspect, WindowAspect=windowAspect, Margin=0)
       pos = [pos[0], pos[2], pos[1], pos[3], 0.0, 1.0] - 0.5
    
    ENDIF ELSE pos = [0, 1, 0, 1, 0, 1] - 0.5
    
    <span class="comments">; Do you have a texture image?</span>
    IF N_Elements(texture_image) NE 0 THEN BEGIN
    
        <span class="comments">; Create a texture image object.</span>
        ndims = Size(texture_image, /N_DIMENSIONS)
        IF ndims LT 2 OR ndims GT 3 THEN Message, 'Texture image must be a 2D or 3D array.'
        type = Size(texture_image, /TYPE)
        IF type GT 1 THEN Message, 'Texture image must be a byte array.'
        IF ndims EQ 2 THEN BEGIN
            textureImage = Obj_New('IDLgrImage', texture_image, PALETTE=colorPalette)
        ENDIF ELSE BEGIN
            textureImage = Obj_New('IDLgrImage', texture_image)
        ENDELSE
        
        <span class="comments">; Set up texture coordinates.</span>
        imageDims = Image_Dimensions(data, XSize=ixsize, YSize=iysize, TrueIndex=trueindex) 
        texcoords = FltArr(2, ixsize, iysize)
        texcoords[0,*,*] = (Findgen(ixsize)#Replicate(1,iysize)) / (ixsize-1)
        texcoords[1,*,*] = (Replicate(1,iysize)#Findgen(ixsize)) / (ixsize-1)
       
        <span class="comments">; Need white surface.</span>
        color = [255, 255, 255]
        
        <span class="comments">; Need shaded surface.</span>
        style = 2
    ENDIF
    
    <span class="comments">; Create a view. The coodinate system is chosen so that (0,0,0) is in the</span>
    <span class="comments">; center of the window. This will make rotations easier.</span>
    IF plotTitleText EQ "" THEN BEGIN
       viewrect = [-1.0,-1.0,1.9,1.9]
    ENDIF ELSE BEGIN
       viewrect = [-1.0,-1.0,1.9,2.0]
    ENDELSE
    thisView = OBJ_NEW('IDLgrView', Color=background, Viewplane_Rect=viewrect)
    
    <span class="comments">; Create a model for the surface and axes and add it to the view.</span>
    <span class="comments">; This model will rotate under the direction of the trackball object.</span>
    thisModel = OBJ_NEW('IDLgrModel')
    thisView->Add, thisModel
    
    <span class="comments">; Create a separate model for the title that doesn't rotate.</span>
    textModel = Obj_New('IDLgrModel')
    thisView->Add, textModel
    
    <span class="comments">; Create helper objects. First, create title objects</span>
    <span class="comments">; for the axes and plot. Color them green.</span>
    xTitle = Obj_New('IDLgrText', xtitleText, Color=axisColor, /Enable_Formatting)
    yTitle = Obj_New('IDLgrText', ytitleText, Color=axisColor, /Enable_Formatting)
    zTitle = Obj_New('IDLgrText', ztitleText, Color=axisColor, /Enable_Formatting)
    
    <span class="comments">; Create font objects.</span>
    axisFont  = Obj_New('IDLgrFont', font, Size=12*charsize)
    titleFont = Obj_New('IDLgrFont', font, Size=12*tcharsize)
    
    <span class="comments">; Create a plot title object. I am going to place the title</span>
    <span class="comments">; centered in X and towards the top of the viewplane rectangle.</span>
    plotTitle = Obj_New('IDLgrText', plotTitleText, Color=tcolor, /Enable_Formatting, $
       Alignment=0.5, Location=[0.0, 0.75, 0.0], Font=titleFont)
    textModel->Add, plotTitle
    
    <span class="comments">; Create a trackball for surface rotations. Center it in</span>
    <span class="comments">; the graphics window. Give it a 300 pixel diameter.</span>
    thisTrackball = OBJ_NEW('Trackball', [xsize/2,ysize/2], 300)
        
    <span class="comments">; Create a surface object. </span>
    IF elevation_shading THEN BEGIN
        thisSurface = OBJ_NEW('IDLgrSurface', data, x, y, $
           Color=color, _Strict_Extra=extra, Style=style, $
           Shading=shading, Hidden_Lines=hidden_lines)
    ENDIF ELSE BEGIN
        thisSurface = OBJ_NEW('IDLgrSurface', data, x, y, $
           Color=color, _Strict_Extra=extra, Style=style, $
           Shading=shading, Hidden_Lines=hidden_lines, BOTTOM=bottom, $
           SPECULAR=specularColor)    
    ENDELSE
    
    <span class="comments">; Do you have a texture image?</span>
    IF N_Elements(texture_image) GT 0 THEN BEGIN
        thisSurface -> SetProperty, Texture_Map=textureImage, Texture_Coord=texcoords
    ENDIF
    
    <span class="comments">; Did you want a skirt?</span>
    IF N_Elements(skirt) NE 0 THEN BEGIN
        thisSurface -> SetProperty, SKIRT=skirt, /SHOW_SKIRT
    ENDIF
    
    <span class="comments">; Get the data ranges of the surface. Use the ranges from the surface,</span>
    <span class="comments">; unless the user specified something else.</span>
    thisSurface->GetProperty, XRange=xrange, YRange=yrange, ZRange=zrange
    IF N_Elements(xrange_u) NE 0 THEN xrange = xrange_u
    IF N_Elements(yrange_u) NE 0 THEN yrange = yrange_u
    IF N_Elements(zrange_u) NE 0 THEN zrange = zrange_u
    
    <span class="comments">; Create axes objects for the surface. Axes are created after the surface </span>
    <span class="comments">; so the range can be set correctly. Note how I set the font.</span>
    xAxis = Obj_New("IDLgrAxis", 0, Color=axisColor, Ticklen=0.1, $
       Minor=4, Title=xtitle, Range=xrange, Exact=(xstyle AND 1), Hide=(xstyle AND 4))
    xAxis->GetProperty, Ticktext=xAxisText
    xAxisText->SetProperty, Font=axisFont
    
    yAxis = Obj_New("IDLgrAxis", 1, Color=axisColor, Ticklen=0.1, $
       Minor=4, Title=ytitle, Range=yrange, Exact=(ystyle AND 1), Hide=(ystyle AND 4))
    yAxis->GetProperty, Ticktext=yAxisText
    yAxisText->SetProperty, Font=axisFont
    
    zAxis = Obj_New("IDLgrAxis", 2, Color=axisColor, Ticklen=0.1, $
       Minor=4, Title=ztitle, Range=zrange, Exact=(zstyle AND 1), Hide=(zstyle AND 4))
    zAxis->GetProperty, Ticktext=zAxisText
    zAxisText->SetProperty, Font=axisFont
    
    <span class="comments">; The axes may not use exact axis scaling, so the ranges may</span>
    <span class="comments">; have changed from what they were originally set to. Get</span>
    <span class="comments">; and update the range variables.</span>
    xAxis->GetProperty, CRange=xrange
    yAxis->GetProperty, CRange=yrange
    zAxis->GetProperty, CRange=zrange
    
    <span class="comments">; If you want elevation shading, have to set the colors up now.</span>
    IF elevation_shading THEN BEGIN
       s = Size(data, /Dimensions)
       thisSurface->SetProperty, Vert_Colors=Reform(BytScl(data, /NAN, Min=Min(data), Max=Max(data)), $
          s[0]*s[1]), Palette=colorPalette
    ENDIF
    
    <span class="comments">; Set scaling parameters for the surface and axes so that everything</span>
    <span class="comments">; is scaled into the range -0.5 to 0.5. We do this so that when the</span>
    <span class="comments">; surface is rotated we don't have to worry about translations. In</span>
    <span class="comments">; other words, the rotations occur about the point (0,0,0).</span>
    xs = cgNormalize(xrange, Position=[pos[0], pos[1]])
    ys = cgNormalize(yrange, Position=[pos[2], pos[3]])
    zs = cgNormalize(zrange, Position=[pos[4], pos[5]] * zscale)
    
    <span class="comments">; Scale the axes and place them in the coordinate space.</span>
    <span class="comments">; Note that not all values in the Location keyword are</span>
    <span class="comments">; used. (I've put really large values into the positions</span>
    <span class="comments">; that are not being used to demonstate this.) For</span>
    <span class="comments">; example, with the X axis only the Y and Z locations are used.</span>
    xAxis->SetProperty, Location=[9999.0, pos[2],  pos[4]*zscale], XCoord_Conv=xs
    yAxis->SetProperty, Location=[pos[0], 9999.0,  pos[4]*zscale], YCoord_Conv=ys
    zAxis->SetProperty, Location=[pos[0],  pos[3], 9999.0], ZCoord_Conv=zs
    
    <span class="comments">; Scale the surface.</span>
    thisSurface->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
    
    <span class="comments">; Add the surface and axes objects to the model.</span>
    thisModel->Add, thisSurface
    thisModel->Add, xAxis
    thisModel->Add, yAxis
    thisModel->Add, zAxis
    
    <span class="comments">; Rotate the surface model to the standard surface view or </span>
    <span class="comments">; apply a transformation matrix, if you have one.</span>
    IF N_Elements(transform) NE 0 THEN BEGIN
      thisModel -> SetProperty, Transform=transform
    ENDIF ELSE BEGIN
      thisModel->Rotate,[1,0,0], -90  <span class="comments">; To get the Z-axis vertical.</span>
      thisModel->Rotate,[0,1,0],  30  <span class="comments">; Rotate it slightly to the right.</span>
      thisModel->Rotate,[1,0,0],  30  <span class="comments">; Rotate it down slightly.</span>
    ENDELSE
    
    <span class="comments">; Create some lights to view the surface. Surfaces will look</span>
    <span class="comments">; best if there is some ambient lighting to illuminate them</span>
    <span class="comments">; uniformly, and some positional lights to give the surface</span>
    <span class="comments">; definition. We will create three positional lights: one,</span>
    <span class="comments">; non-rotating light will provide overhead definition. Two</span>
    <span class="comments">; rotating lights will provide specific surface definition.</span>
    <span class="comments">; Lights should be turned off or hidden if elevation shading</span>
    <span class="comments">; is in effect.</span>
    
    <span class="comments">; First create the ambient light. Don't turn it on too much,</span>
    <span class="comments">; or the surface will appear washed out.</span>
    ambientLight = Obj_New('IDLgrLight', Type=0, Intensity=0.2)
    thisModel->Add, ambientLight
    
    <span class="comments">; Shaded surfaces will not look shaded unless there is a</span>
    <span class="comments">; positional light source to give the surface edges definition.</span>
    <span class="comments">; This light will rotate with the surface.</span>
    rotatingLight = Obj_New('IDLgrLight', Type=1, Intensity=0.60, $
        Location=[xrange[1], yrange[1], 4*zrange[1]], $
        Direction=[xrange[0], yrange[0], zrange[0]])
    thisModel->Add, rotatingLight
    
    <span class="comments">; Create a fill light source so you can see the underside</span>
    <span class="comments">; of the surface. Otherwise, just the top surface will be visible.</span>
    <span class="comments">; This light will also rotate with the surface.</span>
    fillLight = Obj_New('IDLgrLight', Type=1, Intensity=0.4, $
       Location=[(xrange[1]-xrange[0])/2.0, (yrange[1]-yrange[0])/2.0, -2*Abs(zrange[0])], $
       Direction=[(xrange[1]-xrange[0])/2.0, (yrange[1]-yrange[0])/2.0, zrange[1]])
    thisModel->Add, fillLight
    
    <span class="comments">; Create a non-rotating overhead side light.</span>
    nonrotatingLight = Obj_New('IDLgrLight', Type=1, Intensity=0.8, $
        Location=[-xrange[1], (yrange[1]-yrange[0])/2.0, 4*zrange[1]], $
        Direction=[xrange[1], (yrange[1]-yrange[0])/2.0, zrange[0]])
    nonrotatingModel = Obj_New('IDLgrModel')
    nonrotatingModel->Add, nonrotatingLight
    
    <span class="comments">; Be sure to add the non-rotating model to the view, or it won't be visualized.</span>
    thisView->Add, nonrotatingModel
    
    <span class="comments">; Scale the light sources.</span>
    rotatingLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
    fillLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
    nonrotatingLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
    
    <span class="comments">; Rotate the non-rotating model to the standard surface view or apply</span>
    <span class="comments">; the transformation matrix, if you have one.</span>
    IF N_Elements(transform) NE 0 THEN BEGIN
      nonrotatingModel -> SetProperty, Transform=transform
    ENDIF ELSE BEGIN
      nonrotatingModel->Rotate,[1,0,0], -90  <span class="comments">; To get the Z-axis vertical.</span>
      nonrotatingModel->Rotate,[0,1,0],  30  <span class="comments">; Rotate it slightly to the right.</span>
      nonrotatingModel->Rotate,[1,0,0],  30  <span class="comments">; Rotate it down slightly.</span>
    ENDELSE
    
    <span class="comments">; Check for availability of GIF files.</span>
    thisVersion = Float(!Version.Release)
    IF (thisVersion LT 5.4) OR (thisVersion GT 6.3) THEN haveGif = 1 ELSE haveGIF = 0
    
    <span class="comments">; Create the widgets to view the surface. </span>
    <span class="comments">; Button events are on to enable trackball movement.</span>
    tlb = Widget_Base(Title='Resizeable Surface Window', Column=1, $
       TLB_Size_Events=1, MBar=menubase, XOFFSET=xoffset, YOFFSET=yoffset)
    
    <span class="comments">; Sigh...Rendering throws a LOT of floating point exception errors, especially</span>
    <span class="comments">; when asking IDL to to the retaining for backing store. You can solve the problem</span>
    <span class="comments">; in one of two ways. Do your own backing store by turning EXPOSE events on, which</span>
    <span class="comments">; has its own problems when working with blocking widgets, or do the rendering</span>
    <span class="comments">; in software. The code exists here for you to choose your own poison. :-(</span>
    <span class="comments">;drawID = Widget_Draw(tlb, XSize=400, YSize=400, Graphics_Level=2, $</span>
    <span class="comments">;   Event_Pro='cgSurface_Draw_Events', Button_Events=1, Retain=2)</span>
    <span class="comments">;drawID = Widget_Draw(tlb, XSize=400, YSize=400, Graphics_Level=2, $</span>
    <span class="comments">;   Event_Pro='cgSurface_Draw_Events', Button_Events=1, Expose_Events=1)</span>
    drawID = Widget_Draw(tlb, XSize=xsize, YSize=ysize, Graphics_Level=2, $
       Event_Pro='cgSurface_Draw_Events', Button_Events=1, Retain=1, Renderer=1)
    
    <span class="comments">; Create FILE menu buttons.</span>
    filer = Widget_Button(menubase, Value='File', /Menu)
    
    <span class="comments">; Create OUTPUT menu buttons for formatted output files. Use GIF</span>
    <span class="comments">; files if available.</span>
    output = Widget_Button(filer, Value='Save As...', /Menu)
    button = Widget_Button(output, Value='PostScript File', $
       UValue='PS', Event_Pro='cgSurface_Output')
    button = Widget_Button(output, Value='BMP File', $
       UValue='BMP', Event_Pro='cgSurface_Output')
    IF havegif THEN gif = Widget_Button(output, Value='GIF File', $
       UValue='GIF', Event_Pro='cgSurface_Output')
    button = Widget_Button(output, Value='JPEG File', $
       UValue='JPEG', Event_Pro='cgSurface_Output')
    button = Widget_Button(output, Value='PNG File', $
       UValue='PNG', Event_Pro='cgSurface_Output')
    button = Widget_Button(output, Value='TIFF File', $
       UValue='TIFF', Event_Pro='cgSurface_Output')
    
    quitter = Widget_Button(filer, /Separator, Value='Exit', $
       Event_Pro='cgSurface_Exit')
    
    <span class="comments">; Create STYLE menu buttons for surface style.</span>
    style = Widget_Button(menubase, Value='Style', /Menu)
    dummy = Widget_Button(style, Value='Dot Surface', $
       Event_Pro='cgSurface_Style', UValue='DOTS')
    dummy = Widget_Button(style, Value='Wire Mesh', $
       Event_Pro='cgSurface_Style', UValue='MESH')
    dummy = Widget_Button(style, Value='Solid', $
       Event_Pro='cgSurface_Style', UValue='SOLID')
    dummy = Widget_Button(style, Value='Parallel X Lines', $
       Event_Pro='cgSurface_Style', UValue='XPARALLEL')
    dummy = Widget_Button(style, Value='Parallel Y Lines', $
       Event_Pro='cgSurface_Style', UValue='YPARALLEL')
    dummy = Widget_Button(style, Value='Wire Mesh Lego', $
       Event_Pro='cgSurface_Style', UValue='WIRELEGO')
    dummy = Widget_Button(style, Value='Solid Lego', $
       Event_Pro='cgSurface_Style', UValue='SOLIDLEGO')
    IF hidden_lines THEN hlValue = 'Hidden Lines OFF' ELSE hlValue='Hidden Lines ON'
    dummy = Widget_Button(style, Value=hlvalue, $
       Event_Pro='cgSurface_Style', UValue='HIDDEN', /Separator)
    
    IF elevation_shading THEN BEGIN
       elevationID = Widget_Button(style, Value='Elevation Shading OFF', $
          /Separator, UValue='Elevation Shading ON', $
          Event_Pro='cgSurface_Elevation_Shading')
          thisSurface -> SetProperty, Bottom=bottomOffPtr
    ENDIF ELSE BEGIN
       elevationID = Widget_Button(style, Value='Elevation Shading ON', $
          /Separator, UValue='Elevation Shading OFF', $
          Event_Pro='cgSurface_Elevation_Shading')
    ENDELSE
   
    IF elevation_shading THEN BEGIN
       bottomID = Widget_Button(style, Value='Bottom Color ON', $
          /Separator, UValue='Bottom Color OFF', $
          Event_Pro='cgSurface_Bottom_OnOff')
          thisSurface -> SetProperty, Bottom=bottomOffPtr
    ENDIF ELSE BEGIN
       bottomID = Widget_Button(style, Value='Bottom Color OFF', $
          /Separator, UValue='Bottom Color ON', $
          Event_Pro='cgSurface_Bottom_OnOff')
    ENDELSE
    
    void = Widget_Button(style, Value='Turn Axes OFF', $
          /Separator, UValue='Turn Axes ON', $
          Event_Pro='cgSurface_Axes_OnOff')
    
    IF N_Elements(skirt) GT 0 THEN BEGIN
        skirtID = Widget_Button(style, Value='Turn Skirt OFF', $
          /Separator, UValue='Turn Skirt ON', $
          Event_Pro='cgSurface_Skirt_OnOff')
    ENDIF
    <span class="comments">; Create PROPERTIES menu buttons for surface properties.</span>
    properties = Widget_Button(menubase, Value='Properties', /Menu, $
       Event_Pro='cgSurface_Properties')
    
    <span class="comments">; Background Color</span>
    colorID = Widget_Button(properties, Value='Colors', /Menu, $
        Event_Pro='cgSurface_Change_Colors')
    dummy = Widget_Button(colorID, Value='Surface Color', UValue=colorName)
    dummy = Widget_Button(colorID, Value='Bottom Color', UValue=bottomName)
    dummy = Widget_Button(colorID, Value='Axis Color', UValue=axiscolorName)
    dummy = Widget_Button(colorID, Value='Background Color', UValue=backgroundName)
    dummy = Widget_Button(colorID, Value='Title Color', UValue=tColorName)
    
    colorsID = Widget_Button(colorID, Value='Elevation Color Table', $
       Event_Pro='cgSurface_Elevation_Colors', /Separator)
     
    <span class="comments">; Original Axis rotation.</span>
    dummy = Widget_Button(properties, Value='Original Rotation', /Separator, $
       Event_Pro='cgSurface_Properties', UValue='ORIGINAL_T3D')
    
    <span class="comments">; Drag Quality.</span>
    dragID = Widget_Button(properties, Value='Drag Quality', /Separator, /Menu)
       dragLowID = Widget_Button(dragID, Value='Low', $
          Event_Pro='cgSurface_Properties', UValue='DRAG_LOW')
       dragMedID = Widget_Button(dragID, Value='Medium', $
          Event_Pro='cgSurface_Properties', UValue='DRAG_MEDIUM')
       dragHighID = Widget_Button(dragID, Value='High', $
          Event_Pro='cgSurface_Properties', UValue='DRAG_HIGH')
    Widget_Control, dragHighID, Sensitive=0
    
    <span class="comments">; Light controller.</span>
    lightID = Widget_Button(properties, Value='Light Controls...', $
       /Separator, Event_Pro='cgSurface_Light_Controls')
    
    <span class="comments">; Draw the widgets.</span>
    Widget_Control, tlb, /Realize
    
   <span class="comments">; Get the window destination object. The view will</span>
   <span class="comments">; be drawn when the window is exposed.</span>
    Widget_Control, drawID, Get_Value=thisWindow
    thisWindow -> Draw, thisView
    
    <span class="comments">; Create a container object to hold all the other</span>
    <span class="comments">; objects. This will make it easy to free all the</span>
    <span class="comments">; objects when we are finished with the program.</span>
    thisContainer = Obj_New('IDL_Container')
    
    <span class="comments">; Add created objects to the container.</span>
    thisContainer->Add, thisView
    thisContainer->Add, thisTrackball
    thisContainer->Add, xTitle
    thisContainer->Add, yTitle
    thisContainer->Add, zTitle
    thisContainer->Add, xAxis
    thisContainer->Add, yAxis
    thisContainer->Add, zAxis
    thisContainer->Add, thisSurface
    thisContainer->Add, nonRotatingModel
    thisContainer->Add, thisModel
    thisContainer->Add, plotTitle
    thisContainer->Add, axisFont
    thisContainer->Add, titleFont
    thisContainer->Add, colorPalette
    IF Obj_Valid(textureImage) THEN thisContainer->Add, textureImage
    
    <span class="comments">; Get the current transformation matrix, so it can be restored.</span>
    thisModel->GetProperty, Transform=origTransform
    
    <span class="comments">; Create an INFO structure to hold needed program information.</span>
    info = { origTransform:origTransform, $       <span class="comments">; The transformation matrix.</span>
             thisContainer:thisContainer, $       <span class="comments">; The object container.</span>
             thisWindow:thisWindow, $             <span class="comments">; The window object.</span>
             thisSurface:thisSurface, $           <span class="comments">; The surface object.</span>
             thisTrackball:thisTrackball, $       <span class="comments">; The trackball object.</span>
             thisModel:thisModel, $               <span class="comments">; The model object.</span>
             textModel:textModel, $               <span class="comments">; The model holding the instructions.</span>
             xAxis:xAxis, $                       <span class="comments">; The X Axis object.</span>
             yAxis:yAxis, $                       <span class="comments">; The Y Axis object.</span>
             zAxis:zAxis, $                       <span class="comments">; The Z Axis object.</span>
             xTitle:xTitle, $                     <span class="comments">; The X Title object.</span>
             yTitle:yTitle, $                     <span class="comments">; The Y Title object.</span>
             zTitle:zTitle, $                     <span class="comments">; The Z Title object.</span>
             xsize:xsize, $
             ysize:ysize, $
             xstart:-1, $
             ystart:-1, $
             selectedItem:Obj_New(), $
             specularColor:specularColor, $
             bottomOffPtr:bottomOffPtr, $         <span class="comments">; The pointer to turn the bottom color off.</span>
             nonRotatingLight:nonRotatingLight, $ <span class="comments">; The non-rotating light object.</span>
             rotatingLight:rotatingLight, $       <span class="comments">; The rotating light object.</span>
             fillLight:fillLight, $               <span class="comments">; The fill light object.</span>
             ambientLight:ambientLight, $         <span class="comments">; The ambient light object.</span>
             colorPalette:colorPalette, $         <span class="comments">; The surface color palette.</span>
             colorsID:colorsID, $                 <span class="comments">; The color button for the texture map.</span>
             drawID:drawID, $                     <span class="comments">; The widget identifier of the draw widget.</span>
             colortable:colortable, $             <span class="comments">; The current color table.</span>
             brewer:brewer, $
             reverse:reverse, $
             r:rr, $                               <span class="comments">; The R values of the current color table.</span>
             g:gg, $                               <span class="comments">; The G values of the current color table.</span>
             b:bb, $                               <span class="comments">; The B values of the current color table.</span>
             data:data, $                         <span class="comments">; The original 2D data set.</span>
             elevation_shading:elevation_shading, $               <span class="comments">; An elevation shading flag.</span>
             elevationID:elevationID, $           <span class="comments">; The ID of the Elevation Shading button.</span>
             bottomID:bottomID, $
             lightID:lightID, $                   <span class="comments">; The light control button ID.</span>
             plotTitle:plotTitle, $               <span class="comments">; The plot title object.</span>
             dragLowID:dragLowID, $               <span class="comments">; ID of Drag Quality Low button.</span>
             dragMedID:dragMedID, $               <span class="comments">; ID of Drag Quality Medium button.</span>
             dragHighID:dragHighID, $             <span class="comments">; ID of Drag Quality High button.</span>
             dragQuality:2, $                     <span class="comments">; The current drag quality.</span>
             color:color, $
             axiscolor:axiscolor, $
             background:background, $
             bottom:bottom, $
             thisView:thisView }                  <span class="comments">; The view object.</span>
    
    <span class="comments">; Store the info structure in the UValue of the TLB.</span>
    Widget_Control, tlb, Set_UValue=info, /No_Copy
    
    <span class="comments">; Call XManager. Set a cleanup routine so the objects</span>
    <span class="comments">; can be freed upon exit from this program.</span>
    XManager, 'cgsurface', tlb, Cleanup='cgSurface_Cleanup', $
       No_Block=(1 - Keyword_Set(block)), $
       Event_Handler='cgSurface_Resize', Group_Leader=groupLeader
    
END <span class="comments">;-----------------------------------------------------------------------------------------</span>
   
</code>
    </div>
  </body>
</html>