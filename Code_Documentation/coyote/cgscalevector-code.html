<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:28 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgscalevector.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgscalevector.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgScaleVector</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This is a utility routine to scale the elements of a vector or an array into a </span>
<span class="comments">;   given data range. </span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 1998-2013, by Fanning Software Consulting, Inc. All rights reserved.      ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This is a utility routine to scale the elements of a vector or an array into a </span>
<span class="comments">; given data range. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Utilities</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     A vector or array of the same size as the input, scaled into the data range given</span>
<span class="comments">;     by `minRange` and `maxRange'. The input vector is confined to the data range set</span>
<span class="comments">;     by `MinValue` and `MaxValue` before scaling occurs.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    maxRange: in, optional, type=varies, default=1</span>
<span class="comments">;       The maximum output value of the scaled vector. Set to 1 by default.</span>
<span class="comments">;    minRange: in, optional, type=varies, default=0</span>
<span class="comments">;       The minimum output value of the scaled vector. Set to 0 by default.</span>
<span class="comments">;    vector: in, required</span>
<span class="comments">;       The input vector or array to be scaled.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    double: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to perform scaling in double precision. Otherwise, scaling </span>
<span class="comments">;         is done in floating point precision.</span>
<span class="comments">;     maxvalue: in, optional</span>
<span class="comments">;         Set this value to the maximum value of the vector, before scaling (vector &lt; maxvalue).</span>
<span class="comments">;         The default value is Max(vector).</span>
<span class="comments">;     minvalue: in, optional</span>
<span class="comments">;         Set this value to the mimimum value of the vector, before scaling (minvalue &lt; vector).</span>
<span class="comments">;         The default value is Min(vector).</span>
<span class="comments">;     nan: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to enable not-a-number checking. NANs in vector will be ignored.</span>
<span class="comments">;     preserve_type: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to preserve the input data type in the output.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;       Simple example of scaling a vector::</span>
<span class="comments">;       </span>
<span class="comments">;          IDL> x = [3, 5, 0, 10]</span>
<span class="comments">;          IDL> xscaled = cgScaleVector(x, -50, 50)</span>
<span class="comments">;          IDL> Print, xscaled</span>
<span class="comments">;               -20.0000     0.000000     -50.0000      50.0000</span>

<span class="comments">;       Suppose your image has a minimum value of -1.7 and a maximum value = 2.5.</span>
<span class="comments">;       You wish to scale this data into the range 0 to 255, but you want to use</span>
<span class="comments">;       a diverging color table. Thus, you want to make sure value 0.0 is scaled to 128.</span>
<span class="comments">;       You proceed like this::</span>
<span class="comments">;</span>
<span class="comments">;          scaledImage = cgScaleVector(image, 0, 255, MINVALUE=-2.5, MAXVALUE=2.5)</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;         Written by:  David W. Fanning, 12 Dec 1998.</span>
<span class="comments">;         Added MAXVALUE and MINVALUE keywords. 5 Dec 1999. DWF.</span>
<span class="comments">;         Added NAN keyword. 18 Sept 2000. DWF.</span>
<span class="comments">;         Removed check that made minRange less than maxRange to allow ranges to be</span>
<span class="comments">;            reversed on axes, etc. 28 Dec 2003. DWF.</span>
<span class="comments">;         Added PRESERVE_TYPE and DOUBLE keywords. 19 February 2006. DWF.</span>
<span class="comments">;         Added FPUFIX to cut down on floating underflow errors. 11 March 2006. DWF.</span>
<span class="comments">;         Renamed Scale_Vector to cgScaleVector, 16 May 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 1998-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
FUNCTION cgScaleVector, vector, minRange, maxRange, $
   DOUBLE=double, $
   MAXVALUE=vectorMax, $
   MINVALUE=vectorMin, $
   NAN=nan, $
   PRESERVE_TYPE=preserve_type

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN, vector
   ENDIF

   <span class="comments">; Check positional parameters.</span>
   CASE N_Params() OF
      0: Message, 'Incorrect number of arguments.'
      1: BEGIN
         IF Keyword_Set(double) THEN BEGIN
            minRange = 0.0D
            maxRange = 1.0D
         ENDIF ELSE BEGIN
            minRange = 0.0
            maxRange = 1.0
         ENDELSE
         ENDCASE
      2: BEGIN
         IF Keyword_Set(double) THEN maxRange = 1.0D > (minRange + 0.0001D) ELSE $
            maxRange = 1.0 > (minRange + 0.0001)
         ENDCASE
      ELSE:
   ENDCASE

   <span class="comments">; If input data type is DOUBLE and DOUBLE keyword is not set, then set it.</span>
   IF Size(FPUFIX(vector), /TNAME) EQ 'DOUBLE' AND N_Elements(double) EQ 0 THEN double = 1

   <span class="comments">; Make sure we are working with at least floating point numbers.</span>
   IF Keyword_Set(double) THEN minRange = DOUBLE( minRange ) ELSE minRange = FLOAT( minRange )
   IF Keyword_Set(double) THEN maxRange = DOUBLE( maxRange ) ELSE maxRange = FLOAT( maxRange )

   <span class="comments">; Make sure we have a valid range.</span>
   IF maxRange EQ minRange THEN Message, 'Range max and min are coincidental'

   <span class="comments">; Check keyword parameters.</span>
   IF Keyword_Set(double) THEN BEGIN
      IF N_Elements(vectorMin) EQ 0 THEN vectorMin = Double( Min(FPUFIX(vector), NAN=1) ) $
         ELSE vectorMin = Double(vectorMin)
      IF N_Elements(vectorMax) EQ 0 THEN vectorMax = DOUBLE( Max(FPUFIX(vector), NAN=1) ) $
         ELSE vectorMax = DOUBLE( vectorMax )
   ENDIF ELSE BEGIN
      IF N_Elements(vectorMin) EQ 0 THEN vectorMin = FLOAT( Min(FPUFIX(vector), NAN=1) ) $
         ELSE vectorMin = FLOAT( vectorMin )
      IF N_Elements(vectorMax) EQ 0 THEN vectorMax = FLOAT( Max(FPUFIX(vector), NAN=Keyword_Set(nan)) ) $
         ELSE vectorMax = FLOAT( vectorMax )
   ENDELSE

   <span class="comments">; Trim vector before scaling.</span>
   index = Where(Finite(vector) EQ 1, count)
   IF count NE 0 THEN BEGIN
      IF Keyword_Set(double) THEN trimVector = Double(vector) ELSE trimVector = Float(vector)
      trimVector[index]  =  vectorMin >  vector[index] &lt<span class="comments">; vectorMax</span>
   ENDIF ELSE BEGIN
      IF Keyword_Set(double) THEN trimVector = vectorMin > Double(vector) &lt<span class="comments">; vectorMax ELSE $</span>
         trimVector = vectorMin > Float(vector) &lt<span class="comments">; vectorMax</span>
   ENDELSE

   <span class="comments">; Calculate the scaling factors.</span>
   scaleFactor = [((minRange * vectorMax)-(maxRange * vectorMin)) / $
       (vectorMax - vectorMin), (maxRange - minRange) / (vectorMax - vectorMin)]

   <span class="comments">; Clear math errors.</span>
   void = Check_Math()

   <span class="comments">; Return the scaled vector.</span>
   IF Keyword_Set(preserve_type) THEN BEGIN
      RETURN, FPUFIX(Convert_To_Type(trimVector * scaleFactor[1] + scaleFactor[0], Size(vector, /TNAME)))
   ENDIF ELSE BEGIN
      RETURN, FPUFIX(trimVector * scaleFactor[1] + scaleFactor[0])
   ENDELSE

END
</code>
    </div>
  </body>
</html>