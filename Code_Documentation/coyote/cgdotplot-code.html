<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:05 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgdotplot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgdotplot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgDotPlot</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of cgDotPlot is to create a "dot plot" of the sort described on this web page:</span>
<span class="comments">;   http://peltiertech.com/Utility/DotPlotUtility.html.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2012, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of cgDotPlot is to create a "dot plot" of the sort described on this </span>
<span class="comments">; `web page &lt;http://peltiertech.com/Utility/DotPlotUtility.html>`.</span>
<span class="comments">;</span>
<span class="comments">;  .. image:: cgdotplot.png</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    labels: in, required, type=strarr</span>
<span class="comments">;         A vector of string labels to be plotted along the left edge of the dot plot.</span>
<span class="comments">;    values: in, required</span>
<span class="comments">;         A vector of values associated with each label, representing the values to be </span>
<span class="comments">;         plotted on the dot plot.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;     axiscolor: in, optional, type=string/integer, default='opposite'</span>
<span class="comments">;        If this keyword is a string, the name of the axis color. </span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     background: in, optional, type=string/integer, default='WHITE'</span>
<span class="comments">;        If this keyword is a string, the name of the background color. </span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     charsize: in, optional, type=float</span>
<span class="comments">;        The character size for axes annotations. Uses cgDefCharSize to select default</span>
<span class="comments">;        character size, unless !P.Charsize is set, in which case !P.Charsize is always used.</span>
<span class="comments">;     color: in, optional, type=string/integer, default='BLACK'</span>
<span class="comments">;        If this keyword is a string, the name of the data color. </span>
<span class="comments">;        Color names are those used with cgColor. Otherwise, the keyword is assumed </span>
<span class="comments">;        to be a color index into the current color table.</span>
<span class="comments">;     font: in, optional, type=integer, default=!P.Font</span>
<span class="comments">;        The type of font desired for axis annotation.</span>
<span class="comments">;     labelcharsize: in, optional, type=float</span>
<span class="comments">;        The character size of the labels. The default is to use `Charsize`.</span>
<span class="comments">;     labelcolor: in, optional, type=string</span>
<span class="comments">;        The name of the color the labels should be drawn in. The default is the</span>
<span class="comments">;        `AxisColor`.</span>
<span class="comments">;     nogrid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to eliminate the background grid from the plot.</span>
<span class="comments">;     noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw the plot without erasing the display first.</span>
<span class="comments">;     output: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to the name of an output file. The type of file is determined</span>
<span class="comments">;        from the file's extension, as listed below. Normally, the file name is given in</span>
<span class="comments">;        all lowercase letters::</span>
<span class="comments">;            'ps'   - PostScript file</span>
<span class="comments">;            'eps'  - Encapsulated PostScript file</span>
<span class="comments">;            'pdf'  - PDF file</span>
<span class="comments">;            'bmp'  - BMP raster file</span>
<span class="comments">;            'gif'  - GIF raster file</span>
<span class="comments">;            'jpg' - JPEG raster file</span>
<span class="comments">;            'png'  - PNG raster file</span>
<span class="comments">;            'tif' - TIFF raster file</span>
<span class="comments">;        All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;        PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;        to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;        details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;        plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;        output for a single graphics command. Output parameters can be set with `cgWindow_SetDefs`.</span>
<span class="comments">;     overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to overplot data on an already exisiting set of</span>
<span class="comments">;        cgDotPlot axes. Note that labels will have to be passed, but they will not be</span>
<span class="comments">;        drawn again in the overplotting.</span>
<span class="comments">;     position: in, optional, type=vector</span>
<span class="comments">;        The usual four-element position vector for the Plot comamnd. Only monitored and</span>
<span class="comments">;        possibly set if the `Aspect` keyword is used.</span>
<span class="comments">;     psym: in, optional, type=integer</span>
<span class="comments">;        Any normal IDL PSYM values, plus any value supported by the Coyote Library</span>
<span class="comments">;        routine cgSYMCAT. An integer between 0 and 46. This may also be set to the</span>
<span class="comments">;        "name" of a symbol, such as returned from Print, cgSymCat(/Names).</span>
<span class="comments">;     plotfillcolor: in, optional, type=string, default='BLK1'</span>
<span class="comments">;        The name of the color that fills the area inside the axes on the plot.</span>
<span class="comments">;     symsize: in, optional, type=float, default=1.0</span>
<span class="comments">;        The symbol size.</span>
<span class="comments">;     title: in, optional, type=string</span>
<span class="comments">;         The title of the plot.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in a current cgWindow or to</span>
<span class="comments">;        create a new cgWindow for displaying this command.</span>
<span class="comments">;     xcharsize: in, optional, type=float</span>
<span class="comments">;        The character size of the annotations on the X axis of the plot.</span>
<span class="comments">;     xgridstyle: in, optional, type=integer, default=1</span>
<span class="comments">;        The X line style of the grid lines used to draw the grid on the axis. By default, dots.</span>
<span class="comments">;     xrange: in, optional</span>
<span class="comments">;        A two-element array giving the X range of the plot.</span>
<span class="comments">;     xstyle: in, optional</span>
<span class="comments">;        A two-element array giving the X style of the plot. Normally, this is</span>
<span class="comments">;        set to 1 to give exact axis ranges. Otherwise, not used.</span>
<span class="comments">;     xtitle: in, optional, type=string</span>
<span class="comments">;         The X title of the plot.</span>
<span class="comments">;     ygridstyle: in, optional, type=integer, default=1</span>
<span class="comments">;        The Y line style of the grid lines used to draw the grid on the axis. By default, dots.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    There are several examples in a main-level program at the end of this program file.</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;        David W. Fanning </span>
<span class="comments">;        1645 Sheely Drive</span>
<span class="comments">;        Fort Collins, CO 80526 USA</span>
<span class="comments">;        Phone: 970-221-0438</span>
<span class="comments">;        E-mail: david@idlcoyote.com</span>
<span class="comments">;        Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 12 November 2012, by David W. Fanning and donated to the IDL community </span>
<span class="comments">;            by Marta Yebra of CSIRO, Australia.</span>
<span class="comments">;         </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgDotPlot, labels, values, $
    ADDCMD=addcmd, $
    AXISCOLOR=saxiscolor, $
    BACKGROUND=sbackground, $
    CHARSIZE=charsize, $
    COLOR=scolor, $
    FONT=font, $
    LABELCHARSIZE=labelcharsize, $
    LABELCOLOR=slabelcolor, $
    NOGRID=nogrid, $
    NOERASE=noerase, $
    OUTPUT=output, $
    OVERPLOT=overplot, $
    POSITION=position, $
    PSYM=psymIn, $
    PLOTFILLCOLOR=splotFillColor, $
    SYMSIZE=symsize, $
    TITLE=title, $
    XCHARSIZE=xcharsize, $
    XGRIDSTYLE=xgridstyle, $
    XRANGE=xrange, $
    XSTYLE=xstyle, $
    XTITLE=xtitle, $
    YGRIDSTYLE=ygridstyle, $
    WINDOW=window
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        IF (N_Elements(output) NE 0) THEN PS_END, /NOFIX
        RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Check parameters.</span>
    IF N_Params() EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgDotPlot, labels, values'
        RETURN
    ENDIF
    
    <span class="comments">; Need labels and values.</span>
    IF Size(labels, /TNAME) NE 'STRING' THEN Message, 'The LABELS parameter must be a string array.'
    IF N_Elements(values) NE N_Elements(labels) THEN Message, 'The number of labels must match the number of values provided.'    
    
    <span class="comments">; Check to see if psymIn is a string. If so, covert it here.</span>
    IF N_Elements(psymIn) NE 0 THEN BEGIN
        IF Size(psymIn, /TNAME) EQ 'STRING' THEN BEGIN
              names = cgSymCat(/Names) 
              index = Where(STRUPCASE(StrCompress(names, /REMOVE_ALL)) EQ STRUPCASE(StrCompress(psymIN, /REMOVE_ALL)), count)
              IF count GT 0 THEN psym = index[0] ELSE Message, 'Cannot resolve the PSYM value: ' + psymIn
        ENDIF ELSE psym = psymIn
    ENDIF
    
    <span class="comments">; Pay attention to !P.NoErase in setting the NOERASE kewyord. </span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    
    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; Special treatment for overplotting or adding a command.</span>
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgDotPlot', labels, values, $
                AXISCOLOR=saxiscolor, $
                BACKGROUND=sbackground, $
                CHARSIZE=charsize, $
                COLOR=scolor, $
                FONT=font, $
                LABELCHARSIZE=labelcharsize, $
                LABELCOLOR=slabelcolor, $
                NOGRID=nogrid, $
                NOERASE=noerase, $
                OUTPUT=output, $
                OVERPLOT=overplot, $
                POSITION=position, $
                PSYM=psymIn, $
                PLOTFILLCOLOR=splotFillColor, $
                SYMSIZE=symsize, $
                TITLE=title, $
                XCHARSIZE=xcharsize, $
                XGRIDSTYLE=xgridstyle, $
                XRANGE=xrange, $
                XSTYLE=xstyle, $
                XTITLE=xtitle, $
                YGRIDSTYLE=ygridstyle, $
                ADDCMD=1
         RETURN
       ENDIF
        
        <span class="comments">; Open a new window or replace the current commands, as required.</span>
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        cgWindow, 'cgDotPlot', labels, values, $
            AXISCOLOR=saxiscolor, $
            BACKGROUND=sbackground, $
            CHARSIZE=charsize, $
            COLOR=scolor, $
            FONT=font, $
            LABELCHARSIZE=labelcharsize, $
            LABELCOLOR=slabelcolor, $
            NOGRID=nogrid, $
            NOERASE=noerase, $
            OUTPUT=output, $
            OVERPLOT=overplot, $
            POSITION=position, $
            PSYM=psymIn, $
            PLOTFILLCOLOR=splotFillColor, $
            SYMSIZE=symsize, $
            TITLE=title, $
            XCHARSIZE=xcharsize, $
            XGRIDSTYLE=xgridstyle, $
            XRANGE=xrange, $
            XSTYLE=xstyle, $
            XTITLE=xtitle, $
            YGRIDSTYLE=ygridstyle, $
            REPLACECMD=replaceCmd
         RETURN
    ENDIF
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
       
       <span class="comments">; Need to have a filename and extention at this point.</span>
       IF N_Elements(outfilename) EQ 0 THEN Message, 'Output filename  must have an file type extension.'
       IF N_Elements(outputSelection) EQ 0 THEN Message, 'An output filename extension is required.'
       
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    ENDIF
    
    <span class="comments">; Get the current color table vectors.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; Going to do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState
    
    <span class="comments">; Check keywords.</span>
    IF N_Elements(title) EQ 0 THEN title = ""
    IF N_Elements(xtitle) EQ 0 THEN xtitle = ""
    title = cgCheckForSymbols(title)
    xtitle = cgCheckForSymbols(xtitle)
    FOR j=0,N_Elements(labels)-1 DO labels[j] = cgCheckForSymbols(labels[j])
    background = cgDefaultColor(sbackground, DEFAULT='white', /BACKGROUND)
    axisColor = cgDefaultColor(saxisColor, DEFAULT='black')
    color = cgDefaultColor(sColor, DEFAULT='black')
    plotfillcolor = cgDefaultColor(splotfillcolor, DEFAULT='blk1')
    labelcolor = cgDefaultColor(slabelcolor, DEFAULT=axisColor)
    IF N_Elements(font) EQ 0 THEN font = !P.Font
    IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize(FONT=font)
    IF N_Elements(labelcharsize) EQ 0 THEN labelcharsize = charsize
    IF N_Elements(symsize) EQ 0 THEN symsize = 1.0
    IF N_Elements(psym) EQ 0 THEN psym = 9 <span class="comments">; Open circle</span>
    IF N_Elements(xgridstyle) EQ 0 THEN xgridstyle = 1 <span class="comments">; Dots</span>
    IF N_Elements(ygridstyle) EQ 0 THEN ygridstyle = 1 <span class="comments">; Dots</span>
    
    <span class="comments">; Load the drawing colors. If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    IF Size(axiscolor, /TNAME) EQ 'STRING' THEN axiscolor = cgColor(axiscolor)
    IF Size(color, /TNAME) EQ 'STRING' THEN color = cgColor(color)
    IF Size(background, /TNAME) EQ 'STRING' THEN background = cgColor(background)
    IF Size(plotfillcolor, /TNAME) EQ 'STRING' THEN plotfillcolor = cgColor(plotfillcolor)
    IF Size(symcolor, /TNAME) EQ 'STRING' THEN symcolor = cgColor(symcolor)
    IF N_Elements(xstyle) EQ 0 THEN xstyle = 0
    
    <span class="comments">; Calculate the maximum length of the labels in normalized coordinates.</span>
    maxStrLen = Max(StrLen(labels))
    maxLength = maxStrLen * Float(!D.X_CH_SIZE) / !D.X_SIZE
    
    <span class="comments">; Calculate a default plot position.</span>
    IF N_Elements(position) EQ 0 && (Total(!P.Multi) LE 0) && (Total(!P.Position) EQ 0.0) THEN BEGIN
        position = [0.125+maxLength, 0.125, 0.9, 0.9]
    ENDIF
    
    <span class="comments">; Draw the plot axes. The first plot should not be seen, and it just to</span>
    <span class="comments">; establish plot location.</span>
    numLabels = N_Elements(labels)
    IF ~Keyword_Set(overplot) THEN BEGIN
        Plot, values, Indgen(numLabels)+1, /NoData, COLOR=axiscolor, $
          YRANGE=[0,numlabels+1], YSTYLE=9+4, YMINOR=1, YTICKS=numLabels+1, $
          POSITION=position, BACKGROUND=background, YTICKLEN=-0.025, XTICKLEN=-0.025, $
          XSTYLE=xstyle+8+4, XRANGE=xrange, NOERASE=noerase
    ENDIF
    
    <span class="comments">; Fill the inside of the plot with a color.</span>
    p = [!X.Window[0], !Y.Window[0], !X.Window[1], !Y.Window[1]]
    
    IF ~Keyword_Set(overplot) THEN BEGIN
        PolyFill, [p[0],p[0],p[2],p[2],p[0]], [p[1],p[3],p[3],p[1],p[1]], /Normal, $
          Color=plotfillcolor
    ENDIF
    
    <span class="comments">; Add grid lines to the plot, if needed.</span>
    IF ~Keyword_Set(nogrid) && ~Keyword_Set(overplot) THEN BEGIN      
        Plot, values, Indgen(numLabels)+1, /NoData, COLOR=cgColor('gray'), $
          YRANGE=[0,numlabels+1], YSTYLE=9, YMINOR=1, YTICKS=numLabels+1, $
          POSITION=p, YTICKLEN=1, XTICKLEN=1, XGRIDSTYLE=xgridstyle, YGRIDSTYLE=ygridstyle, $
          XSTYLE=xstyle+8, NoErase=1, XTICKFORMAT='(A1)', YTICKFORMAT='(A1)', XMINOR=1, $
          XRANGE=xrange
    ENDIF
    
    <span class="comments">; Draw the actual plot with normal annotations.</span>
    IF Keyword_Set(overplot) THEN BEGIN
       OPlot, values, Indgen(numLabels)+1, PSYM=cgSymCat(psym), COLOR=color, SYMSIZE=symsize 
    ENDIF ELSE BEGIN
        Plot, values, Indgen(numLabels)+1, /NoData, COLOR=axiscolor, $
          YRANGE=[0,numlabels+1], YSTYLE=9, YMINOR=1, YTICKS=numLabels+1, $
          POSITION=p, YTICKLEN=-0.025, XTICKLEN=-0.025, $
          XSTYLE=xstyle+8, NoErase=1, YTICKFORMAT='(A1)', XRANGE=xrange, TITLE=title, XTITLE=xtitle
        Axis, YAXIS=1, COLOR=axiscolor, YMINOR=1, YTICKFORMAT='(A1)', YTICKLEN=0.0001, $
             YRANGE=[0,numlabels+1], YSTYLE=1
        Axis, XAXIS=1, COLOR=axiscolor, XRANGE=xrange, XTICKFORMAT='(A1)', XSTYLE=xstyle
        OPlot, values, Indgen(numLabels)+1, PSYM=cgSymCat(psym), COLOR=color, SYMSIZE=symsize
    ENDELSE
    
    <span class="comments">; Add the plot labels.</span>
    IF ~Keyword_Set(overplot) THEN BEGIN
      FOR j=0,N_Elements(labels)-1 DO BEGIN
         xloc = !X.Window[0] - 0.025
         yloc = !Y.Window[0] + ((j+1) * ((!Y.Window[1]-!Y.Window[0])/(N_Elements(labels)+1)))
         skosh = 0.01
         XYOUTS, xloc, yloc-skosh, labels[j], /Normal, $
            FONT=font, Charsize=labelCharsize, Alignment=1.0, COLOR=cgColor(labelColor)
      ENDFOR
    ENDIF
    
    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width

         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
    <span class="comments">; Restore the decomposed color state if you can.</span>
    SetDecomposedState, currentState
    
    <span class="comments">; Restore the color table. Can't do this for the Z-buffer or</span>
    <span class="comments">; the snap shot will be incorrect.</span>
    IF (!D.Name NE 'Z') THEN TVLCT, rr, gg, bb
        
END

           
</code>
    </div>
  </body>
</html>