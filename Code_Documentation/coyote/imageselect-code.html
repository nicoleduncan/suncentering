<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:58 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>imageselect.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="imageselect.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   IMAGESELECT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   The purpose of this program is to allow the user to select a formatted</span>
<span class="comments">;   image file for reading. The image data is returned as the result of the</span>
<span class="comments">;   function. The program allows the user to see a thumbnail version of the</span>
<span class="comments">;   image, along with information about the image, before selection. The</span>
<span class="comments">;   program uses the file extention to determine what kind of image is to</span>
<span class="comments">;   be read. The following image types are supported:</span>
<span class="comments">;</span>
<span class="comments">;      TYPE      FILE EXTENSION</span>
<span class="comments">;      BMP       *.bmp</span>
<span class="comments">;      DICOM     *.dcm</span>
<span class="comments">;      FITS      *.fits, *.fts (requires NASA ASTRO library on IDL Path)</span>
<span class="comments">;      GIF       *.gif (IDL 6.2 and higher)</span>
<span class="comments">;      JPEG      *.jpg, *.jpeg, *.jpe</span>
<span class="comments">;      JPEG2000  *.jpf, *.jpx, *.jp2, *.j2c, *.j2k</span>
<span class="comments">;      PICT      *.pict</span>
<span class="comments">;      PNG       *.png</span>
<span class="comments">;      TIFF      *.tif, *tiff</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;   FANNING SOFTWARE CONSULTING</span>
<span class="comments">;   David Fanning, Ph.D.</span>
<span class="comments">;   1645 Sheely Drive</span>
<span class="comments">;   Fort Collins, CO 80526 USA</span>
<span class="comments">;   Phone: 970-221-0438</span>
<span class="comments">;   E-mail: david@idlcoyote.com</span>
<span class="comments">;   Coyote's Guide to IDL Programming: http://www.idlcoyote.com/</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;   General programming.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   image = ImageSelect()</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   None. All input is via keywords.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   BMP -- Set this keyword to select BMP files.</span>
<span class="comments">;   </span>
<span class="comments">;   DEMO -- If this keyword is set, the program changes directory to !DIR/examples/data.</span>
<span class="comments">;</span>
<span class="comments">;   DICOM -- Set this keyword to select DICOM files.</span>
<span class="comments">;</span>
<span class="comments">;   DIRECTORY -- The initial input directory name. The current directory by default.</span>
<span class="comments">;   </span>
<span class="comments">;   EXCLUDE -- A list of filenames that should excluded from the file selection list.</span>
<span class="comments">;</span>
<span class="comments">;   FILENAME -- The initial filename. If the initial directory has image files of the</span>
<span class="comments">;               correct type, the default is to display the first of these files. Otherwise, blank.</span>
<span class="comments">;</span>
<span class="comments">;   FILTER -- A string, representing the file filter. For example, '*.jpg'.</span>
<span class="comments">;</span>
<span class="comments">;   FITS -- Set the keyword to select FITS files. (Must have NASA Astro Library on path.)</span>
<span class="comments">;</span>
<span class="comments">;   FLIPIMAGE -- Set this keyword if you wish to flip the image from its current orientation. Setting</span>
<span class="comments">;                this keyword reverses the Y dimension of the image.</span>
<span class="comments">;</span>
<span class="comments">;   GIF -- Set this keyword to select GIF files. (IDL versions before 5.4 and after 6.0, only.)</span>
<span class="comments">;</span>
<span class="comments">;   GROUP_LEADER -- Set this keyword to a widget identifier group leader. This keyword MUST be</span>
<span class="comments">;                   set when calling this program from another widget program to guarantee modal operation.</span>
<span class="comments">;</span>
<span class="comments">;   J2000 -- Set this keyword to select JPEG2000 files. (May also be set as J2K.) (IDL 6.1 or above.)</span>
<span class="comments">;</span>
<span class="comments">;   J2K -- Set this keyword to select JPEG2000 files. (May also be set as J2000.) (IDL 6.1 or above.)</span>
<span class="comments">;</span>
<span class="comments">;   JPEG -- Set this keyword to select JPEG files.</span>
<span class="comments">;</span>
<span class="comments">;   LISTXSIZE -- Set this keyword to the XSIZE of the list widget. Default is 30 or MAX(StrLen(filenames)), whichever is larger.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSETS -- A two-element array containing the X and Y offsets of the program, from the upper left</span>
<span class="comments">;              corner of the display. On dismissal of the program, if this is a named variable (passed into</span>
<span class="comments">;              the program by reference), then it will contain the last offsets of the program. This is</span>
<span class="comments">;              useful if you want to call ImageSelect again and have it positioned in exactly the same</span>
<span class="comments">;              location it was before.</span>
<span class="comments">;</span>
<span class="comments">;   ONLY2D -- Set this keyword if you only want the user to be able to select 2D images. Note</span>
<span class="comments">;             that the user will be able to browse all images, but the Accept button will only</span>
<span class="comments">;             be sensitive for 2D images.</span>
<span class="comments">;</span>
<span class="comments">;   ONLY3D -- Set this keyword if you only want the user to be able to select 3D or true-color images.</span>
<span class="comments">;             Note that the user will be able to browse all images, but the Accept button will only</span>
<span class="comments">;             be sensitive for 3D or true-color images.</span>
<span class="comments">;</span>
<span class="comments">;   PICT -- Set this keyword to select PICT files.</span>
<span class="comments">;</span>
<span class="comments">;   PGM -- Set this keyword to select PGM files.</span>
<span class="comments">;</span>
<span class="comments">;   PPM -- Set this keyword to select PPM files.</span>
<span class="comments">;</span>
<span class="comments">;   PNG -- Set this keyword to select PNG files.</span>
<span class="comments">;</span>
<span class="comments">;   PREVIEWSIZE -- Set this keyword to the maximum size (in pixels) of the preview window. Default is 150.</span>
<span class="comments">;</span>
<span class="comments">;   SILENT -- Set this keyword to turn off Group_Leader educational message. Use only if you</span>
<span class="comments">;             are sure you know what you are doing. :-)</span>
<span class="comments">;</span>
<span class="comments">;   TIFF -- Set this keyword to select TIFF files. (This is the default filter selection.)</span>
<span class="comments">;</span>
<span class="comments">;   TITLE -- Set this keyword to the text to display as the title of the main image selection window.</span>
<span class="comments">;</span>
<span class="comments">;   NOTE: Any extra keywords passed into the program will collected and passed along to the READ_XXX routines</span>
<span class="comments">;   that actually do the image file reading. Using this keyword inheritance mechanism makes it impossible</span>
<span class="comments">;   to trap misspelled or misused keywords. Please take care when using ANY keyword for this routine!</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   CANCEL -- This keyword is set to 1 if the user exits the program in any way except hitting the ACCEPT button.</span>
<span class="comments">;             The ACCEPT button will set this keyword to 0.</span>
<span class="comments">;</span>
<span class="comments">;   FHEADER -- Set this keyword to a named variable that will return the FITS header information for a FITS file.</span>
<span class="comments">;</span>
<span class="comments">;   FILEINFO -- This keyword returns information about the selected file. Obtained from the QUERY_**** functions.</span>
<span class="comments">;</span>
<span class="comments">;   GEOTIFF --  If the file is a GeoTIFF file, this keyword will return the GeoTIFF structure containing</span>
<span class="comments">;               the files GeoTags.</span>
<span class="comments">;               </span>
<span class="comments">;   OUTDIRECTORY -- The directory where the selected file is found.</span>
<span class="comments">;</span>
<span class="comments">;   OUTFILENAME -- The short filename of the selected file.</span>
<span class="comments">;</span>
<span class="comments">;   PALETTE -- The current color table palette returned as a 256-by-3 byte array.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;   None.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;</span>
<span class="comments">;   Requires other programs from the Coyote Library.</span>
<span class="comments">;</span>
<span class="comments">;  Note: Keyword inheritance to collect undefined keywords that may be passed into the</span>
<span class="comments">;  program for use in READ_XXX routines, make it impossible to trap keyword useage errors.</span>
<span class="comments">;  Please take care when using keywords.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   To read JPEG files from the directory:</span>
<span class="comments">;</span>
<span class="comments">;      IDL> image = ImageSelect(/JPEG)</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;   Written by: David W. Fanning, 18 Jan 2001.</span>
<span class="comments">;   Added modification to read both 8-bit and 24-bit BMP files. 27 Jan 2001. DWF.</span>
<span class="comments">;   Fixed a problem with calculating the new size of the draw widget. 5 April 2002. DWF.</span>
<span class="comments">;   Fixed a problem with List Widgets not sizing correctly on UNIX machines. 10 Aug 2002. DWF.</span>
<span class="comments">;   Fixed a problem with the initial file not being selected correctly when you changed</span>
<span class="comments">;     the file type. 10 Aug 2002. DWF.</span>
<span class="comments">;   Added a FLIPIMAGE keyword 10 Aug 2002. DWF.</span>
<span class="comments">;   When user chooses to Flip Image, I now reverse the Y dimension of the image,</span>
<span class="comments">;     rather than set the !Order system variable. 10 Aug 2002. DWF.</span>
<span class="comments">;   Added OUTDIRECTORY and OUTFILENAME keywords. 18 Aug 2002. DWF.</span>
<span class="comments">;   Fairly extensive changes in the way this program works and selects images.</span>
<span class="comments">;     A new version of FSC_FileSelect is also required. Because of interactions</span>
<span class="comments">;     with the operating system with image filters, the program has probably</span>
<span class="comments">;     become more Windows-centric. The default is now to display all image</span>
<span class="comments">;     files the program is capable of reading. 31 October 2002. DWF.</span>
<span class="comments">;   Added ONLY2D keyword to allow the acceptance of 2D images only. 3 Nov 2002. DWF.</span>
<span class="comments">;   Added ability to center itself on the display. 8 Nov 2002. DWF.</span>
<span class="comments">;   Fixed a problem caused by reading old images with short color table vectors. 26 Nov 2002. DWF.</span>
<span class="comments">;   Fixed a problem with specifying a fully-qualified filename. 26 Nov 2002. DWF.</span>
<span class="comments">;   Now highlights the selected file in the directory. 26 Nov 2002. DWF.</span>
<span class="comments">;   Improved error handling. 9 Dec 2002. DWF.</span>
<span class="comments">;   Added PALETTE keyword and improved color operation on 8-bit displays. If the image file</span>
<span class="comments">;     contains a color palette, that palette is now loaded when the image is read from the file.</span>
<span class="comments">;     The current color palette can be obtained with the PALETTE keyword. 4 April 2003. DWF.</span>
<span class="comments">;   Added ONLY3D keyword. 19 April 2003. DWF.</span>
<span class="comments">;   Added ability to read PPM and PGM files. 24 November 2003. DWF.</span>
<span class="comments">;   Added TITLE keyword. 1 December 2003. DWF.</span>
<span class="comments">;   Added EXAMPLES keyword. 22 December 2005. DWF.</span>
<span class="comments">;   Added GIF and JPEG2000 file types. Rearranged and cleaned up code. 3 January 2006. DWF.</span>
<span class="comments">;   Added LISTXSIZE keyword. 3 January 2006. DWF.</span>
<span class="comments">;   Added file type checkmark buttons. Program now compatible with IDL 5.6 and higher. 3 January 2006. DWF.</span>
<span class="comments">;   Improved error handling with invalid file types. 5 January 2006. DWF.</span>
<span class="comments">;   Added OFFSETS and EXCLUDE keywords. 3 March 2006 DWF.</span>
<span class="comments">;   Modified the program to check for FITS unsigned integer data. 3 March 2006. DWF.</span>
<span class="comments">;   Added ability to double-click image name in list to Accept. 10 March 2006. DWF.</span>
<span class="comments">;   Added FHEADER keyword to return FITS header information. 3 April 2006. DWF.</span>
<span class="comments">;   Fixed a problem in which the file type was not set if the user cancelled. 10 July 2006. DWF.</span>
<span class="comments">;   Added a "fit" file extension for FITS images. 1 April 2008. DWF.</span>
<span class="comments">;   Added a FILTER keyword. 1 April 2008. DWF.</span>
<span class="comments">;   Updated for reading transparent images. 13 May 2009. DWF.</span>
<span class="comments">;   Provided check for PNG images with more than 8 bits per channel. 5 August 2009. DWF.</span>
<span class="comments">;   Fixed a problem in which the starting directory was changed on exit. 20 Nov 2010. DWF.</span>
<span class="comments">;   Change EXAMPLES to more easily remembered DEMO keyword. 29 Nov 2010. DWF.</span>
<span class="comments">;   Removed NOINTERPOLATION keywords in going from TVIMAGE to cgImage. 22 Feb 2011. DWF.</span>
<span class="comments">;   Fixed a problem reading 2D Tiff files. 20 Sept 2012. DWF.</span>
<span class="comments">;   </span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008-2012, by Fanning Software Consulting, Inc.                           ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION ImageSelect_WindowSize, image, XSIZE=xsize, YSIZE=ysize

<span class="comments">; This function determines the correct window size for an image that keeps</span>
<span class="comments">; its aspect ratio. Returns two element array: [xsize, ysize]. Assumes the</span>
<span class="comments">; current graphics window is where the image is to be displayed.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN, Size(image, /Dimensions)
   ENDIF

   <span class="comments">; Need X and Y size of image.</span>
   dims = Image_Dimensions(image, XSize=imgXSize, YSize=imgYSize)

   <span class="comments">; Fill the window.</span>
   position=[0.0, 0.0, 1.0, 1.0]

   <span class="comments">; Find aspect ratio of image.</span>
   ratio = FLOAT(imgYsize) / imgXSize

   <span class="comments">; Find the proposed size of the image in pixels without aspect</span>
   <span class="comments">; considerations.</span>
   xpixSize = (position(2) - position(0)) * xsize
   ypixSize = (position(3) - position(1)) * ysize

   <span class="comments">; Try to fit the image width. If you can't maintain</span>
   <span class="comments">; the aspect ratio, fit the image height.</span>
   trialX = xpixSize
   trialY = trialX * ratio
   IF trialY GT ypixSize THEN BEGIN
      trialY = ypixSize
      trialX = trialY / ratio
   ENDIF

   <span class="comments">; Recalculate the position of the image in the window.</span>
   position(0) = (((xpixSize - trialX) / 2.0) / xsize) + position(0)
   position(2) = position(0) + (trialX/FLOAT(xsize))
   position(1) = (((ypixSize - trialY) / 2.0) / ysize)  + position(1)
   position(3) = position(1) + (trialY/FLOAT(ysize))

   <span class="comments">; Return the X and Y sizes.</span>
   RETURN, Round([(position[2]-position[0])*xsize, (position[3]-position[1])*ysize])

END <span class="comments">; ----------------------------------------------------------------------------------------</span>


PRO ImageSelect_Action, event

<span class="comments">; This event handler responds to CANCEL and ACCEPT buttons.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF
   IF event.select NE 1 THEN RETURN

   Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Get the button value.</span>
   Widget_Control, event.id, Get_Value=buttonValue

   <span class="comments">; Set the cancel flag appropriately.</span>
   IF buttonValue EQ 'Accept' THEN (*info.storagePtr).cancel = 0

   <span class="comments">; Get the name and directory you selected and set them into output fields.</span>
   info.filenameObj->GetProperty, Directory=outdirectory, Filename=outfilename
   (*info.storagePtr).outdirectory = outdirectory
   (*info.storagePtr).outfilename = outfilename
   
   <span class="comments">; Is this a GEOTIFF file?</span>
   isTiff = Query_Tiff(Filepath(ROOT_DIR=outdirectory, outfilename), GEOTIFF=geotiff)
   IF isTiff THEN BEGIN
        IF Size(geotiff, /TNAME) EQ 'STRUCT' THEN (*info.storagePtr).geotiff = Ptr_New(geotiff)
   ENDIF

   <span class="comments">; Get the current offsets.</span>
   Widget_Control, event.top, TLB_GET_OFFSET=offsets
   (*info.storagePtr).offsets = offsets

   Widget_Control, event.top, Set_UValue=info, /No_Copy
   Widget_Control, event.top, /Destroy

END <span class="comments">;---------------------------------------------------------------------------------</span>



FUNCTION ImageSelect_BSort, Array, Asort, INFO=info, REVERSE = rev
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ImageSelect_BSort</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Function to sort data into ascending order, like a simple bubble sort.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Original subscript order is maintained when values are equal (FIFO).</span>
<span class="comments">;       (This differs from the IDL SORT routine alone, which may rearrange</span>
<span class="comments">;       order for equal values)</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       result = ImageSelect_BSort( array, [ asort, /INFO, /REVERSE ] )</span>
<span class="comments">;</span>
<span class="comments">; INPUT:</span>
<span class="comments">;       Array - array to be sorted</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       result - sort subscripts are returned as function value</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       Asort - sorted array</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;       /REVERSE - if this keyword is set, and non-zero, then data is sorted</span>
<span class="comments">;                 in descending order instead of ascending order.</span>
<span class="comments">;       /INFO = optional keyword to cause brief message about # equal values.</span>
<span class="comments">;</span>
<span class="comments">; HISTORY</span>
<span class="comments">;       written by F. Varosi Oct.90:</span>
<span class="comments">;       uses WHERE to find equal clumps, instead of looping with IF ( EQ ).</span>
<span class="comments">;       compatible with string arrays, test for degenerate array</span>
<span class="comments">;       20-MAY-1991     JKF/ACC via T AKE- return indexes if the array to</span>
<span class="comments">;                       be sorted has all equal values.</span>
<span class="comments">;       Aug - 91  Added  REVERSE keyword   W. Landsman</span>
<span class="comments">;       Always return type LONG    W. Landsman     August 1994</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;</span>
        N = N_elements( Array )
        if N lt 1 then begin
                print,'Input to ImageSelect_BSort must be an array'
                return, [0L]
           endif

        if N lt 2 then begin
            asort = array       <span class="comments">;MDM added 24-Sep-91</span>
            return,[0L]    <span class="comments">;Only 1 element</span>
        end
<span class="comments">;</span>
<span class="comments">; sort array (in descending order if REVERSE keyword specified )</span>
<span class="comments">;</span>
        subs = sort( Array )
        if keyword_set( REV ) then subs = rotate(subs,5)
        Asort = Array[subs]
<span class="comments">;</span>
<span class="comments">; now sort subscripts into ascending order</span>
<span class="comments">; when more than one Asort has same value</span>
<span class="comments">;</span>
             weq = where( (shift( Asort, -1 ) eq Asort) , Neq )

        if keyword_set( info ) then $
                message, strtrim( Neq, 2 ) + " equal values Located",/CON,/INF

        if (Neq EQ n) then return,lindgen(n) <span class="comments">;Array is degenerate equal values</span>

        if (Neq GT 0) then begin

                if (Neq GT 1) then begin              <span class="comments">;find clumps of equality</span>

                        wclump = where( (shift( weq, -1 ) - weq) GT 1, Nclump )
                        Nclump = Nclump + 1

                  endif else Nclump = 1

                if (Nclump LE 1) then begin
                        Clump_Beg = 0
                        Clump_End = Neq-1
                  endif else begin
                        Clump_Beg = [0,wclump+1]
                        Clump_End = [wclump,Neq-1]
                   endelse

                weq_Beg = weq[ Clump_Beg ]              <span class="comments">;subscript ranges</span>
                weq_End = weq[ Clump_End ] + 1          <span class="comments">; of Asort equalities.</span>

                if keyword_set( info ) then message, strtrim( Nclump, 2 ) + $
                                " clumps of equal values Located",/CON,/INF

                for ic = 0L, Nclump-1 do begin          <span class="comments">;sort each clump.</span>

                        subic = subs[ weq_Beg[ic] : weq_End[ic] ]
                        subs[ weq_Beg[ic] ] = subic[ sort( subic ) ]
                  endfor

                if N_params() GE 2 then Asort = Array[subs]     <span class="comments">;resort array.</span>
           endif

return, subs
END <span class="comments">; ----------------------------------------------------------------------------------------</span>



PRO ImageSelect_Cleanup, tlb

<span class="comments">; Program pointers are cleaned up here.</span>

   Widget_Control, tlb, Get_UValue=info, /No_Copy
   IF N_Elements(info) EQ 0 THEN RETURN
   Ptr_Free, info.theFiles
   Ptr_Free, info.filter
   Ptr_Free, info.excludeFiles

END <span class="comments">; ----------------------------------------------------------------------------------------</span>



FUNCTION ImageSelect_FileExtension, filename

<span class="comments">; This function finds the file extension of the filename by</span>
<span class="comments">; searching for the last ".".</span>

   parts = StrSplit(filename, ".", /Extract)
   IF N_Elements(parts) EQ 1 THEN extension = "*" ELSE $
      extension = parts[N_Elements(parts)-1]

   RETURN, StrUpCase(extension)

END <span class="comments">; ----------------------------------------------------------------------------------------</span>



PRO ImageSelect_FilenameEvents, event

<span class="comments">; This event handler responds to events from the filename compound widget.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Get the name of the file.</span>
   filename = event.basename
   CD, event.directory, Current=thisDirectory

   <span class="comments">; Locate appropriate files.</span>
   Ptr_Free, info.theFiles
   info.theFiles = Ptr_New(/Allocate_Heap)

   <span class="comments">; Sort the files.</span>
   FOR j=0, N_Elements(*info.filter)-1 DO BEGIN
      specificFiles = File_Search((*info.filter)[j], Count=fileCount)
      IF fileCount GT 0 THEN IF N_Elements(*(info.theFiles)) EQ 0 THEN $
         *info.theFiles = specificFiles[ImageSelect_BSort(specificFiles)] ELSE $
         *info.theFiles = [*info.theFiles, specificFiles[ImageSelect_BSort(specificFiles)]]
   ENDFOR
   fileCount = N_Elements(*info.theFiles)
   IF fileCount EQ 0 THEN *info.theFiles = "" ELSE BEGIN
      IF Ptr_Valid(info.excludeFiles) THEN BEGIN
        FOR k=0,N_Elements(*info.excludeFiles)-1 DO BEGIN
           index = Where(StrUpCase(*info.theFiles) EQ StrUpCase((*info.excludeFiles)[k]), count, COMPLEMENT=ok)
           IF count GT 0 THEN *info.theFiles = (*info.theFiles)[ok]
        ENDFOR
      ENDIF
      IF filename EQ "" THEN filename = (*info.theFiles)[0]
   ENDELSE
   info.dataDirectory = event.directory

   <span class="comments">; Is the filename amoung the list of files? If not,</span>
   <span class="comments">; chose another filename.</span>
   index = Where(StrLowCase(*info.theFiles) EQ StrLowCase(filename), count)
   IF count EQ 0 THEN BEGIN
      filename = (*info.theFiles)[0]
      Widget_Control, info.filenameID, Set_Value=filename
   ENDIF

   <span class="comments">; Set the file list.</span>
   Widget_Control, info.fileListID, Set_Value=*info.theFiles

   <span class="comments">; Can you find the filename in the list of files? If so,</span>
   <span class="comments">; highlight it in the list.</span>
   i = Where(StrUpCase(*info.theFiles) EQ StrUpCase(filename), count)
   IF count GT 0 THEN Widget_Control, info.filelistID, Set_List_Select=i

   <span class="comments">; Set the file extension.</span>
   thisExtension = ImageSelect_FileExtension(filename)

   <span class="comments">; Try to read the image</span>
   ImageSelect_ReadFiles, thisExtension, filename, info, fileinfo, $
        image, ok, type, _Extra=*((*info.storagePtr).extra)

   <span class="comments">; If you are only displaying 2D images, set sensitive buttons.</span>
   IF info.only2d THEN IF fileinfo.channels NE 1 THEN $
      Widget_Control, info.acceptID, Sensitive=0 ELSE $
      Widget_Control, info.acceptID, Sensitive=1

   <span class="comments">; If you are only displaying 3D images, set sensitive buttons.</span>
   IF info.only3d THEN IF fileinfo.channels NE 3 THEN $
      Widget_Control, info.acceptID, Sensitive=0 ELSE $
      Widget_Control, info.acceptID, Sensitive=1

   <span class="comments">; What kind of image is this?</span>
   CASE fileinfo.channels OF
      3: imageType = 'True-Color ' + type + ' Image'
      0: imageType = 'No Image'
      -1: imageType = 'Invalid Image File'
      ELSE: imageType = '2D ' + type + ' Image'
   ENDCASE

   <span class="comments">; Get the file sizes. Dicom images can report incorrect sizes,</span>
   <span class="comments">; which is what we are trying to fix in the ysize line.</span>
   xsize = fileInfo.dimensions[0]
   ysize = fileInfo.dimensions[1] > Fix(xsize * 0.5)

   <span class="comments">; Get the file sizes.</span>
   dimensions = Image_Dimensions(image, XSize=xsize, YSize=ysize, YIndex=yindex)

   <span class="comments">; Flip the image if required.</span>
   IF info.flipimage THEN image = Reverse(image, yindex+1)

   <span class="comments">; Calculate a window size for the image preview.</span>
   aspect = Float(xsize) / ysize
   IF aspect GT 1 THEN BEGIN
      wxsize = Fix(info.previewSize)
      wysize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
   ENDIF ELSE BEGIN
      wysize = Fix(info.previewSize)
      wxsize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
   ENDELSE

   <span class="comments">; If you don't have an image, then get sensible numbers for the labels.</span>
   IF imageType EQ 'No Image' OR imageType EQ 'Invalid Image File' THEN BEGIN
      xsize = 0
      ysize = 0
      minval = 0
      maxval = 0
   ENDIF

   <span class="comments">; Update the display with what you have.</span>
   IF imageType EQ 'No Image' THEN imageDataType = 'NONE' ELSE imageDataType = Size(image, /TNAME)
   IF imageType EQ 'Invalid Image File' THEN imageDataType = 'INVALID'
   Widget_Control, info.labelTypeID, Set_Value=imageType
   Widget_Control, info.labelXSizeID, Set_Value="X Size: " + StrTrim(xsize, 2)
   Widget_Control, info.labelYSizeID, Set_Value="Y Size: " + StrTrim(ysize, 2)
   Widget_Control, info.labelDataTypeID, Set_Value="Type: " + imageDataType
   Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
   Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))

   <span class="comments">; Draw the preview image.</span>
   WSet, info.previewWID
   sizes = ImageSelect_WindowSize(image, XSIZE=info.previewSize, YSIZE=info.previewSize)
   Widget_Control, info.previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
   TVLCT, info.r, info.g, info.b
   IF (Min(image) LT 0) OR (Max(image) GT (!D.Table_Size-1)) THEN $
      cgImage, BytScl(image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
      cgImage, image, /Keep_Aspect
   IF imageDataType EQ 'NONE' THEN image = 0

   <span class="comments">; Store the image data for later retrieval.</span>
   *(*(info.storagePtr)).image = image
   *(*(info.storagePtr)).fileInfo = fileInfo
   (*info.storagePtr).r = info.r
   (*info.storagePtr).g = info.g
   (*info.storagePtr).b = info.b

   <span class="comments">; Clean up.</span>
   CD, thisDirectory
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;---------------------------------------------------------------------------------</span>



PRO ImageSelect_FlipImage, event

<span class="comments">; This event handler reverses the Y dimension of the image and re-displays it.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Reverse the Y dimensions.</span>
   dims = Image_Dimensions(*(*(info.storagePtr)).image, YIndex=yindex)
   *(*(info.storagePtr)).image = Reverse(*(*(info.storagePtr)).image, yindex + 1)

   <span class="comments">; Display it again.</span>
   WSet, info.previewWID
   sizes = ImageSelect_WindowSize(*(*(info.storagePtr)).image, XSIZE=info.previewSize, YSIZE=info.previewSize)
   Widget_Control, info.previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
   TVLCT, info.r, info.g, info.b
   IF (Min(*(*(info.storagePtr)).image) LT 0) OR (Max(*(*(info.storagePtr)).image) GT (!D.Table_Size-1)) THEN $
      cgImage, BytScl(*(*(info.storagePtr)).image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
      cgImage, *(*(info.storagePtr)).image, /Keep_Aspect

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; ----------------------------------------------------------------------------------------</span>



PRO ImageSelect_ListEvents, event

<span class="comments">; Handles events from the list widget of file names.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Handle double click events here.</span>
   IF event.clicks NE 1 THEN BEGIN

       Widget_Control, event.top, Get_UValue=info, /No_Copy

      <span class="comments">; Get the name of the file.</span>
      filename = (*info.theFiles)[event.index]
      CD, info.dataDirectory, Current=thisDirectory

      <span class="comments">; Set it in the Filename widget.</span>
      Widget_Control, info.filenameID, Set_Value=filename

      <span class="comments">; Try to read the image</span>
      thisExtension = ImageSelect_FileExtension(filename)
      ImageSelect_ReadFiles, thisExtension, filename, info, fileinfo, $
            image, ok, type, _Extra=*((*info.storagePtr).extra)

      <span class="comments">; If this is an image you can accept, the read it and exit.</span>
      <span class="comments">; If not treat as a single click.</span>
      canRead = 1
      IF info.only2d AND (fileinfo.channels NE 1) THEN canRead = 0
      IF info.only3d AND (fileinfo.channels NE 3) THEN canRead = 0

      IF canRead THEN BEGIN

         <span class="comments">; Set the cancel flag appropriately.</span>
         (*info.storagePtr).cancel = 0

         <span class="comments">; Get the name and directory you selected and set them into output fields.</span>
         info.filenameObj->GetProperty, Directory=outdirectory, Filename=outfilename
         (*info.storagePtr).outdirectory = outdirectory
         (*info.storagePtr).outfilename = outfilename

         <span class="comments">; Get the current offsets.</span>
         Widget_Control, event.top, TLB_GET_OFFSET=offsets
         (*info.storagePtr).offsets = offsets

         <span class="comments">; Store the image data for later retrieval.</span>
         *(*(info.storagePtr)).image = image
         *(*(info.storagePtr)).fileInfo = fileInfo
         (*info.storagePtr).r = info.r
         (*info.storagePtr).g = info.g
         (*info.storagePtr).b = info.b
         TVLCT, info.r, info.g, info.b

         Widget_Control, event.top, Set_UValue=info, /No_Copy
         Widget_Control, event.top, /Destroy

      ENDIF ELSE BEGIN

         <span class="comments">; Set sensive buttons on for both 2D and 3D images.</span>
         IF info.only2d THEN IF fileinfo.channels NE 1 THEN $
            Widget_Control, info.acceptID, Sensitive=0 ELSE $
            Widget_Control, info.acceptID, Sensitive=1
         IF info.only3d THEN IF fileinfo.channels NE 3 THEN $
            Widget_Control, info.acceptID, Sensitive=0 ELSE $
            Widget_Control, info.acceptID, Sensitive=1

         <span class="comments">; What kind of image is this?</span>
           CASE fileinfo.channels OF
              3: imageType = 'True-Color ' + type + ' Image'
              0: imageType = 'No Image'
              -1: imageType = 'Invalid Image File'
              ELSE: imageType = '2D ' + type + ' Image'
           ENDCASE

         <span class="comments">; Get the file sizes. Dicom images can report incorrect sizes,</span>
         <span class="comments">; which is what we are trying to fix in the ysize line.</span>
         xsize = fileInfo.dimensions[0]
         ysize = fileInfo.dimensions[1] > Fix(xsize * 0.5)

         <span class="comments">; Get the file sizes.</span>
         dimensions = Image_Dimensions(image, XSize=xsize, YSize=ysize, YIndex=yindex)

         <span class="comments">; Flip the image if required.</span>
         IF info.flipimage THEN image = Reverse(image, yindex+1)

         <span class="comments">; Calculate a window size for the image preview.</span>
         aspect = Float(xsize) / ysize
         IF aspect GT 1 THEN BEGIN
            wxsize = Fix(info.previewSize)
            wysize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
         ENDIF ELSE BEGIN
            wysize = Fix(info.previewSize)
            wxsize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
         ENDELSE

         <span class="comments">; If you don't have an image, then get sensible numbers for the labels.</span>
         IF imageType EQ 'No Image' OR imageType EQ 'Invalid Image File' THEN BEGIN
            xsize = 0
            ysize = 0
            minval = 0
            maxval = 0
         ENDIF

         <span class="comments">; Update the display with what you have.</span>
         IF imageType EQ 'No Image' THEN imageDataType = 'NONE' ELSE imageDataType = Size(image, /TNAME)
         IF imageType EQ 'Invalid Image File' THEN imageDataType = 'INVALID'
         Widget_Control, info.labelTypeID, Set_Value=imageType
         Widget_Control, info.labelXSizeID, Set_Value="X Size: " + StrTrim(xsize, 2)
         Widget_Control, info.labelYSizeID, Set_Value="Y Size: " + StrTrim(ysize, 2)
         Widget_Control, info.labelDataTypeID, Set_Value="Type: " + imageDataType
         IF imageDataType NE 'FLOAT' THEN BEGIN
            Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
            Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))
         ENDIF ELSE BEGIN
            Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
            Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))
         ENDELSE

         <span class="comments">; Draw the preview image.</span>
         WSet, info.previewWID
         sizes = ImageSelect_WindowSize(image, XSIZE=info.previewSize, YSIZE=info.previewSize)
         Widget_Control, info.previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
         TVLCT, info.r, info.g, info.b
         IF (Min(image) LT 0) OR (Max(image) GT (!D.Table_Size-1)) THEN $
            cgImage, BytScl(image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
            cgImage, image, /Keep_Aspect
         IF imageDataType EQ 'NONE' THEN image = 0

         <span class="comments">; Store the image data for later retrieval.</span>
         *(*(info.storagePtr)).image = image
         *(*(info.storagePtr)).fileInfo = fileInfo
         (*info.storagePtr).r = info.r
         (*info.storagePtr).g = info.g
         (*info.storagePtr).b = info.b

         <span class="comments">; Clean up.</span>
         CD, thisDirectory
         Widget_Control, event.top, Set_UValue=info, /No_Copy

      ENDELSE

   ENDIF


   <span class="comments">; Handle single click events here.</span>
   IF event.clicks EQ 1 THEN BEGIN

      Widget_Control, event.top, Get_UValue=info, /No_Copy

      <span class="comments">; Get the name of the file.</span>
      filename = (*info.theFiles)[event.index]
      CD, info.dataDirectory, Current=thisDirectory

      <span class="comments">; Set it in the Filename widget.</span>
      Widget_Control, info.filenameID, Set_Value=filename

      <span class="comments">; Try to read the image</span>
      thisExtension = ImageSelect_FileExtension(filename)
      ImageSelect_ReadFiles, thisExtension, filename, info, fileinfo, $
            image, ok, type, _Extra=*((*info.storagePtr).extra)

      <span class="comments">; Set sensive buttons on for both 2D and 3D images.</span>
      IF info.only2d THEN IF fileinfo.channels NE 1 THEN $
         Widget_Control, info.acceptID, Sensitive=0 ELSE $
         Widget_Control, info.acceptID, Sensitive=1
      IF info.only3d THEN IF fileinfo.channels NE 3 THEN $
         Widget_Control, info.acceptID, Sensitive=0 ELSE $
         Widget_Control, info.acceptID, Sensitive=1

      <span class="comments">; What kind of image is this?</span>
       CASE fileinfo.channels OF
          3: imageType = 'True-Color ' + type + ' Image'
          0: imageType = 'No Image'
          -1: imageType = 'Invalid Image File'
          ELSE: imageType = '2D ' + type + ' Image'
       ENDCASE

      <span class="comments">; Get the file sizes. Dicom images can report incorrect sizes,</span>
      <span class="comments">; which is what we are trying to fix in the ysize line.</span>
      xsize = fileInfo.dimensions[0]
      ysize = fileInfo.dimensions[1] > Fix(xsize * 0.5)

      <span class="comments">; Get the file sizes.</span>
      dimensions = Image_Dimensions(image, XSize=xsize, YSize=ysize, YIndex=yindex)

      <span class="comments">; Flip the image if required.</span>
      IF info.flipimage THEN image = Reverse(image, yindex+1)

      <span class="comments">; Calculate a window size for the image preview.</span>
      aspect = Float(xsize) / ysize
      IF aspect GT 1 THEN BEGIN
         wxsize = Fix(info.previewSize)
         wysize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
      ENDIF ELSE BEGIN
         wysize = Fix(info.previewSize)
         wxsize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
      ENDELSE

      <span class="comments">; If you don't have an image, then get sensible numbers for the labels.</span>
      IF imageType EQ 'No Image' OR imageType EQ 'Invalid Image File' THEN BEGIN
         xsize = 0
         ysize = 0
         minval = 0
         maxval = 0
      ENDIF

      <span class="comments">; Update the display with what you have.</span>
      IF imageType EQ 'No Image' THEN imageDataType = 'NONE' ELSE imageDataType = Size(image, /TNAME)
      IF imageType EQ 'Invalid Image File' THEN imageDataType = 'INVALID'
      Widget_Control, info.labelTypeID, Set_Value=imageType
      Widget_Control, info.labelXSizeID, Set_Value="X Size: " + StrTrim(xsize, 2)
      Widget_Control, info.labelYSizeID, Set_Value="Y Size: " + StrTrim(ysize, 2)
      Widget_Control, info.labelDataTypeID, Set_Value="Type: " + imageDataType
      IF imageDataType NE 'FLOAT' THEN BEGIN
         Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
         Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))
      ENDIF ELSE BEGIN
         Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
         Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))
      ENDELSE

      <span class="comments">; Draw the preview image.</span>
      WSet, info.previewWID
      sizes = ImageSelect_WindowSize(image, XSIZE=info.previewSize, YSIZE=info.previewSize)
      Widget_Control, info.previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
      TVLCT, info.r, info.g, info.b
      IF (Min(image) LT 0) OR (Max(image) GT (!D.Table_Size-1)) THEN $
         cgImage, BytScl(image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
         cgImage, image, /Keep_Aspect
      IF imageDataType EQ 'NONE' THEN image = 0

      <span class="comments">; Store the image data for later retrieval.</span>
      *(*(info.storagePtr)).image = image
      *(*(info.storagePtr)).fileInfo = fileInfo
      (*info.storagePtr).r = info.r
      (*info.storagePtr).g = info.g
      (*info.storagePtr).b = info.b

      <span class="comments">; Clean up.</span>
      CD, thisDirectory
      Widget_Control, event.top, Set_UValue=info, /No_Copy

   ENDIF

END <span class="comments">;---------------------------------------------------------------------------------</span>



PRO ImageSelect_ReadFiles, extension, filename, info, fileinfo, image, ok, type, _Extra=extra

<span class="comments">; Utility routine to read the data file. Returns the image and file information.</span>
<span class="comments">; First three parameters are required INPUT, last three are optional OUTPUT.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      ok = 0
      RETURN
   ENDIF

   <span class="comments">; We need three required parameters.</span>
   IF N_Params() LT 3 THEN Message, 'Called with incorrect number of required parameters.'

   <span class="comments">; Initialize output variables.</span>
   image = BytArr(info.previewsize, info.previewsize)
   fileInfo = {channels:0, dimensions:[info.previewsize, info.previewsize],  type:""}
   ok = 0

   <span class="comments">; Must have non-null filename to continue.</span>
   IF filename EQ "" THEN RETURN

   <span class="comments">; Read the image for display.</span>
   CASE extension OF

      "BMP": BEGIN
         ok = Query_BMP(filename, fileInfo)
         IF ok THEN BEGIN
            IF fileInfo.channels EQ 3 THEN image = Read_BMP(filename, /RGB, _EXTRA=extra) ELSE $
                                                   image = Read_BMP(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'BMP'
         ENDCASE

      "DCM": BEGIN
         IF StrUpCase(!Version.OS_Family) EQ 'WINDOWS' THEN BEGIN
            thisRelease = Float(!Version.Release)
            IF (thisRelease GT 6.4) AND (thisRelease LT 8) THEN BEGIN
                IF !Version.Memory_Bits EQ 64 THEN Message, 'This version of IDL does not support reading DICOM files.'
            ENDIF
         ENDIF
         ok = Query_DICOM(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_Dicom(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'DICOM'
         ENDCASE

      "GIF": BEGIN
         ok = Query_GIF(filename, fileInfo)
         IF ok THEN BEGIN
            IF fileInfo.channels EQ 0 THEN fileInfo.channels = 1 <span class="comments">; Bug?</span>
            Read_GIF, filename, image, r, g, b, _EXTRA=extra
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'GIF'
         ENDCASE

      "FITS": BEGIN
         header = Call_Function('HeadFits', filename, /Silent, ERRMSG=ok)
         IF ok EQ "" THEN BEGIN
            ok = 1

          <span class="comments">; Check for unsigned integer</span>
          offset = Call_Function('SXPar', header, 'BZERO', Count=count)
          IF count GT 0 THEN BEGIN
             IF offset EQ '32768' THEN BEGIN
                image = Call_Function("MRDFITS", filename, /Unsigned, _EXTRA=extra, /Silent)
             ENDIF ELSE BEGIN
                image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)
             ENDELSE
          ENDIF ELSE image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)

          <span class="comments">; Construct a fileInfo structure for this image.</span>
          dims = Image_Dimensions(image, XSize=xsize, YSize=ysize, TrueIndex=trueindex)
          fileinfo = {has_palette:0, channels:1, dimensions:dims, image_index:0L, $
               num_images:1L, pixel_type:Size(image, /Type), type:"FITS", header:header}
          IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'FITS'
         ENDCASE

      "FIT": BEGIN
         header = Call_Function('HeadFits', filename, /Silent, ERRMSG=ok)
         IF ok EQ "" THEN BEGIN
            ok = 1

          <span class="comments">; Check for unsigned integer</span>
          offset = Call_Function('SXPar', header, 'BZERO', Count=count)
          IF count GT 0 THEN BEGIN
             IF offset EQ '32768' THEN BEGIN
                image = Call_Function("MRDFITS", filename, /Unsigned, _EXTRA=extra, /Silent)
             ENDIF ELSE BEGIN
                image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)
             ENDELSE
          ENDIF ELSE image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)

          <span class="comments">; Construct a fileInfo structure for this image.</span>
            dims = Image_Dimensions(image, XSize=xsize, YSize=ysize, TrueIndex=trueindex)
            fileinfo = {has_palette:0, channels:1, dimensions:dims, image_index:0L, $
               num_images:1L, pixel_type:Size(image, /Type), type:"FITS", header:header}
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'FITS'
         ENDCASE

      "FTS": BEGIN
         header = Call_Function('HeadFits', filename, /Silent, ERRMSG=ok)
         IF ok EQ "" THEN BEGIN
            ok = 1

          <span class="comments">; Check for unsigned integer</span>
          offset = Call_Function('SXPar', header, 'BZERO', Count=count)
          IF count GT 0 THEN BEGIN
             IF offset EQ '32768' THEN BEGIN
                image = Call_Function("MRDFITS", filename, /Unsigned, _EXTRA=extra, /Silent)
             ENDIF ELSE BEGIN
                image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)
             ENDELSE
          ENDIF ELSE image = Call_Function("MRDFITS", filename, _EXTRA=extra, /Silent, /FScale)

          <span class="comments">; Construct a fileInfo structure for this image.</span>
            dims = Image_Dimensions(image, XSize=xsize, YSize=ysize, TrueIndex=trueindex)
            fileinfo = {has_palette:0, channels:1, dimensions:dims, image_index:0L, $
               num_images:1L, pixel_type:Size(image, /Type), type:"FITS", header:header}
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'FITS'
         ENDCASE

      "JPEG": BEGIN
         ok = Query_JPEG(filename, fileInfo)
         IF ok THEN $
         BEGIN
            Device, Get_Visual_Depth = theDepth
            IF theDepth GT 8 THEN BEGIN
               Read_JPEG, filename, image, True=1, _EXTRA=extra
            ENDIF ELSE BEGIN
               Read_JPEG, filename, image, colortable, Dither=1, Colors=!D.Table_Size, _EXTRA=extra
               r = colortable[*,0]
               g = colortable[*,1]
               b = colortable[*,2]
               TVLCT, r, g, b
            ENDELSE
            IF fileInfo.has_palette EQ 1 THEN $
            BEGIN
                  r = colortable[*,0]
                  g = colortable[*,1]
                  b = colortable[*,2]
               TVLCT, r, g, b
            ENDIF
         ENDIF
         type = 'JPEG'
         ENDCASE

      "JPG": BEGIN
         ok = Query_JPEG(filename, fileInfo)
         IF ok THEN $
         BEGIN
            Device, Get_Visual_Depth = theDepth
            IF theDepth GT 8 THEN BEGIN
               Read_JPEG, filename, image, True=1, _EXTRA=extra
            ENDIF ELSE BEGIN
               Read_JPEG, filename, image, colortable, Dither=1, Colors=!D.Table_Size, _EXTRA=extra
               r = colortable[*,0]
               g = colortable[*,1]
               b = colortable[*,2]
               TVLCT, r, g, b
            ENDELSE
            IF fileInfo.has_palette EQ 1 THEN $
            BEGIN
                  r = colortable[*,0]
                  g = colortable[*,1]
                  b = colortable[*,2]
               TVLCT, r, g, b
            ENDIF
         ENDIF
         type = 'JPEG'
         ENDCASE

      "JPE": BEGIN
         ok = Query_JPEG(filename, fileInfo)
         IF ok THEN $
         BEGIN
            Device, Get_Visual_Depth = theDepth
            IF theDepth GT 8 THEN BEGIN
               Read_JPEG, filename, image, True=1, _EXTRA=extra
            ENDIF ELSE BEGIN
               Read_JPEG, filename, image, colortable, Dither=1, Colors=!D.Table_Size, _EXTRA=extra
               r = colortable[*,0]
               g = colortable[*,1]
               b = colortable[*,2]
               TVLCT, r, g, b
            ENDELSE
            IF fileInfo.has_palette EQ 1 THEN $
            BEGIN
                  r = colortable[*,0]
                  g = colortable[*,1]
                  b = colortable[*,2]
               TVLCT, r, g, b
            ENDIF
         ENDIF
         type = 'JPEG'
         ENDCASE

      "JPF": BEGIN
         ok = Query_JPEG2000(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_JPEG2000(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'JPEG2000'
         ENDCASE

      "JPX": BEGIN
         ok = Query_JPEG2000(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_JPEG2000(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'JPEG2000'
         ENDCASE

      "JP2": BEGIN
         ok = Query_JPEG2000(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_JPEG2000(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'JPEG2000'
         ENDCASE

      "J2C": BEGIN
         ok = Query_JPEG2000(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_JPEG2000(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'JPEG2000'
         ENDCASE

      "J2K": BEGIN
         ok = Query_JPEG2000(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_JPEG2000(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'JPEG2000'
         ENDCASE

      "PICT": BEGIN
         ok = Query_PICT(filename, fileInfo)
         IF ok THEN BEGIN
            Read_PICT, filename, image, r, g, b, _EXTRA=extra
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'PICT'
         ENDCASE

      "PGM": BEGIN
         ok = Query_PPM(filename, fileInfo)
         IF ok THEN BEGIN
            Read_PPM, filename, image, _EXTRA=extra
            TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'PGM'
         ENDCASE

      "PPM": BEGIN
         ok = Query_PPM(filename, fileInfo)
         IF ok THEN BEGIN
            Read_PPM, filename, image, _EXTRA=extra
            TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
         ENDIF
         type = 'PPM'
         ENDCASE

      "PNG": BEGIN
         ok = Query_PNG(filename, fileInfo)
         IF ok THEN BEGIN
            image = Read_PNG(filename, r, g, b, _EXTRA=extra)
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
            
            <span class="comments">; Some PNG files (from ImageMagick, for example) are created with 16-bits per channel.</span>
            <span class="comments">; Convert this to 8-bits per channel, and also remove any alpha channel for this application.</span>
            IF Size(image, /TNAME) NE 'BYTE' THEN image = BytScl(image)
            IF Size(image, /N_DIMENSIONS) GT 3 THEN BEGIN
                dims = Image_Dimensions(image, TRUEINDEX=trueindex)
                CASE trueIndex OF
                    0: image = image[0:2, *, *]
                    1: image = image[*, 0:2, *]
                    2: image = image[*, *, 0:2]
                ENDCASE
            ENDIF
         ENDIF
         type = 'PNG'
         ENDCASE

      "TIF": BEGIN
         ok = Query_TIFF(filename, fileInfo, GEOTIFF=geotiff)
         IF ok THEN BEGIN
            CASE fileInfo.channels OF
               3: image = Read_TIFF(filename, _EXTRA=extra, ORIENTATION=orientation)
               ELSE: image = Read_TIFF(filename, r, g, b, _EXTRA=extra, ORIENTATION=orientation)
            ENDCASE
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
            IF Size(geotiff, /TNAME) EQ 'STRUCT' THEN BEGIN

               <span class="comments">; Save the geotiff variable at the IDL main level.</span>
               (Scope_VarFetch('geotiff', LEVEL=1, /ENTER)) = geotiff
            
            ENDIF
         ENDIF ELSE orientation = 1
         IF orientation EQ 1 THEN BEGIN
             dims = Image_Dimensions(image, YINDEX=yindex)
             image = Reverse(Temporary(image), yindex+1)
         ENDIF
         IF Size(geotiff, /TNAME) EQ 'STRUCT' THEN type = 'GEOTIFF' ELSE type = 'TIFF'
         ENDCASE

      "TIFF": BEGIN
         ok = Query_TIFF(filename, fileInfo, GEOTIFF=geotiff)
         IF ok THEN BEGIN
            CASE fileInfo.channels OF
               3: image = Read_TIFF(filename, _EXTRA=extra, ORIENTATION=orientation)
               ELSE: image = Read_TIFF(filename, r, g, b, _EXTRA=extra, ORIENTATION=orientation)
            ENDCASE
            IF fileInfo.has_palette EQ 1 THEN TVLCT, r, g, b ELSE TVLCT, Bindgen(256), Bindgen(256), Bindgen(256)
            IF Size(geotiff, /TNAME) EQ 'STRUCT' THEN BEGIN
               
               <span class="comments">; Save the geotiff variable at the IDL main level.</span>
               (Scope_VarFetch('geotiff', LEVEL=1, /ENTER)) = geotiff
            
            ENDIF
         ENDIF ELSE orientation = 1
         IF orientation EQ 1 THEN BEGIN
             dims = Image_Dimensions(image, YINDEX=yindex)
             image = Reverse(Temporary(image), yindex+1)
         ENDIF
         IF Size(geotiff, /TNAME) EQ 'STRUCT' THEN type = 'GEOTIFF' ELSE type = 'TIFF'
         ENDCASE

      ELSE: ok = 0

   ENDCASE

   <span class="comments">; If there was a problem, report it and indicate an invalid file.</span>
   IF ~ok THEN BEGIN
      void = Dialog_Message('Selected file is not a valid ' + extension + ' type. Returning.')
      fileInfo.channels = -1
      RETURN
   ENDIF
   
   <span class="comments">; Store RGB vectors if they got set.</span>
   IF N_Elements(r) NE 0 THEN info.r = r ELSE info.r = Bindgen(!D.Table_Size)
   IF N_Elements(g) NE 0 THEN info.g = g ELSE info.g = Bindgen(!D.Table_Size)
   IF N_Elements(b) NE 0 THEN info.b = b ELSE info.b = Bindgen(!D.Table_Size)

END <span class="comments">; ------------------------------------------------------------------------------------</span>


PRO ImageSelect_SetFilter, event

<span class="comments">; This event handler responds to events on the Filter button.</span>

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; This event handler sets the filter for image data files.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; The filter is in the User Value of the button. Store it.</span>
   Widget_Control, event.id, Get_UValue=theFilter
   *info.filter = theFilter

   <span class="comments">; Put a check mark next to this button.</span>
   parent = Widget_Info(event.id, /Parent)
   child = Widget_Info(parent, /Child)
   WHILE child  NE 0 DO BEGIN
      IF child NE event.id THEN Widget_Control, child, Set_Button=0 ELSE Widget_Control, child, Set_Button=1
      child = Widget_Info(child, /Sibling)
   ENDWHILE

   <span class="comments">; Get the current filename.</span>
   Widget_Control, info.filenameID, Get_Value=filename

   <span class="comments">; Set the new filter in the Filename compound widget.</span>
   info.filenameObj->SetProperty, Filter=theFilter

   <span class="comments">; Look in the data directory for the files.</span>
   CD, info.dataDirectory, Current=thisDirectory

   <span class="comments">; Locate appropriate files.</span>
   FOR j=0, N_Elements(*info.filter)-1 DO BEGIN

      specificFiles = File_Search((*info.filter)[j], Count=fileCount)
      IF fileCount GT 0 THEN IF N_Elements(theFiles) EQ 0 THEN $
         theFiles = specificFiles[ImageSelect_BSort(StrLowCase(specificFiles))] ELSE $
         theFiles = [theFiles, specificFiles[ImageSelect_BSort(StrLowCase(specificFiles))]]
   ENDFOR
   fileCount = N_Elements(theFiles)
   IF fileCount EQ 0 THEN BEGIN
      theFiles = ""
      filename = ""
   ENDIF ELSE BEGIN
      IF Ptr_Valid(info.excludeFiles) THEN BEGIN
        FOR k=0,N_Elements(*info.excludeFiles)-1 DO BEGIN
           index = Where(StrUpCase(theFiles) EQ StrUpCase((*info.excludeFiles)[k]), count, COMPLEMENT=ok)
           IF count GT 0 THEN theFiles = theFiles[ok]
        ENDFOR
      ENDIF
      filename = theFiles[0]
   ENDELSE

   <span class="comments">; Update the widget interface according to what you found.</span>
   Widget_Control, info.filenameID, Set_Value=filename
   Widget_Control, info.fileListID, Set_Value=theFiles
   IF fileCount GT 0 THEN Widget_Control, info.fileListID, Set_List_Select=0
   *info.theFiles = theFiles

   <span class="comments">; Try to read the image</span>
   thisExtension = ImageSelect_FileExtension(filename)
   ImageSelect_ReadFiles, thisExtension, filename, info, fileinfo, $
        image, ok, type, _Extra=*((*info.storagePtr).extra)

   <span class="comments">; What kind of image is this?</span>
   CASE fileinfo.channels OF
      3: imageType = 'True-Color ' + type + ' Image'
      0: imageType = 'No Image'
      -1: imageType = 'Invalid Image File'
      ELSE: imageType = '2D ' + type + ' Image'
   ENDCASE

   <span class="comments">; Get the file sizes. Dicom images can report incorrect sizes,</span>
   <span class="comments">; which is what we are trying to fix in the ysize line.</span>
   xsize = fileInfo.dimensions[0]
   ysize = fileInfo.dimensions[1] > Fix(xsize * 0.5)

   <span class="comments">; Get the file sizes.</span>
   dimensions = Image_Dimensions(image, XSize=xsize, YSize=ysize, YIndex=yindex)

   <span class="comments">; Flip the image if required.</span>
   IF info.flipimage THEN image = Reverse(image, yindex+1)

   <span class="comments">; Calculate a window size for the image preview.</span>
   aspect = Float(xsize) / ysize
   IF aspect GT 1 THEN BEGIN
      wxsize = Fix(info.previewSize)
      wysize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
   ENDIF ELSE BEGIN
      wysize = Fix(info.previewSize)
      wxsize = Fix(info.previewSize / aspect) &lt<span class="comments">; info.previewSize</span>
   ENDELSE

   <span class="comments">; If you don't have an image, then get sensible numbers for the labels.</span>
   IF imageType EQ 'No Image' OR imageType EQ 'Invalid Image File' THEN BEGIN
      xsize = 0
      ysize = 0
      minval = 0
      maxval = 0
   ENDIF

   <span class="comments">; Update the display with what you have.</span>
   IF imageType EQ 'No Image' THEN imageDataType = 'NONE' ELSE imageDataType = Size(image, /TNAME)
   IF imageType EQ 'Invalid Image File' THEN imageDataType = 'INVALID'
   Widget_Control, info.labelTypeID, Set_Value=imageType
   Widget_Control, info.labelXSizeID, Set_Value="X Size: " + StrTrim(xsize, 2)
   Widget_Control, info.labelYSizeID, Set_Value="Y Size: " + StrTrim(ysize, 2)
   Widget_Control, info.labelDataTypeID, Set_Value="Type: " + imageDataType
   Widget_Control, info.labelminvalID, Set_Value="Min Value: " + cgNumber_Formatter(Min(image))
   Widget_Control, info.labelmaxvalID, Set_Value="Max Value: " + cgNumber_Formatter(Max(image))

   <span class="comments">; Draw the preview image.</span>
   WSet, info.previewWID
   sizes = ImageSelect_WindowSize(image, XSIZE=info.previewSize, YSIZE=info.previewSize)
   Widget_Control, info.previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
   TVLCT, info.r, info.g, info.b
   IF (Min(image) LT 0) OR (Max(image) GT (!D.Table_Size-1)) THEN $
      cgImage, BytScl(image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
      cgImage, image, /Keep_Aspect
   IF imageDataType EQ 'NONE' THEN image = 0

   <span class="comments">; Save the image data for later retrieval.</span>
   *(*(info.storagePtr)).image = image
   *(*(info.storagePtr)).fileInfo = fileInfo
   (*info.storagePtr).r = info.r
   (*info.storagePtr).g = info.g
   (*info.storagePtr).b = info.b

   <span class="comments">; Clean up.</span>
   CD, thisDirectory
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; ----------------------------------------------------------------------------------------</span>





FUNCTION ImageSelect, $
   BMP=bmp, $                      <span class="comments">; Set this keyword to select BMP files.</span>
   Cancel=cancel, $                <span class="comments">; An output keyword. Returns 0 if the ACCEPT button is used, 1 otherwise.</span>
   Demo=demo, $                    <span class="comments">; If set, check the $IDL_DIR/examples/data directory first.</span>
   Dicom=dicom, $                  <span class="comments">; Set this keyword to select DICOM files</span>
   Directory=directory, $          <span class="comments">; Initial directory to search for files.</span>
   Examples=examples, $            <span class="comments">; If set, check the $IDL_DIR/examples/data directory first.</span>
   Exclude=exclude, $              <span class="comments">; A list of files that should be excluded from the list of available files.</span>
   _Extra=extra, $                 <span class="comments">; This is used to pass keywords on to READ_XXX routines.</span>
   FileInfo=fileInfo, $            <span class="comments">; An output keyword containing file information from the Query_*** routine.</span>
   Filename=filename, $            <span class="comments">; Initial file name of image file.</span>
   Filter = filter, $
   FITS=fits, $                    <span class="comments">; Set this keyword to select FITS files. (Must have NASA Astro Library on !PATH)</span>
   Flipimage=flipimage, $          <span class="comments">; Set this keyword to flip the Y indices of the image. Set to 0 by default.</span>
   GEOTIFF=geotiff, $              <span class="comments">; Returns the geotiff structure of GeoTIFF files.</span>
   GIF=gif, $                      <span class="comments">; Set this keyword to select GIF files. (IDL 6.2 and above, only)</span>
   Group_Leader=group_leader, $    <span class="comments">; The group leader ID of this widget program.</span>
   FHeader=fheader, $              <span class="comments">; Output keyword returns FITS header from FITS files.</span>
   J2000=j2000, $                  <span class="comments">; Set this keyword to select JPEG2000 files (IDL 6.1 and above, only.)</span>
   J2K=j2k, $                      <span class="comments">; Set this keyword to select JPEG2000 files (IDL 6.1 and above, only.)</span>
   JPEG=jpeg, $                    <span class="comments">; Set this keyword to select JPEG files</span>
   LISTXSIZE=listxsize, $          <span class="comments">; Set this keyword to the XSIZE of the list widget.</span>
   OFFSETS=offsets, $              <span class="comments">; The offsets of the program.</span>
   ONLY2D=only2d, $                <span class="comments">; Set this keyword so that only 2D images can be accepted.</span>
   ONLY3D=only3d, $                <span class="comments">; Set this keyword so that only 3D or true-color images can be accepted.</span>
   OutDirectory=outdirectory, $    <span class="comments">; The directory name of the selected image file.</span>
   OutFilename=outfilename, $      <span class="comments">; The short filename (without directory) of the selected image file.</span>
   Palette=palette, $              <span class="comments">; The color palette associated with the file.</span>
   PICT=pict, $                    <span class="comments">; Set this keyword to select PICT files</span>
   PGM=pgm, $                      <span class="comments">; Set this keyword to read PGM files.</span>
   PPM=ppm, $                      <span class="comments">; Set this keyword to read PPM files.</span>
   PNG=png, $                      <span class="comments">; Set this keyword to select PNG files.</span>
   SILENT=silent, $                <span class="comments">; Set this keyword to run off educational message.</span>
   TIFF=tiff, $                    <span class="comments">; Set this keyword to select TIFF files.</span>
   TITLE=title, $                  <span class="comments">; The title of the main image selection window.</span>
   PreviewSize=previewsize         <span class="comments">; The maximum size of the image preview window. 150 pixels by default.</span>

CD, Current=originalDir

<span class="comments">; First thing we are going to do is check for the availability of FITS files. We are</span>
<span class="comments">; going to look for MRDFITS on the path. If we don't find it, we will generate an error</span>
<span class="comments">; condition and handle it silently.</span>
skip = 0
Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel
   skip = 1
   haveFits = 0
ENDIF
IF skip EQ 0 THEN BEGIN
   RESOLVE_ROUTINE, 'MRDFITS', /IS_FUNCTION, /NO_RECOMPILE
   haveFits = 1
ENDIF

<span class="comments">; Normal error handling.</span>
Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel
   Cancel = 1
   ok = Error_Message()
   RETURN, 0
ENDIF

<span class="comments">; Set up the info structure.</span>
info = { storagePtr: Ptr_New(), $            <span class="comments">; The "outside the program" storage pointer.</span>
         previewID: 0L, $                    <span class="comments">; The ID of the preview draw widget.</span>
         previewWID: 0L, $                   <span class="comments">; The window index number of the preview draw widget.</span>
         r:BytArr(256), $                    <span class="comments">; The R color vector.</span>
         g:BytArr(256), $                    <span class="comments">; The G color vector.</span>
         b:BytArr(256), $                    <span class="comments">; The B color vector.</span>
         theFiles: Ptr_New(), $              <span class="comments">; The current list of files in the directory.</span>
         excludeFiles: Ptr_New(), $          <span class="comments">; The list of files to exclude from the file list.</span>
         filenameID: 0L, $                   <span class="comments">; The identifier of the FileSelect compound widget.</span>
         fileListID: 0L, $                   <span class="comments">; The identifier of the file list widget.</span>
         flipimage:0L, $                     <span class="comments">; A flag to flip the image Y order.</span>
         previewSize: 0L, $                  <span class="comments">; The default size of the preview window.</span>
         acceptID: 0L, $                     <span class="comments">; The idenfier of the Accept button widget.</span>
         only2d: 0L, $                       <span class="comments">; A flag that permits only the acceptance of 2D images.</span>
         only3d: 0L, $                       <span class="comments">; A flag that permits only the acceptance of true-color images.</span>
         filter: Ptr_New(), $                <span class="comments">; The file filter.</span>
         filenameObj: Obj_New(), $           <span class="comments">; The FileSelect compound widget object reference.</span>
         originalDir: "", $                  <span class="comments">; The starting or original directory.</span>
         dataDirectory: "", $                <span class="comments">; The current data directory.</span>
         display: 0B, $                      <span class="comments">; Display the image after reading?</span>
         labelmaxvalID: 0L, $                <span class="comments">; The ID of the Max Value label.</span>
         labelminvalID: 0L, $                <span class="comments">; The ID of the Max Value label.</span>
         labelTypeID: 0L, $                  <span class="comments">; The ID of the Image Type label.</span>
         labelXSizeID: 0L, $                 <span class="comments">; The ID of the X Size label.</span>
         labelYSizeID: 0L, $                 <span class="comments">; The ID of the Y Size label.</span>
         labelDataTypeID: 0L $               <span class="comments">; The ID of the Data Type label.</span>
       }

<span class="comments">; Check for availability of GIF and JPEG2000 files.</span>
thisVersion = Float(!Version.Release)
IF ((thisVersion LT 5.3) OR (thisVersion GE 6.2)) THEN haveGif = 1 ELSE haveGIF = 0
IF thisVersion GE 6.1 THEN BEGIN
   haveJ2000 = 1
   scopeOK = 1 <span class="comments">; Use ScopeLevel.</span>
ENDIF ELSE BEGIN
   haveJ2000 = 0
   scopeOK = 0 <span class="comments">; Use Routine_Names.</span>
ENDELSE

<span class="comments">; Set up the filter.</span>
IF Keyword_Set(bmp) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.bmp"] ELSE filter = [filter, "*.bmp"]
IF Keyword_Set(dicom) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.dcm"] ELSE filter = [filter, "*.dcm"]
flipimage = Keyword_Set(flipimage)
IF Keyword_Set(examples) THEN demo = 1
demo = Keyword_Set(demo)
IF N_Elements(exclude) NE 0 THEN info.excludeFiles = Ptr_New(exclude)
IF Keyword_Set(gif) THEN BEGIN
   IF havegif THEN BEGIN
      IF N_Elements(filter) EQ 0 THEN filter = ["*.gif"] ELSE filter = [filter, "*.gif"]
   ENDIF ELSE ok = Dialog_Message('GIF files are not available in this version of IDL. Continuing.')
ENDIF
IF haveFits THEN BEGIN
   IF Keyword_Set(fits) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.fits", "*.fts", "*.fit"] ELSE $
      filter = [filter, "*.fits", "*.fts", "*.fit"]
ENDIF
IF Keyword_Set(jpeg) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.jpg", "*.jpeg", "*.jpe"] ELSE $
   filter = [filter, "*.jpg", "*.jpeg", "*.jpe"]
IF Keyword_Set(j2000) OR Keyword_Set(j2k) THEN BEGIN
   IF haveJ2000 THEN BEGIN
      IF N_Elements(filter) EQ 0 THEN filter = ["*.jpf", "*.jpx", "*.jp2", "*.j2c", "*.j2k"] ELSE $
         filter = [filter, "*.jpf", "*.jpx", "*.jp2", "*.j2c", "*.j2k"]
   ENDIF ELSE ok = Dialog_Message('JPEG2000 files are not available in this version of IDL. Continuing.')
ENDIF
IF Keyword_Set(pict) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.pict"] ELSE filter = [filter, "*.pict"]
IF Keyword_Set(png) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.png"] ELSE filter = [filter, "*.png"]
IF Keyword_Set(tiff) THEN IF N_Elements(filter) EQ 0 THEN filter = ["*.tif"] ELSE filter = [filter, "*.tif"]
IF N_Elements(filter) EQ 0 THEN BEGIN
   filter = ['*.bmp', '*.dcm', '*.jpg', "*.jpeg", "*.jpe", '*.pict', '*.ppm', '*.pgm', '*.png', '*.tif']
   IF haveGif THEN filter = [filter, "*.gif"]
   IF havej2000 THEN filter = [filter, "*.jpf", "*.jpx", "*.jp2", "*.j2c", "*.j2k"]
   IF haveFits THEN filter = [filter, "*.fits", "*.fts", "*.fit"]
   allextensions = 1
ENDIF ELSE allextensions = 0
only2D = Keyword_Set(only2d)
only3D = Keyword_Set(only3d)
IF N_Elements(title) EQ 0 THEN title = 'Select Image File'

<span class="comments">; Get the current directory. Some processing involved.</span>
IF Keyword_Set(demo) THEN BEGIN
   path = Filepath(SubDir=['examples', 'data'], 'junk.pro')
   directory = File_Dirname(path)
ENDIF
CD, Current=startDirectory
IF N_Elements(directory) EQ 0 THEN directory = startDirectory ELSE BEGIN
   IF StrMid(directory, 0, 2) EQ ".." THEN BEGIN
      CASE StrUpCase(!Version.OS_Family) OF
      'MACOS': BEGIN
         CD, '..'
         CD, Current=basename
         directory = basename + StrMid(directory, 3)
         END
      'VMS': BEGIN
         CD, '..'
         CD, Current=basename
         directory = basename + StrMid(directory, 3)
         END
      ELSE: BEGIN
         CD, '..'
         CD, Current=basename
         directory = basename + StrMid(directory, 2)
         END
      ENDCASE
   ENDIF
   IF StrMid(directory, 0, 1) EQ "." THEN BEGIN
      CASE StrUpCase(!Version.OS_Family) OF
      'MACOS': BEGIN
         CD, Current=basename
         directory = basename + StrMid(directory, 2)
         END
      'VMS': BEGIN
         CD, Current=basename
         directory = basename + StrMid(directory, 2)
         END
      ELSE: BEGIN
         CD, Current=basename
         directory = basename + StrMid(directory, 1)
      END
      ENDCASE
   ENDIF
ENDELSE
CD, directory

<span class="comments">; Check other keyword values.</span>
IF N_Elements(filename) EQ 0 THEN file = "" ELSE BEGIN
   dir=StrMid(filename, 0, StrPos(filename, Path_Sep(), /REVERSE_SEARCH))
   IF dir NE "" THEN BEGIN
      directory = dir
      CD, directory
      file = StrMid(filename, StrLen(directory)+1)
   ENDIF ELSE file = filename
ENDELSE
IF N_Elements(previewSize) EQ 0 THEN previewSize = 150
info.previewSize = previewSize

<span class="comments">; Locate appropriate files.</span>
FOR j=0, N_Elements(filter)-1 DO BEGIN
   specificFiles = File_Search(filter[j], Count=fileCount)
   IF fileCount GT 0 THEN IF N_Elements(theFiles) EQ 0 THEN $
      theFiles = specificFiles[ImageSelect_BSort(StrLowCase(specificFiles))] ELSE $
      theFiles = [theFiles, specificFiles[ImageSelect_BSort(StrLowCase(specificFiles))]]
ENDFOR
fileCount = N_Elements(theFiles)
IF fileCount EQ 0 THEN theFiles = "" ELSE BEGIN
   theFiles = theFiles[ImageSelect_BSort(theFiles)]
   IF Ptr_Valid(info.excludeFiles) THEN BEGIN
      FOR k=0,N_Elements(*info.excludeFiles)-1 DO BEGIN
         index = Where(StrUpCase(theFiles) EQ StrUpCase((*info.excludeFiles)[k]), count, COMPLEMENT=ok)
         IF count GT 0 THEN theFiles = theFiles[ok]
      ENDFOR
   ENDIF
   IF file EQ "" THEN file = theFiles[0]
ENDELSE

<span class="comments">; Try to read the file.</span>
extension = ImageSelect_FileExtension(file)
ImageSelect_ReadFiles, extension, file, info, fileinfo, image, ok, type, _Extra=extra

<span class="comments">; Get the file sizes.</span>
dimensions = Image_Dimensions(image, XSize=xsize, YSize=ysize, YIndex=yindex)

<span class="comments">; Flip the image if required.</span>
IF flipimage THEN image = Reverse(image, yindex+1)

<span class="comments">; Do you have a group leader? Here is my attempt to educate</span>
<span class="comments">; people to its use. I'll create a group leader if I have</span>
<span class="comments">; to, but it's ugly and I don't want to. I rule it out for</span>
<span class="comments">; RUNTIME and VM use. You should know better. :-)</span>
IF scopeOK THEN scopeLevel = Scope_Level() ELSE scopeLevel = Routine_Names(/Level)
IF scopeLevel GT 2 THEN BEGIN
      IF N_Elements(group_leader) EQ 0 THEN BEGIN
         IF ~Keyword_Set(silent) THEN BEGIN
            CASE 1 OF
               LMGR(/VM): Message, 'In a VM application, a GROUP_LEADER is required for MODAL operation.'
               LMGR(/RUNTIME): Message, 'In a RUNTIME application, a GROUP_LEADER is required for MODAL operation.'
               ELSE:
            ENDCASE
         ENDIF
         group_leader = Widget_Base(Map=0)
         Widget_Control, group_leader, /Realize
         destroy_groupleader = 1
      ENDIF ELSE destroy_groupleader = 0
ENDIF ELSE destroy_groupleader = 0

<span class="comments">; Create the widgets.</span>
IF N_Elements(group_leader) NE 0 THEN BEGIN
   tlb = Widget_Base(Title=title, Column=1, /Base_Align_Center, $
      /Modal, Group_Leader=group_leader)
ENDIF ELSE BEGIN
   tlb = Widget_Base(Title=title, Column=1, /Base_Align_Center)
ENDELSE

fileSelectBase = Widget_Base(tlb, Column=1, Frame=1)
buttonBase = Widget_Base(tlb, Row=1)

<span class="comments">; Define file selection widgets.</span>
filenameID = FSC_FileSelect(fileSelectBase, Filename=file, ObjectRef=filenameObj,$
   Directory=directory, Event_Pro='ImageSelect_FilenameEvents', Filter=filter, _Extra=extra)
fsrowbaseID = Widget_Base(fileSelectBase, Row=1, XPad=10)
IF N_Elements(listxsize) EQ 0 THEN listxsize = Max(StrLen(theFiles)) + 0.1*Max(StrLen(theFiles)) > 30
filelistID = Widget_List(fsrowbaseID, Value=theFiles, YSize = 10, XSize=listxsize, $
   Event_Pro='ImageSelect_ListEvents')
spacer = Widget_Label(fsrowbaseID, Value="     ")
previewID = Widget_Draw(fsrowbaseID, XSize=previewSize, YSize=previewSize)
spacer = Widget_Label(fsrowbaseID, Value="     ")
labelBaseID = Widget_Base(fsrowbaseID, Column=1, /Base_Align_Left)

<span class="comments">; What kind of image is this?</span>
   CASE fileinfo.channels OF
      3: imageType = 'True-Color ' + type + ' Image'
      0: imageType = 'No Image'
      -1: imageType = 'Invalid Image File'
      ELSE: imageType = '2D ' + type + ' Image'
   ENDCASE


xsize = fileInfo.dimensions[0]
ysize = fileInfo.dimensions[1] > Fix(xsize * 0.5)
imageDataType = Size(image, /TNAME)
IF imageType EQ 'Invalid Image File' THEN imageDataType = 'INVALID'
IF imageType EQ 'No Image' THEN imageDataType = 'NONE'

<span class="comments">; If you don't have an image, then get sensible numbers for the labels.</span>
IF imageType EQ 'No Image' OR imageType EQ 'Invalid Image File' THEN BEGIN
   xsize = 0
   ysize = 0
   minval = 0
   maxval = 0
ENDIF

labeltypeID = Widget_Label(labelBaseID, Value=imageType, /Dynamic_Resize)
labelxsizeID = Widget_Label(labelBaseID, Value="X Size: " + StrTrim(xsize, 2), /Dynamic_Resize)
labelysizeID = Widget_Label(labelBaseID, Value="Y Size: " + StrTrim(ysize, 2), /Dynamic_Resize)
labeldataTypeID = Widget_Label(labelBaseID, Value="Type: " + imageDataType, /Dynamic_Resize)
labelminvalID = Widget_Label(labelBaseID, Value="Min Value: " + cgNumber_Formatter(Min(image)), /Dynamic_Resize)
labelmaxvalID = Widget_Label(labelBaseID, Value="Max Value: " + cgNumber_Formatter(Max(image)), /Dynamic_Resize)

<span class="comments">; Size the draw widget appropriately.</span>
<span class="comments">; Calculate a window size for the image preview.</span>
IF xsize NE ysize THEN BEGIN
   aspect = Float(ysize) / xsize
   IF aspect LT 1 THEN BEGIN
      wxsize = previewSize
      wysize = (previewSize * aspect) &lt<span class="comments">; previewSize</span>
   ENDIF ELSE BEGIN
      wysize = previewSize
      wxsize = (previewSize / aspect) &lt<span class="comments">; previewSize</span>
   ENDELSE
ENDIF

<span class="comments">; Can you find the filename in the list of files? If so,</span>
<span class="comments">; highlight it in the list.</span>
index = Where(StrUpCase(theFiles) EQ StrUpCase(file), count)
IF count GT 0 THEN Widget_Control, filelistID, Set_List_Select=index

<span class="comments">; Define buttons widgets.</span>
button = Widget_Button(buttonBase, Value='Cancel', Event_Pro='ImageSelect_Action')
filterID = Widget_Button(buttonBase, Value='Image Type...', /Menu, Event_Pro='ImageSelect_SetFilter')
button = Widget_Button(filterID, Value='BMP Files', UValue=['*.bmp'], /Checked_Menu)
IF Keyword_Set(bmp) THEN Widget_Control, button, Set_Button=1
button = Widget_Button(filterID, Value='DICOM Files', UValue=['*.dcm'], /Checked_Menu)
IF Keyword_Set(dicom) THEN Widget_Control, button, Set_Button=1
IF haveFits THEN BEGIN
   button = Widget_Button(filterID, Value='FITS Files', UValue=['*.fits', '*.fts', '*.fit'], /Checked_Menu)
   IF Keyword_Set(fits) THEN Widget_Control, button, Set_Button=1
ENDIF
IF havegif THEN BEGIN
   button = Widget_Button(filterID, Value='GIF Files', UValue=['*.gif'], /Checked_Menu)
   IF Keyword_Set(gif) THEN Widget_Control, button, Set_Button=1
ENDIF
button = Widget_Button(filterID, Value='JPEG Files', UValue=['*.jpg', '*.jpeg', '*.jpe'], /Checked_Menu)
IF Keyword_Set(jpeg) THEN Widget_Control, button, Set_Button=1
IF haveJ2000 THEN BEGIN
   button = Widget_Button(filterID, Value='JPEG2000 Files', UValue=['*.jpf', '*.jpx', '*.jp2', '*.j2c', '*.j2k'], /Checked_Menu)
   IF Keyword_Set(j2000) THEN Widget_Control, button, Set_Button=1
ENDIF
button = Widget_Button(filterID, Value='PICT Files', UValue=['*.pict'], /Checked_Menu)
IF Keyword_Set(pict) THEN Widget_Control, button, Set_Button=1
button = Widget_Button(filterID, Value='PNG Files', UValue=['*.png'], /Checked_Menu)
IF Keyword_Set(png) THEN Widget_Control, button, Set_Button=1
button = Widget_Button(filterID, Value='PPM Files', UValue=['*.pgm', '*.ppm'], /Checked_Menu)
IF Keyword_Set(ppm) THEN Widget_Control, button, Set_Button=1
button = Widget_Button(filterID, Value='PGM Files', UValue=['*.pgm', '*.ppm'], /Checked_Menu)
IF Keyword_Set(pgm) THEN Widget_Control, button, Set_Button=1
button = Widget_Button(filterID, Value='TIFF Files', UValue=['*.tif', '*.tiff'], /Checked_Menu)
IF Keyword_Set(tiff) THEN Widget_Control, button, Set_Button=1
IF haveFits THEN BEGIN
   button = Widget_Button(filterID, Value='All Types', $
      UValue=['*.bmp', '*.dcm', '*.fits', '*.fts', '*.fit', '*.gif', '*.jpg', '*.jpeg', '*.jpe', '*.jpf', '*.jpx', $
      '*.jp2', '*.j2c', '*.j2k', '*.pict', '*.png', '*.ppm', '*.pgm', '*.tif', '*.tiff'], /Checked_Menu)
ENDIF ELSE BEGIN
   button = Widget_Button(filterID, Value='All Types', $
      UValue=['*.bmp', '*.dcm', '*.gif', '*.jpg', '*.jpeg', '*.jpe', '*.jpf', '*.jpx', $
      '*.jp2', '*.j2c', '*.j2k', '*.pict', '*.png', '*.ppm', '*.pgm', '*.tif', '*.tiff'], /Checked_Menu)
ENDELSE
IF allextensions THEN Widget_Control, button, Set_Button=1
button = Widget_Button(buttonBase, Value='Flip Image', Event_Pro='ImageSelect_FlipImage')
acceptID = Widget_Button(buttonBase, Value='Accept', Event_Pro='ImageSelect_Action')
IF only2d THEN BEGIN
   IF fileinfo.channels NE 1 THEN Widget_Control, acceptID, Sensitive=0
   Widget_Control, tlb, TLB_Set_Title=title + ' (2D Images Only)'
ENDIF

IF only3d THEN BEGIN
   IF fileinfo.channels NE 3 THEN Widget_Control, acceptID, Sensitive=0
   Widget_Control, tlb, TLB_Set_Title=title + ' (True-Color Images Only)'
ENDIF

<span class="comments">; Center the TLB or use offsets, if defined.</span>
IF N_Elements(offsets) NE 0 THEN BEGIN
   IF N_Elements(offsets) NE 2 THEN offsets = [offsets[0], offsets[0]]
   Widget_Control, tlb, XOffset=offsets[0], YOffset=offsets[1]
ENDIF ELSE BEGIN
   cgCenterTLB, tlb
   offsets = LonArr(2)
ENDELSE
Widget_Control, tlb, /Realize

<span class="comments">; Display the image.</span>
Widget_Control, previewID, Get_Value=previewWID
WSet, previewWID
sizes = ImageSelect_WindowSize(image, XSIZE=previewSize, YSIZE=previewSize)
Widget_Control, previewID, Draw_XSize=sizes[0], Draw_YSize=sizes[1]
IF (Min(image) LT 0) OR (Max(image) GT (!D.Table_Size-1)) THEN $
   cgImage, BytScl(image, Top=!D.Table_Size-1), /Keep_Aspect ELSE $
   cgImage, image, /Keep_Aspect

<span class="comments">; Set up information to run the program.</span>
storagePtr = Ptr_New({cancel:1, image:Ptr_New(image), fileInfo:Ptr_New(fileInfo), offsets:offsets, $
   outdirectory:"", outfilename:"", r:info.r, g:info.g, b:info.b, $
   geotiff:Ptr_New(), extra:Ptr_New(extra), originalDir:originalDir})

<span class="comments">; Load the info structure.</span>
info.storagePtr = storagePtr
info.previewID = previewID
info.previewWID = previewWID
info.theFiles = Ptr_New(theFiles)
info.filenameID = filenameID
info.fileListID = fileListID
info.flipImage = flipImage
info.previewSize = previewSize
info.acceptID = acceptID
info.only2d = only2d
info.only3d = only3d
info.filter = Ptr_New(filter)
info.filenameObj = filenameObj
info.dataDirectory = directory
info.display = Keyword_Set(display)
info.labelmaxvalID = labelmaxvalID
info.labelminvalID = labelminvalID
info.labelTypeID = labelTypeID
info.labelXSizeID = labelXSizeID
info.labelYSizeID = labelYSizeID
info.labelDataTypeID = labelDataTypeID
info.originalDir = originalDir

Widget_Control, tlb, Set_UValue=info, /No_Copy

<span class="comments">; Blocking or modal widget mode, depending upon presence of GROUP_LEADER.</span>
XManager, "imageselect", tlb, Cleanup='ImageSelect_Cleanup'


<span class="comments">; Return collected information.</span>
cancel = (*storagePtr).cancel
fileInfo = *(*storagePtr).fileInfo
type = fileInfo.type
IF Ptr_Valid((*storagePtr).geotiff) THEN geotiff = *(*storagePtr).geotiff ELSE Undefine, geotiff
IF type EQ 'FITS' THEN fheader = fileInfo.header
image = *((*storagePtr).image)
outDirectory = (*storagePtr).outDirectory
outFilename = (*storagePtr).outFilename
originalDir = (*storagePtr).originalDir
CD, originalDir
offsets = (*storagePtr).offsets
Ptr_Free, (*storagePtr).image
Ptr_Free, (*storagePtr).fileInfo
Ptr_Free, (*storagePtr).geotiff
palette = BytArr(256,3)
palette[*,0] = (*storagePtr).r
palette[*,1] = (*storagePtr).g
palette[*,2] = (*storagePtr).b
IF Ptr_Valid((*storagePtr).extra) NE 0 THEN BEGIN
   IF N_Elements(*(*storagePtr).extra) NE 0 THEN extra = *(*storagePtr).extra
ENDIF
Ptr_Free, (*storagePtr).extra
Ptr_Free, storagePtr

<span class="comments">; Did you create your own group leader?</span>
IF destroy_groupleader THEN Widget_Control, group_leader, /Destroy

<span class="comments">; Return the image.</span>
IF cancel EQ 1 THEN RETURN, 0 ELSE RETURN, image

END <span class="comments">; ----------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>