<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:40 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>contrastzoom.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="contrastzoom.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       CONTRASTZOOM</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The purpose of this program is to demonstrate how to</span>
<span class="comments">;       zoom an image "in place" and how to window and level</span>
<span class="comments">;       (set "contrast and brightness") an image using object</span>
<span class="comments">;       graphics functionality. The exercise involves using</span>
<span class="comments">;       multiple views in an object graphics scene, and being</span>
<span class="comments">;       able to interact with different views in different ways.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Widgets, Object Graphics.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       ContrastZoom, image</span>
<span class="comments">;</span>
<span class="comments">; REQUIRED INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       None. The image "mr_knee.dcm" from the examples/data directory</span>
<span class="comments">;       is used if no data is supplied in call.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS</span>
<span class="comments">;</span>
<span class="comments">;       image: A 2D image array of any data type.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       COLORTABLE: The number of a color table to use as the image palette.</span>
<span class="comments">;       Color table 0 (grayscale) is used as a default.</span>

<span class="comments">;       GROUP_LEADER: The group leader for this program. When the group leader</span>
<span class="comments">;       is destroyed, this program will be destroyed.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;</span>
<span class="comments">;       None. The Coyote Library program VCOLORBAR is included.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       To use this program with your 8-bit image data and a red-temperature</span>
<span class="comments">;       color scale, type:</span>
<span class="comments">;</span>
<span class="comments">;          IDL> ContrastZoom, image, Colortable=3</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;</span>
<span class="comments">;       The left image is used to "zoom" into a portion of the image.</span>
<span class="comments">;       The aspect ratio of the sub-image is always preserved. To see</span>
<span class="comments">;       the entire image, click and release the mouse button in this</span>
<span class="comments">;       window.</span>
<span class="comments">;</span>
<span class="comments">;       The center image is used to adjust the contrast and brightness</span>
<span class="comments">;       (sometimes called the "window" and "level" of the image. Click and</span>
<span class="comments">;       drag the mouse vertically to set contrast. Click and drag the mouse</span>
<span class="comments">;       horizontally to set brightness. To return to original values (25%</span>
<span class="comments">;       contrast and 75% brightness), click and release in the center image.</span>
<span class="comments">;</span>
<span class="comments">;       The color bars shows the image values of the image.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;       Written by David Fanning, 18 November 2001.</span>
<span class="comments">;       Added second colorbar to show the relationship of the clamped</span>
<span class="comments">;          colors to the overall image values. 19 November 2001. DWF.</span>
<span class="comments">;       Changed FSC_Normalize to cgNormalize to reflect new name. 6 Feb 2013. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
PRO ContrastZoom_VColorBar::Clamp, datarange

<span class="comments">; This method clamps the data to a particular data range.</span>

self->GetProperty, Range=currentRange

thisclamp = Bytscl(datarange, Max=currentRange[1], Min=currentRange[0])
bar = BytScl(Replicate(1B,10) # Bindgen(self.ncolors), Min=thisclamp[0], Max=thisclamp[1])
self.thisImage->SetProperty, Data=bar
END
<span class="comments">;-------------------------------------------------------------------------</span>



FUNCTION ContrastZoom_VColorBar::INIT, Position=position, $
    NColors=ncolors, Title=title, Palette=palette, $
    Major=major, Minor=minor, Range=range, Color=color, $
    _Extra=extra, Name=name

   <span class="comments">; Catch possible errors.</span>

Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel
   ok = Dialog_Message(!Error_State.Msg)
   Message, !Error_State.Msg, /Informational
   RETURN, 0
ENDIF

   <span class="comments">; Initialize model superclass.</span>

IF (self->IDLgrModel::Init(_EXTRA=extra) NE 1) THEN RETURN, 0

    <span class="comments">; Define default values for keywords, if necessary.</span>

IF N_Elements(name) EQ 0 THEN name=''
IF N_Elements(color) EQ 0 THEN self.color = [255,255,255] $
   ELSE self.color = color
thisFont = Obj_New('IDLgrFont', 'Helvetica', Size=8.0)
self.thisFont = thisFont
IF N_Elements(title) EQ 0 THEN title=''

thisTitle = Obj_New('IDLgrText', title, Color=self.color, $
    Font=thisFont, Recompute_Dimensions=2, /Enable_Formatting)

IF N_Elements(ncolors) EQ 0 THEN self.ncolors = 256 $
   ELSE self.ncolors = ncolors
IF N_Elements(palette) EQ 0 THEN BEGIN
    red = (green = (blue = BIndGen(self.ncolors)))
    self.palette = Obj_New('IDLgrPalette', red, green, blue)
ENDIF ELSE self.palette = palette
IF N_Elements(range) EQ 0 THEN self.range = [0, self.ncolors] $
   ELSE self.range = range
IF N_Elements(major) EQ 0 THEN self.major = 5 $
   ELSE self.major = major
IF N_Elements(minor) EQ 0 THEN self.minor = 4 $
   ELSE self.minor = minor
IF N_Elements(position) EQ 0 THEN self.position = [0.90, 0.10, 0.95, 0.90] $
   ELSE self.position = position

    <span class="comments">; Create the colorbar image. Get its size.</span>

bar = REPLICATE(1B,10) # BINDGEN(self.ncolors)
s = SIZE(bar, /Dimensions)
xsize = s[0]
ysize = s[1]

    <span class="comments">; Create the colorbar image object. Add palette to it.</span>

thisImage = Obj_New('IDLgrImage', bar, Palette=self.palette)
xs = cgNormalize([0,xsize], Position=[0,1.])
ys = cgNormalize([0,ysize], Position=[0,1.])
thisImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

   <span class="comments">; Create a polygon object. Add the image as a texture map. We do</span>
   <span class="comments">; this so the image can rotate in 3D space.</span>

thisPolygon = Obj_New('IDLgrPolygon', [0, 1, 1, 0], [0, 0, 1, 1], [0,0,0,0], $
   Texture_Map=thisImage, Texture_Coord = [[0,0], [1,0], [1,1], [0,1]], color=[255,255,255])

    <span class="comments">; Scale the polygon into the correct position.</span>

xs = cgNormalize([0,1], Position=[self.position(0), self.position(2)])
ys = cgNormalize([0,1], Position=[self.position(1), self.position(3)])
thispolygon->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

    <span class="comments">; Create scale factors to position the axes.</span>

longScale = cgNormalize(self.range, Position=[self.position(1), self.position(3)])
shortScale = cgNormalize([0,1], Position=[self.position(0), self.position(2)])

    <span class="comments">; Create the colorbar axes. 1000 indicates this location ignored.</span>

shortAxis1 = Obj_New("IDLgrAxis", 0, Color=self.color, Ticklen=0.025, $
    Major=1, Range=[0,1], /NoText, /Exact, XCoord_Conv=shortScale,  $
    Location=[1000, self.position(1), 0.001])
shortAxis2 = Obj_New("IDLgrAxis", 0, Color=self.color, Ticklen=0.025, $0.001
    Major=1, Range=[0,1], /NoText, /Exact, XCoord_Conv=shortScale,  $
    Location=[1000, self.position(3), 0.001], TickDir=1)

textAxis = Obj_New("IDLgrAxis", 1, Color=self.color, Ticklen=0.025, $
    Major=self.major, Minor=self.minor, Title=thisTitle, Range=self.range, /Exact, $
    YCoord_Conv=longScale, Location=[self.position(0), 1000, 0.001])
textAxis->GetProperty, TickText=thisText
thisText->SetProperty, Font=self.thisFont, Recompute_Dimensions=2

longAxis2 = Obj_New("IDLgrAxis", 1, Color=self.color, /NoText, Ticklen=0.025, $
    Major=self.major, Minor=self.minor, Range=self.range, TickDir=1, $
    YCoord_Conv=longScale, Location=[self.position(2), 1000, 0.001], /Exact)

    <span class="comments">; Add the parts to the colorbar model.</span>

self->Add, shortAxis1
self->Add, shortAxis2
self->Add, textAxis
self->Add, longAxis2
self->Add, thisPolygon

   <span class="comments">; Assign the name.</span>

self->IDLgrModel::SetProperty, Name=name, Select_Target=1

    <span class="comments">; Create a container object and put the objects into it.</span>

thisContainer = Obj_New('IDL_Container')
thisContainer->Add, thisFont
thisContainer->Add, thisImage
thisContainer->Add, thisText
thisContainer->Add, thisTitle
thisContainer->Add, self.palette
thisContainer->Add, textAxis
thisContainer->Add, shortAxis1
thisContainer->Add, shortAxis2
thisContainer->Add, longAxis2

    <span class="comments">; Update the SELF structure.</span>

self.thisImage = thisImage
self.thisFont = thisFont
self.thisText = thisText
self.textAxis = textAxis
self.shortAxis1 = shortAxis1
self.shortAxis2 = shortAxis2
self.longAxis2 = longAxis2
self.thisContainer = thisContainer
self.thisTitle = thisTitle

RETURN, 1
END
<span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_VColorBar::Cleanup

    <span class="comments">; Lifecycle method to clean itself up.</span>

Obj_Destroy, self.thisContainer
self->IDLgrMODEL::Cleanup
END
<span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_VColorBar::GetProperty, Position=position, Text=text, $
    Title=title, Palette=palette, Major=major, Minor=minor, $
    Range=range, Color=color, Name=name, $
    Transform=transform, _Ref_Extra=extra

    <span class="comments">; Get the properties of the colorbar.</span>

IF Arg_Present(position) THEN position = self.position
IF Arg_Present(text) THEN text = self.thisText
IF Arg_Present(title) THEN self.thisTitle->GetProperty, Strings=title
IF Arg_Present(palette) THEN palette = self.palette
IF Arg_Present(major) THEN major = self.major
IF Arg_Present(minor) THEN minor = self.minor
IF Arg_Present(range) THEN range = self.range
IF Arg_Present(color) THEN color = self.color
IF Arg_Present(name) THEN self->IDLgrMODEL::GetProperty, Name=name
IF Arg_Present(transform) THEN self->IDLgrMODEL::GetProperty, Transform=transform
IF Arg_Present(extra) THEN self->IDLgrMODEL::GetProperty, _Extra=extra

END
<span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_VColorBar::SetProperty, Position=position, $
    Title=title, Palette=palette, Major=major, Minor=minor, $
    Range=range, Color=color, Name=name, Transform=transform, _Extra=extra

    <span class="comments">; Set properties of the colorbar.</span>

IF N_Elements(position) NE 0 THEN BEGIN
    self.position = position

        <span class="comments">; Find the size of the image.</span>

    self.thisImage->GetProperty, Data=image
    s = Size(image)
    xsize = s(1)
    ysize = s(2)
    xs = cgNormalize([0,xsize], Position=[position(0), position(2)])
    ys = cgNormalize([0,ysize], Position=[position(1), position(3)])
    self.thisImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

        <span class="comments">; Create new scale factors to position the axes.</span>

    longScale = cgNormalize(self.range, $
       Position=[self.position(1), self.position(3)])
    shortScale = cgNormalize([0,1], $
       Position=[self.position(0), self.position(2)])

        <span class="comments">; Position the axes. 1000 indicates this position ignored.</span>

    self.textaxis->SetProperty, YCoord_Conv=longScale, $
       Location=[self.position(0), 1000, 0]
    self.longaxis2->SetProperty, YCoord_Conv=longScale, $
       Location=[self.position(2), 1000, 0]
    self.shortAxis1->SetProperty, XCoord_Conv=shortScale, $
       Location=[1000, self.position(1), 0]
    self.shortAxis2->SetProperty, XCoord_Conv=shortScale, $
       Location=[1000, self.position(3), 0]

ENDIF
IF N_Elements(title) NE 0 THEN self.thisTitle->SetProperty, Strings=title
IF N_Elements(transform) NE 0 THEN self->IDLgrMODEL::SetProperty, Transform=transform
IF N_Elements(palette) NE 0 THEN BEGIN
    self.palette = palette
    self.thisImage->SetProperty, Palette=palette
ENDIF
IF N_Elements(major) NE 0 THEN BEGIN
    self.major = major
    self.textAxis->SetProperty, Major=major
    self.longAxis2->SetProperty, Major=major
END
IF N_Elements(minor) NE 0 THEN BEGIN
    self.minor = minor
    self.textAxis->SetProperty, Minor=minor
    self.longAxis2->SetProperty, Minor=minor
END
IF N_Elements(range) NE 0 THEN BEGIN
    self.range = range
    longScale = cgNormalize(range, $
       Position=[self.position(1), self.position(3)])
    self.textAxis->SetProperty, Range=range, YCoord_Conv=longScale
    self.longAxis2->SetProperty, Range=range, YCoord_Conv=longScale
ENDIF
IF N_Elements(color) NE 0 THEN BEGIN
    self.color = color
    self.textAxis->SetProperty, Color=color
    self.longAxis2->SetProperty, Color=color
    self.shortAxis1->SetProperty, Color=color
    self.shortAxis2->SetProperty, Color=color
    self.thisText->SetProperty, Color=color
ENDIF
IF N_Elements(name) NE 0 THEN self->IDLgrMODEL::SetProperty, Name=name
IF N_Elements(extra) NE 0 THEN self->IDLgrMODEL::SetProperty, _Extra=extra
END
<span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_VColorBar__Define

<span class="comments">; For details on how this colorbar object works, see the VCOLORBAR__DEFINE.PRO</span>
<span class="comments">; program in the Coyote Library.</span>
<span class="comments">;</span>
<span class="comments">;   http://www.idlcoyote.com/programs/vcolorbar__define.pro</span>

colorbar = { ContrastZoom_VColorBar, $
             INHERITS IDLgrMODEL, $      <span class="comments">; Inherits the Model Object.</span>
             Position:FltArr(4), $       <span class="comments">; The position of the colorbar.</span>
             Palette:Obj_New(), $        <span class="comments">; The colorbar palette.</span>
             thisImage:Obj_New(), $      <span class="comments">; The colorbar image.</span>
             imageModel:Obj_New(), $     <span class="comments">; The colorbar image model.</span>
             thisContainer:Obj_New(), $  <span class="comments">; Container for cleaning up.</span>
             thisFont:Obj_New(), $       <span class="comments">; The annotation font object.</span>
             thisText:Obj_New(), $       <span class="comments">; The bar annotation text object.</span>
             thisTitle: Obj_New(), $     <span class="comments">; The title of the colorbar.</span>
             textAxis:Obj_New(), $       <span class="comments">; The axis containing annotation.</span>
             shortAxis1:Obj_New(), $     <span class="comments">; A short axis.</span>
             shortAxis2:Obj_New(), $     <span class="comments">; A second short axis.</span>
             longAxis2:Obj_New(), $      <span class="comments">; The other long axis.</span>
             NColors:0, $                <span class="comments">; The number of colors in the bar.</span>
             Major:0, $                  <span class="comments">; Number of major axis intervals.</span>
             Minor:0, $                  <span class="comments">; Number of minor axis intervals.</span>
             Color:BytArr(3), $          <span class="comments">; Color of axes and annotation.</span>
             Range:FltArr(2) }           <span class="comments">; The range of the colorbar axis.</span>

END
<span class="comments">;-------------------------------------------------------------------------</span>



FUNCTION ContrastZoom_Aspect, aspectRatio, MARGIN=margin, WindowAspect=wAspectRatio

<span class="comments">; This function calculates the correct aspect ratios for positioning</span>
<span class="comments">; objects in windows.</span>

ON_ERROR, 2

   <span class="comments">; Check for aspect ratio parameter and possibilities.</span>

IF N_PARAMS() EQ 0 THEN aspectRatio = 1.0

IF aspectRatio EQ 0 THEN BEGIN
   MESSAGE, 'Aspect Ratio of 0. Changing to 1...', /Informational
   aspectRatio = 1.0
ENDIF

s = SIZE(aspectRatio)
IF s(s(0)+1) NE 4 THEN $
   MESSAGE, 'Aspect Ratio is not a FLOAT. Take care...', /Informational

   <span class="comments">; Check for margins.</span>

IF N_ELEMENTS(margin) EQ 0 THEN margin = 0.15

   <span class="comments">; Error checking.</span>

IF margin LT 0 OR margin GE 0.5 THEN $
   MESSAGE, 'The MARGIN keyword value must be between 0.0 and 0.5.'

   <span class="comments">; Calculate the aspect ratio of the current window.</span>

IF N_Elements(wAspectRatio) EQ 0 THEN wAspectRatio = FLOAT(!D.Y_VSIZE) / !D.X_VSIZE

   <span class="comments">; Calculate normalized positions in window.</span>

IF (aspectRatio LE wAspectRatio) THEN BEGIN
   xstart = margin
   ystart = 0.5 - (0.5 - margin) * (aspectRatio / wAspectRatio)
   xend = 1.0 - margin
   yend = 0.5 + (0.5 - margin) * (aspectRatio / wAspectRatio)
ENDIF ELSE BEGIN
   xstart = 0.5 - (0.5 - margin) * (wAspectRatio / aspectRatio)
   ystart = margin
   xend = 0.5 + (0.5 - margin) * (wAspectRatio / aspectRatio)
   yend = 1.0 - margin
ENDELSE

position = [xstart, ystart, xend, yend]

RETURN, position
END
<span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_Resize, event

<span class="comments">; This event handler responds to resize events.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

    <span class="comments">; Resize the draw widget. This is the proper way to do this</span>
    <span class="comments">; in object graphics, but it does not always work in UNIX</span>
    <span class="comments">; versions of IDL. If it doesn't work for you, comment the</span>
    <span class="comments">; first line out and try the second. The second line is more</span>
    <span class="comments">; portable, but not exactly the proper "object" way. :-(</span>

info.theWindow->SetProperty, Dimensions=[event.x, event.y-20]
<span class="comments">;Widget_Control, info.drawID, Draw_XSize=event.x, Draw_YSize=event.y-20</span>


   <span class="comments">; Update the aspect ratios and re-position the images</span>
   <span class="comments">; in the window.</span>

sz = Size(*info.subimage, /Dimensions)
imageAspect = Float(sz[1]) / sz[0]
info.theWindow->GetProperty, Dimensions=dims
windowAspect = (450./info.window_ysize * dims[1]) / (300./info.window_xsize * dims[0])
pos = ContrastZoom_Aspect(imageAspect, WindowAspect=windowAspect, Margin=0)
info.zoomImage->GetProperty, XRange=xrange, YRange=yrange
xs = cgNormalize(xrange, Position=[pos(0), pos(2)])
ys = cgNormalize(yrange, Position=[pos(1), pos(3)])
info.zoomImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys
info.theBox->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

sc = Size(*info.image, /Dimensions)
imageAspect = Float(sc[1]) / sc[0]
info.theWindow->GetProperty, Dimensions=dims
windowAspect = (450./info.window_ysize * dims[1]) / (300./info.window_xsize * dims[0])
pos = ContrastZoom_Aspect(imageAspect, WindowAspect=windowAspect, Margin=0)
info.contrastImage->GetProperty, XRange=xrange, YRange=yrange
xs = cgNormalize(xrange, Position=[pos(0), pos(2)])
ys = cgNormalize(yrange, Position=[pos(1), pos(3)])
info.contrastImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

   <span class="comments">; Draw the scene.</span>

info.theWindow->Draw, info.theScene
Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;-------------------------------------------------------------------------</span>



PRO ContrastZoom_DistinguishEvents, event

<span class="comments">; This event handler responds to all draw widget events.</span>

   <span class="comments">; Error handling.</span>

Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel
   ok = Error_Message(/Traceback)
   Widget_Control, event.top, Set_UValue=info, /No_Copy
   RETURN
ENDIF

   <span class="comments">; Get the info structure.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Which view object are we dealing with. Find out by getting</span>
   <span class="comments">; the UVALUE from the view obect?</span>

thisView = info.theWindow->Select(info.theScene, [event.x, event.y], Dimensions=[1,1])
thisView = thisView[0]
IF Obj_Valid(thisView) EQ 0 THEN BEGIN
   possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL', 'EXPOSE' ]
   thisEvent = possibleEventTypes(event.type)
   IF thisEvent EQ 'EXPOSE' THEN info.theWindow->Draw, info.theScene
   Widget_Control, event.top, Set_UValue=info, /No_Copy
   RETURN
ENDIF
thisView->GetProperty, UValue=selectWindow

   <span class="comments">; What happens depends upon which view the event comes from.</span>

CASE selectWindow OF

   'ZOOMWINDOW': BEGIN <span class="comments">; You are trying to zoom into a region in the left-hand image.</span>

         <span class="comments">; Make sure ContrastWindow events don't show up here.</span>

      IF info.currentMode EQ 'CONTRASTWINDOW' THEN BEGIN
         Widget_Control, event.top, Set_UValue=info, /No_Copy
         RETURN
      ENDIF

         <span class="comments">; Find the point in the coordinates of the image in the window.</span>

      hit = info.theWindow->Pickdata(thisView, info.zoomImage, [event.x, event.y], xyz)
      xpt = Floor(xyz[0])
      ypt = Floor(xyz[1])

      possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL', 'EXPOSE' ]
      thisEvent = possibleEventTypes(event.type)

      CASE thisEvent OF

         'DOWN': BEGIN

               <span class="comments">; While the coordinates are in the image coordinate system, it is</span>
               <span class="comments">; possible that they are *outside* the actual coordinates of the</span>
               <span class="comments">; image. Make sure they don't exceed the size of the image.</span>
               <span class="comments">; What you do with the point depends on what kind of event it is.</span>

            IF xpt LT 0 OR xpt GT (info.zxsize-1) THEN BEGIN
               Widget_Control, event.top, Set_UValue=info, /No_Copy
               RETURN
            ENDIF
            IF ypt LT 0 OR ypt GT (info.zysize-1) THEN BEGIN
               Widget_Control, event.top, Set_UValue=info, /No_Copy
               RETURN
            ENDIF

               <span class="comments">; Set the static corners of the box to current</span>
               <span class="comments">; cursor location. See the current mode so dragging</span>
               <span class="comments">; outside the image can't cause problems.</span>

            info.xs = xpt
            info.ys = ypt
            info.currentMode = "ZOOMWINDOW"

               <span class="comments">; Change the event handler for the draw widget and turn MOTION</span>
               <span class="comments">; events ON.</span>

            Widget_Control, event.id, Draw_Motion_Events=1

               <span class="comments">; Initialize and hide the polyline object.</span>

            box = FltArr(2,5)
            box[0,*] = Replicate(info.xs, 5)
            box[1,*] = Replicate(info.ys, 5)
            info.theBox->SetProperty, Data=box, Hide=0

            END <span class="comments">; of DOWN event</span>

        'UP': BEGIN

              <span class="comments">; It is possible to get an UP event without a previous DOWN event. (For</span>
              <span class="comments">; example, the user starts the box outside the draw widget window.) If this</span>
              <span class="comments">; occurs, info.xs and info.ys will be negative. Check for this and return,</span>
              <span class="comments">; if necessary.</span>

           IF info.xs EQ -1 OR info.ys EQ -1 THEN BEGIN
              Widget_Control, event.top, Set_UValue=info, /No_Copy
              RETURN
           ENDIF

              <span class="comments">; If this is an UP event, you need to erase the zoombox, turn motion events</span>
              <span class="comments">; OFF, and draw the "zoomed" plot.</span>

              <span class="comments">; Turn motion events off. Set the current mode to NULL.</span>

           Widget_Control, event.id, Draw_Motion_Events=0
           Widget_Control, event.id, /Clear_Events
           info.currentMode = ""

              <span class="comments">; Draw the "zoomed" image. Start by getting the LAST zoom</span>
              <span class="comments">; box outline. These are indices into image array.</span>

              xpt = 0 > xpt &lt<span class="comments">; (info.zxsize)</span>
              ypt = 0 > ypt &lt<span class="comments">; (info.zysize)</span>

              x = [info.xs, xpt]
              y = [info.ys, ypt]

                 <span class="comments">; If the static point and the dynamic point are the same,</span>
                 <span class="comments">; zoom all the way out.</span>

           IF Abs(info.xs - xpt) LT 2 AND Abs(info.ys-ypt) LT 2 THEN BEGIN
              s = Size(*info.image, /Dimensions)
              info.zxsize = s[0]
              info.zysize = s[1]
              contrast = info.contrast
              brightness = info.brightness
              level = (1-brightness/100.)*(info.maxVal - info.minVal) + info.minVal
              width = (1-contrast/100.)*(info.maxVal - info.minVal)

                 <span class="comments">; Calculate display minimum and maximum.</span>

              displayMax = (level + (width / 2))
              displayMin = (level - (width / 2))

              IF displayMax GT info.maxval THEN BEGIN
                 difference = Abs(displayMax - info.maxval)
                 displayMax = displayMax - difference
                 displayMin = displayMin - difference
              ENDIF
              IF displayMin LT info.minval THEN BEGIN
                 difference = Abs(info.minval - displayMin)
                 displayMin = displayMin + difference
                 displayMax = displayMax + difference
              ENDIF

                     <span class="comments">; Display the image.</span>

              info.zoomImage->SetProperty, Data=BytScl(*info.image, Min=info.minval > $
                  displayMin, Max=displayMax &lt<span class="comments">; info.maxval), Dimensions=s</span>
              *info.subimage = *info.image
              imageAspect = Float(s[1]) / s[0]
              info.theWindow->GetProperty, Dimensions=dims
              windowAspect = (450./info.window_ysize * dims[1]) / (300./info.window_xsize * dims[0])
              pos = ContrastZoom_Aspect(imageAspect, WindowAspect=windowAspect, Margin=0)
              info.zoomImage->GetProperty, XRange=xrange, YRange=yrange
              xs = cgNormalize(xrange, Position=[pos(0), pos(2)])
              ys = cgNormalize(yrange, Position=[pos(1), pos(3)])

              info.zoomImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys
              info.theBox->SetProperty, Hide=1, XCoord_Conv=xs, YCoord_Conv=ys
              info.theWindow->Draw, info.theScene
              info.xs = 0
              info.ys = 0
              info.xd = s[0]
              info.yd = s[1]
              Widget_Control, event.top, Set_UValue=info, /No_Copy
              RETURN
           ENDIF

              <span class="comments">; Make sure the x and y values are ordered as [min, max].</span>

           IF info.xs GT xpt THEN x = [xpt, info.xs]
           IF info.ys GT ypt THEN y = [ypt, info.ys]

              <span class="comments">; Subset the image.</span>


           *info.subimage = (*info.subimage)(x[0]:x[1] &lt<span class="comments">; (info.zxsize-1), y[0]:y[1] &lt; (info.zysize-1))</span>
           zoomedImage = *info.subimage

              <span class="comments">; Update the zoomed image data and draw it.</span>

           s = Size(zoomedImage, /Dimensions)
           info.zxsize = s[0]
           info.zysize = s[1]
           contrast = info.contrast
           brightness = info.brightness
           level = (1-brightness/100.)*(info.maxVal - info.minVal) + info.minVal
           width = (1-contrast/100.)*(info.maxVal - info.minVal)

              <span class="comments">; Calculate display minimum and maximum.</span>

           displayMax = (level + (width / 2))
           displayMin = (level - (width / 2))

           IF displayMax GT info.maxval THEN BEGIN
              difference = Abs(displayMax - info.maxval)
              displayMax = displayMax - difference
              displayMin = displayMin - difference
           ENDIF
           IF displayMin LT info.minval THEN BEGIN
              difference = Abs(info.minval - displayMin)
              displayMin = displayMin + difference
              displayMax = displayMax + difference
           ENDIF

              <span class="comments">; Display the image after positioning it appropriately</span>
              <span class="comments">; in the window so that it maintains the aspect ratio of the</span>
              <span class="comments">; sub-sampled image. Apply the positioning to the image and</span>
              <span class="comments">; to the zoom box.</span>

           info.zoomImage->SetProperty, Data=BytScl(*info.subimage, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval), Dimensions=s</span>
           imageAspect = Float(s[1]) / s[0]
           info.theWindow->GetProperty, Dimensions=dims
           windowAspect = (450./info.window_ysize * dims[1]) / (300./info.window_xsize * dims[0])
           pos = ContrastZoom_Aspect(imageAspect, WindowAspect=windowAspect, Margin=0)
           info.zoomImage->GetProperty, XRange=xrange, YRange=yrange
           xs = cgNormalize(xrange, Position=[pos(0), pos(2)])
           ys = cgNormalize(yrange, Position=[pos(1), pos(3)])
           info.zoomImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys
           info.theBox->SetProperty, Hide=1, XCoord_Conv=xs, YCoord_Conv=ys

              <span class="comments">; Clear any motion events that may have occurred.</span>

           Widget_Control, event.id, /Clear_Events

              <span class="comments">; Set the static values to negative values.</span>

           info.xs = -1
           info.ys = -1

           END <span class="comments">; of UP event</span>

         'MOTION': BEGIN

               <span class="comments">; Get the dynamic corner of the box.</span>

             info.xd = 0 > xpt &lt<span class="comments">; (info.zxsize)</span>
             info.yd = 0 > ypt &lt<span class="comments">; (info.zysize)</span>

               <span class="comments">; Re-configure the box coordinates.</span>

            box = FltArr(2,5)
            box[0,*] = [info.xs, info.xd, info.xd, info.xs, info.xs]
            box[1,*] = [info.ys, info.ys, info.yd, info.yd, info.ys]

               <span class="comments">; Draw the new zoom box.</span>

           info.theBox->SetProperty, Data=box

            END <span class="comments">; of MOTION event.</span>

         ELSE:

     ENDCASE

  END <span class="comments">; of ZOOMWINDOW processing.</span>

  'CONTRASTWINDOW': BEGIN <span class="comments">; You are trying to window and level the image.</span>

        <span class="comments">; Make sure no zooming event sneak in here by accident.</span>

     IF info.currentMode EQ 'ZOOMWINDOW' THEN BEGIN
        Widget_Control, event.top, Set_UValue=info, /No_Copy
        RETURN
     ENDIF


        <span class="comments">; Find the point in the coordinates of the image in the window.</span>

     hit = info.theWindow->Pickdata(thisView, info.zoomImage, [event.x, event.y], xyz)
     xpt = Floor(xyz[0])
     ypt = Floor(xyz[1])

        <span class="comments">; What happens next depends on the type of event this is.</span>

     possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL', 'EXPOSE' ]
     thisEvent = possibleEventTypes(event.type)

     CASE thisEvent OF

     'DOWN': BEGIN

           <span class="comments">; Set the initial (x,y) point. Turn motion events on.</span>

        info.x1 = xpt
        info.y1 = ypt
        Widget_Control, info.drawID, Draw_Motion_Events=1
        info.currentMode = "CONTRASTWINDOW"
        END

      'UP': BEGIN

            <span class="comments">; Turn motion events off. Clear any motion events that might have queued.</span>
            <span class="comments">; Reset the current mode.</span>

         Widget_Control, info.drawID, Draw_Motion_Events=0
         Widget_Control, info.drawID, /Clear_Events
         info.currentMode = ""

            <span class="comments">; If the static point and the dynamic point are the same,</span>
            <span class="comments">; reset the level and width.</span>

         IF Abs(info.x1 - xpt) LT 2 AND Abs(info.y1-ypt) LT 2 THEN BEGIN
            contrast = 0
            brightness = 100
            level = (1-brightness/100.)*(info.maxVal - info.minVal) + info.minVal
            width = (1-contrast/100.)*(info.maxVal - info.minVal)

             <span class="comments">; Calculate display minimum and maximum.</span>

            displayMax = (level + (width / 2))
            displayMin = (level - (width / 2))

            IF displayMax GT info.maxval THEN BEGIN
               difference = Abs(displayMax - info.maxval)
               displayMax = displayMax - difference
               displayMin = displayMin - difference
            ENDIF
            IF displayMin LT info.minval THEN BEGIN
               difference = Abs(info.minval - displayMin)
               displayMin = displayMin + difference
              displayMax = displayMax + difference
             ENDIF

             <span class="comments">; Display the image.</span>

            info.contrastImage->SetProperty, Data=BytScl(*info.image, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
            info.zoomImage->SetProperty, Data=BytScl(*info.subimage, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
            info.colorbar->Clamp, [info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>
            info.colorbar2->SetProperty, Range=[info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>

               <span class="comments">; Update the current contrast and brightness values.</span>

            info.contrast = contrast
            info.brightness = brightness
            info.theWindow->Draw, info.theScene
            Widget_Control, event.top, Set_UValue=info, /No_Copy
            RETURN

           ENDIF

               <span class="comments">; Calculate new contrast, brightness, level, and width parameters.</span>

           contrast = 0 > ((info.y1 - ypt) * info.cstep + info.contrast) &lt<span class="comments">; 99</span>
           brightness = 0 > ((info.x1 - xpt) * info.bstep + info.brightness) &lt<span class="comments">; 100</span>
           level = (1-brightness/100.)*(info.maxVal - info.minVal) + info.minVal
           width = (1-contrast/100.)*(info.maxVal - info.minVal)

               <span class="comments">; Calculate display minimum and maximum.</span>

           displayMax = (level + (width / 2))
           displayMin = (level - (width / 2))

           IF displayMax GT info.maxval THEN BEGIN
              difference = Abs(displayMax - info.maxval)
              displayMax = displayMax - difference
              displayMin = displayMin - difference
           ENDIF
           IF displayMin LT info.minval THEN BEGIN
              difference = Abs(info.minval - displayMin)
              displayMin = displayMin + difference
              displayMax = displayMax + difference
           ENDIF

              <span class="comments">; Display the image.</span>

           info.contrastImage->SetProperty, Data=BytScl(*info.image, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
           info.zoomImage->SetProperty, Data=BytScl(*info.subimage, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
           info.colorbar->Clamp, [info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>
           info.colorbar2->SetProperty, Range=[info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>

              <span class="comments">; Update the current contrast and brightness values.</span>

           info.contrast = contrast
           info.brightness = brightness
           END

         'MOTION': BEGIN

               <span class="comments">; Calculate new contrast, brightness, level, and width parameters.</span>
               <span class="comments">; Restrict the width to 5 percent of the image range.</span>

            contrast = 0 > ((info.y1 - ypt) * info.cstep + info.contrast) &lt<span class="comments">; 99</span>
            brightness = 0 > ((info.x1 - xpt) * info.bstep + info.brightness) &lt<span class="comments">; 100</span>
            level = (1-brightness/100.)*(info.maxVal - info.minVal) + info.minVal
            width = (1-contrast/100.)*(info.maxVal - info.minVal)

               <span class="comments">; Calculate display minimum and maximum.</span>

            displayMax = (level + (width / 2))
            displayMin = (level - (width / 2))

            IF displayMax GT info.maxval THEN BEGIN
               difference = Abs(displayMax - info.maxval)
               displayMax = displayMax - difference
               displayMin = displayMin - difference
            ENDIF
            IF displayMin LT info.minval THEN BEGIN
               difference = Abs(info.minval - displayMin)
               displayMin = displayMin + difference
               displayMax = displayMax + difference
            ENDIF

               <span class="comments">; Display the image.</span>

            info.contrastImage->SetProperty, Data=BytScl(*info.image, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
            info.zoomImage->SetProperty, Data=BytScl(*info.subimage, Min=info.minval > $
               displayMin, Max=displayMax &lt<span class="comments">; info.maxval)</span>
            info.colorbar->Clamp, [info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>
            info.colorbar2->SetProperty, Range=[info.minval > displayMin, displayMax &lt<span class="comments">; info.maxval]</span>

            END

         ELSE:

         ENDCASE

      END <span class="comments">; of ContrastWindow processing.</span>

   ELSE:


ENDCASE

   <span class="comments">; Draw the scene.</span>

info.theWindow->Draw, info.theScene

   <span class="comments">; Store the info structure.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END<span class="comments">;-------------------------------------------------------------------------------------</span>



PRO ContrastZoom_Cleanup, tlb

   <span class="comments">; This is the clean-up procedure for the program.</span>

Widget_Control, tlb, Get_UValue=info, /No_Copy
IF N_Elements(info) EQ 0 THEN RETURN

Obj_Destroy, info.theContainer
Ptr_Free, info.image
Ptr_Free, info.subimage

END<span class="comments">;-------------------------------------------------------------------------------------</span>


PRO ContrastZoom, image, Colortable=colortable, Group_Leader=group_leader

On_Error, 2

   <span class="comments">; Find an image, if needed.</span>

IF N_Elements(image) EQ 0 THEN BEGIN
   filename = Filepath(Subdir=['examples','data'], 'rbcells.jpg')
   Read_JPEG, filename, image
   image = Reverse(image,2) <span class="comments">; Image is upside down.</span>
ENDIF

   <span class="comments">; Only 2D images can be used.</span>

IF Size(image, /N_Dimensions) NE 2 THEN Message, 'Image must be 2D. Returning...'

   <span class="comments">; Get a colortable if needed.</span>

IF N_Elements(colortable) EQ 0 THEN colortable = 0 ELSE colortable = 0 > colortable &lt<span class="comments">; 41</span>

   <span class="comments">; Create a color palette and load the colortable.</span>

thePalette = Obj_New('IDLgrPalette')
thePalette->LoadCT, colortable

   <span class="comments">; Create a zoom box for zoom rubberbanding.</span>

theBox = Obj_New('IDLgrPolyline', Hide=1, Color=[255,255,255])

   <span class="comments">; Create contrast and zoom image objects.</span>

dims = Size(image, /Dimensions)
zxsize = dims[0]
zysize = dims[1]
zoomImage = Obj_New('IDLgrImage', image, Palette=thePalette, Dimensions=dims)
contrastImage = Obj_New('IDLgrImage', BytScl(image), Palette=thePalette, Dimensions=dims)

   <span class="comments">; Create a color bar.</span>

colorbar = Obj_New('ContrastZoom_VColorBar', Palette=thePalette, Range=[Min(image), Max(image)], $
   Position=[0.7, 0.1, 0.95, 0.95], Title='Image Values')
colorbar2 = Obj_New('ContrastZoom_VColorBar', Palette=thePalette, Range=[Min(image), Max(image)], $
   Position=[0.7, 0.1, 0.95, 0.95], Title='Displayed Values', Major=8)

   <span class="comments">; Create the scene, views, and models for the object heirarchy. The dimensions</span>
   <span class="comments">; and location are in normalized units, but device units are used to calculate</span>
   <span class="comments">; the values. The numbers window_xsize and window_ysize refer to the X size and Y</span>
   <span class="comments">; size of the initial draw widget that will be created later. User values will be</span>
   <span class="comments">; used to identify which events are associated with which view.</span>

window_xsize = 925
window_ysize = 500

theScene = Obj_New('IDLgrScene', Color=[125, 125, 125])
zoomView = Obj_New('IDLgrView', Color=[125, 125, 125], Viewplane_Rect=[0,0,1,1], $
   Location=[25./window_xsize, 25./window_ysize], Dimensions=[300./window_xsize, 450./window_ysize], Units=3, UValue='ZOOMWINDOW')
contrastView = Obj_New('IDLgrView', Color=[125, 125, 125], Viewplane_Rect=[0,0,1,1], $
   Location=[350./window_xsize, 25./window_ysize], Dimensions=[300./window_xsize, 450./window_ysize], Units=3, UValue='CONTRASTWINDOW')
colorbarView = Obj_New('IDLgrView', Color=[125, 125, 125], Viewplane_Rect=[-0.2,0,1.2,1], $
   Location=[675./window_xsize, 25./window_ysize], Dimensions=[75./window_xsize, 450./window_ysize], Units=3, UValue='COLORBARWINDOW')
colorbar2View = Obj_New('IDLgrView', Color=[125, 125, 125], Viewplane_Rect=[-0.2,0,1.2,1], $
   Location=[775./window_xsize, 25./window_ysize], Dimensions=[75./window_xsize, 450./window_ysize], Units=3, UValue='COLORBAR2WINDOW')

theScene->Add, zoomView
theScene->Add, contrastView
theScene->Add, colorbarView
theScene->Add, colorbar2View

zoomModel = Obj_New('IDLgrModel')
contrastModel = Obj_New('IDLgrModel')
colorbarModel = Obj_New('IDLgrModel')
colorbar2Model = Obj_New('IDLgrModel')

zoomView->Add, zoomModel
contrastView->Add, contrastModel
colorbarView->Add, colorbarModel
colorbar2View->Add, colorbar2Model

zoomModel->Add, zoomImage
zoomModel->Add, theBox
contrastModel->Add, contrastImage
colorbarModel->Add, colorbar
colorbar2Model->Add, colorbar2

   <span class="comments">; We need to scale the image into the view. Start by</span>
   <span class="comments">; getting the image range. This is the same for both</span>
   <span class="comments">; the zoom and contrast image.</span>

zoomImage->GetProperty, XRange=xrange, YRange=yrange

    <span class="comments">; Calculate the aspect ratios (height/width) for the image</span>
    <span class="comments">; and for the display window. Scale the images and the zoom box.</span>

s = Size(image, /Dimensions)
imageAspect = Float(s[1]) / s[0]
windowAspect = Float(450) / 300
pos = ContrastZoom_Aspect(imageAspect, WindowAspect=windowAspect, Margin=0)
xs = cgNormalize(xrange, Position=[pos(0), pos(2)])
ys = cgNormalize(yrange, Position=[pos(1), pos(3)])
zoomImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys
contrastImage->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys
theBox->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys

   <span class="comments">; Set up initial parameters. Contrast and brightness values</span>
   <span class="comments">; go from 0 to 100. Start with 25% contrast and 75% brightness.</span>

maxval = Max(image, Min=minVal)
contrast = 25
brightness = 75

   <span class="comments">; Calculate window level and width from contrast/brightness values.</span>

level = (1-brightness/100.)*(maxVal - minVal) + minVal
width = (1-contrast/100.)*(maxVal - minVal)

   <span class="comments">; Calculate display minimum and maximum.</span>

displayMax = (level + (width / 2))
displayMin = (level - (width / 2))

IF displayMax GT maxval THEN BEGIN
   difference = Abs(displayMax - maxval)
   displayMax = displayMax - difference
   displayMin = displayMin - difference
ENDIF
IF displayMin LT minval THEN BEGIN
   difference = Abs(minval - displayMin)
   displayMin = displayMin + difference
   displayMax = displayMax + difference
ENDIF

   <span class="comments">; Update the contrast and zoom image after changes.</span>

contrastImage->SetProperty, Data=BytScl(image, Min=displayMin, Max=displayMax)
zoomImage->SetProperty, Data=BytScl(image, Min=displayMin, Max=displayMax)
colorbar2->SetProperty, Range=[displayMin, displayMax]

   <span class="comments">; Create the widgets for the program. Set software rendering for the draw</span>
   <span class="comments">; widget, or rubberbanding may be slow.</span>

tlb = Widget_Base(Title='Contrast/Zoom Object Graphics Example', /Base_Align_Center, $
   Column=1, /TLB_Size_Events)
drawID = Widget_Draw(tlb, XSize=window_xsize, YSize=window_ysize, Button_Events=1, $
   Graphics_Level=2, Event_Pro='ContrastZoom_DistinguishEvents', Expose_Events=1, $
   Renderer=1)
label = Widget_Label(tlb, Value='Left image allows ZOOMING. Center image allows WINDOWING. ' + $
   'Click and drag. Click and release in window restores original view.')
Widget_Control, tlb, /Realize

   <span class="comments">; Get the window object and draw the scene.</span>

Widget_Control, drawID, Get_Value=theWindow
theWindow->Draw, theScene

   <span class="comments">; Create a container object to aid in proper object clean-up.</span>

theContainer = Obj_New('IDL_Container')
theContainer->Add, thePalette
theContainer->Add, zoomView
theContainer->Add, contrastView
theContainer->Add, colorbarView
theContainer->Add, colorbar2View
theContainer->Add, theScene

   <span class="comments">; Create the info structure.</span>

info = { zoomImage:zoomImage, $            <span class="comments">; The zoom image object.</span>
         contrastImage: contrastImage, $   <span class="comments">; The contrast image object.</span>
         image:Ptr_New(image), $           <span class="comments">; A pointer to the original image.</span>
         subimage: Ptr_New(image), $       <span class="comments">; A pointer to the current image subset.</span>
         zoomView:zoomView, $              <span class="comments">; The zoom view object.</span>
         contrastView:contrastView, $      <span class="comments">; The contrast view object.</span>
         colorbar:colorbar, $              <span class="comments">; The color bar object.</span>
         colorbar2:colorbar2, $            <span class="comments">; The second color bar.</span>
         colorbarView:colorbarView, $      <span class="comments">; The color bar view.</span>
         theContainer:theContainer, $      <span class="comments">; The container object.</span>
         theWindow:theWindow, $            <span class="comments">; The window object.</span>
         theScene:theScene, $              <span class="comments">; The scene to be displayed.</span>
         drawID:drawID, $                  <span class="comments">; The draw widget identifier.</span>
         thebox: thebox, $                 <span class="comments">; The zoom box object.</span>
         currentMode: "", $                <span class="comments">; The current mode the window is operating in.</span>
         x1:-1L, $                         <span class="comments">; Locations in the window for contrast/brightness operations.</span>
         x2:-1L, $
         y1:-1L, $
         y2:-1L, $
         zxsize:zxsize, $                  <span class="comments">; The X size of the zoom image.</span>
         zysize:zysize, $                  <span class="comments">; The Y size of the zoom image.</span>
         contrast:contrast, $              <span class="comments">; The current contrast value.</span>
         brightness:brightness, $          <span class="comments">; The current brightness value.</span>
         bstep:zxsize/512., $              <span class="comments">; The amount of brighness change for one pixel movement.</span>
         cstep:zysize/512., $              <span class="comments">; The amount of contrast change for one pixel movement.</span>
         maxVal:maxVal, $
         minVal:minVal, $
         window_xsize:window_xsize, $      <span class="comments">; The original X size of the draw widget.</span>
         window_ysize:window_ysize, $      <span class="comments">; The original Y size of the draw widget.</span>
         xs:-1L, $                         <span class="comments">; Locations in the window for zooming operations.</span>
         ys:-1L, $
         xd:zxsize-1, $
         yd:zysize-1 }

Widget_Control, tlb, Set_UValue=info, /No_Copy
XManager, 'contrastzoom', tlb, /No_Block, Cleanup='ContrastZoom_Cleanup', $
   Event_Handler='Contrastzoom_Resize', Group_Leader=group_leader

END
</code>
    </div>
  </body>
</html>