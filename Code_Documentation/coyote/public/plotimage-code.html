<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:17 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>plotimage.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="plotimage.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   PLOTIMAGE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Displays an image via a "PLOT"-like interface.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   PLOTIMAGE, img, [xrange=xrange,] [yrange=yrange,] ...</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;   PLOTIMAGE displays an image (or slice of an image) on the current</span>
<span class="comments">;   graphics device.  The syntax is very similar to the PLOT command,</span>
<span class="comments">;   in the sense that an XRANGE and YRANGE for the plot can be</span>
<span class="comments">;   specified.  </span>
<span class="comments">;</span>
<span class="comments">;   PLOTIMAGE keeps separate the notions of the image coordinate</span>
<span class="comments">;   system and the displayed coordinate system, which allows any input</span>
<span class="comments">;   image to be "cropped," "zoomed," or "flipped."</span>
<span class="comments">;</span>
<span class="comments">;   PLOTIMAGE allows the user to express image extents in physical</span>
<span class="comments">;   units rather than pixel units.</span>
<span class="comments">;</span>
<span class="comments">;   The image coordinate system specifies the physical coordinates of</span>
<span class="comments">;   original image data, IMG.  The image is considered to be a 2D</span>
<span class="comments">;   array (IMG = ARRAY(NX,NY)), where the values are attached to the</span>
<span class="comments">;   midpoint of each geometric pixel.  The image has NX columns and NY</span>
<span class="comments">;   rows.  Physical coordinates are attached to each pixel by using</span>
<span class="comments">;   the IMGXRANGE and IMGYRANGE keywords.  The IMGXRANGE keyword is a</span>
<span class="comments">;   two-element array specifying the "left" and "right" boundaries of</span>
<span class="comments">;   the image pixels in physical units; the IMGYRANGE keyword</span>
<span class="comments">;   specifies the "top" and "bottom" boundaries of the image.  This is</span>
<span class="comments">;   illustrated in Figure 1 for a simplified case.</span>
<span class="comments">;</span>
<span class="comments">;                                   ___</span>
<span class="comments">;         +-----------+-----------+  ^  IMGYRANGE[1]</span>
<span class="comments">;         |           |           |  |</span>
<span class="comments">;         | IMG[0,1]  | IMG[1,1]  |  |</span>
<span class="comments">;         |     +     |     +     |  |</span>
<span class="comments">;         |           |           |  |</span>
<span class="comments">;         |           |           |  |</span>
<span class="comments">;         +-----------+-----------+  |</span>
<span class="comments">;         |           |           |  |</span>
<span class="comments">;         | IMG[0,0]  | IMG[1,0]  |  |</span>
<span class="comments">;         |     +     |     +     |  |</span>
<span class="comments">;         |           |           |  |</span>
<span class="comments">;         |           |           |  v</span>
<span class="comments">;         +-----------+-----------+ ___ IMGYRANGE[0]</span>
<span class="comments">;        |                         |</span>
<span class="comments">;        |&lt;----------------------->|</span>
<span class="comments">;        IMGXRANGE[0]   IMGXRANGE[1]</span>
<span class="comments">;</span>
<span class="comments">;      Figure 1.  Simplified example of a 2x2 input image,</span>
<span class="comments">;      demonstrating that IMG[*,*] values refer to the pixel</span>
<span class="comments">;      mid-points, and that IMGXRANGE and IMGYRANGE ranges specify the</span>
<span class="comments">;      physical coordinates of the outer edges of the image extent in</span>
<span class="comments">;      X and Y, respectively.</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">;   The displayed plot coordinate system is entirely independent of</span>
<span class="comments">;   the native image coordinates.  Users can set up the plot scale</span>
<span class="comments">;   using any combination of {X,Y}RANGE, {X,Y}STYLE and/or {X,Y}LOG,</span>
<span class="comments">;   as they would for any IDL plot, using physical units.  The input</span>
<span class="comments">;   image will then be overlayed on this coordinate system.</span>
<span class="comments">;</span>
<span class="comments">;   If the displayed plot coordinates are narrower than the native</span>
<span class="comments">;   image coordinates, then the displayed portion of the image will be</span>
<span class="comments">;   cropped to fit.  If the displayed coordinates are wider than the</span>
<span class="comments">;   native image coordinates, then the image will be displayed with</span>
<span class="comments">;   blank spaces on either side (see Figure 2).  A mirror "flip" is</span>
<span class="comments">;   also possible in X and/or Y, if XRANGE or YRANGE are specified in</span>
<span class="comments">;   reverse order.</span>
<span class="comments">;                                                 ___</span>
<span class="comments">;      +---------------------------------------+   ^</span>
<span class="comments">;      |            ___                        |   |</span>
<span class="comments">;      |             ^  +---------------+      |   |</span>
<span class="comments">;      |             |  |               |      |   |</span>
<span class="comments">;      |             |  |               |      |   |</span>
<span class="comments">;      |    IMGYRANGE|  |     IMG       |      |   | YRANGE</span>
<span class="comments">;      |             |  |               |      |   |</span>
<span class="comments">;      |             v  |               |      |   |</span>
<span class="comments">;      |            ___ +---------------+      |   |</span>
<span class="comments">;      |               |&lt;-- IMGXRANGE -->|     |   |</span>
<span class="comments">;      |                                       |   v</span>
<span class="comments">;      +---------------------------------------+  ___</span>
<span class="comments">;     |&lt;-------------   XRANGE   -------------->|</span>
<span class="comments">;</span>
<span class="comments">;     Figure 2.  Example of an image whose native image coordinates</span>
<span class="comments">;     are embedded in a wider plot display range.</span>
<span class="comments">;</span>
<span class="comments">;   The standard [XY]STYLE keywords can be used to style either axis.</span>
<span class="comments">;   However at the very least [XY]STYLE=1 is always implied, i.e. the</span>
<span class="comments">;   plot limits exactly obey the [XY]RANGE keyword values.</span>
<span class="comments">;</span>
<span class="comments">;   If XLOG or YLOG are set, then the image is assumed to be sampled</span>
<span class="comments">;   on a logarithmic grid, and logarithmic axes are displayed</span>
<span class="comments">;   accordingly.  PLOTIMAGE does not attempt to resample the image</span>
<span class="comments">;   from linear scale to logarithmic scale, or reverse.</span>
<span class="comments">;</span>
<span class="comments">;   Psuedocolor images may be of any type, but must rescaled to a byte</span>
<span class="comments">;   range by using the RANGE keyword.  By default the color range used</span>
<span class="comments">;   in the rescaling operation is 0 to !D.N_COLORS - 3B.  The extra</span>
<span class="comments">;   two color values are reserved for the background and default pen</span>
<span class="comments">;   colors.  This behavior can be adjusted by specifying the BOTTOM</span>
<span class="comments">;   and/or NCOLORS keywords.</span>
<span class="comments">;</span>
<span class="comments">;   Truecolor images must always be of type BYTE and one of their</span>
<span class="comments">;   dimensions must have 3 elements, corresponding to the three color</span>
<span class="comments">;   planes of the image.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   IMG - Array to be displayed.  For single-plane images (i.e.,</span>
<span class="comments">;         pseudocolor), the image must be two dimensional and of any</span>
<span class="comments">;         real numeric type.  For images that are not of BYTE type,</span>
<span class="comments">;         the RANGE keyword must be supplied, and then PLOTIMAGE will</span>
<span class="comments">;         rescale the image values to a byte range.</span>
<span class="comments">;</span>
<span class="comments">;         An image declared as ARRAY(NX,NY) will be NX pixels in the</span>
<span class="comments">;         x-direction and NY pixels in the y-direction.  The image is</span>
<span class="comments">;         resampled to fill the desired display region (and optionally</span>
<span class="comments">;         smoothed).</span>
<span class="comments">;</span>
<span class="comments">;         For three-plane images (i.e., truecolor) the image must be</span>
<span class="comments">;         of type BYTE.  One of the dimensions of the array must have</span>
<span class="comments">;         three elements.  Hence it must be one of BYTARR(NX, NY, 3),</span>
<span class="comments">;         BYTARR(NX, 3, NY) or BYTARR(3, NX, NY).  The 3-element</span>
<span class="comments">;         dimension is recognized automatically.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;   NONE</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   IMGXRANGE, IMGYRANGE - Each is a two component vector that</span>
<span class="comments">;                          describes the X and Y position of the outer</span>
<span class="comments">;                          edges of the first and last pixels.</span>
<span class="comments">;                          Default: IMGXRANGE = [0,NX]</span>
<span class="comments">;                                   IMGYRANGE = [0,NY]</span>
<span class="comments">;</span>
<span class="comments">;   XRANGE, YRANGE - Each is a two component vector that specifies the</span>
<span class="comments">;                    X and Y plot ranges, respectively.  These values</span>
<span class="comments">;                    are not required to coincide with IMG[XY]RANGE.</span>
<span class="comments">;                    Default: XRANGE=IMGXRANGE</span>
<span class="comments">;                             YRANGE=IMGYRANGE</span>
<span class="comments">;</span>
<span class="comments">;   POSITION - Position of the inner plot window in the standard</span>
<span class="comments">;              graphics keyword format.  Overrides PANEL and SUBPANEL.</span>
<span class="comments">;</span>
<span class="comments">;   INTERP - if set, interpolate (smooth) the image before displaying.</span>
<span class="comments">;            This keyword applies to the screen displays.  For printed</span>
<span class="comments">;            images that are coarser than MIN_DPI, the image is</span>
<span class="comments">;            implicitly interpolated regardless of INTERP.</span>
<span class="comments">;</span>
<span class="comments">;   PRESERVE_ASPECT - if set, preserve the aspect ratio of the</span>
<span class="comments">;                     original image (in pixels).  The result will be</span>
<span class="comments">;                     the largest image that fits in the display</span>
<span class="comments">;                     region while maintaining approximately square</span>
<span class="comments">;                     pixels.  However, PIXEL_ASPECT_RATIO overrides</span>
<span class="comments">;                     PRESERVE_ASPECT.  The POSITION keyword will be</span>
<span class="comments">;                     reset upon output to the ultimate image</span>
<span class="comments">;                     position.</span>
<span class="comments">;                     DEFAULT: not set (image will fill POSITION rectangle)</span>
<span class="comments">;</span>
<span class="comments">;   PIXEL_ASPECT_RATIO - The ratio of width to height for each pixel.</span>
<span class="comments">;                        If specified, then the image will be scaled</span>
<span class="comments">;                        so that each pixel has the specified aspect</span>
<span class="comments">;                        ratio.  If not specified, then the image will</span>
<span class="comments">;                        be scaled independently in X and Y in order</span>
<span class="comments">;                        to fill the POSITION rectangle.  NOTE: If you</span>
<span class="comments">;                        want to change the overall image aspect</span>
<span class="comments">;                        ratio, then use the POSITION keyword.</span>
<span class="comments">;                  DEFAULT: undefined (image will fill POSITION rectangle)</span>
<span class="comments">;</span>
<span class="comments">;   MIN_DPI - if printing, the minimum dot-per-inch pixel resolution</span>
<span class="comments">;             for the resulting image.  Output images that would be</span>
<span class="comments">;             coarser than this value are resampled to have a</span>
<span class="comments">;             resolution of at least MIN_DPI, and smoothed.  Some</span>
<span class="comments">;             common resolutions are: screen, 90 dpi; dot matrix, 72</span>
<span class="comments">;             dpi; laser printer 300-600 dpi.  Note that large values</span>
<span class="comments">;             of MIN_DPI will produce very large output files.</span>
<span class="comments">;             Default: 0 (i.e., the output image will not be smoothed)</span>
<span class="comments">;</span>
<span class="comments">;   RANGE - a two element vector.  If the image is single plane (i.e.,</span>
<span class="comments">;           pseudocolor) the input image can be of any real numeric</span>
<span class="comments">;           type, and then must be rescaled into byte range with this</span>
<span class="comments">;           keyword.  In contrast, truecolor images must always be of</span>
<span class="comments">;           type BYTE.  Values are scaled into byte range with the</span>
<span class="comments">;           following statement:</span>
<span class="comments">;              RESULT = BYTSCL(INPUT, MIN=RANGE(0), MAX=RANGE(1), $</span>
<span class="comments">;                              TOP=NCOLORS-1) + BOTTOM</span>
<span class="comments">;           so that pixels with an intensity RANGE(0) are set to</span>
<span class="comments">;           BOTTOM; those with RANGE(1) are set to the maximum color.</span>
<span class="comments">;           Default: no range scaling occurs (and the image must hence</span>
<span class="comments">;                    be of type BYTE -- otherwise an error occurs)</span>
<span class="comments">;</span>
<span class="comments">;   NCOLORS - number of color table values be used in the byte</span>
<span class="comments">;             rescaling operation.</span>
<span class="comments">;             Default: !D.N_COLORS - BOTTOM - 1 (for default pen color)</span>
<span class="comments">;</span>
<span class="comments">;   BOTTOM - bottom-most value of the color table to be used in the</span>
<span class="comments">;            byte rescaling operation.</span>
<span class="comments">;            Default: 1 (for default background color)</span>
<span class="comments">;</span>
<span class="comments">;   NOERASE - If set, the display is not erased before graphics</span>
<span class="comments">;             operations.</span>
<span class="comments">;</span>
<span class="comments">;   NODATA - If set, the image is not actually displayed, but</span>
<span class="comments">;            coordinate axes may be drawn.</span>
<span class="comments">;</span>
<span class="comments">;   NOAXES - An attempt is made to render the image without coordinate</span>
<span class="comments">;            axes.  However, it's usually more straightforward to set </span>
<span class="comments">;            XSTYLE=4 or YSTYLE=4, which is the standard IDL way to</span>
<span class="comments">;            disable coordinate axes.</span>
<span class="comments">;</span>
<span class="comments">;   ORDER - same interpretation as the !ORDER system variable; </span>
<span class="comments">;           if ORDER=0, then the first pixel is drawn in the lower</span>
<span class="comments">;           left corner; if ORDER=1, then the first pixel is drawn in</span>
<span class="comments">;           the upper left corner.</span>
<span class="comments">;           Default: 0</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;   PANEL, SUBPANEL - An alternate way to more precisely specify the</span>
<span class="comments">;                     plot and annotation positions.  See SUBCELL.</span>
<span class="comments">;</span>
<span class="comments">;   PLOTIMAGE will pass other keywords directly to the PLOT command</span>
<span class="comments">;   used for generating the plot axes.  XSTYLE=1 and YSTYLE=1 are</span>
<span class="comments">;   enforced.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;   NONE</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   This example constructs an image whose values are found by</span>
<span class="comments">;       z(x,y) = cos(x) * sin(y)</span>
<span class="comments">;   and x and y are in the range [-2,2] and [4,8], respectively.</span>
<span class="comments">;   The image is then plotted, with appropriate axes.</span>
<span class="comments">;</span>
<span class="comments">;   x = findgen(20)/5. - 2. + .1   ; 0.1 = half-pixel</span>
<span class="comments">;   y = findgen(20)/5. + 4. + .1</span>
<span class="comments">;   zz = cos(x) # sin(y)</span>
<span class="comments">;   imgxrange = [-2.,2.]           ; extend to pixel edges</span>
<span class="comments">;   imgyrange = [4.,8.]</span>
<span class="comments">;   plotimage, bytscl(zz), imgxrange=imgxrange, imgyrange=imgyrange</span>
<span class="comments">;</span>
<span class="comments">;   This second example plots the same image, but with a plot range</span>
<span class="comments">;   much larger than the image's.</span>
<span class="comments">;</span>
<span class="comments">;   xr=[-10.,10]</span>
<span class="comments">;   yr=[-10.,10]</span>
<span class="comments">;   plotimage, bytscl(zz), imgxrange=imgxrange, imgyrange=imgyrange, $</span>
<span class="comments">;      xrange=xr, yrange=yr</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   OPLOTIMAGE, BYTSCL</span>
<span class="comments">;</span>
<span class="comments">; EXTERNAL SUBROUTINES:</span>
<span class="comments">;</span>
<span class="comments">;   SUBCELL, DEFSUBCELL</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, CM, 1997</span>
<span class="comments">;   Correct various one-off problems, 02 Feb 1999, CM</span>
<span class="comments">;   Made self-contained with some pre-processing, 17 Oct 1999, CM</span>
<span class="comments">;   Corrected bug in newly introduced CONGRID functions, 18 Oct 1999, CM</span>
<span class="comments">;   Correct behavior with no POSITION keyword, 17 Nov 1999, CM</span>
<span class="comments">;   Simplified axis plotting, 17 Nov 1999, CM</span>
<span class="comments">;   Use _EXTRA keyword in first PLOT, but with blank TITLEs, 11 Jan</span>
<span class="comments">;     2000, CM</span>
<span class="comments">;   Correct implementation of X/YSTYLE in first PLOT, 11 Feb 2000, CM</span>
<span class="comments">;   Correct CONGRID implementation (small effect when enlarging most</span>
<span class="comments">;     images), 14 Feb 2000, CM</span>
<span class="comments">;   Major changes: 19 Apr 2000</span>
<span class="comments">;      - now handle decomposed color, automatic color mapping via</span>
<span class="comments">;        RANGE, and 24-bit multiplane images</span>
<span class="comments">;      - new PRESERVE_ASPECT keyword to keep square pixels</span>
<span class="comments">;      - removed legacy TVIMAGE code</span>
<span class="comments">;      - smoothing is more configurable, esp. for printers, but is not</span>
<span class="comments">;        done by default; more printers are supported</span>
<span class="comments">;   Corrected INTERPOLATE behavior (thanks to Liam Gumley</span>
<span class="comments">;     &lt;Liam.Gumley@ssec.wisc.edu>), other minor tweaks, CM 20 Apr 2000</span>
<span class="comments">;   Added ability to use PRESERVE_ASPECT with POSITION, PANEL or</span>
<span class="comments">;     SUBPANEL keywords CM 20 Oct 2000</span>
<span class="comments">;   Oops, a typo is now fixed, CM 23 Oct 2000</span>
<span class="comments">;   Add fix for MacIntoshes and DECOMPOSED color, Tupper, 02 Aug 2001</span>
<span class="comments">;   Better behavior with fractional pixels (ie, when the image pixels</span>
<span class="comments">;     are very large compared to the screen), 23 Aug 2001</span>
<span class="comments">;   Add support for Z buffer, CM, 20 Oct 2002</span>
<span class="comments">;   Memory conservation: use REVERSE() to reverse IMG; rewrote</span>
<span class="comments">;     PLOTIMAGE_RESAMP to rescale entire image instead of each color plane</span>
<span class="comments">;     separately.  Jeff Guerber, 30 July 2003</span>
<span class="comments">;   Add PIXEL_ASPECT_RATIO keyword, 22-25 Nov 2005</span>
<span class="comments">;   Check for the case of an 1xNXxNY 3D image and treat it as a 2D</span>
<span class="comments">;     image.  The "1" dimension can be anywhere, CM, 03 Sep 2006</span>
<span class="comments">;   Add the ORDER keyword parameter, CM, 20 Mar 2007</span>
<span class="comments">;   Enable XLOG and YLOG keywords, for logarithmic axes;</span>
<span class="comments">;     doesn't actually resample the image from linear&lt;->log, CM</span>
<span class="comments">;     21 Jan 2009</span>
<span class="comments">;   Documentation, CM, 21 Jan 2009</span>
<span class="comments">;   Allow reverse color scale, CM, 13 Nov 2010</span>
<span class="comments">;</span>
<span class="comments">;   $Id: plotimage.pro,v 1.15 2010/11/13 09:53:39 cmarkwar Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 1997-2001,2003,2005,2006,2007,2009,2010 Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
<span class="comments">;%insert HERE</span>
<span class="comments">;%include subcell.pro</span>
<span class="comments">;%include defsubcell.pro</span>

<span class="comments">; Utility routine to resample an image</span>
<span class="comments">;</span>
<span class="comments">;  IMAGE - image data ARRAY(NX,NY,BDEPTH)</span>
<span class="comments">;  NX,NY - original X,Y image size</span>
<span class="comments">;  BDEPTH- original image depth</span>
<span class="comments">;  NEWX, NEWY- desired X,Y image size</span>
<span class="comments">;  INTERP - if set, then use bilinear interpolation, otherwise nearest neighbor</span>
<a id="plotimage_resamp:source"></a>function plotimage_resamp, image, nx, ny, bdepth, newx, newy, interp=interp

  <span class="comments">;; Sometimes the final dimension is lost.  Put it back</span>
  image = reform(image, nx, ny, bdepth, /overwrite)

  <span class="comments">;; Correct interpolation</span>
  srx = float(nx)/newx * findgen(newx) - 0.5 + 0.5*(float(nx)/newx)
  sry = float(ny)/newy * findgen(newy) - 0.5 + 0.5*(float(ny)/newy)
  srz = indgen(bdepth)
  if keyword_set(interp) then $
    return, interpolate(image, srx, sry, srz, /grid)

  <span class="comments">;; Simple nearest neighbor interpolation</span>
  return, interpolate(image, round(srx), round(sry), srz, /grid)
end

<a id="plotimage_pos:source"></a>pro plotimage_pos, xrange0, imgxrange0, imgxsize, xreverse, srcxpix, imgxpanel, $
                   logscale=logscale, $
                   quiet=quiet, status=status, pixtolerance=pixtolerance

  if keyword_set(logscale) then begin
     if min(xrange0) LE 0 OR min(imgxrange0) LE 0 then $
        message, ('ERROR: if XLOG or YLOG is set, then the image boundary cannot '+$
                  'cross or touch zero.  Did you forget to set IMGXRANGE or IMGYRANGE?')
     xrange    = alog10(xrange0)
     imgxrange = alog10(imgxrange0)
  endif else begin
     xrange    = xrange0
     imgxrange = imgxrange0
  endelse

  if n_elements(pixtolerance) EQ 0 then pixtolerance = 1.e-2
  status = 0
  <span class="comments">;; Decide if image must be reversed</span>
  xreverse = 0
  if double(xrange(1)-xrange(0))*(imgxrange(1)-imgxrange(0)) LT 0 then begin
      xreverse = 1
      imgxrange = [imgxrange(1), imgxrange(0)]
  endif

  srcxpix  = [ 0L, imgxsize-1 ]
  <span class="comments">;; Size of one x pix</span>
  dx = double(imgxrange(1) - imgxrange(0)) / imgxsize

  if min(xrange) GE max(imgxrange) OR max(xrange) LE min(imgxrange) then begin
      message, 'WARNING: No image data in specified plot RANGE.', /info, $
        noprint=keyword_set(quiet)
      return
  endif

  <span class="comments">;; Case where xrange cuts off image at left</span>
  if (xrange(0) - imgxrange(0))/dx GT 0 then begin
      offset = double(xrange(0)-imgxrange(0))/dx
      if abs(offset-round(offset)) LT pixtolerance then $
        offset = round(offset)
      srcxpix(0) = floor(offset)
      froffset = offset - floor(offset)
      if abs(froffset) GT pixtolerance then begin
          xrange = double(xrange)
          xrange(0) = imgxrange(0) +dx*srcxpix(0)
      endif
  endif

  <span class="comments">;; Case where xrange cuts off image at right</span>
  if (xrange(1) - imgxrange(1))/dx LT 0 then begin
      offset = double(xrange(1)-imgxrange(0))/dx
      if abs(offset-round(offset)) LT pixtolerance then $
        offset = round(offset)
      srcxpix(1) = ceil(offset) - 1
      froffset = offset - ceil(offset)
      if abs(froffset) GT pixtolerance then begin
          xrange = double(xrange)
          srcxpix(1) = srcxpix(1) &lt<span class="comments">; (imgxsize-1)</span>
          xrange(1) = imgxrange(0) + dx*(srcxpix(1)+1)
      endif
  endif

  imgxpanel = [0., 1.]
  if (xrange(0) - imgxrange(0))/dx LT 0 then $
    imgxpanel(0) = (imgxrange(0) - xrange(0))/(xrange(1)-xrange(0))
  if (xrange(1) - imgxrange(1))/dx GT 0 then $
    imgxpanel(1) = (imgxrange(1) - xrange(0))/(xrange(1)-xrange(0))

  status = 1
  return
end

<span class="comments">;; Main program</span>
<a id="plotimage:source"></a>pro plotimage, img0, xrange=xrange0, yrange=yrange0, $
               imgxrange=imgxrange0, imgyrange=imgyrange0, $
               xlog=xlog, ylog=ylog, $
               position=position, panel=panel, subpanel=subpanel, $
               xstyle=xstyle, ystyle=ystyle, title=title, $
               interp=interp0, quiet=quiet, dither=dither, $
               preserve_aspect=paspect, pixel_aspect_ratio=asprat, $
               min_dpi=min_dpi, order=order, $
               ncolors=ncolors0, bottom=bottom0, range=range, $
               noerase=noerase0, nodata=nodata, noaxes=noaxes, $
               pixtolerance=pixtolerance, _EXTRA=extra

  <span class="comments">;; Return to user when an error is encountered</span>
  on_error, 2

  <span class="comments">;; Usage message</span>
  if n_params() EQ 0 then begin
      message, 'PLOTIMAGE, image, xrange=, yrange=, imgxrange=, imgyrange=,..', $
               /info
      return
  endif

  <span class="comments">;; Must have a byte-scaled image already</span>
  imgsize  = size(img0)

  <span class="comments">;; Make sure windowing exists (borrowed from IMDISP)</span>
  if ((!d.flags and 256) ne 0) and (!d.window lt 0) then begin
      window, /free, /pixmap
      wdelete, !d.window
  endif

  <span class="comments">;; Parameter checking</span>
  if n_elements(ystyle) EQ 0 then ystyle = 0L
  if n_elements(xstyle) EQ 0 then xstyle = 0L
  if keyword_set(nodata) then mynodata = 1 else mynodata = 0
  if n_elements(pixtolerance) EQ 0 then pixtolerance = 1.e-2
  if n_elements(title) EQ 0 then title = ''
  if n_elements(min_dpi) EQ 0 then min_dpi = 0
  interp = keyword_set(interp0)
  noerase = keyword_set(noerase0)
  imgpanel = [0., 0., 1., 1.]

  <span class="comments">;; Default handling of color table stuff</span>
  if n_elements(bottom0) EQ 0 then bottom0 = 1B
  bottom = byte(bottom0(0)) &lt<span class="comments">; 255B</span>
  dncolors = min([!d.n_colors, !d.table_size, 256])
  if n_elements(ncolors0) EQ 0 then ncolors0 = dncolors - 1 - bottom
  <span class="comments">;; Make sure color table values are in bounds</span>
  ncolors = floor(ncolors0(0)) &lt<span class="comments">; 256</span>
  if bottom + ncolors GT 256 then ncolors = 256 - bottom

  <span class="comments">;; Image size and dimensions</span>
  nimgdims  = imgsize(0)
  imgtype   = imgsize(nimgdims+1)
  if nimgdims LT 2 OR nimgdims GT 3 then begin
      message, 'ERROR: image must have 2 or 3 dimensions'
  endif

  if nimgdims EQ 2 then begin
      <span class="comments">;; Two dimensional image is pseudo color</span>
      img = img0

      ONE_CHANNEL_IMAGE:
      imgxsize = imgsize(1)
      imgysize = imgsize(2)
      bdepth = 1

      if imgtype NE 1 then begin
          if n_elements(range) LT 2 then $
            message, 'ERROR: non-byte image must be scaled with RANGE keyword'
          if range(0) LE range(1) then begin
              img = bytscl(img, min=range(0), max=range(1), top=ncolors-1B) $
                + bottom
          endif else begin
              <span class="comments">;; Reverse color scheme</span>
              img = bytscl(img, min=range(1), max=range(0), top=ncolors-1B)
              img = ncolors-1B-img + bottom
          endelse
      endif
      img = reform(img, imgxsize, imgysize, bdepth, /overwrite)
  endif else begin
      wh = where(imgsize(1:3) EQ 1, ct)
      if ct GT 0 then begin
          imgxsize = 1
          imgysize = 1
          j = 0
          for i = 1, 3 do if imgsize(i) NE 1 then begin
              if j EQ 0 then imgxsize = imgsize(i) else imgysize = imgsize(i)
              j = j + 1
          endif
          img = reform(img0, imgxsize, imgysize)
          imgsize = size(img)

          goto, ONE_CHANNEL_IMAGE
      endif else begin
          <span class="comments">;; Three dimensional image has three planes</span>
          wh = where(imgsize(1:3) EQ 3, ct)
          if imgtype NE 1 then $
            message, 'ERROR: true color image must of type byte'
          if ct EQ 0 then $
            message, ('ERROR: True color image must have 3 elements '+$
                      'in one of its dimensions')
          truedim = wh(0)
          
          <span class="comments">;; Shuffle the data so planes are interleaved ...</span>
          case truedim of
              0: img = transpose(img0, [1,2,0]) <span class="comments">;; ... from pixels interleaved</span>
              1: img = transpose(img0, [0,2,1]) <span class="comments">;; ... from rows interleaved</span>
              2: img = img0                 <span class="comments">;; ... by straight copying</span>
          end

          imgsize = size(img)
          imgxsize = imgsize(1)
          imgysize = imgsize(2)
          bdepth = imgsize(3)

      endelse

  endelse

  <span class="comments">;; By default, we have no info about the image, and display the</span>
  <span class="comments">;; whole thing</span>
  if n_elements(imgxrange0) LT 2 then imgxrange = [ 0., imgxsize ] $
  else imgxrange = 0. + imgxrange0(0:1)
  if n_elements(xrange0) LT 2 then xrange = imgxrange $
  else xrange = 0. + xrange0(0:1)

  status = 0
  plotimage_pos, xrange, imgxrange, imgxsize, xreverse, srcxpix, imgxpanel, $
    quiet=keyword_set(quiet), status=status, pixtolerance=pixtolerance, $
    logscale=xlog
  if status EQ 0 then mynodata = 1 $
  else imgpanel([0,2]) = imgxpanel

  <span class="comments">;; By default, we have no info about the image, and display the</span>
  <span class="comments">;; whole thing</span>
  if n_elements(imgyrange0) LT 2 then imgyrange = [ 0., imgysize ] $
  else imgyrange = 0. + imgyrange0(0:1)
  if n_elements(yrange0) LT 2 then yrange = imgyrange $
  else yrange = 0. + yrange0(0:1)
  if keyword_set(order) then yrange = [yrange(1), yrange(0)]

  status = 0
  plotimage_pos, yrange, imgyrange, imgysize, yreverse, srcypix, imgypanel, $
    quiet=keyword_set(quiet), status=status, pixtolerance=pixtolerance, $
    logscale=ylog
  if status EQ 0 then mynodata = 1 $
  else imgpanel([1,3]) = imgypanel

  <span class="comments">;; Dimensions of output image in pixels</span>
  nx = srcxpix(1)-srcxpix(0)+1
  ny = srcypix(1)-srcypix(0)+1

  <span class="comments">;; Create a coordinate system by plotting with no data or axes</span>
  if n_elements(position) EQ 0 AND n_elements(panel) EQ 0 AND $
    n_elements(subpanel) EQ 0 then begin

      <span class="comments">;; If PANEL/SUBPANEL is not given, then plot once to set up</span>
      <span class="comments">;; axes, despite NOAXES</span>
      plot, xrange, yrange, noerase=noerase, /nodata, $
        xstyle=xstyle OR 5, ystyle=xstyle OR 5, xlog=xlog, ylog=ylog, $
        xrange=xrange, yrange=yrange, xtitle='', ytitle='', title='', $
        _EXTRA=extra

      <span class="comments">;; Retrieve axis settings</span>
      xwindow = !x.window
      ywindow = !y.window

      subpanel1 = [xwindow(0), ywindow(0), xwindow(1), ywindow(1)]
      imgposition = subcell(imgpanel, subpanel1)
      position = subpanel1

  endif else begin

      <span class="comments">;; Construct the plot size from panel info.  Default is full-screen</span>
      if NOT keyword_set(noerase) then erase
      if n_elements(position) GE 4 then begin
          imgposition = subcell(imgpanel, position)
      endif else begin
          if n_elements(panel) LT 4 then panel = [0.0,0.0,1.0,1.0]
          if n_elements(subpanel) LT 4 then subpanel = [-1., -1, -1, -1]
          subpanel = defsubcell(subpanel)

          imgposition = subcell(subcell(imgpanel, subpanel), panel)
          position = subcell(subpanel, panel)
      endelse

      xwindow = position([0,2])
      ywindow = position([1,3])

  endelse

  <span class="comments">;; If the aspect is to be preserved then we need to recompute the</span>
  <span class="comments">;; position after considering the image size.  Since we have already</span>
  <span class="comments">;; computed the outer envelope of the image from either the POSITION</span>
  <span class="comments">;; or PANEL, or from the plot window itself, we can now go to the</span>
  <span class="comments">;; logic which estimates the aspect-corrected size.</span>

  if (keyword_set(paspect) OR n_elements(asprat) GT 0) AND $
    nx GT 0 AND ny GT 0 then begin

      if n_elements(asprat) EQ 0 then asprat1 = 1.0 $
      else asprat1 = asprat(0) + 0.

      <span class="comments">;; If we are preserving the aspect, then re-plot after scaling</span>
      <span class="comments">;; the POSITION</span>

      imgaspect = float(ny)/float(nx)/asprat1
      dispaspect = (ywindow(1)-ywindow(0))*!d.y_vsize $
        / ((xwindow(1)-xwindow(0))*!d.x_vsize)

      <span class="comments">;; Compute the new image dimensions</span>
      if imgaspect GT dispaspect then begin
          x0 = total(xwindow)/2
          dx = (ywindow(1)-ywindow(0))*!d.y_vsize/(imgaspect*!d.x_vsize)
          xwindow = x0 + dx*[-0.5,0.5]
      endif else begin
          y0 = total(ywindow)/2
          dy = (xwindow(1)-xwindow(0))*!d.x_vsize*imgaspect/!d.y_vsize
          ywindow = y0 + dy*[-0.5,0.5]
      endelse

      subpanel1 = [xwindow(0), ywindow(0), xwindow(1), ywindow(1)]
      imgposition = subcell(imgpanel, subpanel1)
      position = subpanel1

      <span class="comments">;; Replot to regain coordinate system</span>
      plot, xrange, yrange, /noerase, /nodata, $
        xstyle=xstyle OR 5, ystyle=xstyle OR 5, xlog=xlog, ylog=ylog, $
        xrange=xrange, yrange=yrange, xtitle='', ytitle='', title='', $
        position=position, _EXTRA=extra

  endif

  <span class="comments">;; Draw the image data</span>
  if NOT keyword_set(mynodata) then begin

      <span class="comments">;; Reverse X- or Y- directions if necessary</span>
      if xreverse then $
        srcxpix = imgxsize - 1 - [srcxpix(1), srcxpix(0)]
      if yreverse then $
        srcypix = imgysize - 1 - [srcypix(1), srcypix(0)]

      <span class="comments">;; Extract relevant image elements</span>
      img = (temporary(img))(srcxpix(0):srcxpix(1), srcypix(0):srcypix(1),*)
      img = reform(img, nx, ny, bdepth, /overwrite)

      <span class="comments">;; Complete the extraction, if reversed</span>
      if xreverse then begin
          img = reverse(img, 1, /overwrite)
          img = reform(img, nx, ny, bdepth, /overwrite)
      endif
      if yreverse then begin
          img = reverse(img, 2, /overwrite)
          img = reform(img, nx, ny, bdepth, /overwrite)
      endif

      <span class="comments">;; Compute the image position on screen in pixels</span>
      x0 = round(imgposition(0) * !d.x_vsize)
      y0 = round(imgposition(1) * !d.y_vsize)
      dx = round((imgposition(2) - imgposition(0)) * !d.x_vsize) > 1
      dy = round((imgposition(3) - imgposition(1)) * !d.y_vsize) > 1

      <span class="comments">;; Decide which output type</span>
      windowing = (!d.name EQ 'WIN') OR (!d.name EQ 'MAC') OR (!d.name EQ 'X')
      printing = (!d.name EQ 'PRINTER') OR (!d.flags AND 1) NE 0

      <span class="comments">;; Decide whether to resample the image</span>
      rescaling = (windowing OR (!d.name EQ 'Z')) $
        AND ((dx NE nx) OR (dy NE ny))

      <span class="comments">;; If printing, and the printed resolution of the image will be</span>
      <span class="comments">;; too coarse, then we should resample and interpolate</span>
      dpi = min([nx*!d.x_px_cm/dx, ny*!d.y_px_cm/dy]*2.54) <span class="comments">; d.p.i. of image</span>
      dxsize = dx & dysize = dy
      if printing AND (dpi LT min_dpi(0)) then begin
          dx = round(min_dpi(0)*dx/(2.54*!d.x_px_cm)) > nx
          dy = round(min_dpi(0)*dy/(2.54*!d.y_px_cm)) > ny
          interp = 1
          rescaling = 1
      endif

      <span class="comments">;; Rescale the image if needed</span>
      if rescaling then begin
          img = plotimage_resamp(temporary(img), nx, ny, bdepth, $
            dx, dy, interp=interp)
          img = reform(img, dx, dy, bdepth, /overwrite)
      endif

      <span class="comments">;; Generic printer device</span>
      if !d.name EQ 'PRINTER' then begin
          if bdepth EQ 3 then begin
              device, /true_color
              tv, img, x0, y0, xsize=dxsize, ysize=dysize, true=3
          endif else begin
              device, /index_color
              tv, img, x0, y0, xsize=dxsize, ysize=dysize
          endelse
          goto, DONE_IMG
      endif

      <span class="comments">;; Devices with scalable pixels</span>
      if (!d.flags AND 1) NE 0 then begin
          if bdepth EQ 3 then begin
              tvlct, r, g, b, /get
              loadct, 0, /silent
              tv, img, x0, y0, xsize=dxsize, ysize=dysize, true=3
              tvlct, r, g, b
          endif else begin
              tv, img, x0, y0, xsize=dxsize, ysize=dysize
          endelse
          goto, DONE_IMG
      endif

      <span class="comments">;; Get visual depth (in bytes) and decomposed state</span>
      decomposed0 = 0
      vdepth = 1
      version = float(!version.release)
      if windowing then begin

          <span class="comments">;; Visual depth</span>
          if version GE 5.1 then begin
              device, get_visual_depth=vdepth
              vdepth = vdepth / 8
          endif else begin
              if !d.n_colors GT 256 then vdepth = 3
          endelse

          <span class="comments">;; Decomposed state</span>
          if vdepth GT 1 then begin
              if version GE 5.2 then device, get_decomposed=decomposed0
              if bdepth EQ 3 then    device, decomposed=1 $
              else                   device, decomposed=0
          endif
      endif

      <span class="comments">;; If visual is 8-bit but image is 24-bit, then quantize</span>
      if vdepth LE 1 AND bdepth EQ 3 then begin
          img = color_quan(temporary(img), 3, r, g, b, colors=ncolors-1, $
                           dither=keyword_set(dither)) + bottom
          tvlct, r, g, b, bottom
          bdepth = 1
      endif

      <span class="comments">;; Put the image</span>
      if bdepth EQ 3 then tv, img, x0, y0, true=3 $
      else                tv, img, x0, y0

      <span class="comments">;; Restore the decomposed state</span>
      if windowing then begin
          if vdepth GT 1 then device, decomposed=decomposed0
          <span class="comments">;; Tupper supplies following work-around for MacIntoshes</span>
          if (!d.name EQ 'MAC') then tv, [0], -1, -1
      endif
  endif

  <span class="comments">;; Plot the axes if requested</span>
  DONE_IMG:
  if NOT keyword_set(noaxes) then begin
      if n_elements(xrange) EQ 0 then begin
          if n_elements(imgxrange) GT 1 then xrange=imgxrange $
          else xrange = [0L, imgxsize]
      endif
      if n_elements(yrange) EQ 0 then begin
          if n_elements(imgyrange) GT 1 then yrange=imgyrange $
          else yrange = [0L, imgysize]
      endif

      plot, xrange, yrange, /noerase, /nodata, /normal, $
        xrange=xrange, yrange=yrange, xlog=xlog, ylog=ylog, $
        xstyle=xstyle OR 1, ystyle=ystyle OR 1, title=title, $
        position=position, _EXTRA=extra
  endif

  return
end

</code>
    </div>
  </body>
</html>