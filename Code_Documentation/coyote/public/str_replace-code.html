<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:17 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>str_replace.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="str_replace.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; Handle string replacment with regular expressions.</span>
<span class="comments">;</span>
<span class="comments">; @examples The following example demonstrate basic operations of STR_REPLACE:&lt;pre></span>
<span class="comments">; &lt;b>IDL>&lt;/b> print, str_replace('Mike was here', 'was', 'was not')</span>
<span class="comments">; Mike was not here</span>
<span class="comments">; &lt;b>IDL>&lt;/b> print, str_replace('Mike was here', '([^ ]*) ([^ ]*)', '$2 $1')</span>
<span class="comments">; was Mike here</span>
<span class="comments">; &lt;b>IDL>&lt;/b> print, str_replace('MikeGeorgeHenryMikeBill', 'Mike([A-Z][a-z]*)', '"Mike"+strupcase("$1")', /evaluate, /global)</span>
<span class="comments">; MikeGEORGEHenryMikeBILL</span>
<span class="comments">; &lt;b>IDL>&lt;/b> print, str_replace('Mike5', 'Mike([0-9]+)', 'strtrim(fix($1) * 2, 2)', /evaluate)</span>
<span class="comments">; 10</span>
<span class="comments">; &lt;b>IDL>&lt;/b> str = '187438273587285'</span>
<span class="comments">; &lt;b>IDL>&lt;/b> for i = 0, strlen(str)/3 - 1 do str = str_replace(str, '^[+-]?([[:digit:]]+)([[:digit:]]{3})', '$1,$2', /global)</span>
<span class="comments">; &lt;b>IDL>&lt;/b> print, str</span>
<span class="comments">; 187,438,273,587,285&lt;/pre></span>
<span class="comments">; @returns string</span>
<span class="comments">; @param str {in}{required}{type=string} a string to search for expressions</span>
<span class="comments">;            and replace them</span>
<span class="comments">; @param pattern {in}{required}{type=string} a regular expression possibly</span>
<span class="comments">;        using subexpressions; see IDL's online help for STREGEX for more</span>
<span class="comments">;        help on regular expressions</span>
<span class="comments">; @param replacement {in}{required}{type=string} the string to replace matches</span>
<span class="comments">;        of the "pattern"; can use $1, $2, etc. to refer to subexpressions</span>
<span class="comments">;        in "pattern"</span>
<span class="comments">; @keyword evaluate {in}{optional}{type=boolean} set to evaluate the</span>
<span class="comments">;          "replacement" as a IDL expression instead of just a string.</span>
<span class="comments">; @keyword fold_case {in}{optional}{type=boolean} set to make a case</span>
<span class="comments">;          insensitive match with "pattern"</span>
<span class="comments">; @keyword global {in}{optional}{type=boolean} set to replace all expressions</span>
<span class="comments">;          that match</span>
<span class="comments">; @keyword start {out}{optional}{type=integral}{private} where to start looking</span>
<span class="comments">; @author Michael Galloy</span>
<span class="comments">; @copyright RSI, 2002</span>
<span class="comments">;-</span>
<a id="str_replace:source"></a>function str_replace, str, pattern, replacement, evaluate=evaluate, $
    fold_case=fold_case, global=global, start=start
    compile_opt idl2
    on_error, 2

    if (n_elements(str) ne 1) then begin
        message, 'str parameter must be a scalar string'
    endif

    if (keyword_set(global)) then begin
        ans = str_replace(str, pattern, replacement, start=start, $
            fold_case=keyword_set(fold_case), evaluate=keyword_set(evaluate))

        while (start lt strlen(ans)) do begin
            temp = strmid(ans, 0, start)
            ans =  temp $
                + str_replace(strmid(ans, start), pattern, replacement, start=start, $
                    fold_case=keyword_set(fold_case), evaluate=keyword_set(evaluate))
            start = strlen(temp) + start
        endwhile

        return, ans
    endif

    pos = stregex(str, pattern, length=len, /subexpr, $
        fold_case=keyword_set(fold_case))

    <span class="comments">; pattern not found</span>
    if (pos[0] eq -1) then begin
        start = strlen(str)
        return, str
    endif

    pre = pos[0] eq 0 ? '' : strmid(str, 0, pos[0])
    post = pos[0] + len[0] ge strlen(str) ? '' : strmid(str, pos[0] + len[0])

    <span class="comments">; $& -> pos[0], len[0]</span>
    <span class="comments">; $1 -> pos[1], len[1]</span>
    <span class="comments">; $2 -> pos[2], len[2]</span>
    <span class="comments">; etc...</span>
    rpos = strsplit(replacement, '$', escape='\', length=rlen)
    static_replacement = ''
    if ((n_elements(rlen) ne 1) or (rlen[0] ne 0)) then begin
        for i = 0, n_elements(rpos) - 1 do begin
            if (rpos[i] ne 0) then begin
                part = strmid(replacement, rpos[i], rlen[i])
                ppos = stregex(part, '^[0-9]+|^&', length=plen)
                if (ppos[0] eq -1) then $
                    message, 'illegal $, use \ to escape'

                match = strmid(part, ppos, plen)
                var_no = match eq '&' ? 0 : long(match)
                if (var_no ge n_elements(pos)) then begin
                    message, '$' + strtrim(var_no, 2) + ' undefined'
                endif

                var = strmid(str, pos[var_no], len[var_no])
                static_replacement $
                    = static_replacement + var + strmid(part, ppos + plen)
            endif else begin
                if (rlen[0] eq 0) then begin
                    message, 'illegal $, use \ to escape'
                endif
                static_replacement = strmid(replacement, rpos[0], rlen[0])
            endelse
        endfor
    endif

    <span class="comments">; call IDL if EVALUATE keyword is set</span>
    if (keyword_set(evaluate)) then begin
        result = execute('static_replacement = ' + static_replacement)
    endif

    ret_str = pre + static_replacement + post
    start = strlen(pre) + strlen(static_replacement)

    return, ret_str
end
</code>
    </div>
  </body>
</html>