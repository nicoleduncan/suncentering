<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:18 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgmap__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgmap__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Provides an easy way to set up a map projection coordinate space using GCTP map </span>
<span class="comments">;   projections normally accessed via Map_Proj_Init.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Provides an easy way to set up a map projection coordinate space using GCTP map </span>
<span class="comments">;   projections normally accessed via Map_Proj_Init. Allows an unlimited number of map</span>
<span class="comments">;   overlays, and can provide a fresh map structure on demand, eliminating the problem</span>
<span class="comments">;   of ephemerial map structures that plaqued Map_Proj_Init until IDL 8.x. This program</span>
<span class="comments">;   is basically a wrapper for Map_Proj_Init, with additional features that make it </span>
<span class="comments">;   superiour for working with map projections in IDL.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Map Projections</span>
<span class="comments">;    </span>
<span class="comments">; :File_comments:</span>
<span class="comments">;     Only GCTP projections are allowed. If you wish to use projections normally </span>
<span class="comments">;     set up with Map_Set, use the comparable cgMap_Set command. </span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;     David W. Fanning </span>
<span class="comments">;     1645 Sheely Drive </span>
<span class="comments">;     Fort Collins, CO 80526 USA </span>
<span class="comments">;     Phone: 970-221-0438 </span>
<span class="comments">;     E-mail: david@idlcoyote.com </span>
<span class="comments">;     Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Brought over to the Coyote Library from a similar routine in the Catalyst Library.</span>
<span class="comments">;           Updated to account for the bug that creates incorrect result in UTM projections</span>
<span class="comments">;           when using the WGS84 ellipsoid. The Wallbeck ellipsoid is substituted for the</span>
<span class="comments">;           WGS84 ellipsoid in this instance. David W. Fanning, 7 November 2011.</span>
<span class="comments">;        Added IS_CYLINDRICAL method to solve a problem with grid labeling and drawing</span>
<span class="comments">;           of grid lines. 16 Dec 2011. DWF.</span>
<span class="comments">;        Added ERASE method to erase the display. 28 Dec 2011. DWF.</span>
<span class="comments">;        Added check for identical range values in FORWARD method. 30 Dec 2011. DWF.</span>
<span class="comments">;        I am convinced that the map structure returned by Map_Proj_Init, when there</span>
<span class="comments">;           is a LIMIT used in the call contains a uv_box with incorrect latitude values.</span>
<span class="comments">;           This is important because other routines (e.g., cgMapGrid) depend on these values.</span>
<span class="comments">;           I've created a fix wherein I fixed the uv_box latitude values to correspond</span>
<span class="comments">;           to the LIMIT of the map projection. 6 April 2012. DWF.</span>
<span class="comments">;        Set the default CENTER_LATITUDE and CENTER_LONGITUDE to 0.0. 9 April 2012. DWF.</span>
<span class="comments">;        Added NOFORWARDFIX keyword to allow skipping of the "fix" in the FORWARD method,</span>
<span class="comments">;           as sometimes this is not needed or required. 29 June 2012. DWF.</span>
<span class="comments">;        Fixed a problem that required having to set the UTM zone in addition to the latitude</span>
<span class="comments">;           and longitude in a UTM projection. Now using cgUTMZone to determine the proper</span>
<span class="comments">;           zone. 8 Aug 2012. DWF.</span>
<span class="comments">;        Added a BOUNDARY keyword to the GetProperty method. 16 Aug 2012. DWF.</span>
<span class="comments">;        Modified to allow Hotine Oblique Mercator map projections to work correctly. 7 Sept 2012. DWF.</span>
<span class="comments">;        Additional changes to better handle IDL 8.2 map projections. 12 Sept 2012. DWF.</span>
<span class="comments">;        Added LATLONBOX keyword to the GetProperty method to allow me to obtain</span>
<span class="comments">;            the map boundary in the Google Map preferred notation of [north, south, east, west]</span>
<span class="comments">;            in degrees. 30 Oct 2012.</span>
<span class="comments">;        I was calculating the default X and Y range incorrectly for non-UTM map projections.</span>
<span class="comments">;            I have now gone back to my original method of using the UV_BOX of the map structure</span>
<span class="comments">;            to do this. However, there is still a problem with the UV_BOX when the center latitude</span>
<span class="comments">;            is not zero. I still attempt to fix this problem in the code (SetMapProjection method). 3 Jan 2012. DWF.</span>
<span class="comments">;        I added ASPECT and ISOTROPIC keywords to allow the setting of the aspect ratio of the map. 3 Jan 2012. DWF.</span>
<span class="comments">;        Added zone to the information returned with MapInfo method if projection is UTM. 25 April 2013. DWF.</span>
<span class="comments">;        The map aspect was disappearing because Total(!P.Multi) can occasionally be LT 0! Fixed. 3 July 2013. DWF.</span>
<span class="comments">;        </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   The initialization method for the cgMap object.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    map_projection: in, optional, type=string/integer, default='Equirectangular'</span>
<span class="comments">;        The name or index number of the map projection desired. Passed directly</span>
<span class="comments">;        to Map_Proj_Init as the map projection value. Only GCTP projections are</span>
<span class="comments">;        allowed. If you wish to use projections normally set up with Map_Set, use</span>
<span class="comments">;        the comparable cgMap_Set command.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object is added to the resizeable graphics</span>
<span class="comments">;        window, cgWindow. The DRAW method of the object is called in cgWindow.</span>
<span class="comments">;     aspect: in, optional, type=float, default=none</span>
<span class="comments">;        Set this keyword to a floating point ratio that represents the aspect ratio </span>
<span class="comments">;        (ysize/xsize) of the resulting map projection. Note that `Aspect` cannot be </span>
<span class="comments">;        used when plotting with !P.MULTI. Consider using cgLayout instead for multiple</span>
<span class="comments">;        plots.</span>
<span class="comments">;     background: in, optional, type=string, default='white'</span>
<span class="comments">;        The name of the background color. Used only if the map object erases</span>
<span class="comments">;        the display when it draws its contents.</span>
<span class="comments">;     bcolor: optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the color to draw box axes with. Requires BOX_AXES be set.</span>
<span class="comments">;     box_axes: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw a box-style grid axes around the map. Applies</span>
<span class="comments">;        only if creating a mapGrid object.</span>
<span class="comments">;     center_latitude: in, optional, type=float, default=0.0</span>
<span class="comments">;        The center latitude of the map projection.</span>
<span class="comments">;     center_longitude: in, optional, type=float, default=0.0</span>
<span class="comments">;        The center longitude of the map projection.</span>
<span class="comments">;     ccolor: in, optional, type=string, default='charcoal'</span>
<span class="comments">;        The name of the drawing color for the MapContinents object if this is requested.</span>
<span class="comments">;     color: in, optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the drawing color for the object. Passed along to the mapGrid</span>
<span class="comments">;        and MapContinents object if these are requested.</span>
<span class="comments">;     continents: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to create an overlay object of continental outlines</span>
<span class="comments">;        that will be rendered when the draw method is called.</span>
<span class="comments">;     datum: in, optional, type=string/integer, default='Sphere'</span>
<span class="comments">;        This keyword is being depreciated in favor of the keyword ELLIPSOID,</span>
<span class="comments">;        corresponding to changes to Map_Proj_Init initiated in IDL 7.</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to immediately call the DRAW method after the</span>
<span class="comments">;        object has been completely initialized.</span>
<span class="comments">;     ellipsoid: in, optional, type=string/integer</span>
<span class="comments">;        Set this to the name or index number of the ellopsoid or datum you wish to use</span>
<span class="comments">;        for the map projection. The value is passed directly to Map_Proj_Init. The</span>
<span class="comments">;        default is a sphere for those projections that only support a sphere, otherwise</span>
<span class="comments">;        a Clark projection is used to conform to Map_Proj_Init defaults.</span>
<span class="comments">;     fill: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to display filled continents, if the keyword CONTINENTS is set.</span>
<span class="comments">;     erase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to have the object erase the current graphics display</span>
<span class="comments">;        before drawing its content in the DRAW method. The graphics display will be erased</span>
<span class="comments">;        in the background color.</span>
<span class="comments">;     gcolor: in, optional, type=string, default='gray'</span>
<span class="comments">;        The name of the drawing color for the MapGrid object if this is requested.</span>
<span class="comments">;     grid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to create an overlay object of map grid lines</span>
<span class="comments">;        that will be rendered when the draw method is called.</span>
<span class="comments">;     hires: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to use high resolution continental outlines.</span>
<span class="comments">;        Passed to the MapContinents object if one is requested.</span>
<span class="comments">;     isotropic: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to set the `Aspect` keyword to a value that correctly represents</span>
<span class="comments">;        the same map unit length in both the X and Y directions. In other words, a map</span>
<span class="comments">;        unit measured in the X direction is the same physical length as a map unit measured</span>
<span class="comments">;        in the Y direction.</span>
<span class="comments">;     land_color: in, optional, type=string</span>
<span class="comments">;        The name of the drawing color for filled continents, if the keyword CONTINENTS </span>
<span class="comments">;        is set. Passed directly to the cgMapContinents object.</span>
<span class="comments">;     latlon_ranges: in, optional, type=boolean, default=0</span>
<span class="comments">;        Normally the XRANGE and YRANGE keywords are set in terms of projected meters. If </span>
<span class="comments">;        this keyword is set, then the values of XRANGE and YRANGE are assumed to be in longitude</span>
<span class="comments">;        and latitude values, respectively, and will be converted to projected meters prior to </span>
<span class="comments">;        being stored in the object.</span>
<span class="comments">;     limit: in, optional, type=FltArr(4), default=none</span>
<span class="comments">;        The normal LIMIT keyword to Map_Proj_Init, specifying the limit of the map</span>
<span class="comments">;        projection in terms of latitude and longitude. Normally, `Limit` is used when using</span>
<span class="comments">;        Map_Proj_Init. Most work is done by specifying the projected XY rectangular</span>
<span class="comments">;        coordinate system with the keywords XRANGE and YRANGE.</span>
<span class="comments">;     lcolor: in, optional, type=string</span>
<span class="comments">;        Set this to the name of the label color to use in labeling grid lines.</span>
<span class="comments">;        By default, the same as COLOR, or if BOX_AXIS is set, then same as BCOLOR.</span>
<span class="comments">;     name: in, optional, type=string, default=selected by cgContainer.</span>
<span class="comments">;        Use this keyword to name the object. Names are often used to select objects in </span>
<span class="comments">;        program code. </span>
<span class="comments">;     noborder: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the customary border than surrounds the map projection is</span>
<span class="comments">;        not drawn.</span>
<span class="comments">;     noforwardfix: in, optional, type=boolean, default=0</span>
<span class="comments">;        There is, I believe, a bug in MAP_PROJ_FORWARD that renders longitude values </span>
<span class="comments">;        incorrectly in projected meter space. This is evidenced by MAP_GRID not producing</span>
<span class="comments">;        the correct longitude lines in map coordinate systems set up in projected XY meters.</span>
<span class="comments">;        In the FORWARD method I correct for this. But, this correction is not always needed</span>
<span class="comments">;        or wanted. This property of the object allows me to turn that correction on or off,</span>
<span class="comments">;        as needed. Normally, the fix is provided, unless this keyword is set to 1.</span>
<span class="comments">;     onimage: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the position of the map projection in the graphics window</span>
<span class="comments">;        is obtained from the last image displayed with cgImage. This makes it extremely</span>
<span class="comments">;        easy to display an image and immediately set up a map projection space that will</span>
<span class="comments">;        allow you to annotate the image using map locations.</span>
<span class="comments">;     position: in, optional, type=FltArr(4)</span>
<span class="comments">;        The normalized position of the map projection space in the graphics window.</span>
<span class="comments">;        The default is [0.075, 0.075, 0.925, 0.925]</span>
<span class="comments">;     radians: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to indicate latitude and longitude values are in radians rather </span>
<span class="comments">;        than degrees.</span>
<span class="comments">;     semimajor_axis: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the semimajor axis of the ellipsoid in meters. Normally calculated</span>
<span class="comments">;        from the ELLIPSOID keyword values.</span>
<span class="comments">;     semiminor_axis: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the semiminor axis of the ellipsoid in meters. Normally calculated</span>
<span class="comments">;        from the ELLIPSOID keyword values.</span>
<span class="comments">;     sphere_radius: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the ellipsoidal sphere in meters. Normally calculated from the </span>
<span class="comments">;        ELLIPSOID keyword values.</span>
<span class="comments">;     title: in, optional, type=string, default=""</span>
<span class="comments">;        The title of the map projection display.</span>
<span class="comments">;     uvalue: in, optional, type=any, default=none</span>
<span class="comments">;        A storage space for storing any kind of IDL variable of importance to the user.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object replaces any commands in a current</span>
<span class="comments">;        cgWindow or it opens a new cgWindow and adds itself to it.</span>
<span class="comments">;     xrange: in, optional, type=various</span>
<span class="comments">;        Set this keyword to the X axis range desired in the data coordinate system.</span>
<span class="comments">;        Normally expressed in XY projected meter space, unless the LATLON_RANGES </span>
<span class="comments">;        keyword is set. The default is mapStruct.uv_box[[0,2]].</span>
<span class="comments">;     yrange: in, optional, type=various</span>
<span class="comments">;         Set this keyword to the X axis range desired in the data coordinate system.</span>
<span class="comments">;         Normally expressed in XY projected meter space, unless the LATLON_RANGES </span>
<span class="comments">;         keyword is set. The default is mapStruct.uv_box[[1,3]].</span>
<span class="comments">;     zone: in, optional, type=integer, default=varies</span>
<span class="comments">;         The zone (normally in UTM projections) of the map projection. If not given and needed,</span>
<span class="comments">;         calculated from the CENTER_LATITUDE and CENTER_LONGITUDE keyword values.</span>
<span class="comments">;     _EXTRA: in, optional</span>
<span class="comments">;         Other keywords accepted by the MAP_PROJ_INIT command are allowed and are passed</span>
<span class="comments">;         directly to the MAP_PROJ_INIT program.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::INIT, map_projection, $
    ADDCMD=addcmd, $
    ASPECT=aspect, $
    BACKGROUND=background, $
    BCOLOR=bcolor, $
    BOX_AXES=box_axes, $
    CCOLOR=ccolor, $
    CENTER_LATITUDE=center_latitude, $
    CENTER_LONGITUDE=center_longitude, $
    COLOR=color, $
    CONTINENTS=continents, $
    DATUM=datum, $
    DRAW=draw, $
    EASTING=easting, $
    ELLIPSOID=ellipsoid, $
    ERASE=erase, $
    FILL=fill, $
    GCOLOR=gcolor, $
    GRID=grid, $
    HIRES=hires, $
    ISOTROPIC=isotropic, $
    LAND_COLOR=land_color, $
    LATLON_RANGES=latlon_ranges, $
    LCOLOR=lcolor, $
    LIMIT=limit, $
    NAME=name, $
    NOBORDER=noborder, $
    NOFORWARDFIX=noForwardFix, $
    NORTHING=northing, $
    ONIMAGE=onimage, $
    POSITION=position, $
    RADIANS=radians, $
    SEMIMAJOR_AXIS=semimajor_axis, $
    SEMIMINOR_AXIS=semiminor_axis, $
    SPHERE_RADIUS=sphere_radius, $
    TITLE=title, $
    WINDOW=window, $
    XRANGE=xrange, $
    YRANGE=yrange, $
    UVALUE=uvalue, $
    ZONE=zone, $
    _EXTRA=extraKeywords

   Compile_Opt idl2
    
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, 0
   ENDIF
      
   <span class="comments">; Structures used in the object.</span>
   datumStruct = { cgMap_DATUM }
   void = { cgMap_PROJECTION }
   
   <span class="comments">; If you specify a BACKGROUND keyword, then ERASE is set automatically.</span>
   IF N_Elements(background) NE 0 THEN BEGIN
       erase = 1
   ENDIF ELSE background = 'white'
   erase = Keyword_Set(erase)
   SetDefaultValue, center_latitude, 0.0
   SetDefaultValue, center_longitude, 0.0
   SetDefaultValue, color, "opposite"
   SetDefaultValue, easting, 0.0
   SetDefaultValue, northing, 0.0
   SetDefaultValue, position, [0.075, 0.075, 0.925, 0.925]
   SetDefaultValue, title, ""

   <span class="comments">; Default map projection.</span>
   IF N_Elements(map_projection) EQ 0 THEN BEGIN
        this_map_projection = 'Equirectangular'
        map_projection = 117
        limit = [-90, -180, 90, 180]
   ENDIF
   
    projections=[ {cgMap_PROJECTION, 'UTM', 101, 0 }, $  <span class="comments">; GCTP 101</span>
                  {cgMap_PROJECTION, 'State Plane', 102, 0 }, $  <span class="comments">; GCTP 102</span>
                  {cgMap_PROJECTION, 'Albers Equal Area', 103, 0 }, $  <span class="comments">; GCTP 103</span>
                  {cgMap_PROJECTION, 'Lambert Conformal Conic', 104, 0 }, $  <span class="comments">; GCTP 104</span>
                  {cgMap_PROJECTION, 'Mercator', 105, 0 }, $  <span class="comments">; GCTP 105</span>
                  {cgMap_PROJECTION, 'Polar Stereographic', 106, 0 }, $  <span class="comments">; GCTP 106</span>
                  {cgMap_PROJECTION, 'Polyconic', 107, 0 }, $  <span class="comments">; GCTP 107</span>
                  {cgMap_PROJECTION, 'Equidistant Conic A', 108, 0 }, $  <span class="comments">; GCTP 108</span>
                  {cgMap_PROJECTION, 'Transverse Mercator', 109, 0 }, $  <span class="comments">; GCTP 109</span>
                  {cgMap_PROJECTION, 'Stereographic', 110, 1 }, $  <span class="comments">; GCTP 110</span>
                  {cgMap_PROJECTION, 'Lambert Azimuthal', 111, 1 }, $  <span class="comments">; GCTP 111</span>
                  {cgMap_PROJECTION, 'Azimuthal', 112, 1 }, $  <span class="comments">; GCTP 112</span>
                  {cgMap_PROJECTION, 'Gnomonic', 113, 1 }, $  <span class="comments">; GCTP 113</span>
                  {cgMap_PROJECTION, 'Orthographic', 114, 1 }, $  <span class="comments">; GCTP 114</span>
                  {cgMap_PROJECTION, 'Near Side Perspective', 115, 1 }, $  <span class="comments">; GCTP 115</span>
                  {cgMap_PROJECTION, 'Sinusoidal', 116, 1 }, $  <span class="comments">; GCTP 116</span>
                  {cgMap_PROJECTION, 'Equirectangular', 117, 1 }, $  <span class="comments">; GCTP 117</span>
                  {cgMap_PROJECTION, 'Miller Cylindrical', 118, 1 }, $  <span class="comments">; GCTP 118</span>
                  {cgMap_PROJECTION, 'Van der Grinten', 119, 1 }, $  <span class="comments">; GCTP 119</span>
                  {cgMap_PROJECTION, 'Hotine Oblique Mercator A', 120, 0 }, $ <span class="comments">; GCTP 120</span>
                  {cgMap_PROJECTION, 'Robinson', 121, 1 }, $ <span class="comments">; GCTP 121</span>
                  {cgMap_PROJECTION, 'Space Oblique Mercator A', 122, 0 }, $ <span class="comments">; GCTP 122</span>
                  {cgMap_PROJECTION, 'Alaska Conformal', 123, 0 }, $ <span class="comments">; GCTP 123</span>
                  {cgMap_PROJECTION, 'Interrupted Goode', 124, 1 }, $  <span class="comments">; GCTP 124</span>
                  {cgMap_PROJECTION, 'Mollweide', 125, 1 }, $ <span class="comments">; GCTP 125</span>
                  {cgMap_PROJECTION, 'Interrupted Mollweide', 126, 1 }, $ <span class="comments">; GCTP 126</span>
                  {cgMap_PROJECTION, 'Hammer', 127, 1 }, $  <span class="comments">; GCTP 127</span>
                  {cgMap_PROJECTION, 'Wagner IV', 128, 1 }, $ <span class="comments">; GCTP 128</span>
                  {cgMap_PROJECTION, 'Wagner VII', 129, 1 }, $ <span class="comments">; GCTP 129</span>
                  {cgMap_PROJECTION, 'Integerized Sinusoidal', 131, 1 }, $ <span class="comments">; GCTP 131</span>
                  {cgMap_PROJECTION, 'Equidistant Conic B', 208, 0 }, $ <span class="comments">; GCTP 208</span>
                  {cgMap_PROJECTION, 'Hotine Oblique Mercator B', 220, 0 }, $ <span class="comments">; GCTP 220</span>
                  {cgMap_PROJECTION, 'Space Oblique Mercator B', 222, 0 }] <span class="comments">; GCTP 222</span>
                  
    IF Float(!Version.Release) GE 8.0 THEN BEGIN
        projections = [projections, {cgMap_PROJECTION, 'Cylindrical Equal Area', 132, 0 }]
        
        <span class="comments">; Lambert Azimuthal now allows all ellipsoids.</span>
        index = Where(projections.name EQ 'Lambert Azimuthal', count)
        IF count GT 0 THEN projections[index].sphereOnly = 0
    ENDIF

    <span class="comments">; Find the map projection.</span>
    IF Size(map_projection, /TNAME) EQ 'STRING' THEN BEGIN
        index = Where(StrUpCase(projections.name[*]) EQ StrUpCase(map_projection))
        IF index[0] EQ -1 THEN Message, 'Cannot find map projection ' + map_projection + ' in the CGTP projection list.'
    ENDIF ELSE BEGIN
        index = Where(projections.index EQ map_projection, count)
        IF count EQ 0 THEN Message, 'Cannot find map projection index ' + StrTrim(map_projection,2) + ' in GCTP projection list.' 
    ENDELSE
    this_map_projection = projections[index]
    IF StrUpCase(this_map_projection.name) EQ StrUpCase('Mercator') THEN BEGIN
       IF N_Elements(limit) EQ 0 THEN limit = [-84.75, -180, 84.75, 180]
    ENDIF
   
   <span class="comments">; Find the datum.</span>
   theDatums = Replicate(datumStruct, 21)
   theDatums[0] =  { cgMap_DATUM,  0, 'Clark 1866', 6378206.4 , 6356583.8  }
   theDatums[1] =  { cgMap_DATUM,  1, 'Clark 1880', 6378249.145, 6356514.86955  }
   theDatums[2] =  { cgMap_DATUM,  2, 'Bessel', 6377397.155, 6356078.96284 }
   theDatums[3] =  { cgMap_DATUM,  3, 'International 1967', 6378157.5, 6356772.2 }
   theDatums[4] =  { cgMap_DATUM,  4, 'International 1909', 6378388.0, 6356911.94613  }
   theDatums[5] =  { cgMap_DATUM,  5, 'WGS 72', 6378135.0, 6356750.519915  }
   theDatums[6] =  { cgMap_DATUM,  6, 'Everst', 6377276.3452 , 6356075.4133 }
   theDatums[7] =  { cgMap_DATUM,  7, 'WGS 66', 6378145.0 , 6356759.769356  }
   theDatums[8] =  { cgMap_DATUM,  8, 'WGS 84', 6378137.0, 6356752.314245 }
   theDatums[9] =  { cgMap_DATUM,  9, 'Airy', 6377563.396, 6356256.91  }
   theDatums[10] = { cgMap_DATUM, 10, 'Modified Everest', 6377304.063, 6356103.039 }
   theDatums[11] = { cgMap_DATUM, 11, 'Modified Airy', 6377340.189, 6356034.448  }
   theDatums[12] = { cgMap_DATUM, 12, 'Walbeck', 6378137.0, 6356752.314245 }
   theDatums[13] = { cgMap_DATUM, 13, 'Southeast Asia', 6378155.0, 6356773.3205 }
   theDatums[14] = { cgMap_DATUM, 14, 'Australian National', 6378160.0, 6356774.719 }
   theDatums[15] = { cgMap_DATUM, 15, 'Krassovsky', 6378245.0, 6356863.0188 }
   theDatums[16] = { cgMap_DATUM, 16, 'Hough', 6378270.0 , 6356794.343479  }
   theDatums[17] = { cgMap_DATUM, 17, 'Mercury 1960', 6378166.0, 6356784.283666  }
   theDatums[18] = { cgMap_DATUM, 18, 'Modified Mercury 1968', 6378150.0, 6356768.337303 }
   theDatums[19] = { cgMap_DATUM, 19, 'Sphere', 6370997.0, 6370997.0 }
   theDatums[20] = { cgMap_DATUM,  8, 'GRS 1980', 6378137.0, 6356752.31414 }
   
   <span class="comments">; Since I already have "WGS 84" in the list, and since IDL 8 introduces an ellipsoid </span>
   <span class="comments">; with this name, I am going to use index 24 to list the more commonly used "WGS84" name.</span>
   IF Float(!Version.Release) GE 8.0 THEN BEGIN
      theDatums = [theDatums, $
                  { cgMap_DATUM, 20, 'Clarke IGN', 6378249.2, 6356515.0 }, $
                  { cgMap_DATUM, 21, 'Helmert 1906', 6378200.0, 6356818.2 }, $
                  { cgMap_DATUM, 22, 'Modified Fischer 1960', 6378115.0, 6356773.3 }, $
                  { cgMap_DATUM, 23, 'South American 1969', 6378160.0, 6356774.7 }, $
                  { cgMap_DATUM, 24, 'WGS84', 6378137.0, 6356752.314245 }]
       
   ENDIF
   
   <span class="comments">; Need a datum?</span>
   IF (N_Elements(datum) EQ 0) && (N_Elements(ellipsoid) EQ 0) THEN BEGIN
      IF this_map_projection.sphereOnly EQ 1 THEN datum = 19 ELSE datum = 0
   ENDIF
   IF (N_Elements(datum) EQ 0) && (N_Elements(ellipsoid) NE 0) THEN datum = ellipsoid
   IF N_Elements(datum) EQ 0 THEN BEGIN
        thisDatum = theDatums[19] 
   ENDIF ELSE BEGIN
        IF Size(datum, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase(theDatums.name) EQ StrUpCase(datum))
            
            <span class="comments">; If you can't find one, try compressing the names.</span>
            IF index[0] EQ -1 THEN BEGIN
               index = Where(StrCompress(StrUpCase(theDatums.name), /Remove_All) EQ $
                    StrCompress(StrUpCase(datum), /Remove_All))
            ENDIF
            
            <span class="comments">; Now if you can't find one, report it.</span>
            IF index[0] EQ -1 THEN Message, 'Cannot find datum ' + datum + ' in datum list.' 
            thisDatum = theDatums[index[0]]
        ENDIF ELSE thisDatum = theDatums[0 > datum &lt<span class="comments">; (N_Elements(theDatums)-1)]</span>
   ENDELSE
   
   <span class="comments">; There is a bug in all versions of IDL up to IDL 8.1 apparently that</span>
   <span class="comments">; produces the wrong result when a UTM projection is used in conjunction</span>
   <span class="comments">; with a WGS84 datum (the most common datum used in this projection). Here</span>
   <span class="comments">; we substitute the WALBECK datum, which is nearly identical to WGS84 are</span>
   <span class="comments">; results in position errors of less than a meter typically.</span>
   IF ((StrUpCase(thisDatum.Name) EQ 'WGS 84') || (StrUpCase(thisDatum.Name) EQ 'WGS84')) && $
      (StrUpCase(this_map_projection.Name) EQ 'UTM') && $
      (Float(!version.release) LT 8.2) THEN BEGIN
          Print, 'Switching UTM datum from WGS84 to WALBECK to avoid UTM projection bug.'
          thisDatum = { cgMAP_DATUM, 12, 'Walbeck', 6378137.0, 6356752.314245 }
   ENDIF
   
   <span class="comments">; Modify the radii?</span>
   IF N_Elements(sphere_radius) NE 0 THEN BEGIN
        semimajor_axis = sphere_radius
        semiminor_axis = sphere_radius
   ENDIF
   IF N_Elements(semimajor_axis) NE 0 THEN thisDatum.semimajor_axis = semimajor_axis
   IF N_Elements(semiminor_axis) NE 0 THEN thisDatum.semiminor_axis = semiminor_axis
   IF N_Elements(zone) EQ 0 THEN zone = cgUTMZone(center_longitude, center_latitude)
   
      <span class="comments">; Default MAP_PROJ_INIT keywords.</span>
   IF N_Elements(extraKeywords) NE 0 $
        THEN self._cg_map_projection_keywords = Ptr_New(extraKeywords) $
        ELSE self._cg_map_projection_keywords = Ptr_New(/ALLOCATE_HEAP)
   
   <span class="comments">; Are ISOTROPIC or ASPECT keywords used?</span>
   IF Keyword_Set(isotropic) THEN self._cg_isotropic = 1
   IF N_Elements(aspect) NE 0 THEN self._cg_aspect = aspect
   
   <span class="comments">; Load the object.</span>
   self._cg_background = background
   self._cg_center_latitude = center_latitude
   self._cg_center_longitude = center_longitude
   self._cg_color = color
   self._cg_erase = erase
   self._cg_multi_position = FltArr(4)
   self._cg_noborder = Keyword_Set(noborder)
   self._cg_noforwardfix = Keyword_Set(noforwardfix)
   self._cg_onimage = Keyword_Set(onimage)
   self._cg_radians = Keyword_Set(radians)
   self._cg_theDatums = Ptr_New(theDatums)
   self._cg_theProjections = Ptr_New(projections)
   self._cg_thisDatum = thisDatum
   self._cg_thisProjection = this_map_projection
   self._cg_title = title
   self._cg_zone = zone
   self._cg_overlays = Obj_New('cgContainer')
   
   <span class="comments">; Do you have a limit?</span>
   IF N_Elements(limit) NE 0 $
      THEN self._cg_limit = Ptr_New(Double(limit)) $
      ELSE self._cg_limit = Ptr_New(/ALLOCATE_HEAP)
   
   <span class="comments">; Get the map structure.</span>
   mapStruct = self -> SetMapProjection()
   
   <span class="comments">; Do you need to set the data ranges? If so, these should be set from</span>
   <span class="comments">; the UV_BOX of the map structure.</span>
   IF N_Elements(xrange) EQ 0 THEN BEGIN 
      xrange = mapStruct.uv_box[[0,2]]
      latlon_ranges = 0
   ENDIF
   IF N_Elements(yrange) EQ 0 THEN BEGIN 
      yrange = mapStruct.uv_box[[1,3]]
      latlon_ranges = 0
   ENDIF
         
   <span class="comments">; Are the ranges in lat/lon space?</span>
   IF Keyword_Set(latlon_ranges) THEN BEGIN
      uvcoords = self -> Forward(xrange, yrange)
      xrange = Reform(uvcoords[0,*])
      yrange = Reform(uvcoords[1,*])
   ENDIF
   
      <span class="comments">; Call the SUPERCLASS object INIT method.</span>
   ok = self -> cgCOORD::INIT ($
        POSITION=position, $
        XRANGE=xrange, $
        YRANGE=yrange, $
        XLOG=0, YLOG=0, $ <span class="comments">; No log axis on maps!</span>
        NAME=name, $
        UVALUE=uvalue)
        
   IF ~ok THEN RETURN, 0
   
   <span class="comments">; Do you need overlay objects in this map?</span>
   IF N_Elements(continents) NE 0 THEN BEGIN
   
       <span class="comments">; Is this a continental object? If so add it, if not</span>
       <span class="comments">; create one and add it.</span>
       IF Obj_Valid(continents) THEN BEGIN
           continents -> GetProperty, NAME=continentsName
           IF continentsName EQ "" THEN continentsName = 'MAPCONTINENTS'
           continents -> SetProperty, NAME=continentsName
           self._cg_overlays -> Add, continents
       ENDIF ELSE BEGIN
           continents = Obj_New('cgMapContinents', self, /COUNTRIES, $
               COLOR=cccolor, NAME='MAPCONTINENTS', HIRES=Keyword_Set(hires), $
               FILL=Keyword_Set(fill), LAND_COLOR=land_color)
           self._cg_overlays -> Add, continents
       ENDELSE
   ENDIF
   
   IF N_Elements(grid) NE 0 THEN BEGIN
   
       <span class="comments">; Is this a grid object? If so add it, if not</span>
       <span class="comments">; create one and add it.</span>
       IF Obj_Valid(grid) THEN BEGIN
           grid -> GetProperty, NAME=gridName
           IF gridName EQ "" THEN gridName = 'MAPGRID'
           grid -> SetProperty, NAME=gridName
           self._cg_overlays -> Add, grid
       ENDIF ELSE BEGIN
           grid = Obj_New('cgMapGrid', self, COLOR=gcolor, $
              NAME='MAPGRID', BOX_AXES=box_axes, BCOLOR=bcolor, LCOLOR=lcolor)
           self._cg_overlays -> Add, grid
       ENDELSE
   ENDIF
   
   <span class="comments">; Need to add this command to a resizeable cgWindow?</span>
   IF Keyword_Set(window) THEN self -> AddCmd, /REPLACE
   IF Keyword_Set(addcmd) THEN self -> AddCmd
   
   <span class="comments">; Need immediate draw?</span>
   IF Keyword_Set(draw) THEN self -> Draw
   
   RETURN, 1

END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Adds the object as a command (the DRAW method is called) in a cgWindow </span>
<span class="comments">;   resizeable graphics window. If there is no current cgWindow, one is</span>
<span class="comments">;   created.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     method: in, optional, type='string', default='draw'</span>
<span class="comments">;        The object method to add to the cgWindow.</span>
<span class="comments">;     replace: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, object DRAW method replaces any commands in the</span>
<span class="comments">;        current graphics window.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::AddCmd, REPLACE=replace, METHOD=method

   IF N_Elements(method) EQ 0 THEN method = 'DRAW'

   <span class="comments">; Which method are we adding?</span>
   currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
   
   <span class="comments">; Do we have a window to add it to?</span>
   IF wincnt EQ 0 THEN cgWindow
   
   <span class="comments">; Add (or replace) the command to the window.</span>
   IF Keyword_Set(replace) $
      THEN cgWindow, method, self, /Method, /ReplaceCmd $ <span class="comments">; Replace all commands in the window</span>
      ELSE cgWindow, method, self, /Method, /AddCmd       <span class="comments">; Add this command to the window.</span>
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Adds the an overlay object into the overlay container of the object.</span>
<span class="comments">;   Overlay objects are drawn (by calling their DRAW methods) after the</span>
<span class="comments">;   map coordinate space is set up in the DRAW method of the object. They</span>
<span class="comments">;   are drawn in the order they appear in the object.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    overlayObject: required, type=object</span>
<span class="comments">;       The object that will draw a graphic overlay in the map projection space</span>
<span class="comments">;       created by this map object. Typically, overlay objects contain map grid</span>
<span class="comments">;       lines (cgMapGrid object), continental outlines (cgMapContinents object), or </span>
<span class="comments">;       other types of graphical overlays. The only requirement of an overlay  </span>
<span class="comments">;       object is that is have a DRAW method and that it draw into a map </span>
<span class="comments">;       projection space. This may be an object array.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::AddOverlay, overLayObject

   <span class="comments">; Required parameter must be a valid object with a DRAW method.</span>
   IF N_Elements(overLayObject) EQ 0 THEN $
      Message, 'A map overlay object is a required parameter.'
   IF ~Obj_Valid(overLayObject) THEN Message, 'A valid overlay object is required.'
   IF Float(!Version.Release) GT 6.4 THEN BEGIN
        hasMethod = Call_Function('Obj_HasMethod', overLayObject, 'DRAW')
        IF ~hasMethod THEN Message, 'The overlay object must have a DRAW method.'
   ENDIF
   
   <span class="comments">; Add the object to the overlay container.</span>
   FOR j=0,N_Elements(overlayObject)-1 DO BEGIN
      self._cg_overlays -> Add, overLayObject   
   ENDFOR
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Advances the map projection position to the next position of a multiple</span>
<span class="comments">;   plot (using !P.MULTI). Does not need to be called directly, as the object</span>
<span class="comments">;   will call this method as needed.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to immediately call the draw method after the position</span>
<span class="comments">;        has been advanced.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::Advance, DRAW=draw

   IF Total(!P.Multi) NE 0 THEN BEGIN
   
          <span class="comments">; Draw the invisible plot to get plot position.</span>
          IF Size(self._cg_background, /TNAME) EQ 'STRING' $
             THEN background = cgColor(self._cg_background)$
             ELSE background = self._cg_background
          TVLCT, rr, gg, bb, /Get
          Plot, Findgen(11), XStyle=4, YStyle=4, /NoData<span class="comments">;, Background=background</span>
          TVLCT, rr, gg, bb
          
          <span class="comments">; Use position coordinates to indicate position in this set of coordinates.</span>
          <span class="comments">; New position based on !P.MULTI position.</span>
          position = [!x.window[0], !y.window[0], !x.window[1], !y.window[1]]
          self._cg_multi_position = position
          
   ENDIF ELSE self._cg_multi_position = FltArr(4)
   
   IF Keyword_Set(draw) THEN self -> Draw
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method sets up the map projection space of the object. Also, if map</span>
<span class="comments">;   borders or titles are required, they are drawn here. If the object contains</span>
<span class="comments">;   any overlay objects, they are also drawn at this time.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     erase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to erase contents of the map window for one time only</span>
<span class="comments">;        in this Draw method. It does NOT set the Erase parameter for the object.</span>
<span class="comments">;     nographics: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, no graphics are drawn, but the map data coordinate</span>
<span class="comments">;        system is set up.</span>
<span class="comments">;     </span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::Draw, ERASE=erase, NOGRAPHICS=nographics, _EXTRA=extra
 
    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
    ENDIF
    
    displayGraphics = 1 - Keyword_Set(nographics)
    
    <span class="comments">; If this is a graphics device, and there is no current graphics window,</span>
    <span class="comments">; then set the erase flag.</span>
    IF (!D.Name EQ 'WIN' || !D.Name EQ 'X') && (!D.Window LT 0) && displayGraphics THEN BEGIN
        erase = 1
    ENDIF
    
    <span class="comments">; Temporary erase?</span>
    IF N_Elements(erase) NE 0 THEN erase = Keyword_Set(erase)
    
    <span class="comments">; If you are doing multiple plots, then you have to update</span>
    <span class="comments">; your position.</span>
    IF Total(!P.Multi) GT 0 THEN BEGIN
        self -> Advance 
        position = self._cg_multi_position
        old_position = self._cg_position
        self -> SetProperty, POSITION=position
    ENDIF 
    
    <span class="comments">; Are you putting this on an image? If so, get the position from</span>
    <span class="comments">; the last image position in.</span>
    IF self._cg_onimage THEN BEGIN
        COMMON FSC_$CGIMAGE, _cgimage_xsize, _cgimage_ysize, $
                             _cgimage_winxsize, _cgimage_winysize, $
                             _cgimage_position, _cgimage_winID, $
                             _cgimage_current
        old_position = self._cg_position
        self -> SetProperty, POSITION=_cgimage_position
    ENDIF
    
    <span class="comments">; Did you set the isotropic keyword:</span>
    IF self._cg_isotropic THEN BEGIN
        self -> GetProperty, XRANGE=xr, YRANGE=yr
        self._cg_aspect = Double(Abs(yr[1]-yr[0]))/Abs(xr[1]-xr[0])
    ENDIF
    
    <span class="comments">; Do you need an aspect ratio?</span>
    IF (self._cg_aspect NE 0.0) AND (Total(!P.MULTI) LT 0) THEN BEGIN
        
      position = self._cg_position
       
      trial_position = Aspect(self._cg_aspect, margin=0.)
      trial_width = trial_position[2]-trial_position[0]
      trial_height = trial_position[3]-trial_position[1]
      pos_width = position[2]-position[0]
      pos_height = position[3]-position[1]
    
      <span class="comments">; Same logic as cgImage: try to fit image width, then if you can't get the right aspect</span>
      <span class="comments">; ratio, fit the image height instead.</span>
      fit_ratio = pos_width / trial_width
      IF trial_height * fit_ratio GT pos_height THEN $
      fit_ratio = pos_height / trial_height
    
      <span class="comments">; new width and height</span>
      trial_width *= fit_ratio
      trial_height *= fit_ratio
    
      <span class="comments">; calculate position vector based on trial_width and trial_height</span>
      position[0] += 0.5*(pos_width - trial_width)
      position[2] -= 0.5*(pos_width - trial_width)
      position[1] += 0.5*(pos_height - trial_height)
      position[3] -= 0.5*(pos_height - trial_height)
            
    ENDIF ELSE position = self._cg_position
    
    <span class="comments">; Do you need to erase in the background color? Don't do this if you</span>
    <span class="comments">; are just drawing the coordinate system.</span>
    IF ~Keyword_Set(nographics) THEN BEGIN
        IF N_Elements(erase) EQ 0 THEN erase = self._cg_erase
        p = position
        IF erase THEN cgColorFill, [p[0],p[0],p[2],p[2],p[0]], NORMAL=1, $
                                   [p[1],p[3],p[3],p[1],p[1]], COLOR=self._cg_background
    ENDIF
    
   <span class="comments">; Draw the map data coordinate system.</span>
    mapStruct = self -> SetMapProjection()
    temp_position = self._cg_position
    self._cg_position = position
    self -> cgCoord::Draw, _EXTRA=extra
    self._cg_position = temp_position
    
    <span class="comments">; Draw overlays?</span>
    count = self._cg_overlays -> Count()
    IF (count GT 0) && displayGraphics THEN BEGIN
    
        <span class="comments">; Get the overlay objects out of the overlay container.</span>
        FOR j=0,count-1 DO BEGIN
            thisOverlay = self._cg_overlays -> Get(POSITION=j)
            IF Obj_Valid(thisOverlay) THEN thisOverlay -> Draw
        ENDFOR
    ENDIF
    
    <span class="comments">; Draw a border around the map?</span>
    IF ~Keyword_Set(self._cg_noborder) && displayGraphics THEN BEGIN
        p = position
        cgPlots, [p[0],p[0],p[2],p[2],p[0]], [p[1],p[3],p[3],p[1],p[1]], $
            /NORMAL, COLOR=self._cg_color
    ENDIF
    
    <span class="comments">; Draw a title?</span>
    IF (self._cg_title NE "") && displayGraphics THEN BEGIN
       p = position
       px = (p[2]-p[0])/2.0 + p[0]
       py = (p[3] + 0.05) &lt<span class="comments">; 0.975</span>
       cgText, px, py, /Normal, Alignment=0.5, self._cg_title, Charsize=cgDefCharsize()*1.25
    ENDIF
    
    <span class="comments">; If you changed the position for some reason, put it back.</span>
    IF N_Elements(old_position) NE 0 THEN self -> SetProperty, POSITION=old_position
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method erases the graphics window.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     color: in, optional, type=string, default='white'</span>
<span class="comments">;        The color used in the erasing of the display.</span>
<span class="comments">;     </span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::Erase, COLOR=color
 
    cgErase, COLOR=color
    
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method transforms latitude and longitude values into projected</span>
<span class="comments">;   XY Cartesian values. This is known as the forward map transformation.</span>
<span class="comments">;   </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The projected XY coordinates are returned in a 2xN array. The first</span>
<span class="comments">;    column contains the projected X values and the second column contains</span>
<span class="comments">;    the projected Y values.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;     lons: in, required</span>
<span class="comments">;         The longitude values to transform. May be a scalar or an array.</span>
<span class="comments">;     lats: in, required</span>
<span class="comments">;         The latitude values to transform. May be a scalar or an array.</span>
<span class="comments">;     mapStruct: in, optional, type=structure</span>
<span class="comments">;         The map structure to use in doing the forward transformation. If</span>
<span class="comments">;         not provided, the map structure is obtained from the object itself.</span>
<span class="comments">;         </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     noforwardfix: in, optional, type=boolean, default=0</span>
<span class="comments">;         I may be wrong about the fix I put in when the longitude values</span>
<span class="comments">;         are the same. If so, setting this keyword will avoid the fix.</span>
<span class="comments">;         The default value is the default for the object.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::Forward, lons, lats, mapStruct, NOFORWARDFIX=noForwardFix

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, -1
    ENDIF
    
    
    IF N_Elements(lons) EQ 0 THEN Message, 'Longitude values are required.'
    IF N_Elements(lats) EQ 0 THEN Message, 'Latitude values are required.'
    IF N_Elements(noforwardfix) EQ 0 $
        THEN noforwardfix = self._cg_noForwardFix $
        ELSE noforwardfix = Keyword_Set(noforwardfix)
    
    <span class="comments">; Forward map transformation.</span>
    IF N_Elements(mapStruct) EQ 0 THEN mapStruct = self->GetMapStruct()
    xycoords = Map_Proj_Forward(lons, lats, MAP_STRUCTURE=mapStruct)
    
    <span class="comments">; Check to see if longitude range values are identical. If so, then fix. This is, I believe,</span>
    <span class="comments">; a bug in IDL code, but I can't get the IDL support engineers to believe it.</span>
    IF ~Keyword_Set(noforwardfix) THEN BEGIN
        xr = Reform(xycoords[0,*])
        n = N_Elements(xr)
        IF (Floats_Equal(xr[0], xr[n-1], ULP=8)) && N_Elements(xr) GT 1 THEN BEGIN
           IF xr[0] GT 0 THEN xycoords[0,0] = -xr[n-1] ELSE xycoords[0,n-1] = Abs(xr[0])
        ENDIF
    ENDIF
    
    RETURN, xycoords
END 



<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method returns a 1 if the map projection is a cylindrical projection</span>
<span class="comments">;   and a 0 otherwise.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::Is_Cylindrical

    CASE (self._cg_thisProjection).index OF
       100: retval = 1 <span class="comments">; Geographic</span>
       105: retval = 1 <span class="comments">; Mercator</span>
       109: retval = 1 <span class="comments">; Transvere Mercator</span>
       116: retval = 1 <span class="comments">; Sinusoidal</span>
       117: retval = 1 <span class="comments">; Equirectangular</span>
       118: retval = 1 <span class="comments">; Miller Cylindrical</span>
       121: retval = 1 <span class="comments">; Robinson</span>
       125: retval = 1 <span class="comments">; Mollweide</span>
       126: retval = 1 <span class="comments">; Interrupted Mollweide</span>
       127: retval = 1 <span class="comments">; Hammer-Aitoff</span>
       128: retval = 1 <span class="comments">; Wagner IV</span>
       129: retval = 1 <span class="comments">; Wagner VII</span>
       132: retval = 1 <span class="comments">; Cylindrical Equal Area</span>
       ELSE: retval = 0
    ENDCASE
    
    RETURN, retval
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method returns a map structure that is the result of calling Map_Proj_Init.</span>
<span class="comments">;   It is important to get a fresh map structure because up until IDL 8, the map</span>
<span class="comments">;   structure was ephemeral (http://www.idlcoyote.com/map_tips/ephemeral.php).</span>
<span class="comments">;   Every time this function is called, a new map structure is created.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::GetMapStruct
    RETURN, self -> SetMapProjection()
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method allows the user to get various properties of the object. In general,</span>
<span class="comments">;   the same keywords that are used for the INIT method can be used here. Here</span>
<span class="comments">;   are a few that are different.</span>
<span class="comments">;   </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     boundary: out, optional, type=array</span>
<span class="comments">;        A four-element array giving the boundaries of the image in the form</span>
<span class="comments">;        [x0,y0,x1,y1]. This is a more convenient way of expressing the range</span>
<span class="comments">;        of the map space.</span>
<span class="comments">;     latlonbox: out, optional, type=array</span>
<span class="comments">;        A four-element array giving the boundaries of the map projection in the</span>
<span class="comments">;        Google Map form of [north, south, east, west]. This is useful when you</span>
<span class="comments">;        are creating image overlays to be added to Google Earth.</span>
<span class="comments">;     overlays: out, optional, type=object</span>
<span class="comments">;        Set this keyword to a named variable that will return an object</span>
<span class="comments">;        array containing the overlay objects in the map object.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::GetProperty, $
    BACKGROUND=background, $
    BCOLOR=bcolor, $
    BOUNDARY=boundary, $
    CENTER_LATITUDE=center_latitude, $
    CENTER_LONGITUDE=center_longitude, $
    COLOR=color, $
    DATUM=datum, $
    DRAW=draw, $
    EASTING=easting, $
    ELLIPSOID=ellipsoid, $
    ERASE=erase, $
    HIRES=hires, $
    LATLONBOX=latlonbox, $
    LIMIT=limit, $
    MAP_PROJECTION=map_projection, $
    NAME=name, $
    NOBORDER=noborder, $
    NOFORWARDFIX=noforwardfix, $
    NORTHING=northing, $
    ONIMAGE=onimage, $
    OVERLAYS=overlays, $
    POSITION=position, $
    RADIANS=radians, $
    SEMIMAJOR_AXIS=semimajor_axis, $
    SEMIMINOR_AXIS=semiminor_axis, $
    SPHERE_RADIUS=sphere_radius, $
    TITLE=title, $
    XRANGE=xrange, $
    YRANGE=yrange, $
    UVALUE=uvalue, $
    ZONE=zone, $
    _REF_EXTRA=extraKeywords

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
    ENDIF
   
   <span class="comments">; Make sure the map structure is up to date by always calculating it in real-time.</span>
   mapStruct = self -> SetMapProjection() 
   
   IF Arg_Present(overlays) THEN overlays = self._cg_draw_overlays -> Get(/ALL)
   position = self._cg_position
   IF Arg_Present(xrange) THEN BEGIN
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            xrange = Reform(llcoords[0,*])
      ENDIF ELSE xrange = self._cg_xrange
   ENDIF
   IF Arg_Present(yrange) THEN BEGIN
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            yrange = Reform(llcoords[1,*])
      ENDIF ELSE yrange = self._cg_yrange
   ENDIF
   
   <span class="comments">; The boundary is just the XRANGE and YRANGE in another form.</span>
   IF Arg_Present(boundary) THEN BEGIN
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            xrange = Reform(llcoords[0,*])
      ENDIF ELSE xrange = self._cg_xrange
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            yrange = Reform(llcoords[1,*])
      ENDIF ELSE yrange = self._cg_yrange
      boundary = [xrange[0], yrange[0], xrange[1], yrange[1]]
   ENDIF
   
   <span class="comments">; The latlonbox is just the XRANGE and YRANGE in a form Google Earth prefers </span>
   <span class="comments">; [north, south, east, west] in degrees.</span>
   IF Arg_Present(latlonbox) THEN BEGIN
      latlon_ranges = 1
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            xrange = Reform(llcoords[0,*])
      ENDIF ELSE xrange = self._cg_xrange
      IF Keyword_Set(latlon_ranges) THEN BEGIN
            llcoords = Map_Proj_Inverse(self._cg_xrange, self._cg_yrange, MAP_STRUCTURE=mapStruct)
            yrange = Reform(llcoords[1,*])
      ENDIF ELSE yrange = self._cg_yrange
      latlonbox = [ yrange[1], yrange[0], xrange[0], xrange[1] ]
   ENDIF
   
   <span class="comments">; Other keywords.</span>
   background = self._cg_background
   color = self._cg_color
   center_latitude = self._cg_center_latitude
   center_longitude = self._cg_center_longitude
   easting = self._cg_easting
   erase = self._cg_erase
   IF N_Elements(*self._cg_limit) NE 0 THEN limit = *self._cg_limit
   noborder = self._cg_noborder
   noforwardfix = self._cg_noforwardfix
   northing = self._cg_northing
   map_projection = self._cg_thisProjection.name
   IF Arg_Present(map_proj_keywords) THEN BEGIN
        IF Ptr_Valid(self._cg_map_projection_keywords) THEN BEGIN
            IF N_Elements(*self._cg_map_projection_keywords) NE 0 THEN $
                map_proj_keywords = *self._cg_map_projection_keywords
        ENDIF
   ENDIF
   datum = self._cg_thisDatum.name
   ellipsoid = self._cg_thisDatum.name
   radians = self._cg_radians
   sphere_radius = self._cg_thisDatum.semimajor_axis
   semimajor_axis = self._cg_thisDatum.semimajor_axis
   semiminor_axis = self._cg_thisDatum.semiminor_axis
   zone = self._cg_zone
   
   <span class="comments">; If asked for the GRID, see if you can find an object with the name MAPGRID</span>
   <span class="comments">; in the overlay container. If you can, return it.</span>
   IF Arg_Present(grid) THEN BEGIN
       gridPos = self._cg_overlays -> FindByName('MAPGRID', COUNT=count)
       IF count GT 0 THEN grid = self._cg_overlays -> Get(POSITION=gridPos)
   ENDIF
   
   <span class="comments">; Superclass keywords.</span>
   IF (N_ELEMENTS(extraKeywords) GT 0) THEN $
       self -> cgCOORD::GetProperty, _EXTRA=extraKeywords

END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method transforms X and Y projected Cartesian map coordinates into</span>
<span class="comments">;   longitude and latitude values. This is known as the inverse map transformation.</span>
<span class="comments">;   </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The projected lon/lat coordinates are returned in a 2xN array. The first</span>
<span class="comments">;    column contains the longitude values and the second column contains</span>
<span class="comments">;    the latitude values.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;     x: in, required</span>
<span class="comments">;         The projected X values to transform. May be a scalar or an array.</span>
<span class="comments">;     y: in, required</span>
<span class="comments">;         The projected Y values to transform. May be a scalar or an array.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::Inverse, x, y
    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, -1
    ENDIF
    
    
    IF N_Params() NE 2 THEN Message, 'Both longitude and latitude values are required.'
    IF N_Elements(x) EQ 0 THEN Message, 'Projected X values are required.'
    IF N_Elements(y) EQ 0 THEN Message, 'Projected Y values are required.'
    
    <span class="comments">; Inverse map transformation.</span>
    lonlat = Map_Proj_Inverse(x, y, MAP_STRUCTURE=self->GetMapStruct())
    
    RETURN, lonlat
END 



<span class="comments">;--------------------------------------------------------------------------</span>
<span class="comments">;   This method uses the data ranges to calculate appropriate latitude and</span>
<span class="comments">;   longitude lines to be drawn through the map projection. Vectors of </span>
<span class="comments">;   latitudes and longitudes, as well as latitute and longitude names is</span>
<span class="comments">;   created.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     latdelta: in, optional, type=float</span>
<span class="comments">;        The degree spacing in latitude between latitude lines.</span>
<span class="comments">;     latlab: out, optional, type=float</span>
<span class="comments">;        The suggested location for the latitude labels.</span>
<span class="comments">;     latnames: out, optional, type=string</span>
<span class="comments">;        The vector of latitude names associated with the `lats` vector.</span>
<span class="comments">;     lats: out, optional, type=float</span>
<span class="comments">;        A vector of latitude values that describe latitude lines traversing</span>
<span class="comments">;        the data range.</span>
<span class="comments">;     londelta: in, optional, type=float</span>
<span class="comments">;        The degree spacing in longitude between longitude lines.</span>
<span class="comments">;     lonlab: out, optional, type=float</span>
<span class="comments">;        The suggested location for the longitude labels.</span>
<span class="comments">;     lonnames: out, optional, type=string</span>
<span class="comments">;        The vector of longitude names associated with the `lons` vector.</span>
<span class="comments">;     lons: out, optional, type=float</span>
<span class="comments">;        A vector of longitude values that describe longitude lines traversing</span>
<span class="comments">;        the data range.</span>
<span class="comments">;     success: out, optional, type=boolean</span>
<span class="comments">;        Will be set to 1 on return, if the operation was successful. Otherwise,</span>
<span class="comments">;        this value is set to 0.</span>
<span class="comments">;--------------------------------------------------------------------------</span>
PRO cgMap::LatLonLabels, $
    LATDELTA=latdelta, $
    LATLAB=latlab, $
    LATNAMES=latnames, $
    LATS=lats, $
    LONDELTA=londelta, $
    LONLAB=lonlab, $
    LONNAMES=lonnames, $
    LONS=lons, $
    SUCCESS=success

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        success = 0
        RETURN
    ENDIF
    
    <span class="comments">; Assume success.</span>
    success = 1
    
    <span class="comments">; The longitudes might be calculated from the results of the latitude calculation.</span>
    <span class="comments">; If they are, this flag will be set to 1.</span>
    lonsdone = 0
    latsdone = 0
    
    <span class="comments">; Get the ranges of the map coordinate object.</span>
    self -> GetProperty, XRANGE=xrange, YRANGE=yrange

    <span class="comments">; Sample XY grid at 625 locations throughout the grid (25x25).</span>
    xstep = (xrange[1] - xrange[0]) / 24.0
    ystep = (yrange[1] - yrange[0]) / 24.0
    xvec = (Findgen(25) * xstep) + xrange[0]
    yvec = (Findgen(25) * ystep) + yrange[0]
    xarr = Rebin(xvec, 25, 25)
    yarr = Rebin(Reform(Reverse(yvec), 1, 25), 25, 25)
    
    <span class="comments">; Find the latitude/longitude of these locations. Find the min, max,</span>
    <span class="comments">; and lat/lon at the center of the grid.</span>
    ll = Map_Proj_Inverse(xarr, yarr, MAP_STRUCTURE=self->GetMapStruct())
    latlon = Reform(ll, 2, 25, 25)
    latlon = Transpose(latlon, [1,2,0])
    latitudes = latlon[*,*,1]
    longitudes = latlon[*,*,0]

    <span class="comments">; Convert the longitudes to 0 to 360. Otherwise, I have</span>
    <span class="comments">; problems near the date line.</span>
    longitudes = (longitudes + 360.0) MOD 360.0
    
    lon_min = Min(longitudes, MAX=lon_max, /NAN)
    lat_min = Min(latitudes, MAX=lat_max, /NAN)
    center_lat = latitudes[12,12]
    center_lon = longitudes[12,12]
    
    <span class="comments">; We are going to try to have seven lines running through the grid space.</span>
    <span class="comments">; We will have special rules if the center latitude is at the pole.</span>
    latrange = Abs(lat_max - lat_min)
    IF latrange GT 90.0 THEN BEGIN
        IF N_Elements(latdelta) NE 0 THEN BEGIN
            num = 180 / Fix(latdelta)
            lats = -90 > Findgen(num) * latDelta -90.0 &lt<span class="comments">; 90.0</span>
            latsdone = 1
        ENDIF ELSE BEGIN
           lats = -90.0 > (Findgen(7) * 30 - 90.0) &lt<span class="comments">; 90.0</span>
           latsdone = 1
        ENDELSE
    ENDIF
    IF N_Elements(latDelta) EQ 0 THEN latstep =  latrange / 6.0 ELSE latStep = latDelta
    
    lonrange = Abs(lon_max - lon_min)
    IF lonrange GT 180.0 THEN BEGIN
        IF N_Elements(londelta) NE 0 THEN BEGIN
            num = 360 / Fix(londelta)
            lons = 0.0  > Findgen(num) * lonDelta   &lt<span class="comments">; 360.0</span>
            lonsdone = 1
        ENDIF ELSE BEGIN
           lons = 0 > (Findgen(9) * 45 ) &lt<span class="comments">; 360.0</span>
           lonsdone = 1
        ENDELSE
    ENDIF
    IF N_Elements(lonDelta) EQ 0 THEN lonstep =  (lonrange)/ 6.0 ELSE lonstep = lonDelta
    
    <span class="comments">; Make sure we don't have a center latitude at either pole. If we</span>
    <span class="comments">; do, then lons are calulated differently.</span>
    IF (center_lat GT (90.-0.05)) && (center_lat LT (90.0 + 0.05)) THEN BEGIN
       lats = cgScaleVector(Findgen(5), 0 > Round(lat_min) &lt<span class="comments">; 80, 80) </span>
       latsdone = 1 
       IF lonstep GT 40 THEN BEGIN
          lons = Findgen(11) * 36 
          lonsDone = 1
       ENDIF      
    ENDIF ELSE BEGIN
       IF (center_lat LT (-90.+0.05)) && (center_lat GT (-90.0 - 0.05)) THEN BEGIN
           lats = cgScaleVector(Findgen(5), -80, 0 &lt<span class="comments">; Round(lat_max))  </span>
           latsdone = 1    
           IF lonstep GT 40 THEN BEGIN
              lons = Findgen(11) * 36 
              lonsDone = 1
           ENDIF 
       ENDIF    
    ENDELSE
    
    IF latsdone EQ 0 THEN BEGIN
       CASE 1 OF
       
           (latstep GE 30): BEGIN
                latstep = 30
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 10) && (latstep LT 60): BEGIN
                latstep = Ceil(latstep/10.) * 10.0
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 1) && (latstep LT 10): BEGIN
                latstep = Ceil(latstep)
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 0.1) && (latstep LT 1): BEGIN
                latstep = Ceil(latstep*10.0)/ 10.
                center_lat = Round(center_lat*10.0) / 10.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 0.01) && (latstep LT 0.1): BEGIN
                latstep = Ceil(latstep*100.0)/ 100.
                center_lat = Round(center_lat*100.0) / 100.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep LT 0.01) : BEGIN
                latstep = Ceil(latstep*1000.0)/ 1000.
                center_lat = Round(center_lat*1000.0) / 1000.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           ELSE: BEGIN
                latstep = 30
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
       ENDCASE
    ENDIF
    
    IF lonsDone EQ 0 THEN BEGIN
       CASE 1 OF
       
           (lonstep GE 60): BEGIN
                lonstep = 60
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(3)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(3)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 10) && (lonstep LT 60): BEGIN
                lonstep = Ceil(lonstep/10.) * 10.0
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 1) && (lonstep LT 10): BEGIN
                lonstep = Ceil(lonstep)
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 0.1) && (lonstep LT 1): BEGIN
                lonstep = Ceil(lonstep*10.0)/ 10.
                center_lon = Round(center_lon*10.0) / 10.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 0.01) && (lonstep LT 0.1): BEGIN
                lonstep = Ceil(lonstep*100.0)/ 100.
                center_lon = Round(center_lon*100.0) / 100.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep LT 0.01) : BEGIN
                lonstep = Ceil(lonstep*1000.0)/ 1000.
                center_lon = Round(center_lon*1000.0) / 1000.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           ELSE: BEGIN
                lonstep = 30
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
       ENDCASE
     ENDIF
        
    <span class="comments">; The values might need to be sorted.</span>
    lats = lats[Sort(lats)]
    lons = lons[Sort(lons)]
    lons = lons - (LONG(lons )/180)*360.0
    
    <span class="comments">; Labels should be near the center.</span>
    index = N_Elements(lons) / 2
    latlab = (lons[index] - lons[index-1]) / 2.0 + lons[index-1]
    index = N_Elements(lats) / 2 
    lonlab = (lats[index] - lats[index-1]) / 2.0 + lats[index-1]

    <span class="comments">; Set up the latitude and longitude names.</span>
    IF Total(lats-Long(lats)) EQ 0 THEN format='(I0)' ELSE format='(F0.2)'
    latnames = String(lats, FORMAT=format)
    IF Total(lons-Long(lons)) EQ 0 THEN format='(I0)' ELSE format='(F0.2)'
    lonnames = String(lons, FORMAT=format)
    
 END


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method returns information about the current map projection in an </span>
<span class="comments">;   IDL structure variable. Fields of the structure will reflect</span>
<span class="comments">;   values that are used in MAP_PROJ_INIT to create a map structure.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::MapInfo

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, -1
    ENDIF
   
   map_keywords = Create_Struct( $
       'projection', self._cg_thisProjection.name, $
       'datum', self._cg_thisDatum.name, $
       'gctp', 1, $
       'center_latitude', self._cg_center_latitude, $
       'center_longitude', self._cg_center_longitude )
   IF N_Elements(*self._cg_limit) NE 0 THEN map_keywords = Create_Struct(map_keywords, 'limit', *self._cg_limit)
   IF self._cg_thisProjection.sphereOnly THEN BEGIN
       map_keywords = Create_Struct(map_keywords, 'sphere_radius', self._cg_thisDatum.semimajor_axis)
   ENDIF ELSE BEGIN
       map_keywords = Create_Struct(map_keywords, $
            'semimajor_axis', self._cg_thisDatum.semimajor_axis, $
            'semiminor_axis', self._cg_thisDatum.semiminor_axis)        
   ENDELSE
   IF N_Elements(*self._cg_map_projection_keywords) NE 0 THEN BEGIN
        keywords = *self._cg_map_projection_keywords
        fields = Tag_Names(keywords)
        FOR j=0,N_Elements(fields)-1 DO BEGIN
           map_keywords = Create_Struct(map_keywords, fields[j], keywords.(j))
        ENDFOR
   ENDIF  
   
   <span class="comments">; Add other important information.</span>
   map_keywords = Create_Struct(map_keywords, $
      'x_tie_point_projected_xy_upper_left', self._cg_xrange[0], $
      'y_tie_point_projected_xy_upper_left', self._cg_yrange[1], $      
      'xrange',  self._cg_xrange, 'yrange', self._cg_yrange, $
      'position', self._cg_position, 'map_title', self._cg_title)
      
   IF StrUpCase(self._cg_thisProjection.name) EQ 'UTM' THEN BEGIN
       map_keywords = Create_Struct(map_keywords, 'zone', self._cg_zone)
   ENDIF
 
   RETURN, map_keywords
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method allows the user to set various properties of the object. In general,</span>
<span class="comments">;   the same keywords that are used for the INIT method can be used here.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     background: in, optional, type=string, default='white'</span>
<span class="comments">;        The name of the background color. Used only if the map object erases</span>
<span class="comments">;        the display when it draws its contents.</span>
<span class="comments">;     bcolor: optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the color to draw box axes with. Requires BOX_AXES be set.</span>
<span class="comments">;     box_axes: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw a box-style grid axes around the map. Applies</span>
<span class="comments">;        only if creating a mapGrid object.</span>
<span class="comments">;     center_latitude: in, optional, type=float, default=varies</span>
<span class="comments">;        The center latitude of the map projection.</span>
<span class="comments">;     center_longitude: in, optional, type=float, default=varies</span>
<span class="comments">;        The center longitude of the map projection.</span>
<span class="comments">;     ccolor: in, optional, type=string, default='charcoal'</span>
<span class="comments">;        The name of the drawing color for the MapContinents object if this is requested.</span>
<span class="comments">;     color: in, optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the drawing color for the object. Passed along to the mapGrid</span>
<span class="comments">;        and MapContinents object if these are requested.</span>
<span class="comments">;     continents: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to create an overlay object of continental outlines</span>
<span class="comments">;        that will be rendered when the draw method is called.</span>
<span class="comments">;     datum: in, optional, type=string/integer, default='Sphere'</span>
<span class="comments">;        This keyword is being depreciated in favor of the keyword ELLIPSOID,</span>
<span class="comments">;        corresponding to changes to Map_Proj_Init initiated in IDL 7.</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to immediately call the DRAW method after the</span>
<span class="comments">;        object has been completely initialized.</span>
<span class="comments">;     ellipsoid: in, optional, type=string/integer, default='Sphere'</span>
<span class="comments">;        Set this to the name or index number of the ellopsoid or datum you wish to use</span>
<span class="comments">;        for the map projection. The value is passed directly to Map_Proj_Init.</span>
<span class="comments">;     erase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to have the object erase the current graphics display</span>
<span class="comments">;        before drawing its content in the DRAW method. The graphics display will be erased</span>
<span class="comments">;        in the background color.</span>
<span class="comments">;     gcolor: in, optional, type=string, default='gray'</span>
<span class="comments">;        The name of the drawing color for the MapGrid object if this is requested.</span>
<span class="comments">;     grid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to create an overlay object of map grid lines</span>
<span class="comments">;        that will be rendered when the draw method is called.</span>
<span class="comments">;     hires: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to use high resolution continental outlines.</span>
<span class="comments">;        Passed to the MapContinents object if one is requested.</span>
<span class="comments">;     latlon_ranges: in, optional, type=boolean, default=0</span>
<span class="comments">;        Normally the XRANGE and YRANGE keywords are set in terms of projected meters. If </span>
<span class="comments">;        this keyword is set, then the values of XRANGE and YRANGE are assumed to be in longitude</span>
<span class="comments">;        and latitude values, respectively, and will be converted to projected meters prior to </span>
<span class="comments">;        being stored in the object.</span>
<span class="comments">;     limit: in, optional, type=FltArr(4), default=none</span>
<span class="comments">;        The normal LIMIT keyword to Map_Proj_Init, specifying the limit of the map</span>
<span class="comments">;        projection in terms of latitude and longitude. Normally, little used when using</span>
<span class="comments">;        Map_Proj_Init. Most work is done by specifying the projected XY rectangular</span>
<span class="comments">;        coordinate system with the keywords XRANGE and YRANGE.</span>
<span class="comments">;     lcolor: in, optional, type=string</span>
<span class="comments">;        Set this to the name of the label color to use in labeling grid lines.</span>
<span class="comments">;        By default, the same as COLOR, or if BOX_AXIS is set, then same as BCOLOR.</span>
<span class="comments">;     map_projection, in, optional, type=varies</span>
<span class="comments">;        The name or index number of a GCTP map projection to use.</span>
<span class="comments">;     name: in, optional, type=string, default=selected by cgContainer.</span>
<span class="comments">;        Use this keyword to name the object. Names are often used to select objects in </span>
<span class="comments">;        program code. </span>
<span class="comments">;     noborder: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the customary border than surrounds the map projection is</span>
<span class="comments">;        not drawn.</span>
<span class="comments">;     noforwardfix: in, optional, type=boolean, default=0</span>
<span class="comments">;        There is, I believe, a bug in MAP_PROJ_FORWARD that renders longitude values </span>
<span class="comments">;        incorrectly in projected meter space. This is evidenced by MAP_GRID not producing</span>
<span class="comments">;        the correct longitude lines in map coordinate systems set up in projected XY meters.</span>
<span class="comments">;        In the FORWARD method I correct for this. But, this correction is not always needed</span>
<span class="comments">;        or wanted. This property of the object allows me to turn that correction on or off,</span>
<span class="comments">;        as needed. Normally, the fix is provided, unless this keyword is set to 1.</span>
<span class="comments">;     onimage: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the position of the map projection in the graphics window</span>
<span class="comments">;        is obtained from the last image displayed with cgImage. This makes it extremely</span>
<span class="comments">;        easy to display an image and immediately set up a map projection space that will</span>
<span class="comments">;        allow you to annotate the image using map locations.</span>
<span class="comments">;     position: in, optional, type=FltArr(4)</span>
<span class="comments">;        The normalized position of the map projection space in the graphics window.</span>
<span class="comments">;        The default value is [0.075, 0.075, 0.925, 0.900].</span>
<span class="comments">;     radians: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to indicate latitude and longitude values are in radians rather </span>
<span class="comments">;        than degrees.</span>
<span class="comments">;     semimajor_axis: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the semimajor axis of the ellipsoid in meters. Normally calculated</span>
<span class="comments">;        from the ELLIPSOID keyword values.</span>
<span class="comments">;     semiminor_axis: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the semiminor axis of the ellipsoid in meters. Normally calculated</span>
<span class="comments">;        from the ELLIPSOID keyword values.</span>
<span class="comments">;     sphere_radius: in, optional, type=double, default=varies</span>
<span class="comments">;        The length of the ellipsoidal sphere in meters. Normally calculated from the </span>
<span class="comments">;        ELLIPSOID keyword values.</span>
<span class="comments">;     title: in, optional, type=string, default=""</span>
<span class="comments">;        The title of the map projection display.</span>
<span class="comments">;     uvalue: in, optional, type=any, default=none</span>
<span class="comments">;        A storage space for storing any kind of IDL variable of importance to the user.</span>
<span class="comments">;     xrange: in, optional, type=various</span>
<span class="comments">;        Set this keyword to the X axis range desired in the data coordinate system.</span>
<span class="comments">;        Normally expressed in XY projected meter space, unless the LATLON_RANGES </span>
<span class="comments">;        keyword is set. The default is mapStruct.uv_box[[0,2]].</span>
<span class="comments">;     yrange: in, optional, type=various</span>
<span class="comments">;         Set this keyword to the X axis range desired in the data coordinate system.</span>
<span class="comments">;         Normally expressed in XY projected meter space, unless the LATLON_RANGES </span>
<span class="comments">;         keyword is set. The default is mapStruct.uv_box[[1,3]]</span>
<span class="comments">;     zone: in, optional, type=integer, default=varies</span>
<span class="comments">;         The zone (normally in UTM projections) of the map projection. If not given and needed,</span>
<span class="comments">;         calculated from the CENTER_LATITUDE and CENTER_LONGITUDE keyword values.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::SetProperty, $
    BACKGROUND=background, $
    BCOLOR=bcolor, $
    BOX_AXES=box_axes, $
    CCOLOR=ccolor, $
    CENTER_LATITUDE=center_latitude, $
    CENTER_LONGITUDE=center_longitude, $
    COLOR=color, $
    CONTINENTS=continents, $
    DATUM=datum, $
    DRAW=draw, $
    EASTING=easting, $
    ELLIPSOID=ellipsoid, $
    ERASE=erase, $
    GCOLOR=gcolor, $
    GRID=grid, $
    HIRES=hires, $
    LATLON_RANGES=latlon_ranges, $
    LCOLOR=lcolor, $
    LIMIT=limit, $
    MAP_PROJECTION=map_projection, $
    NAME=name, $
    NOBORDER=noborder, $
    NOFORWARDFIX=noForwardFix, $
    NORTHING=northing, $
    ONIMAGE=onimage, $
    POSITION=position, $
    RADIANS=radians, $
    SEMIMAJOR_AXIS=semimajor_axis, $
    SEMIMINOR_AXIS=semiminor_axis, $
    SPHERE_RADIUS=sphere_radius, $
    TITLE=title, $
    XRANGE=xrange, $
    YRANGE=yrange, $
    UVALUE=uvalue, $
    ZONE=zone, $
    _EXTRA=extraKeywords
    
    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
    ENDIF
      
   <span class="comments">; Are we changing the map projection?</span>
   IF N_Elements(map_projection) NE 0 THEN BEGIN
        projections = *self._cg_theProjections
        IF Size(map_projection, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase(projections.name[*]) EQ StrUpCase(map_projection))
            IF index[0] EQ -1 THEN Message, 'Cannot find map projection ' + map_projection + ' in the projection list.'
        ENDIF
        IF (N_Elements(index) EQ 0) THEN BEGIN
            index = Where(projections.index EQ map_projection, count)
            IF count EQ 0 THEN Message, 'Cannot find map projection index ' + StrTrim(map_projection,2) + ' in projection list.' 
        ENDIF
        self._cg_thisProjection = projections[index]
   ENDIF
   
   <span class="comments">; Are we changing the map datum.</span>
   IF N_Elements(datum) NE 0 THEN BEGIN
        IF Size(datum, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase((*self._cg_theDatums).name) EQ StrUpCase(datum))
            IF index[0] EQ -1 THEN Message, 'Cannot find datum ' + datum + ' in datum list.' 
            thisDatum = (*self._cg_theDatums)[index]
        ENDIF ELSE thisDatum = (*self._cg_theDatums)[0 > datum &lt<span class="comments">; 19]</span>
        self._cg_thisDatum = thisDatum
   ENDIF
   
   <span class="comments">; Are we changing the map ellipsoid.</span>
   IF N_Elements(ellipsoid) NE 0 THEN BEGIN
        IF Size(ellipsoid, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase((*self._cg_theDatums).name) EQ StrUpCase(ellipsoid))
            IF index[0] EQ -1 THEN Message, 'Cannot find ellipsoid ' + ellipsoid + ' in datum list.' 
            thisDatum = (*self._cg_theDatums)[index]
        ENDIF ELSE thisDatum = (*self._cg_theDatums)[0 > ellipsoid &lt<span class="comments">; 19]</span>
        self._cg_thisDatum = thisDatum
   ENDIF

   <span class="comments">; Are there map projection keywords to deal with?</span>
   IF N_Elements(map_proj_keywords) NE 0 THEN BEGIN
   
        <span class="comments">; Make the pointer a valid pointer, if necessary.</span>
        IF ~Ptr_Valid(self._cg_map_projection_keywords) THEN self._cg_map_projection_keywords = Ptr_New(/ALLOCATE_HEAP)
        
        <span class="comments">; Is there a NULL field in the current structure that means erase what is currently in the pointer?</span>
        index = Where(Tag_Names(map_proj_keywords) EQ 'NULL', count)
        IF count GT 0 THEN BEGIN
            IF map_proj_keywords.(index) EQ 1 THEN self._cg_map_projection_keywords = Ptr_New(/ALLOCATE_HEAP)
        ENDIF
        
        <span class="comments">; Add these fields to the structure, or modify the tag value if it is already present.</span>
        IF N_Elements(*self._cg_map_projection_keywords) GT 0 THEN BEGIN
            ntags = N_Tags(map_proj_keywords)
            tags = Tag_Names(map_proj_keywords)
            FOR j=0,ntags-1 DO BEGIN
               thisTag = tags[j]
               index = Where(Tag_Names(*self._cg_map_projection_keywords) EQ thisTag, count)
               IF count GT 0 THEN BEGIN
                   (*self._cg_map_projection_keywords).(index) = map_proj_keywords.(j)
               ENDIF ELSE BEGIN
                   *self._cg_map_projection_keywords = Create_Struct(*self._cg_map_projection_keywords, thisTag, map_proj_keywords.(j))
               ENDELSE
            ENDFOR
        ENDIF ELSE BEGIN
            
            <span class="comments">; Add all the tags, except for NULL tags</span>
            ntags = N_Tags(map_proj_keywords)
            tags = Tag_Names(map_proj_keywords)
            FOR j=0,ntags-1 DO BEGIN
               thisTag = tags[j]
               IF thisTag EQ 'NULL' THEN Continue
               IF N_Elements(*self._cg_map_projection_keywords) EQ 0 THEN BEGIN
                    count = 0
               ENDIF ELSE BEGIN
                    index = Where(Tag_Names(*self._cg_map_projection_keywords) EQ thisTag, count)
               ENDELSE
               IF count GT 0 THEN BEGIN
                   (*self._cg_map_projection_keywords).(index) = map_proj_keywords.(j)
               ENDIF ELSE BEGIN
                   IF N_Elements(*self._cg_map_projection_keywords) EQ 0 THEN BEGIN
                        *self._cg_map_projection_keywords = Create_Struct(thisTag, map_proj_keywords.(j))
                   ENDIF ELSE BEGIN
                        *self._cg_map_projection_keywords = Create_Struct(*self._cg_map_projection_keywords, $
                            thisTag, map_proj_keywords.(j))
                   ENDELSE
               ENDELSE
            ENDFOR
        ENDELSE
        
        <span class="comments">; For debugging purposes.</span>
        <span class="comments">;Help, *self._cg_map_projection_keywords, /Structure</span>
   ENDIF
   
   IF N_Elements(background) NE 0 THEN self._cg_background = background
   IF N_Elements(color) NE 0 THEN self._cg_color = color
   IF N_Elements(center_latitude) NE 0 THEN self._cg_center_latitude = center_latitude
   IF N_Elements(center_longitude) NE 0 THEN self._cg_center_longitude = center_longitude
   IF N_Elements(easting) NE 0 THEN self._cg_easting = easting
   IF N_Elements(erase) NE 0 THEN self._cg_erase = Keyword_Set(erase)
   IF N_Elements(noborder) NE 0 THEN self._cg_noborder = Keyword_Set(noborder)
   IF N_Elements(noForwardFix) NE 0 THEN self._cg_noForwardFix = Keyword_Set(noForwardFix)
   IF N_Elements(northing) NE 0 THEN self._cg_northing = northing
   IF N_Elements(onimage) NE 0 THEN self._cg_onimage = Keyword_Set(onimage)
   IF N_Elements(radians) NE 0 THEN self._cg_radians = Keyword_Set(radians)
   IF N_Elements(title) NE 0 THEN self._cg_title = title
   
   
   <span class="comments">; If you change the limit, you really also need to change the XRANGE and YRANGE.</span>
   changedLimit = 0
   IF N_Elements(limit) NE 0 THEN BEGIN
        *self._cg_limit = limit
        changedLimit = 1
   ENDIF
   IF N_Elements(sphere_radius) NE 0 THEN BEGIN
      self._cg_thisDatum.semimajor_axis = sphere_radius
      self._cg_thisDatum.semiminor_axis = sphere_radius
   ENDIF
   IF N_Elements(semimajor_axis) NE 0 THEN self._cg_thisDatum.semimajor_axis = semimajor_axis
   IF N_Elements(semiminor_axis) NE 0 THEN self._cg_thisDatum.semiminor_axis = semiminor_axis
   
   <span class="comments">; Make sure the map structure is up to date.</span>
   map_structure = self -> SetMapProjection() 

   IF N_Elements(parent) NE 0 THEN self -> cgCOORD::SetProperty, PARENT=parent
   IF N_Elements(position) NE 0 THEN self -> cgCOORD::SetProperty, POSITION=position
   IF N_Elements(xrange) NE 0 THEN BEGIN
      IF Keyword_Set(latlon_ranges) THEN BEGIN
        uvcoords = Map_Proj_Forward(xrange, [-5000,5000], MAP_STRUCTURE=map_structure)
        xrange = Reform(uvcoords[0,*])   
      ENDIF
      self -> cgCOORD::SetProperty, XRANGE=xrange
   ENDIF ELSE BEGIN
      IF changedLimit THEN BEGIN
            xrange = map_structure.uv_box[[0,2]]
            self -> cgCOORD::SetProperty, XRANGE=xrange
      ENDIF
   ENDELSE
   IF N_Elements(yrange) NE 0 THEN BEGIN
      IF Keyword_Set(latlon_ranges) THEN BEGIN
        uvcoords = Map_Proj_Forward([-5000,5000], yrange, MAP_STRUCTURE=map_structure)
        yrange = Reform(uvcoords[1,*])     
      ENDIF
      self -> cgCOORD::SetProperty, YRANGE=yrange
   ENDIF ELSE BEGIN
      IF changedLimit THEN BEGIN
            yrange = map_structure.uv_box[[1,3]]
            self -> cgCOORD::SetProperty, YRANGE=yrange
      ENDIF
   ENDELSE
   
   <span class="comments">; Do you need overlay objects in this map?</span>
   IF N_Elements(continents) NE 0 THEN BEGIN
   
       <span class="comments">; Is this a continental object? If so add it, if not</span>
       <span class="comments">; create one and add it.</span>
       IF Obj_Valid(continents) THEN BEGIN
           continents -> SetProperty, NAME='MAPCONTINENTS'
           self._cg_overlays -> Add, continents
       ENDIF ELSE BEGIN
           continents = Obj_New('cgMapContinents', self, /COUNTRIES, $
               COLOR=self._cg_color, NAME='MAPCONTINENTS')
           self._cg_overlays -> Add, continents
       ENDELSE
   ENDIF
   
   IF N_Elements(grid) NE 0 THEN BEGIN
   
       <span class="comments">; Is this a grid object? If so add it, if not</span>
       <span class="comments">; create one and add it.</span>
       IF Obj_Valid(grid) THEN BEGIN
           grid -> SetProperty, NAME='MAPGRID'
           self._cg_overlays -> Add, grid
       ENDIF ELSE BEGIN
           grid = Obj_New('cgMapGrid', self, /AUTODRAW, COLOR=self._cg_color, NAME='MAPGRID')
           self._cg_overlays -> Add, grid
       ENDELSE
   ENDIF
   
   IF (N_ELEMENTS(extraKeywords) GT 0) THEN self -> cgCOORD::SetProperty,  _EXTRA=extraKeywords
   
   <span class="comments">; Need to draw after setting properties?</span>
   IF Keyword_Set(draw) THEN self -> Draw
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; :Private:</span>
<span class="comments">;   This method calls MAP_PROJ_INIT to create a map structure variable.</span>
<span class="comments">;   This method should not be called directly. Use GetMapStruct() instead.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMap::SetMapProjection, map_projection, $
    LATLON_RANGES=latlon_ranges, $
    POSITION=position, $
    XRANGE=xrange, $
    YRANGE=yrange, $
    <span class="comments">; MAP_PROJ_INIT keywords (partial list)</span>
    CENTER_LATITUDE=center_latitude, $
    CENTER_LONGITUDE=center_longitude, $
    DATUM=datum, $
    EASTING=easting, $
    ELLIPSOID=ellipsoid, $
    LIMIT=limit, $
    NORTHING=northing, $
    RADIANS=radians, $
    SEMIMAJOR_AXIS=semimajor_axis, $
    SEMIMINOR_AXIS=semiminor_axis, $
    SPHERE_RADIUS=sphere_radius, $
    ZONE=zone, $
    _EXTRA=extraKeywords

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, 1
    ENDIF
   
   <span class="comments">; Need a new map projection?</span>
   IF N_Elements(map_projection) NE 0 THEN BEGIN
        <span class="comments">; Find the map projection.</span>
        IF Size(map_projection, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase((*self._cg_theProjections).name) EQ StrUpCase(map_projection))
            IF index[0] EQ -1 THEN Message, 'Cannot find map projection ' + map_projection + ' in the projection list.'
        ENDIF
        IF (N_Elements(index) EQ 0) AND (N_Elements(map_projection) NE 0) THEN BEGIN
            index = Where((*self._cg_theProjections).index EQ map_projection, count)
            IF count EQ 0 THEN Message, 'Cannot find map projection index ' + StrTrim(map_projection,2) + ' in projection list.' 
        ENDIF 
        thisProjection = (*self._cg_theProjections)[index]
        self._cg_thisProjection = thisProjection
   ENDIF
   
   <span class="comments">; Need a new datum?</span>
   IF N_Elements(datum) NE 0 THEN BEGIN
        IF Size(datum, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase((*self._cg_theDatums).name) EQ StrUpCase(datum))
            IF index[0] EQ -1 THEN Message, 'Cannot find datum ' + datum + ' in datum list.' 
            thisDatum = (*self._cg_theDatums)[index]
        ENDIF ELSE thisDatum = (*self._cg_theDatums)[0 > datum &lt<span class="comments">; 24]</span>
        self._cg_thisDatum = thisDatum
   ENDIF

   <span class="comments">; Need a new ellipsoid?</span>
   IF N_Elements(ellipsoid) NE 0 THEN BEGIN
        IF Size(ellipsoid, /TNAME) EQ 'STRING' THEN BEGIN
            index = Where(StrUpCase((*self._cg_theDatums).name) EQ StrUpCase(ellipsoid))
            IF index[0] EQ -1 THEN Message, 'Cannot find ellipsoid ' + ellipsoid + ' in datum list.' 
            thisDatum = (*self._cg_theDatums)[index]
        ENDIF ELSE thisDatum = (*self._cg_theDatums)[0 > ellipsoid &lt<span class="comments">; 24]</span>
        self._cg_thisDatum = thisDatum
   ENDIF
   
   <span class="comments">; Other map keywords?</span>
   IF N_Elements(center_latitude) NE 0 THEN self._cg_center_latitude = center_latitude
   IF N_Elements(center_longitude) NE 0 THEN self._cg_center_longitude = center_longitude
   IF N_Elements(easting) NE 0 THEN self._cg_easting = easting
   IF N_Elements(northing) NE 0 THEN self._cg_northing = northing
   IF N_Elements(sphere_radius) NE 0 THEN BEGIN
      self._cg_thisDatum.semimajor_axis = sphere_radius
      self._cg_thisDatum.semiminor_axis = sphere_radius
   ENDIF
   IF N_Elements(semimajor_axis) NE 0 THEN self._cg_thisDatum.semimajor_axis = semimajor_axis
   IF N_Elements(semiminor_axis) NE 0 THEN self._cg_thisDatum.semiminor_axis = semiminor_axis
   IF N_Elements(limit) NE 0 THEN *self._cg_limit = limit
   IF N_Elements(zone) NE 0 THEN self._cg_zone = zone
   IF N_Elements(extrakeywords) NE 0 THEN *self._cg_map_projection_keywords = extrakeywords
   
   <span class="comments">; Extract the values you need to call MAP_PROJ_INIT.</span>
   thisProjection = self._cg_thisProjection.name
   sphereOnly = self._cg_thisProjection.sphereOnly
   thisDatum = self._cg_thisDatum.name
   radians = self._cg_radians
   semimajor_axis = self._cg_thisDatum.semimajor_axis 
   semiminor_axis = self._cg_thisDatum.semiminor_axis
   center_lon = self._cg_center_longitude
   center_lat = self._cg_center_latitude
   easting = self._cg_easting
   northing = self._cg_northing
   IF N_Elements(*self._cg_limit) NE 0 THEN limit = *self._cg_limit
   zone = self._cg_zone
   IF N_Elements(*self._cg_map_projection_keywords) NE 0 THEN keywords = *self._cg_map_projection_keywords
   
   <span class="comments">; Center latitudes are not allowed in some projections. Here are the ones where</span>
   <span class="comments">; they are prohibited.</span>
   centerlatOK = 1
   centerlonOK = 1
   badprojLatstr = ['GOODES HOMOLOSINE', 'STATE PLANE', 'MERCATOR', 'SINUSOIDAL', 'EQUIRECTANGULAR', $
      'MILLER CYLINDRICAL', 'ROBINSON', 'SPACE OBLIQUE MERCATOR A', 'SPACE OBLIQUE MERCATOR B', $
      'ALASKA CONFORMAL', 'INTERRUPTED GOODE', 'MOLLWEIDE', 'INTERRUPED MOLLWEIDE', 'HAMMER', $
      'WAGNER IV', 'WAGNER VII', 'INTEGERIZED SINUSOIDAL']
   void = Where(badprojLatstr EQ StrUpCase(thisProjection), count)
   IF count GT 0 THEN centerlatOK = 0

   badprojLonstr = ['HOTINE OBLIQUE MERCATOR A','HOTINE OBLIQUE MERCATOR B']
   void = Where(badprojLonstr EQ StrUpCase(thisProjection), count)
   IF count GT 0 THEN centerLonOK = 0
    
    <span class="comments">; UTM and State Plane projections have to be handled differently.</span>
    IF (StrUpCase(thisProjection) EQ 'UTM') OR (StrUpCase(thisProjection) EQ 'STATE PLANE') THEN BEGIN
    
        CASE StrUpCase(thisProjection) OF
            'UTM': BEGIN
                IF N_Elements(zone) NE 0 THEN BEGIN
                    Undefine, center_lat
                    Undefine, center_lon
                ENDIF
                mapStruct = Map_Proj_Init(thisProjection, DATUM=self._cg_thisDatum.(0), /GCTP, $
                    CENTER_LATITUDE=center_lat, CENTER_LONGITUDE=center_lon, $
                    RADIANS=radians, ZONE=zone, LIMIT=limit)
                END
            'STATE PLANE': BEGIN
                mapStruct = Map_Proj_Init(thisProjection, DATUM=self._cg_thisDatum.(0), /GCTP, $
                    RADIANS=radians, ZONE=zone, LIMIT=limit)
                END
        ENDCASE
        
    ENDIF ELSE BEGIN

        <span class="comments">; Call MAP_PROJ_INIT to get the map projection structure.</span>
        CASE 1 OF
        
            centerLatOK && centerLonOK && sphereOnly: BEGIN
                mapStruct = Map_Proj_Init(thisProjection, /GCTP, $
                    CENTER_LATITUDE=center_lat, $
                    CENTER_LONGITUDE=center_lon, $
                    SPHERE_RADIUS=semimajor_axis, $
                    LIMIT=limit, RADIANS=radians, $
                    _EXTRA=keywords, $
                    FALSE_NORTHING=northing, FALSE_EASTING=easting)
                END
                
            ~centerLatOK && centerLonOK && sphereOnly: BEGIN

                mapStruct = Map_Proj_Init(thisProjection, /GCTP, $
                    CENTER_LONGITUDE=center_lon, $
                    SPHERE_RADIUS=semimajor_axis, $
                    LIMIT=limit, RADIANS=radians, $
                    _EXTRA=keywords, $
                    FALSE_NORTHING=northing, FALSE_EASTING=easting)
                END
                
            ~centerLatOK && centerLonOK &&  ~sphereOnly: BEGIN
                mapStruct = Map_Proj_Init(thisProjection, /GCTP, $
                    CENTER_LONGITUDE=center_lon, $
                    SEMIMAJOR_AXIS=semimajor_axis, $
                    SEMIMINOR_AXIS=semiminor_axis, $
                    LIMIT=limit, RADIANS=radians, $
                    _EXTRA=keywords, $
                    FALSE_NORTHING=northing, FALSE_EASTING=easting)
                END
    
            centerLatOK && centerLonOK && ~sphereOnly: BEGIN
                mapStruct = Map_Proj_Init(thisProjection, /GCTP, $
                    CENTER_LATITUDE=center_lat, $
                    CENTER_LONGITUDE=center_lon, $
                    SEMIMAJOR_AXIS=semimajor_axis, $
                    SEMIMINOR_AXIS=semiminor_axis, $
                    LIMIT=limit, RADIANS=radians, $
                    _EXTRA=keywords, $
                    FALSE_NORTHING=northing, FALSE_EASTING=easting)
                END
                
            centerLatOK && ~centerLonOK && ~sphereOnly: BEGIN
                mapStruct = Map_Proj_Init(thisProjection, /GCTP, $
                    CENTER_LATITUDE=center_lat, $
                    SEMIMAJOR_AXIS=semimajor_axis, $
                    SEMIMINOR_AXIS=semiminor_axis, $
                    LIMIT=limit, RADIANS=radians, $
                    _EXTRA=keywords, $
                    FALSE_NORTHING=northing, FALSE_EASTING=easting)
                END
        ENDCASE
   ENDELSE

   <span class="comments">; The UV_BOX created in Map_Proj_Init will return the wrong values if the CENTER_LON is</span>
   <span class="comments">; not equal to zero and the range is the full 360 degrees. In this case, UV_BOX[0] is</span>
   <span class="comments">; equal to UV_BOX[2]. While this is technically correct, it doesn't work for displaying</span>
   <span class="comments">; grids on maps set up with a projected XY coordinate system. In this grid system, these</span>
   <span class="comments">; two points are not coincident, but are far apart on the plot. This code tries to fix</span>
   <span class="comments">; the UV_BOX in this case. See http://www.idlcoyote.com/map_tips/uvrange.php for details.</span>
   IF N_Elements(center_lon) NE 0 THEN BEGIN
       IF (center_lon NE 0.0) && $
           ( (N_Elements(limit) EQ 0) || (limit[2]-limit[0] EQ 180) || (limit[3]-limit[1] EQ 360) ) THEN BEGIN
            IF mapStruct.uv_box[0] GE 0 THEN BEGIN
               mapStruct.uv_box[2] = -Abs(mapStruct.uv_box[0])
            ENDIF ELSE BEGIN
               mapStruct.uv_box[2] = Abs(mapStruct.uv_box[0])
            ENDELSE
            IF mapStruct.uv_box[1] GE 0 THEN BEGIN
               mapStruct.uv_box[3] = -Abs(mapStruct.uv_box[1])
            ENDIF ELSE BEGIN
               mapStruct.uv_box[3] = Abs(mapStruct.uv_box[1])
            ENDELSE
       ENDIF
   ENDIF
   
   RETURN, mapStruct
    
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the clean-up routine for the object.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap::CLEANUP

    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
    ENDIF
   
   Ptr_Free, self._cg_limit
   Ptr_Free, self._cg_map_projection_keywords
   Ptr_Free, self._cg_theDatums
   Ptr_Free, self._cg_theProjections
   Obj_Destroy, self._cg_overlays
   
   self -> cgCOORD::CLEANUP 

END


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the class definition module. Structures used to manipulate</span>
<span class="comments">;   map projectatum information are also created here.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    class: out, optional, type=structure</span>
<span class="comments">;       Occasionally, it is useful to have an object class definition as</span>
<span class="comments">;       a structure variable. Using this output keyword will allow that.</span>
<span class="comments">;       </span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap__Define, class

   <span class="comments">; Structures used in the object.</span>
   datumStruct = { cgMap_DATUM, index:0, name:"", semimajor_axis:0.0D, semiminor_axis:0.0D }
   mapStruct =   { cgMap_PROJECTION, name:"", index:0, sphereOnly:0 }

   class = { cgMap, $
             _cg_isotropic: 0B, $
             _cg_aspect: 0.0D, $
             _cg_background: "", $                      <span class="comments">; The background color for erasing the display.</span>
             _cg_center_latitude: 0.0D, $               <span class="comments">; The latitude at the center of the map projection.</span>
             _cg_center_longitude:0.0D, $               <span class="comments">; The lontigude at the center of the map projection.</span>
             _cg_color: "", $                           <span class="comments">; The name of the color in which to draw a border.</span>
             _cg_easting: 0.0D, $                       <span class="comments">; The easting value in meters.</span>
             _cg_erase: 0B, $                           <span class="comments">; A flag that indicates the map should erase the display before drawing.</span>
             _cg_limit: Ptr_New(), $                    <span class="comments">; The limit of the map projection.</span>
             _cg_map_projection_keywords: Ptr_New(), $  <span class="comments">; A storage location for MAP_PROJ_INIT keywords.</span>
             _cg_noborder: 0B, $                        <span class="comments">; A flag that indicates a border should not be drawn.</span>
             _cg_noforwardfix: 0B, $                    <span class="comments">; A flag that indicates no fix in the FORWARD method.</span>
             _cg_northing: 0.0D, $
             _cg_multi_position: FltArr(4), $           <span class="comments">; The position of a multiple plot.</span>
             _cg_onimage: 0B, $                         <span class="comments">; A flag that, if set, will get the position from the last image position.</span>
             _cg_overlays: Obj_New(), $                 <span class="comments">; A storage location for map overlays.</span>
             _cg_radians: 0B, $                         <span class="comments">; A flag that indicated values are in radians, not degrees.</span>
             _cg_theDatums: Ptr_New(), $                <span class="comments">; Information about available map datums.</span>
             _cg_thisDatum: datumStruct, $              <span class="comments">; The particular datum structure for this map projection.</span>
             _cg_theProjections: Ptr_New(), $           <span class="comments">; Information about available map projections.</span>
             _cg_thisProjection: mapStruct, $           <span class="comments">; The particular map projection structure for this map projection.</span>
             _cg_title: "", $                           <span class="comments">; The map title.</span>
             _cg_zone: 0, $                             <span class="comments">; The UTM zone of the map projection.</span>
             INHERITS cgCOORD $                         <span class="comments">; The superclass object.</span>
           }

END <span class="comments">;--------------------------------------------------------------------------</span>


</code>
    </div>
  </body>
</html>