<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:10 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cghistoplot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cghistoplot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgHistoplot</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This program is used to draw a histogram plot in an IDL direct graphics window..</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This program is used to draw a histogram plot in an IDL direct graphics window..</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cghistoplot.png</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, </span>
<span class="comments">;       The data from which the histogram is created.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;    axiscolorname: in, optional, type=string, default='opposite'                     </span>
<span class="comments">;       The name of the axis color. All color names are derived from cgColor.</span>
<span class="comments">;    backcolorname: in, optional, type=string, default='background'</span>
<span class="comments">;       The name of the background color. All color names are derived from cgColor.</span>
<span class="comments">;    binsize: in, optional</span>
<span class="comments">;       The binsize of the histogram. By default, Scott's Choice of bin size for histograms is used::</span>
<span class="comments">;                         </span>
<span class="comments">;           binsize = (3.5 * StdDev(data)) / N_Elements(data)^(0.3333)</span>
<span class="comments">;                            </span>
<span class="comments">;       If BINSIZE in not defined, and NBINS is defined, the BINSIZE is calcuated as::</span>
<span class="comments">;                         </span>
<span class="comments">;            binsize = (Max(dataToHistogram) - Min(dataToHistogram)) / (NBINS -1)</span>
<span class="comments">;                             </span>
<span class="comments">;       While it is pointed out in the HISTOGRAM documentation, it is extremely</span>
<span class="comments">;       important that the BINSIZE be of the same data type as the data you are going to</span>
<span class="comments">;       calculate the histogram of. If it is not VERY strange things can happen. I've</span>
<span class="comments">;       tried to protect you from most of the bad things, but I don't have a high confidence</span>
<span class="comments">;       level that I have done it for every situation. If you see something that "just don't</span>
<span class="comments">;       look right", I would check first to see if your data types match. That might solve</span>
<span class="comments">;       all your problems.</span>
<span class="comments">;    charsize: in, optional, type=float</span>
<span class="comments">;       The character size of the annotations. Default set by calling cgDefCharSize().</span>
<span class="comments">;    color: in, optional, type=string</span>
<span class="comments">;       Used as a shorthand way of setting the `DataColorName` keyword or, if the `FillPolygon`</span>
<span class="comments">;       keyword is set, the `PolyColor` keyword. Only used if those other two keywords are not</span>
<span class="comments">;       set.</span>
<span class="comments">;    datacolorname: in, optional, type=string, default="indian red"</span>
<span class="comments">;       The name of the data color for drawing the histogram outlines.</span>
<span class="comments">;    filename: in, optional, type=string</span>
<span class="comments">;       The name of a color name file to use with cgCOLOR.</span>
<span class="comments">;    fillpolygon: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to fill the histogram polygons with the `POLYCOLOR`.</span>
<span class="comments">;    frequency: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, the relative frequency is plotted on the Y axis,</span>
<span class="comments">;       rather than the histogram density.</span>
<span class="comments">;    histdata: out, optional</span>
<span class="comments">;       The output value of the internal HISTOGRAM command.</span>
<span class="comments">;    l64: in, optional, type=boolean, default=0                       </span>
<span class="comments">;       If set, the return value of HISTOGRAM are 64-bit integers, rather than</span>
<span class="comments">;       the default 32-bit integers.</span>
<span class="comments">;    log: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if you wish the histogram count to be represented on a logarithmic scale.</span>
<span class="comments">;    layout: in, optional, type=integer</span>
<span class="comments">;       This keyword specifies a grid with a graphics window and determines </span>
<span class="comments">;       where the graphic should appear. The syntax of LAYOUT is a 3-element </span>
<span class="comments">;       array: [ncolumns, nrows, location]. The grid is determined by the </span>
<span class="comments">;       number of columns (ncolumns) by the number of rows (nrows). The location </span>
<span class="comments">;       of the graphic is determined by the third number. The grid numbering </span>
<span class="comments">;       starts in the upper left (1) and goes sequentually by column and then by row.</span>
<span class="comments">;    line_fill: in, optional, type=boolean, default=0           </span>
<span class="comments">;       If set, the polygons are filled with lines instead of solid color. If</span>
<span class="comments">;       this keyword is set, the following keywords can also be used: `ORIENTATION`,</span>
<span class="comments">;       `PATTERN`, `POLYCOLOR`, and `SPACING`.</span>
<span class="comments">;    line_thick: in, optional, type=integer, default=1</span>
<span class="comments">;       Set this keyword to set the thickness of lines used in the fill pattern. Applies only</span>
<span class="comments">;       if the `Line_Fill` keyword is set.</span>
<span class="comments">;    locations: out, optional</span>
<span class="comments">;       Starting locations of each bin. (See the HISTOGRAM documentation for details.)</span>
<span class="comments">;    maxinput: in, optional</span>
<span class="comments">;       The maximum value to use in calculating input histogram. Equivalent to the MAX keyword</span>
<span class="comments">;       in the HISTOGRAM documentation.</span>
<span class="comments">;    max_value: in, optional</span>
<span class="comments">;       The maximum Y data value to represent on graphics plot. Default: Max(data) * 1.05.</span>
<span class="comments">;    mininput: in, optional</span>
<span class="comments">;       The minimum value to use in calculating input histogram. Equivalent to the MIN keyword</span>
<span class="comments">;       in the HISTOGRAM documentation.</span>
<span class="comments">;    min_value: in, optional</span>
<span class="comments">;       The minimum Y data value to represent on graphics plot. Default: 0.</span>
<span class="comments">;    missing: in, optional</span>
<span class="comments">;       The value that should be represented as "missing" and not used in the histogram.</span>
<span class="comments">;       Be aware that if the input data is not of type "float" or "double" that the input</span>
<span class="comments">;       data will be converted to floating point prior to calculating the histogram.</span>
<span class="comments">;    nan: in, optional, type=boolean, default=0   </span>
<span class="comments">;       If set, ignore NAN values in calculating and plotting histogram.</span>
<span class="comments">;    nbins: in, optional, type=integer</span>
<span class="comments">;       The number of output bins in the histogram. Meaning is slightly different from</span>
<span class="comments">;       meaning in the HISTOGRAM command. Used only to calculate BINSIZE when BINSIZE is</span>
<span class="comments">;       not specified. In this case, binsize = rangeofData/(nbins-1).</span>
<span class="comments">;    omax: out, optional</span>
<span class="comments">;       The maximum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    omin: out, optional</span>
<span class="comments">;       The minimum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    oprobability: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if you want to overplot the cumulative probability on the plot.</span>
<span class="comments">;    oplot: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if you want to overplot the histogram on already established axes.</span>
<span class="comments">;    orientation: in, optional, type=float, default=0.0</span>
<span class="comments">;       The orientation (rotations) of the lines used to fill the polygons if `LINE_FILL` is set.</span>
<span class="comments">;       (See POLYFILL documentation.)</span>
<span class="comments">;    outfilename: in, optional, type=string</span>
<span class="comments">;       If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;       filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;       value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;       presented to the user.</span>
<span class="comments">;    outline: in, optional, type=boolean, default=0   </span>
<span class="comments">;       Set this keyword if you wish to draw only the outline of the histogram plot,</span>
<span class="comments">;       in a manner similar to setting PSYM=10 on a PLOT command.</span>
<span class="comments">;    output: in, optional, type=string, default=""</span>
<span class="comments">;       Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;       Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;       file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;       user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;       All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;       PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;       to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;       details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;       plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;       output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;    pattern: in, optional</span>
<span class="comments">;       The fill pattern for the polygons if the `FILLPOLYGON` keyword is set. (See POLYFILL documentation.)</span>
<span class="comments">;    polycolor: in, optional, type=string, default="rose"</span>
<span class="comments">;       The name of the polygon fill color if the `FILLPOLYGON` keyword is set.</span>
<span class="comments">;    position: in, optional, type=fltarr</span>
<span class="comments">;       The position of the plot axes in normalized data coordinates, [x0,y0,x1,y1].</span>
<span class="comments">;    probability_function: out, optional, type=float</span>
<span class="comments">;       The total cummulative probability of the histogram plot, scaled from 0 to 1.</span>
<span class="comments">;    probcolorname: in, optional, type=string, default="blue"                      </span>
<span class="comments">;       The name of the probability color for overplotting the cumulative probability</span>
<span class="comments">;       on the plot. </span>
<span class="comments">;    probthick: in, optional, type=float, default=1.0</span>
<span class="comments">;       The thickness of the probability line drawn on the plot.</span>
<span class="comments">;    reverse_indices: out, optional</span>
<span class="comments">;       The list of reverse indices returned from the HISTOGRAM command. (See HISTOGRAM documentation.)</span>
<span class="comments">;    rotate: in, optional, type=boolean, default=0                     </span>
<span class="comments">;       Set this keyword to cause the histogram bins to be drawn from left to right, rather </span>
<span class="comments">;       than from bottom to top.</span>
<span class="comments">;    smooth: in, optional, type=integer, default=0</span>
<span class="comments">;       Set this keyword to an odd positive integer to smooth the histogram output before plotting.</span>
<span class="comments">;       The integer will set the width of a smoothing box to be applied to the histogram data with</span>
<span class="comments">;       the Smooth function.</span>
<span class="comments">;    spacing: in, optional</span>
<span class="comments">;       The spacing of fill line if the 'LINE_FILL` keyword is set. (See POLYFILL documentation.)</span>
<span class="comments">;    thick: in, optional, type=integer, default=1   </span>
<span class="comments">;       Set this keyword to a value greater than 1 to draw thicker axes and lines.</span>
<span class="comments">;    title: in, optional, type=string</span>
<span class="comments">;        Set this keyword to the plot title.</span>
<span class="comments">;    window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in the current cgWindow or to</span>
<span class="comments">;        create a new cgWindow, if one doesn't currenly exist, for displaying this command.</span>
<span class="comments">;        To create a new cgWindow if one currenly exists, use the `cgWindow` command.</span>
<span class="comments">;    xticknames: in, optional, type=string</span>
<span class="comments">;        An array of tick names for the axis.</span>
<span class="comments">;    xtickformat: in, optional, type=string</span>
<span class="comments">;        As tick format or name of tick formatting function for the axis.</span>
<span class="comments">;    xticks: in, optional, type=integer</span>
<span class="comments">;        The number of major tick spaces for the axis.</span>
<span class="comments">;    xtickvalues: in, optional</span>
<span class="comments">;        A vector of tick values that should be labelled on the axis.</span>
<span class="comments">;    xtitle: in, optional, type=string, default="Relative Frequency"</span>
<span class="comments">;        The X title of the histogram plot.</span>
<span class="comments">;    yticknames: in, optional, type=string</span>
<span class="comments">;        An array of tick names for the axis.</span>
<span class="comments">;    ytickformat: in, optional, type=string</span>
<span class="comments">;        As tick format or name of tick formatting function for the axis.</span>
<span class="comments">;    yticks: in, optional, type=integer</span>
<span class="comments">;        The number of major tick spaces for the axis.</span>
<span class="comments">;    ytickvalues: in, optional</span>
<span class="comments">;        A vector of tick values that should be labelled on the axis.</span>
<span class="comments">;    ytitle: in, optional, type=string, default="Histogram Density"</span>
<span class="comments">;        The Y title of the histogram plot.</span>
<span class="comments">;    _ref_extra: in, optional</span>
<span class="comments">;         Any additional PLOT keywords are passed via keyword inheritance.</span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Some of the ways cgHistogram can be used::</span>
<span class="comments">;    </span>
<span class="comments">;       cgHistoplot, Dist(256), BINSIZE=5.0</span>
<span class="comments">;       cgHistoplot, Fix(RandomU(seed, 200)*20), POLYCOLOR=['charcoal', 'steel blue'], /FILLPOLYGON</span>
<span class="comments">;       cgHistoplot, Fix(RandomU(seed, 200)*20), POLYCOLOR=['navy', 'forest green'], /LINE_FILL, ORIENTATION=[45,-45]</span>
<span class="comments">;       </span>
<span class="comments">;    Additional examples can be found here::</span>
<span class="comments">;    </span>
<span class="comments">;        http://www.idlcoyote.com/gallery/index.html</span>
<span class="comments">;        </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Change History::</span>
<span class="comments">;       Written by:  David W. Fanning, 14 November 2007.</span>
<span class="comments">;       Modified to work with !P.MULTI. 20 Nov 2007. DWF.</span>
<span class="comments">;       Slight problem with extra space at the right end of the plot resolved. 20 Nov 2007. DWF.</span>
<span class="comments">;       Added FILE and NOLINES keywords. 24 Nov 2007. DWF.</span>
<span class="comments">;       Added additional HISTOGRAM access via keywords. 24 Nov 2007. DWF.</span>
<span class="comments">;       Fixed a small problem with FILLPOLY keyword. 26 Nov 2007. DWF.</span>
<span class="comments">;       Fixed a small problem with the OVERPLOTTED histogram being slightly offset. 12 Jan 2009. DWF</span>
<span class="comments">;       Major reconstructive surgery on the actual drawing part of the program. As far as I can</span>
<span class="comments">;          tell, all functionality is the same, but without drawing problems evidenced before. 14 March 2009. DWF.</span>
<span class="comments">;       A small problem with the way I was specifying ranges caused the bars to be slightly offset. 23 March 2009. DWF.</span>
<span class="comments">;       I fixed a small problem with BINSIZE and HISTOGRAM data type matching (see the Note), and I also</span>
<span class="comments">;          fixed a small problem with the range calculations when byte data is passed in. 1 April 2009. DWF.</span>
<span class="comments">;       I removed a NOLINES keyword, which was no longer being used. 1 April 2009. DWF.</span>
<span class="comments">;       MIN_VALUE and MAX_VALUE keywords now work again, thanks to Josiah Schwab. 22 April 2009. DWF.</span>
<span class="comments">;       Changed default POLYFILL color to "ROSE". 22 April 2009. DWF.</span>
<span class="comments">;       Having problems with binsize selection when data to histogram is an integer type. Fixed. 8 June 2009. DWF.</span>
<span class="comments">;       When the input array has a considerable number of NANs, the Histogram command complains with an error</span>
<span class="comments">;           "Array has too many elements." This happens even when the NAN keyword is set for the Histogram</span>
<span class="comments">;           command. So, I now screen for NANs before I process the histogram. 8 June 2009. DWF.</span>
<span class="comments">;       Added MISSING keyword to represent missing data. 18 July 2009. DWF.</span>
<span class="comments">;       Adding the MISSING keyword exposed a problem I had in restoring the original input data</span>
<span class="comments">;           to its original values when there were NANs and MISSING values. Fixed now by making</span>
<span class="comments">;           a copy of the data to work on internally. Everything else is too complex. 20 July 2009. DWF.</span>
<span class="comments">;       Yikes! Bad error in calculating start and end of histogram plot when overplotting fixed. 4 Sept 2009. DWF.</span>
<span class="comments">;       Added needed XSTYLE=1 to AXIS command to match Plot axis labelling. 19 Oct 2009. DWF.</span>
<span class="comments">;       Added a THICK keyword. 9 November 2009. DWF.</span>
<span class="comments">;       Added an OUTLINE keyword so only the outline of the histogram is plotted. 3 December 2009. DWF.</span>
<span class="comments">;       I was trying to be a good citizen by reloading the input color table when I exited</span>
<span class="comments">;            the program. But, of course, that makes it impossible to use the program in</span>
<span class="comments">;            the Z-buffer. Fixed by being less of a good citizen. 23 July 2010. DWF.</span>
<span class="comments">;       Because of the way I was dealing with NANs and MISSING data, the reverse indices were</span>
<span class="comments">;            inaccurate when they were returned, if there was NANs or MISSING data in the</span>
<span class="comments">;            input array. The data is now being handled correctly in all cases. This requires</span>
<span class="comments">;            that missing data must be set to !VALUES.F_NAN prior to calculating the histogram.</span>
<span class="comments">;            This means the data MUST be converted to floats for this operation. Since I am</span>
<span class="comments">;            always working on a *copy* of the data when this occurs, it should not affect</span>
<span class="comments">;            user input data. Also, I scan all input floating point and double data for NANs,</span>
<span class="comments">;            and if found, and the NAN keyword is not set, I issue a warning and set the NAN</span>
<span class="comments">;            keyword. This is a change in behavior. 1 October 2010. DWF.</span>
<span class="comments">;       Fixed a problem when specifying more than one POLYCOLOR. I made a change to the program</span>
<span class="comments">;            and forgot to propogate it everywhere. 4 October 2010. DWF.</span>
<span class="comments">;       Default axis color name changed from "Navy" to "Black". 28 October 2010. DWF.</span>
<span class="comments">;       Fixed a problem with restoring color tables in PostScript. 24 Nov 2010. DWF.</span>
<span class="comments">;       Added OPROBABILITY, PROBCOLOR, and PROBABILITY keywords. 24 Nov 2010. DWF.</span>
<span class="comments">;       Changed the way I find a default axis color. 3 Dec 2010. DWF.</span>
<span class="comments">;       Expanded search for "integers" from in BINSIZE calculation from DataType LE 3 </span>
<span class="comments">;             to include DataType GE 12, too. 8 Dec 2010. DWF.</span>
<span class="comments">;       Added WINDOW keyword. 24 Jan 2011. DWF.</span>
<span class="comments">;       Added ADDCMD keyword. 26 Jan 2011. DWF.</span>
<span class="comments">;       Added LAYOUT keyword. 28 Jan 2011. DWF.</span>
<span class="comments">;       Added CHARSIZE keyword. 2 Feb 2011. DWF.</span>
<span class="comments">;       Added YTITLE keyword. 9 May 2011. DWF.</span>
<span class="comments">;       Worked around a PLOT problem when setting the X axis range that caused the Y axis</span>
<span class="comments">;          range to be corrupted. 19 May 2011. DWF.</span>
<span class="comments">;       Added the ROTATE keyword. 18 Aug 2011. DWF.</span>
<span class="comments">;       I was calculating and displaying the cumulative probability distribution function</span>
<span class="comments">;           incorrectly. Now changed to what I think is the correct result. 8 Nov 2011. DWF.</span>
<span class="comments">;       Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;       PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2001. DWF.</span>
<span class="comments">;       I had a problem with OVERPLOTs being slightly offset because I was calculating the xrange</span>
<span class="comments">;           and yrange, rather than taking them from !X.CRange and !Y.CRange. 17 Dec 2011. DWF.</span>
<span class="comments">;       Modified to use cgDefaultColor for default color selection. 24 Dec 2011. DWF.</span>
<span class="comments">;       Incomplete implementation of new color selection scheme, fixed. 30 Dec 2011. DWF.</span>
<span class="comments">;       The change of 17 Dec 2011 was incorrect, as I misunderstood the problem. Restored original. 30 Dec 2011. DWF.</span>
<span class="comments">;       Changes to allow better default colors, based on changes to cgColor and cgDefaultColor. 1 Feb 2012. DWF.</span>
<span class="comments">;       Added a SMOOTH keyword. 26 April 2012. DWF.</span>
<span class="comments">;       Small fix (CR missing!) to allow overplotting in cgWindow. 26 April 2012. DWF.</span>
<span class="comments">;       The Outline keyword was incorrectly drawing the last histogram bin outline. Fixed. 26 April 2012. DWF.</span>
<span class="comments">;       Added POSITION and PROBTHICK keywords to set the plot position and the thickness of the cumulative</span>
<span class="comments">;          probability line, respectively. 25 May 2012. DWF.</span>
<span class="comments">;       If the cumulative probability option (keyword OPROBABILITY) is set, a second axis is drawn indicating</span>
<span class="comments">;          the cumulative probablity from 0 to 1. 25 May 2012. DWF.</span>
<span class="comments">;        Whoops! Don't want to set default position unless Total(!P.MULTI) equals zero. 25 May 2012. DWF.</span>
<span class="comments">;        More work on getting the cumulative probability to be correctly plotted. 30 May 2012. DWF.</span>
<span class="comments">;        More whoops! Setting POSITION now interfering with LAYOUT keyword. More fixes to restore LAYOUT. 26 July 2012. DWF.</span>
<span class="comments">;        Aaauuughhh! Typo introduced in yesterday's fix before I saved final version. 27 July 2012. DWF.</span>
<span class="comments">;        Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;        Mis-spelled "probability" in one section of the code. Fixed. 31 July 2012. DWF.</span>
<span class="comments">;        Added COLOR keyword. 19 Sept 2012. DWF.</span>
<span class="comments">;        Now restoring previous plot parameters after drawing cumulative probability axis, so as not</span>
<span class="comments">;           to interfere with subsequent overplotting. 27 Sept 2012. DWF.</span>
<span class="comments">;        Changed the way the "ystart" variable is set on log plots. 21 Jan 2013. DWF.</span>
<span class="comments">;        Now taking into account the MININPUT and MAXINPUT values when calculating a default bin size. 19 Feb 2013. DWF.</span>
<span class="comments">;        Added [XY]TickNames, [XY]Tickformat, [XY]TickS, and [XY]TickValues keywords. 21 Feb 2013. DWF.</span>
<span class="comments">;        Now choosing the default tick format of '(F)' when LOG is set. 28 April 2013. DWF.</span>
<span class="comments">;        Added Line_Thick keyword to change thickness of fill line. 28 Aug 2013. DWF.</span>
<span class="comments">;        </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2007-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgHistoplot, $                  <span class="comments">; The program name.</span>
   data, $                          <span class="comments">; The data to draw a histogram of.</span>
   ADDCMD=addcmd, $                 <span class="comments">; Add this command to an cgWindow.</span>
   AXISCOLORNAME=axisColorName, $   <span class="comments">; The axis color.</span>
   BACKCOLORNAME=backcolorName, $   <span class="comments">; The background color.</span>
   BINSIZE=binsize, $               <span class="comments">; The histogram bin size.</span>
   CHARSIZE=charsize, $
   COLOR=color, $
   DATACOLORNAME=datacolorName, $   <span class="comments">; The data color.</span>
   FILENAME=file, $                 <span class="comments">; For specifying a color name file.</span>
   FILLPOLYGON=fillpolygon, $       <span class="comments">; Set if you want filled polygons</span>
   FREQUENCY=frequency, $           <span class="comments">; Plot relative frequency, rather than density.</span>
   HISTDATA=histdata, $
   L64=l64, $                       <span class="comments">; Input for HISTOGRAM.</span>
   LAYOUT=layout, $                 <span class="comments">; Select the grid layout.</span>
   LINE_FILL=line_fill, $           <span class="comments">; Set if you want line-filled polygons.</span>
   LINE_THICK=line_thick, $         <span class="comments">; Change thickness of fill lines.</span>
   LOCATIONS=locations, $
   LOG=log, $
   MAXINPUT=maxinput, $             <span class="comments">; The maximum value to HISTOGRAM.</span>
   MAX_VALUE=max_value, $           <span class="comments">; The maximum value to plot.</span>
   MIN_VALUE=min_value, $           <span class="comments">; The minimum value to plot.</span>
   MININPUT=mininput, $             <span class="comments">; The minimum value to HISTOGRAM.</span>
   MISSING=missing, $               <span class="comments">; The value that indicates "missing" data to be excluded from the histgram.</span>
   NAN=nan, $                       <span class="comments">; Check for NAN.</span>
   NBINS=nbins, $                   <span class="comments">; The number of bins to display.</span>
   NOERASE=noerase, $               <span class="comments">; Set this keyword to avoid erasing when plot is drawn.</span>
   OMAX=omax, $
   OMIN=omin, $
   OPLOT=overplot, $                <span class="comments">; Set if you want overplotting.</span>
   OPROBABILITY=oprob, $            <span class="comments">; Overplot the cummulative probability distribution.</span>
   ORIENTATION=orientation, $       <span class="comments">; The orientation of the lines.</span>
   OUTFILENAME=outfilename, $       <span class="comments">; The name of the output file.</span>
   OUTLINE=outline, $               <span class="comments">; Set this keyword if you wish to draw only the outline of the plot.</span>
   OUTPUT=output, $                 <span class="comments">; The type of output file desired.</span>
   PATTERN=pattern, $               <span class="comments">; The fill pattern.</span>
   POLYCOLOR=polycolorname, $       <span class="comments">; The name of the polygon draw/fill color.</span>
   POSITION=position, $             <span class="comments">; The position of the plot in the window in normalized coordinates.</span>
   PROBABILITY_FUNCTION=probability, $
   PROBCOLORNAME=probColorName, $   <span class="comments">; The color for the probability plot, if it is used. By default, "blue".</span>
   PROBTHICK=probthick, $           <span class="comments">; The thickness of the probability line.</span>
   REVERSE_INDICES=ri, $
   ROTATE=rotate, $                 <span class="comments">; Rotate plot so histogram bars are drawn left to right.</span>
   SMOOTH=smooth, $                 <span class="comments">; Run a smoothing filter of this width over the histogram data before plotting.</span>
   SPACING=spacing, $               <span class="comments">; The spacing of filled lines.</span>
   THICK=thick, $                   <span class="comments">; Set to draw thicker lines and axes.</span>
   TITLE=title, $                   <span class="comments">; The plot title.</span>
   WINDOW=window, $                 <span class="comments">; Display this in an cgWindow.</span>
   XTICKNAMES=xticknames, $
   XTICKFORMAT=xtickformat, $
   XTICKS=xticks, $
   XTICKVALUES=xtickvalues, $
   XTITLE=xtitle, $                 <span class="comments">; The X title.</span>
   YTICKNAMES=yticknames, $
   YTICKFORMAT=ytickformat, $
   YTICKS=yticks, $
   YTICKVALUES=ytickvalues, $
   YTITLE=ytitle, $                 <span class="comments">; The Y title.</span>
    _REF_EXTRA=extra                <span class="comments">; For passing extra keywords.</span>
    
   Compile_Opt idl2

   <span class="comments">; Catch any error in the cgHistoplot program.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(!Error_State.Msg + '. Returning...')
      IF N_Elements(nancount) EQ 0 THEN BEGIN
            IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
      ENDIF ELSE BEGIN
            IF nancount EQ 0 THEN BEGIN
                IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
            ENDIF
      ENDELSE
      IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
      RETURN
   ENDIF

    <span class="comments">; Should this be added to a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
        
        <span class="comments">; Have to do something different if we are overplotting or adding a command.</span>
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgHistoplot', $          <span class="comments">; The program name.</span>
               data, $                          <span class="comments">; The data to draw a histogram of.</span>
               AXISCOLORNAME=axisColorName, $   <span class="comments">; The axis color.</span>
               BACKCOLORNAME=backcolorName, $   <span class="comments">; The background color.</span>
               CHARSIZE=charsize, $
               COLOR=color, $
               DATACOLORNAME=datacolorName, $   <span class="comments">; The data color.</span>
               _EXTRA=extra, $                  <span class="comments">; For passing extra keywords.</span>
               FILENAME=file, $                 <span class="comments">; For specifying a color name file.</span>
               FREQUENCY=frequency, $           <span class="comments">; Plot relative frequency, rather than density.</span>
               LAYOUT=layout, $
               LOG=log, $
               MAX_VALUE=max_value, $           <span class="comments">; The maximum value to plot.</span>
               MIN_VALUE=min_value, $           <span class="comments">; The minimum value to plot.</span>
               MISSING=missing, $               <span class="comments">; The value that indicates "missing" data to be excluded from the histgram.</span>
               NOERASE=noerase, $               <span class="comments">; Set this keyword to avoid erasing when plot is drawn. </span>
               OPLOT=overplot, $
               OPROBABILITY=oprob, $            <span class="comments">; Overplot the cummulative probability distribution.</span>
               OUTLINE=outline, $               <span class="comments">; Set this keyword if you wish to draw only the outline of the plot.</span>
               POSITION=position, $             <span class="comments">; The position of the plot in the window in normalized coordinates.</span>
               PROBCOLORNAME=probColorName, $   <span class="comments">; The color for the probability plot, if it is used. By default, "blue".</span>
               PROBTHICK=probthick, $           <span class="comments">; The thickness of the probability line.</span>
               ROTATE=rotate, $
               SMOOTH=smooth, $
               THICK=thick, $                   <span class="comments">; Set to draw thicker lines and axes.</span>
               TITLE=title, $
               XTITLE=xtitle, $                 <span class="comments">; The X title.</span>
               XTICKNAMES=xticknames, $
               XTICKFORMAT=xtickformat, $
               XTICKS=xticks, $
               XTICKVALUES=xtickvalues, $
               YTITLE=ytitle, $                 <span class="comments">; The Y title.</span>
               YTICKNAMES=yticknames, $
               YTICKFORMAT=ytickformat, $
               YTICKS=yticks, $
               YTICKVALUES=ytickvalues, $
                           <span class="comments">;</span>
               <span class="comments">; POLYFILL KEYWORDS</span>
               <span class="comments">;</span>
               FILLPOLYGON=fillpolygon, $       <span class="comments">; Set if you want filled polygons</span>
               LINE_FILL=line_fill, $           <span class="comments">; Set if you want line-filled polygons.</span>
               LINE_THICK=line_thick, $         <span class="comments">; Change thickness of fill lines.</span>
               ORIENTATION=orientation, $       <span class="comments">; The orientation of the lines.</span>
               PATTERN=pattern, $               <span class="comments">; The fill pattern.</span>
               POLYCOLOR=polycolorname, $           <span class="comments">; The name of the polygon draw/fill color.</span>
               SPACING=spacing, $               <span class="comments">; The spacing of filled lines.</span>
               <span class="comments">;</span>
               <span class="comments">; HISTOGRAM OUTPUT KEYWORDS</span>
               <span class="comments">;</span>
               HISTDATA=histdata, $
               LOCATIONS=locations, $
               OMAX=omax, $
               OMIN=omin, $
               PROBABILITY_FUNCTION=probability, $
               REVERSE_INDICES=ri, $
               <span class="comments">;</span>
               <span class="comments">; HISTOGRAM INPUT KEYWORDS</span>
               <span class="comments">;</span>
               BINSIZE=binsize, $               <span class="comments">; The histogram bin size.</span>
               L64=l64, $                       <span class="comments">; Input for HISTOGRAM.</span>
               MAXINPUT=maxinput, $             <span class="comments">; The maximum value to HISTOGRAM.</span>
               MININPUT=mininput, $             <span class="comments">; The minimum value to HISTOGRAM.</span>
               NAN=nan, $                       <span class="comments">; Check for NAN.</span>
               NBINS=nbins, $                   <span class="comments">; The number of bins to display.</span>
               ADDCMD=1
            RETURN
        ENDIF 
        
        <span class="comments">; Otherwise, we are just replacing the commands in a new or existing window.</span>
            void = cgQuery(COUNT=wincnt)
            IF wincnt EQ 0 THEN replaceCmd=0 ELSE replaceCmd=1
            cgWindow, 'cgHistoplot', $          <span class="comments">; The program name.</span>
               data, $               <span class="comments">; The data to draw a histogram of.</span>
               AXISCOLORNAME=axisColorName, $   <span class="comments">; The axis color.</span>
               BACKCOLORNAME=backcolorName, $   <span class="comments">; The background color.</span>
               CHARSIZE=charsize, $
               COLOR=color, $
               DATACOLORNAME=datacolorName, $   <span class="comments">; The data color.</span>
               _EXTRA=extra, $                  <span class="comments">; For passing extra keywords.</span>
               FILENAME=file, $                 <span class="comments">; For specifying a color name file.</span>
               FREQUENCY=frequency, $           <span class="comments">; Plot relative frequency, rather than density.</span>
               LAYOUT=layout, $
               LOG=log, $
               MAX_VALUE=max_value, $           <span class="comments">; The maximum value to plot.</span>
               MIN_VALUE=min_value, $           <span class="comments">; The minimum value to plot.</span>
               MISSING=missing, $               <span class="comments">; The value that indicates "missing" data to be excluded from the histgram.</span>
               NOERASE=noerase, $               <span class="comments">; Set this keyword to avoid erasing when plot is drawn.               OPLOT=overplot, $                ; Set if you want overplotting.</span>
               OPLOT=overplot, $                <span class="comments">; Set if you want overplotting.</span>
               OPROBABILITY=oprob, $            <span class="comments">; Overplot the cummulative probability distribution.</span>
               OUTLINE=outline, $               <span class="comments">; Set this keyword if you wish to draw only the outline of the plot.</span>
               POSITION=position, $             <span class="comments">; The position of the plot in the window in normalized coordinates.</span>
               PROBCOLORNAME=probColorName, $   <span class="comments">; The color for the probability plot, if it is used. By default, "blue".</span>
               PROBTHICK=probthick, $           <span class="comments">; The thickness of the probability line.</span>
               ROTATE=rotate, $
               SMOOTH=smooth, $
               THICK=thick, $                   <span class="comments">; Set to draw thicker lines and axes.</span>
               TITLE=title, $
               XTITLE=xtitle, $                 <span class="comments">; The X title.</span>
               XTICKNAMES=xticknames, $
               XTICKFORMAT=xtickformat, $
               XTICKS=xticks, $
               XTICKVALUES=xtickvalues, $
               YTITLE=ytitle, $                 <span class="comments">; The Y title.</span>
               YTICKNAMES=yticknames, $
               YTICKFORMAT=ytickformat, $
               YTICKS=yticks, $
               YTICKVALUES=ytickvalues, $
                            <span class="comments">;</span>
               <span class="comments">; POLYFILL KEYWORDS</span>
               <span class="comments">;</span>
               FILLPOLYGON=fillpolygon, $       <span class="comments">; Set if you want filled polygons</span>
               LINE_FILL=line_fill, $           <span class="comments">; Set if you want line-filled polygons.</span>
               LINE_THICK=line_thick, $         <span class="comments">; Change thickness of fill lines.</span>
               ORIENTATION=orientation, $       <span class="comments">; The orientation of the lines.</span>
               PATTERN=pattern, $               <span class="comments">; The fill pattern.</span>
               POLYCOLOR=polycolorname, $           <span class="comments">; The name of the polygon draw/fill color.</span>
               SPACING=spacing, $               <span class="comments">; The spacing of filled lines.</span>
               <span class="comments">;</span>
               <span class="comments">; HISTOGRAM OUTPUT KEYWORDS</span>
               <span class="comments">;</span>
               HISTDATA=histdata, $
               LOCATIONS=locations, $
               OMAX=omax, $
               OMIN=omin, $
               PROBABILITY_FUNCTION=probability, $
               REVERSE_INDICES=ri, $
               <span class="comments">;</span>
               <span class="comments">; HISTOGRAM INPUT KEYWORDS</span>
               <span class="comments">;</span>
               BINSIZE=binsize, $               <span class="comments">; The histogram bin size.</span>
               L64=l64, $                       <span class="comments">; Input for HISTOGRAM.</span>
               MAXINPUT=maxinput, $             <span class="comments">; The maximum value to HISTOGRAM.</span>
               MININPUT=mininput, $             <span class="comments">; The minimum value to HISTOGRAM.</span>
               NAN=nan, $                       <span class="comments">; Check for NAN.</span>
               NBINS=nbins, $                   <span class="comments">; The number of bins to display.</span>
               REPLACECMD=replaceCmd
            RETURN
    ENDIF

    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    
    ENDIF
   
   <span class="comments">; Set up PostScript device for working with colors.</span>
   IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
   <span class="comments">; Check for parameters.</span>
   IF N_Elements(color) NE 0 THEN BEGIN
       IF Keyword_Set(fillpolygon) && (N_Elements(polycolorname) EQ 0) THEN polycolorname = color
       IF ~Keyword_Set(fillpolygon) && (N_Elements(datacolorname) EQ 0) THEN datacolorname = color
   ENDIF
   IF N_Elements(data) EQ 0 THEN Message, 'Must pass data to histogram.'
   IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize()
   IF N_Elements(smooth) NE 0 THEN BEGIN
     IF (smooth MOD 2) NE 0 THEN smooth = smooth + 1
   ENDIF
   IF N_Elements(position) EQ 0 && (Total(!P.Multi) LE 0) && (Total(!P.Position) EQ 0.0) THEN BEGIN
       IF Keyword_Set(oprob) THEN BEGIN
          IF Keyword_Set(rotate) THEN BEGIN
             position = [0.125, 0.125, 0.925, 0.875]
          ENDIF ELSE BEGIN
             position = [0.175, 0.125, 0.875, 0.925]
          ENDELSE
       ENDIF ELSE BEGIN
          IF Keyword_Set(rotate) THEN BEGIN
             position = [0.125, 0.15, 0.925, 0.925]
          ENDIF ELSE BEGIN
             position = [0.175, 0.125, 0.925, 0.875]
          ENDELSE
       ENDELSE
   ENDIF
   
   <span class="comments">; What kind of data are we doing a HISTOGRAM on?</span>
   dataType = Size(data, /TYPE)
      
   <span class="comments">; Check the data for NANs and alert the user if the NAN keyword is not set.</span>
   IF dataType EQ 4 OR datatype EQ 5 THEN BEGIN
        goodIndices = Where(Finite(data), count, NCOMPLEMENT=nancount, COMPLEMENT=nanIndices)
        IF nancount GT 0 THEN BEGIN
           IF ~Keyword_Set(nan) THEN BEGIN
               Message, 'NANs found in the data. NAN keyword is set to 1.', /INFORMATIONAL
               nan = 1
           ENDIF
        ENDIF 
   ENDIF 
   
   <span class="comments">; The only sensible way to proceed is to make a copy of the data. Otherwise, I'll have</span>
   <span class="comments">; a devil of a time putting it back together again at the end. There is a bug in</span>
   <span class="comments">; HISTOGRAM when using BYTE data, so convert that here</span>
   IF N_Elements(_data) EQ 0 THEN BEGIN
      IF Size(data, /TNAME) EQ 'BYTE' THEN BEGIN
          _data = Fix(data) 
       ENDIF ELSE BEGIN
          _data = data
       ENDELSE
   ENDIF
   
   <span class="comments">; If you have any "missing" data, then the data needs to be converted to float</span>
   <span class="comments">; and the missing data set to F_NAN.</span>
   IF N_Elements(missing) NE 0 THEN BEGIN
      missingIndices = Where(_data EQ missing, missingCount)
      IF missingCount GT 0 THEN BEGIN
         CASE datatype OF
            4: _data[missingIndices] = !Values.F_NAN
            5: _data[missingIndices] = !Values.D_NAN
            ELSE: BEGIN
                _data = Float(_data)
                dataType = 4
                _data[missingIndices] = !Values.F_NAN
                END
         ENDCASE
         nan = 1
      ENDIF ELSE BEGIN
        IF missingCount EQ N_Elements(_data) THEN $
            Message, 'All values are "missing"!'
      ENDELSE
   ENDIF
   
   <span class="comments">; Define minimum and maximum input values, if not defined otherwise.</span>
   IF N_Elements(minInput) EQ 0 THEN minInput = Min(_data, NAN=nan)
   IF N_Elements(maxInput) EQ 0 THEN maxInput = Max(_data, NAN=nan)

   <span class="comments">; Check for histogram keywords.</span>
   IF N_Elements(binsize) EQ 0 THEN BEGIN
      range = Max(_data &lt<span class="comments">; maxInput, /NAN) - Min(_data > minInput, /NAN)</span>
      IF N_Elements(nbins) EQ 0 THEN BEGIN  <span class="comments">; Scott's Choice</span>
         binsize = (3.5D * StdDev(minInput > _data &lt<span class="comments">; maxInput, /NAN))/N_Elements(_data)^(1./3.0D) </span>
         IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDIF ELSE BEGIN
         binsize = range / (nbins -1)
         IF dataType LE 3 THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDELSE
   ENDIF ELSE BEGIN
       IF Size(binsize, /TYPE) NE dataType THEN BEGIN
          IF dataType LE 3 THEN binsize = Round(binsize) > 1
          binsize = Convert_To_Type(binsize, dataType)
       ENDIF
   ENDELSE

   <span class="comments">; Check for keywords.</span>
   IF N_Elements(backColorName) EQ 0 THEN backColorName = "background"
   IF N_Elements(dataColorName) EQ 0 THEN dataColorName = "Indian Red"
   SetDefaultValue, title, ""
   
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       IF N_Elements(position) NE 0 THEN Undefine, position
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

   <span class="comments">; Choose an axis color.</span>
   IF N_Elements(axisColorName) EQ 0 AND N_Elements(saxescolor) NE 0 THEN axisColorName = saxescolor
   axisColorName = cgDefaultColor(axisColorName, DEFAULT='opposite')
   IF N_Elements(polycolorname) EQ 0 THEN polycolorname = "Rose"
   IF N_Elements(probColorname) EQ 0 THEN probColorname = "Blue"
   frequency = Keyword_Set(frequency)
   line_fill = Keyword_Set(line_fill)
   IF line_fill THEN fillpolygon = 1
   log = Keyword_Set(log)
   fillpolygon = Keyword_Set(fillpolygon)
   IF fillpolygon THEN BEGIN
      IF N_Elements(orientation) EQ 0 THEN orientation = 0
      IF N_Elements(spacing) EQ 0 THEN spacing = 0
   ENDIF
   IF N_Elements(thick) EQ 0 THEN thick = 1.0

   <span class="comments">; Do this in decomposed color, if possible.</span>
   SetDecomposedState, 1, CURRENT=currentState
   
   <span class="comments">; Load plot colors.</span>
   TVLCT, r, g, b, /GET
   
   <span class="comments">; If needed create a window first, so the drawing</span>
   <span class="comments">; colors are correct for the window you want to draw into.</span>
   IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) && ~Keyword_Set(overplot) THEN cgDisplay
   axisColor = cgColor(axisColorName, FILE=file)
   dataColor = cgColor(datacolorName, FILE=file)
   backColor = cgColor(backColorName, FILE=file)
   polyColor = cgColor(polyColorName, FILE=file)
   probColor = cgColor(probColorName, FILE=file)

   <span class="comments">; Set up some labels.</span>
   IF frequency THEN BEGIN
      IF Keyword_Set(rotate) THEN BEGIN
          IF N_Elements(xtitle) EQ 0 THEN xtitle = 'Relative Frequency'
          IF (N_Elements(xtickformat) EQ 0) && (N_Elements(xticknames) EQ 0) THEN xtickformat = '(F6.4)'
      ENDIF ELSE BEGIN
          IF N_Elements(ytitle) EQ 0 THEN ytitle = 'Relative Frequency'
          IF (N_Elements(ytickformat) EQ 0) && (N_Elements(yticknames) EQ 0) THEN ytickformat = '(F6.4)'
      ENDELSE
   ENDIF ELSE BEGIN
      IF Keyword_Set(rotate) THEN BEGIN
          IF N_Elements(xtitle) EQ 0 THEN xtitle = 'Histogram Density'
          IF (N_Elements(xtickformat) EQ 0) && (N_Elements(xticknames) EQ 0) THEN BEGIN
            IF Keyword_Set(log) THEN xtickformat = '(F)' ELSE xtickformat = '(I)'
          ENDIF
      ENDIF ELSE BEGIN
          IF N_Elements(ytitle) EQ 0 THEN ytitle = 'Histogram Density'
          IF (N_Elements(ytickformat) EQ 0) && (N_Elements(yticknames) EQ 0) THEN BEGIN
            IF Keyword_Set(log) THEN ytickformat = '(F)' ELSE ytickformat = '(I)'
          ENDIF
      ENDELSE
   ENDELSE
   
   <span class="comments">; Check for symbols in titles.</span>
   IF N_Elements(title) NE 0 THEN title = cgCheckForSymbols(title)
   IF N_Elements(xtitle) NE 0 THEN xtitle = cgCheckForSymbols(xtitle)
   IF N_Elements(ytitle) NE 0 THEN ytitle = cgCheckForSymbols(ytitle)
   
   
   <span class="comments">; Calculate the histogram.</span>
    histdata = Histogram(_data, $
      BINSIZE=binsize, $
      L64=l64, $
      MAX=maxinput, $
      MIN=mininput, $
      NAN=nan, $
      LOCATIONS=locations, $
      OMAX=omax, $
      OMIN=omin, $
      REVERSE_INDICES=ri)

   <span class="comments">; Do you need to smooth the data?</span>
   IF N_Elements(smooth) NE 0 THEN histdata = Smooth(histdata, smooth)
   
   <span class="comments">; Are you plotting the frequency rather than the count?</span>
   IF frequency THEN histdata = Float(histdata)/N_Elements(_data)
   
   <span class="comments">; Need a probability distribution?</span>
   IF Arg_Present(probability) OR Keyword_Set(oprob) THEN BEGIN
       cumTotal = Total(histData, /CUMULATIVE)
       probability = Total(Double(histdata)/Total(Double(histdata)), /CUMULATIVE)
   ENDIF

   <span class="comments">; Calculate the range of the plot output.</span>
   IF N_Elements(min_value) EQ 0 THEN BEGIN
      IF Keyword_Set(log) THEN min_value = 1e-3 ELSE min_value = 0
   ENDIF
   IF N_Elements(max_value) EQ 0 THEN BEGIN
      IF Keyword_Set(log) $
        THEN max_value = Max(histData) * 1.25 $
        ELSE max_value = Max(histData) * 1.05
   ENDIF
   IF Keyword_Set(rotate) THEN BEGIN
       xmin = min_value
       xmax = max_value
       ymin = Double(omin) - binsize
       ymax = Double(omax) + (binsize * 1.5)
   ENDIF ELSE BEGIN
       ymin = min_value
       ymax = max_value
       xmin = Double(omin) - binsize
       xmax = Double(omax) + (binsize * 1.5)
   ENDELSE
   
   <span class="comments">; Save the current system variables, if doing multiple plots.</span>
   IF Total(!P.MULTI) NE 0 THEN BEGIN
      bangp = !P
      bangx = !X
      bangy = !Y
      bangmap = !MAP
   ENDIF
   
   
   <span class="comments">; Unless we are overplotting, draw the plot to establish a data coordinate system.</span>
   <span class="comments">; Don't actually display anything yet, because we may have to repair damage caused</span>
   <span class="comments">; by polygon filling.</span>
   xrange = [xmin, xmax]
   yrange = [ymin, ymax]
   IF ~Keyword_Set(overplot) THEN BEGIN
       IF Keyword_Set(rotate) THEN BEGIN
          Plot, [0,0], xrange=xrange, yrange=yrange, $             
             Background=backColor, $
             Color=axisColor, $                       <span class="comments">; The color of the axes.</span>
             Charsize=charsize, $
             XLOG=log, $
             NoData=1, $                              <span class="comments">; Draw the axes only. No data.</span>
             NOERASE=noerase, $
             POSITION=position, $
             TITLE=title, $
             XTHICK=thick, $                          <span class="comments">; Axes thicker, if needed.</span>
             YTHICK=thick, $
             XStyle=5, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             YMinor=0, $                              <span class="comments">; No minor tick mark on X axis.</span>
             YStyle=5, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             XTickformat='(A1)', $                    <span class="comments">; No format. Nothing drawn</span>
             YTickformat='(A1)', $                    <span class="comments">; No format. Nothing drawn</span>
             _Strict_Extra=extra                      <span class="comments">; Pass any extra PLOT keywords.</span>
       ENDIF ELSE BEGIN
          Plot, [0,0], xrange=xrange, yrange=yrange, $             
             Background=backColor, $
             Color=axisColor, $                       <span class="comments">; The color of the axes.</span>
             Charsize=charsize, $
             YLOG=log, $
             NoData=1, $                              <span class="comments">; Draw the axes only. No data.</span>
             NOERASE=noerase, $
             POSITION=position, $
             TITLE=title, $
             XTHICK=thick, $                          <span class="comments">; Axes thicker, if needed.</span>
             YTHICK=thick, $
             XStyle=5, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             YMinor=0, $                              <span class="comments">; No minor tick mark on X axis.</span>
             YStyle=5, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             XTickformat='(A1)', $                    <span class="comments">; No format. Nothing drawn</span>
             YTickformat='(A1)', $                    <span class="comments">; No format. Nothing drawn</span>
             _Strict_Extra=extra                      <span class="comments">; Pass any extra PLOT keywords.</span>
        ENDELSE
   ENDIF

   <span class="comments">; Save the after-plot system variables, if doing multiple plots.</span>
   <span class="comments">; You will need it to advance the plots in !P.MULTI, since you draw</span>
   <span class="comments">; the plots with NOERASE.</span>
   IF Total(!P.MULTI) NE 0 THEN BEGIN
       bangAfterp = !P
       bangAfterx = !X
       bangAftery = !Y
       bangAftermap = !MAP
   ENDIF

   <span class="comments">; Do we need to have things be filled?</span>
   IF Keyword_Set(fillpolygon) THEN BEGIN

       ncolors = N_Elements(polycolor)

      <span class="comments">; Are we line filling?</span>
      IF line_fill THEN BEGIN

         norient = N_Elements(orientation)
         nspace = N_Elements(spacing)
         step = (xrange[1] - xrange[0]) / (binsize + 1)
         IF Keyword_Set(rotate) THEN BEGIN
            start = yrange[0] + binsize
         ENDIF ELSE BEGIN
            start = xrange[0] + binsize
         ENDELSE

         endpt = start + binsize
         FOR j=0,N_Elements(histdata)-1 DO BEGIN
            IF Keyword_Set(rotate) THEN BEGIN
               y = [start, start, endpt, endpt, start]
               IF log THEN BEGIN
                  x = [1, histdata[j], histdata[j], 1, 1]
               ENDIF ELSE BEGIN
                  x = [0, histdata[j], histdata[j], 0, 0]
               ENDELSE
            ENDIF ELSE BEGIN
               x = [start, start, endpt, endpt, start]
               IF log THEN BEGIN
                  y = [1, histdata[j], histdata[j], 1, 1]
               ENDIF ELSE BEGIN
                  y = [0, histdata[j], histdata[j], 0, 0]
               ENDELSE
            ENDELSE
            fillcolor = polycolor[j MOD ncolors]
            orient = orientation[j MOD norient]
            space = spacing[j MOD nspace]
            PolyFill, x, y, COLOR=fillColor, /LINE_FILL, ORIENTATION=orient, $
               PATTERN=pattern, SPACING=space, NOCLIP=0, THICK=line_thick
            start = start + binsize
            endpt = start + binsize
         ENDFOR

      ENDIF ELSE BEGIN <span class="comments">; Normal polygon color fill.</span>

         step = (xrange[1] - xrange[0]) / (binsize + 1)
         IF Keyword_Set(rotate) THEN BEGIN
            start = yrange[0] + binsize
         ENDIF ELSE BEGIN
            start = xrange[0] + binsize
         ENDELSE
         endpt = start + binsize
         FOR j=0,N_Elements(histdata)-1 DO BEGIN
            IF Keyword_Set(rotate) THEN BEGIN
               y = [start, start, endpt, endpt, start]
               IF log THEN BEGIN
                   x = [!X.CRange[0], histdata[j], histdata[j], !X.CRange[0], !X.CRange[0]]
               ENDIF ELSE BEGIN
                   x = [0, histdata[j], histdata[j], 0, 0]
               ENDELSE
            ENDIF ELSE BEGIN
               x = [start, start, endpt, endpt, start]
               IF log THEN BEGIN
                  y = [!Y.CRange[0], histdata[j], histdata[j], !Y.CRange[0], !Y.CRange[0]]
               ENDIF ELSE BEGIN
                  y = [0, histdata[j], histdata[j], 0, 0]
               ENDELSE
            ENDELSE
            fillcolor = polycolor[j MOD ncolors]
            PolyFill, x, y, COLOR=fillColor, NOCLIP=0
            start = start + binsize
            endpt = start + binsize
         ENDFOR

      ENDELSE
   ENDIF
      
   <span class="comments">; Restore the pre-plot system variables.</span>
   IF Total(!P.MULTI) NE 0 THEN BEGIN
       !P = bangp
       !X = bangx
       !Y = bangy
       !MAP = bangmap
    ENDIF

   IF ~Keyword_Set(overplot) THEN BEGIN
       xrange = [xmin, xmax]
       yrange = [ymin, ymax]
       IF Keyword_Set(oprob) THEN BEGIN
          IF Keyword_Set(rotate) THEN BEGIN
             xstyle = 9
             ystyle = 9
          ENDIF ELSE BEGIN
             xstyle = 9
             ystyle = 9
          ENDELSE
       ENDIF ELSE BEGIN
          IF Keyword_Set(rotate) THEN BEGIN
             xstyle = 1
             ystyle = 9
          ENDIF ELSE BEGIN
             xstyle = 9
             ystyle = 1
          ENDELSE
       ENDELSE
       IF Keyword_Set(rotate) THEN BEGIN
       Plot, [0,0], xrange=xrange, yrange=yrange, $             
             Background=backColor, $
             Charsize=charsize, $
             Color=axisColor, $                       <span class="comments">; The color of the axes.</span>
             POSITION=position, $
             XLOG=log, $
             NoData=1, $                              <span class="comments">; Draw the axes only. No data.</span>
             XThick=thick, $  
             YThick=thick, $
             YStyle=ystyle, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             XMinor=1, $                              <span class="comments">; No minor tick mark on X axis.</span>
             XStyle=xstyle, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             XTickformat=xtickformat, $               <span class="comments">; Y Tickformat</span>
             YTickformat=ytickformat, $
             XTITLE=xtitle, $                 <span class="comments">; The X title.</span>
             XTICKNAMES=xticknames, $
             XTICKS=xticks, $
             XTICKVALUES=xtickvalues, $
             YTITLE=ytitle, $                 <span class="comments">; The Y title.</span>
             YTICKNAMES=yticknames, $
             YTICKS=yticks, $
             YTICKVALUES=ytickvalues, $
             NoErase=1, $
             YTicklen=-0.025, $
             _Strict_Extra=extra                      <span class="comments">; Pass any extra PLOT keywords.</span>
       ENDIF ELSE BEGIN
       Plot, [0,0], xrange=xrange, yrange=yrange, $             
             Background=backColor, $
             Charsize=charsize, $
             Color=axisColor, $                       <span class="comments">; The color of the axes.</span>
             POSITION=position, $
             YLOG=log, $
             NoData=1, $                              <span class="comments">; Draw the axes only. No data.</span>
             XThick=thick, $  
             YThick=thick, $
             XStyle=xstyle, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             YMinor=1, $                              <span class="comments">; No minor tick mark on X axis.</span>
             YStyle=ystyle, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
             XTickformat=xtickformat, $               <span class="comments">; Y Tickformat</span>
             YTickformat=ytickformat, $
             XTITLE=xtitle, $                 <span class="comments">; The X title.</span>
             XTICKNAME=xticknames, $
             XTICKS=xticks, $
             XTICKV=xtickvalues, $
             YTITLE=ytitle, $                 <span class="comments">; The Y title.</span>
             YTICKNAME=yticknames, $
             YTICKS=yticks, $
             YTICKV=ytickvalues, $
             NoErase=1, $
             XTicklen=-0.025, $
             _Strict_Extra=extra                      <span class="comments">; Pass any extra PLOT keywords.</span>
        ENDELSE
             
        <span class="comments">; Repair the damage caused by polygon filling.</span>
        IF Keyword_Set(rotate) THEN BEGIN
            IF log THEN BEGIN
                Axis, 10^!X.CRange[1], 10^!Y.CRange[0], YAXIS=1, YTickformat='(A1)', YMINOR=1, $
                    COLOR=axisColor, YSTYLE=1, YTHICK=thick, CHARSIZE=charsize, XLOG=1
            ENDIF ELSE BEGIN
                Axis, !X.CRange[1], !Y.CRange[0], YAXIS=1, YTickformat='(A1)', YMINOR=1, $
                    COLOR=axisColor, YSTYLE=1, YTHICK=thick, CHARSIZE=charsize
            ENDELSE
        ENDIF ELSE BEGIN
            IF log THEN BEGIN
            Axis, 10^!X.CRange[0], 10^!Y.CRange[1], XAXIS=1, XTickformat='(A1)', XMINOR=1, $
                COLOR=axisColor, XSTYLE=1, XTHICK=thick, CHARSIZE=charsize, /YLOG
            ENDIF ELSE BEGIN
            Axis, !X.CRange[0], !Y.CRange[1], XAXIS=1, XTickformat='(A1)', XMINOR=1, $
                COLOR=axisColor, XSTYLE=1, XTHICK=thick, CHARSIZE=charsize
            ENDELSE
        ENDELSE

   ENDIF
    
    step = (xrange[1] - xrange[0]) / (binsize + 1)
    IF Keyword_Set(rotate) THEN BEGIN
        start = yrange[0] + binsize
    ENDIF ELSE BEGIN
        start = xrange[0] + binsize
    ENDELSE
    endpt = start + binsize
    IF log THEN BEGIN
       IF Keyword_Set(rotate) THEN ystart = 10^!X.CRange[0] ELSE ystart = 10^!Y.CRange[0] 
    ENDIF ELSE ystart = 0
    jend = N_Elements(histdata)-1
    FOR j=0,jend DO BEGIN
        IF Keyword_Set(outline) THEN BEGIN
           IF Keyword_Set(rotate) THEN BEGIN
               Plots, [ystart, histdata[j]], [start, start], COLOR=dataColor, THICK=thick, NOCLIP=0
               Plots, [histdata[j], histdata[j]], [start, endpt], COLOR=dataColor, THICK=thick, NOCLIP=0
               IF j EQ jend THEN BEGIN
                  Plots, [histdata[j], xrange[0]], [endpt, endpt], COLOR=dataColor, THICK=thick, NOCLIP=0
               ENDIF
           ENDIF ELSE BEGIN
               Plots, [start, start], [ystart, histdata[j]], COLOR=dataColor, THICK=thick, NOCLIP=0
               Plots, [start, endpt], [histdata[j], histdata[j]], COLOR=dataColor, THICK=thick, NOCLIP=0
               IF j EQ jend THEN BEGIN
                  Plots, [endpt, endpt], [yrange[0], histdata[j]], COLOR=dataColor, THICK=thick, NOCLIP=0
               ENDIF
           ENDELSE
           start = start + binsize
           endpt = start + binsize
           ystart = histdata[j]
        ENDIF ELSE BEGIN
           x = [start, start, endpt, endpt, start]
           y = [ystart, histdata[j], histdata[j], ystart, ystart]
           IF Keyword_Set(rotate) THEN BEGIN
              PLOTS, y, x, COLOR=dataColor, NOCLIP=0, THICK=thick
           ENDIF ELSE BEGIN
              PLOTS, x, y, COLOR=dataColor, NOCLIP=0, THICK=thick
           ENDELSE
           start = start + binsize
           endpt = start + binsize
        ENDELSE
    ENDFOR
   
   <span class="comments">; Need to overplot probability function?</span>
   IF Keyword_Set(oprob) THEN BEGIN
   
        <span class="comments">; Save the current axes system variable so they can be restored after</span>
        <span class="comments">; the axis is drawn.</span>
        xsave = !X
        ysave = !Y
        
        <span class="comments">; If you are plotting the probability plot, label the axes appropriately.</span>
        IF Keyword_Set(overplot) THEN style = 5 ELSE style = 1
        IF Keyword_Set(rotate) THEN BEGIN
            Axis, !X.CRange[0], !Y.CRange[1], XAXIS=1, COLOR=axisColor, /SAVE, $
                 XSTYLE=style, XTHICK=thick, CHARSIZE=charsize, XRANGE=[0.0,1.0005], XTITLE='Cumulative Probability'
        ENDIF ELSE BEGIN
            Axis, !X.CRange[1], !Y.CRange[0], YAXIS=1, YMINOR=1, COLOR=axisColor, /SAVE, $
                 YSTYLE=style, YTHICK=thick, CHARSIZE=charsize, YRANGE=[0.0,1.0005], YTITLE='Cumulative Probability'
        ENDELSE
        IF N_Elements(probthick) EQ 0 THEN probthick = (!D.Name NE 'PS') ? 1.0 : 3.0
        IF Keyword_Set(rotate) THEN BEGIN
            proby = locations + (binsize/2.0)
            Oplot, probability, proby, COLOR=probcolor, THICK=probthick<span class="comments">;, PSYM=2</span>
        ENDIF ELSE BEGIN
            probx = locations + (binsize/2.0)
            Oplot, probx, probability, COLOR=probcolor, THICK=probthick<span class="comments">;, PSYM=2</span>
        ENDELSE
        
        <span class="comments">; Restore the axes system variables.</span>
        !X = xsave
        !Y = ysave
        
   ENDIF

   <span class="comments">; Advance the plot for !P.Multi purposes.</span>
   IF Total(!P.MULTI) NE 0 THEN BEGIN
       !P = bangAfterp 
       !X = bangAfterx 
       !Y = bangAftery
       !MAP = bangAftermap
   ENDIF

   <span class="comments">; Clean up. But you really can't do this in the Z-buffer. </span>
   IF !D.Name NE 'Z' THEN TVLCT, r, g, b
   
    <span class="comments">; Clean up if you are using a layout.</span>
    IF N_Elements(layout) NE 0 THEN !P.Multi = thisMulti

    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width
              
         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
    <span class="comments">; Clean up.</span>
    SetDecomposedState, currentState
END
</code>
    </div>
  </body>
</html>