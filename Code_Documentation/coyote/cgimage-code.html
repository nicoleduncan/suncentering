<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:11 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgimage.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgimage.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">; The purpose of this program is to create a TV command that works the way</span>
<span class="comments">; the TV command would be expected to work if it was written today, rather</span>
<span class="comments">; than 25 years ago. In other words, it knows the difference between an</span>
<span class="comments">; 8-bit device and a 24-bit device, it honors the POSITION keyword like </span>
<span class="comments">; other graphics commands in IDL, it honors the !P.MULTI value, like other</span>
<span class="comments">; graphics commands in IDL, it works seamlessly with both 8-bit and 24-bit</span>
<span class="comments">; images. In addition to other modern features, this program can also </span>
<span class="comments">; display images that contain an alpha channel and can display images with</span>
<span class="comments">; transparency.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of this program is to create a TV command that works the way</span>
<span class="comments">; the TV command would be expected to work if it was written today, rather</span>
<span class="comments">; than 25 years ago. In other words, it knows the difference between an</span>
<span class="comments">; 8-bit device and a 24-bit device, it honors the POSITION keyword like </span>
<span class="comments">; other graphics commands in IDL, it honors the !P.MULTI value, like other</span>
<span class="comments">; graphics commands in IDL, it works seamlessly with both 8-bit and 24-bit</span>
<span class="comments">; images. In addition to other modern features, this program can also </span>
<span class="comments">; display images that contain an alpha channel and can display transparent</span>
<span class="comments">; images.</span>
<span class="comments">;   </span>
<span class="comments">; There is a common block in cgImage that is defined as follows upon exiting</span>
<span class="comments">; this command::</span>
<span class="comments">; </span>
<span class="comments">;    COMMON FSC_$CGIMAGE, $</span>
<span class="comments">;       _cgimage_xsize, $    ; The X size of the image.</span>
<span class="comments">;       _cgimage_ysize, $    ; The Y size of the imge.</span>
<span class="comments">;       _cgimage_winxsize, $ ; The X size of the window displaying the image.</span>
<span class="comments">;       _cgimage_winysize, $ ; The Y size of the window displaying the image.</span>
<span class="comments">;       _cgimage_position, $ ; The final position of the image in the window.</span>
<span class="comments">;       _cgimage_winID, $    ; The window index number of the window displaying the image.</span>
<span class="comments">;       _cgimage_current     ; Set to 1 if a call to cgImage is made.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">; </span>
<span class="comments">; To learn more about transparent images and cgImage see the article</span>
<span class="comments">; `Working with Transparent Images and cgImage &lt;http://www.idlcoyote.com/cg_tips/transimage.php>`. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;       </span>
<span class="comments">; :Examples:</span>
<span class="comments">;     To display an image with a contour plot on top of it, type::</span>
<span class="comments">;</span>
<span class="comments">;        filename = FILEPATH(SUBDIR=['examples','data'], 'worldelv.dat')</span>
<span class="comments">;        image = BYTARR(360,360)</span>
<span class="comments">;        OPENR, lun, filename, /GET_LUN</span>
<span class="comments">;        READU, lun, image</span>
<span class="comments">;        FREE_LUN, lun</span>
<span class="comments">;</span>
<span class="comments">;        thisPostion = [0.1, 0.1, 0.9, 0.9]</span>
<span class="comments">;        cgIMAGE, image, POSITION=thisPosition, /KEEP_ASPECT_RATIO</span>
<span class="comments">;        CONTOUR, image, POSITION=thisPosition, /NOERASE, XSTYLE=1, $</span>
<span class="comments">;            YSTYLE=1, XRANGE=[0,360], YRANGE=[0,360], NLEVELS=10</span>
<span class="comments">;</span>
<span class="comments">;     To display four images in a window without spacing between them::</span>
<span class="comments">;</span>
<span class="comments">;        !P.Multi=[0,2,2]</span>
<span class="comments">;        cgImage, image, Margin=0</span>
<span class="comments">;        cgImage, image, Margin=0</span>
<span class="comments">;        cgImage, image, Margin=0</span>
<span class="comments">;        cgImage, image, Margin=0</span>
<span class="comments">;        !P.Multi = 0</span>
<span class="comments">;</span>
<span class="comments">;     To display four image in a window with associated color bars::</span>
<span class="comments">;</span>
<span class="comments">;        !P.Multi=[0,2,2]</span>
<span class="comments">;        p = [0.02, 0.3, 0.98, 0.98]</span>
<span class="comments">;        LoadCT, 0</span>
<span class="comments">;        cgImage, image, Position=p</span>
<span class="comments">;        cgColorbar, Position=[p[0], p[1]-0.1, p[2], p[1]-0.05]</span>
<span class="comments">;        p = [0.02, 0.3, 0.98, 0.98]</span>
<span class="comments">;        LoadCT, 2</span>
<span class="comments">;        cgImage, image, Position=p</span>
<span class="comments">;        cgColorbar, Position=[p[0], p[1]-0.1, p[2], p[1]-0.05]</span>
<span class="comments">;        p = [0.02, 0.3, 0.98, 0.98]</span>
<span class="comments">;        LoadCT, 3</span>
<span class="comments">;        cgImage, image, Position=p</span>
<span class="comments">;        cgColorbar, Position=[p[0], p[1]-0.1, p[2], p[1]-0.05]</span>
<span class="comments">;        p = [0.02, 0.3, 0.98, 0.98]</span>
<span class="comments">;        LoadCT, 5</span>
<span class="comments">;        cgImage, image, Position=p</span>
<span class="comments">;        cgColorbar, Position=[p[0], p[1]-0.1, p[2], p[1]-0.05]</span>
<span class="comments">;        !P.Multi =0</span>
<span class="comments">;     </span>
<span class="comments">;     To set a missing value to -32767 and the color white and do</span>
<span class="comments">;     a 3% histogram clip of the image::</span>
<span class="comments">;     </span>
<span class="comments">;        cgLoadCT, 4, /Brewer, NColors=254</span>
<span class="comments">;        TVLCT, palette, /Get</span>
<span class="comments">;        cgImage, image, Missing_Value=-32767, Missing_Color='white', Stretch='Clip', Clip=3</span>
<span class="comments">;        </span>
<span class="comments">;     To display a transparent image on top of another image::</span>
<span class="comments">;     </span>
<span class="comments">;        cgImage, cgDemoData(7), CTIndex=0</span>
<span class="comments">;        cgImage, cgDemoData(5), CTIndex=33, Transparent=50, $</span>
<span class="comments">;             AlphaFGPosition=[0.25, 0.25, 0.75, 0.75], Missing_Value=0</span>
<span class="comments">;   </span>
<span class="comments">; .. image:: cgimage.png</span>
<span class="comments">; </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;        David W. Fanning </span>
<span class="comments">;        1645 Sheely Drive</span>
<span class="comments">;        Fort Collins, CO 80526 USA</span>
<span class="comments">;        Phone: 970-221-0438</span>
<span class="comments">;        E-mail: david@idlcoyote.com</span>
<span class="comments">;        Coyote's Guide to IDL Programming: http://www.idlcoyote.com/</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Modification History::</span>
<span class="comments">;      Written by: David W. Fanning, from modifications to TVIMAGE. 3 Feb 2011.</span>
<span class="comments">;      8 Feb 2011. Added OPOSITION keyword. DWF.</span>
<span class="comments">;      27 Feb 2011. Added keywords to make cgImage more compatible with TVImage calls. DWF.</span>
<span class="comments">;      Color table vectors must be obtained AFTER loading the color palette. 6 March 2011. DWF.</span>
<span class="comments">;      I have been convinced (conversations with Wayne Landsman) that if the </span>
<span class="comments">;         CENTER keyword is set, the MINUS_ONE keyword is not needed, since </span>
<span class="comments">;         it was created to solve the same problem. So, I have changed the </span>
<span class="comments">;         default setting of MINUS_ONE to 0. 14 March 2011. DWF.</span>
<span class="comments">;       Corrected a problem with restoring color tables if a PALETTE is used. 31 March 2011. DWF.</span>
<span class="comments">;       Whoops! Documented a CHARSIZE keyword, but forgot to define it. 7 July 2011.</span>
<span class="comments">;       Damnation! I did the same thing with the FONT keyword! 25 July 2011.</span>
<span class="comments">;       And now a TITLE keyword! What the devil is going on!? 29 Aug 2011.</span>
<span class="comments">;       Very slight modifications to image size and start position so that the image is</span>
<span class="comments">;          positioned completely inside the axes. 30 Sept 2011. DWF.</span>
<span class="comments">;       Fitting the image inside the axes causes image matching problems (and lines!) in</span>
<span class="comments">;          other programs, so I've decided to only do positioning inside axes when the</span>
<span class="comments">;          user asks for this capability by setting the new FIT_INSIDE keyword. 16 Nov 2011. DWF.</span>
<span class="comments">;       Problem with transparent images with alpha channels caused by changes in the TVImage->cgImage</span>
<span class="comments">;          transition. Added AlphaFGPosition keyword to address issues. Cleaned up the</span>
<span class="comments">;          code and improved the internal documentation. 22 Nov 2011. DWF.</span>
<span class="comments">;       Added the ability to stretch 2D image arrays in various ways before display. 1 Dec 2011.</span>
<span class="comments">;       Added the ability to handle missing data in 2D arrays before display. 1 Dec 2011.</span>
<span class="comments">;       Added a DISPLAY keyword to display the image in windows with the image aspect ratio. 2 Dec 2011.</span>
<span class="comments">;       Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;       PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2001. DWF.</span>
<span class="comments">;       Modified to use cgDefaultColor for default color selection. 24 Dec 2011. DWF.</span>
<span class="comments">;       Changes to allow better default colors, based on changes to cgColor and cgDefaultColor. 1 Feb 2012. DWF.</span>
<span class="comments">;       I was passing the wrong MINVALUE and MAXVALUE values to the scaling function. 12 Feb 2012. DWF.</span>
<span class="comments">;       I made cgImage aware of a "feature" of MAP_SET that sets !P.MULTI[0]=-1, which was screwing</span>
<span class="comments">;          up the algorithm to cause cgImage to erase the display window. 28 Feb 2012. DWF.</span>
<span class="comments">;       Added a Standard Deviation stretch, including the EXCLUDE and MULTIPLIER keywords to the</span>
<span class="comments">;          SDevScl command. 6 June 2012. DWF.</span>
<span class="comments">;       Now saving the image POSITION in FSC_$CGIMAGE common block, even if in PostScript, because other</span>
<span class="comments">;          routines (e.g., cgMap) may depend on it (e.g., using ONIMAGE keyword). 26 July 2012. DWF.</span>
<span class="comments">;       Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;       Modified the way the XRANGE and YRANGE keywords work when the OVERPLOT keyword is also set. In this case,</span>
<span class="comments">;          I will modify the image position to honor the XRANGE and YRANGE values with respect to the axes that the</span>
<span class="comments">;          image is being overplot onto. 15 August 2012. DWF.</span>
<span class="comments">;       Set the NOERASE keyword if the OVERPLOT keyword is set and NOERASE is undefined. 16 Aug 2012. DWF.</span>
<span class="comments">;       Modified the way the HIST_EQUAL stretch works. Previously the image was displayed as all zeros</span>
<span class="comments">;          if the input image had a minimum value less that zero. 21 Aug 2012. DWF.</span>
<span class="comments">;       Fixed a problem with the INTERPOLATE variable that prevented interpolaton from occurring. 12 Sept 2012. DWF.</span>
<span class="comments">;       A misspelled MULTIPLIER keyword was interfering with a Standard Deviation stretch. 16 Sept 2012. DWF</span>
<span class="comments">;       Added the TRANSPARENT keyword to allow transparent display of images. 17 October 2012. DWF.</span>
<span class="comments">;       Added the MAPCOORD keyword to allow the XRANGE and YRANGE of the image to be specified by the map </span>
<span class="comments">;          coordinate object. 17 October 2012. DWF.</span>
<span class="comments">;       Added CTINDEX, BREWER, and REVERSE keywords to make loading a color table palette easier. 17 October 2012. DWF.</span>
<span class="comments">;       Now setting MISSING_VALUE pixels to completely transparent if a transparent image is created. 17 October 2012. DWF.</span>
<span class="comments">;       Added the ability to apply a stretch to a 2D image prior to converting it to a transparent image. 18 October 2012.DWF.   </span>
<span class="comments">;       Added a FILENAME keyword so that files of known format (GeoTIFF, JPEG, PNG, etc.) can be read to supply an</span>
<span class="comments">;          image for display. 18 October 2012. DWF.</span>
<span class="comments">;       Fixed a problem that prevented transparent images from be displayed with !P.Multi. 20 Oct 2012. DWF.</span>
<span class="comments">;       Provided a fix to allow transparent images in versions of IDL from IDL 6.4 and earlier. 18 Nov 2012. DWF.</span>
<span class="comments">;       When reading a GeoTiff file, the map object created should be named mapCoord, not map, so that</span>
<span class="comments">;          the image data ranges can be set automatically. 11 January 2013. DWF.</span>
<span class="comments">;       Additional work to allow overplotting of transparent images. 12 Jan 2013. DWF.</span>
<span class="comments">;       For some reason I thought I had to have transparency ON when overplotting. This turns out to be wrong</span>
<span class="comments">;           and gets in the way of outputting to PostScript and working with some map projected images. I've</span>
<span class="comments">;           removed this requirement in the code. I also fixed a problem in which the OUTPUT position changes</span>
<span class="comments">;           if the TRANSPARENT keyword is used. 27 January 2013. DWF.</span>
<span class="comments">;       I had some code dealing with XRANGE and YRANGE properties of the image when a map coodinate object</span>
<span class="comments">;           was used with cgImage. This was inadvertently setting the XRANGE and YRANGE properties of the</span>
<span class="comments">;           image, which was in turn causing the range values to be SAVED in the plotting system variables.</span>
<span class="comments">;           This interferred with backward compatibility with the TV command, so I have removed it. 31 Jan 2013. DWF. </span>
<span class="comments">;       Whoops! Typo in my last fix. Getting too old, I guess. 6 Feb 2013. DWF.</span>
<span class="comments">;       Setting any of the MISSING_*** keywords while doing multiple plots resulted in the value</span>
<span class="comments">;           of !P.Multi being ignored for the image. This is fixed for now, but just a warning. Setting</span>
<span class="comments">;           these keywords creates transparent images, and makes things MUCH more complicated. So, I'm </span>
<span class="comments">;           probably at the limit of what is possible now. :-) 30 April 2013. DWF.</span>
<span class="comments">;       The LAYOUT keyword went on walkabout after the last changes. Restored to operation. 12 July 2013. DWF.</span>
<span class="comments">;       </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This function creates a transparent image out of a normal 2D or 3D image.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;   image: in, required</span>
<span class="comments">;        The input image. Must be either 2D or a true-color image.</span>
<span class="comments">;   transparent: in, optional, type=integer, default=50</span>
<span class="comments">;        The transparentcy of the image with respect to the background image. A number </span>
<span class="comments">;        from 0 to 100.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    missing_value: in, optional, type=integer</span>
<span class="comments">;         The number that represents the missing value in the image. Available only with 2D images.</span>
<span class="comments">;         This value is set to be completely transparent in the image.</span>
<span class="comments">;    palette: in, optional, type=bytarr</span>
<span class="comments">;         A 3x256 byte array containing the color table vectors that the image is to</span>
<span class="comments">;         be displayed in.</span>
<span class="comments">;    success: out, optional</span>
<span class="comments">;         An output keyword that is set to 1 if the transparent image is created</span>
<span class="comments">;         successfully. Otherwise, set to 0.</span>
<span class="comments">;-</span>
FUNCTION cgImage_Make_Transparent_Image, image, transparent, $
   MISSING_VALUE=missing_value, $
   PALETTE=palette, $
   SUCCESS=success

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        success = 0
        RETURN, 0
    ENDIF

    success = 1
    IF N_Elements(image) EQ 0 THEN Message, 'An image parameter is required'
    IF N_Elements(transparent) EQ 0 THEN transparent = 50
    
    <span class="comments">; Make sure the transparent value is between 0 and 100 initially, and between 0 and 1 finally.</span>
    transparent = (0 > transparent &lt<span class="comments">; 100) / 100.0</span>
    
    ndims = Size(image, /N_DIMENSIONS)
    
    CASE ndims OF
        2: BEGIN
           s = Size(image, /DIMENSIONS)
           IF N_Elements(palette) NE 0 THEN BEGIN
              IF (Size(palette, /DIMENSIONS))[0] EQ 3 THEN BEGIN
                 r = Reform(palette[0,*])
                 g = Reform(palette[1,*])
                 b = Reform(palette[2,*])
              ENDIF ELSE BEGIN
                 r = palette[*,0]
                 g = palette[*,1]
                 b = palette[*,2]
              ENDELSE
           ENDIF ELSE BEGIN
              TVLCT, r, g, b, /Get
           ENDELSE
           
           newimage = BytArr(4, s[0], s[1])
           newImage[0,*,*] = r[image]
           newImage[1,*,*] = g[image]
           newImage[2,*,*] = b[image]
           newimage[3,*,*] = BytArr(s[0],s[1]) + (255 * (1.0 - transparent)) 
           
           <span class="comments">; Is there missing data to consider?</span>
           IF (N_Elements(missing_value) NE 0) THEN BEGIN
   
               <span class="comments">; The missing value may be the symbol for NAN.</span>
               IF Finite(missing_value) THEN BEGIN
                   missingIndices = Where(image EQ missing_value, missingCnt)
               ENDIF ELSE BEGIN
                   missingIndices = Where(Finite(image) EQ 0, missingCnt)
               ENDELSE
               
               <span class="comments">; Make the missing pixels completely transparent in the alpha channel.</span>
               IF missingCnt GT 0 THEN BEGIN
                  alpha = Reform(newimage[3,*,*])
                  alpha[missingIndices] = 0B
                  newimage[3,*,*] = Temporary(alpha)
               ENDIF
               
           ENDIF
           
           END
           
         3: BEGIN
            dims = Image_Dimensions(image, XSIZE=xsize, YSIZE=ysize, ALPHACHANNEL=alpha, TRUEINDEX=true)
            newimage = BytArr(4, xsize, ysize)
            
            <span class="comments">; Prepare an alpha image, if needed.</span>
            IF ~alpha THEN BEGIN
                index = Where(Size(image,/DIMENSIONS) EQ 3)
                CASE index OF
                     0: aImage = image
                     1: aImage = Transpose(image, [1,0,2])
                     2: aimage = Transpose(image, [2,0,1])
                ENDCASE
                newImage[0:2,*,*] = aImage
                newimage[3,*,*] = BytArr(xsize,ysize) + (255 * (1.0 - transparent)) 
          ENDIF ELSE BEGIN
                index = Where(Size(image,/DIMENSIONS) EQ 4)
                CASE index OF
                     0: aImage = image
                     1: aImage = Transpose(image, [1,0,2])
                     2: aimage = Transpose(image, [2,0,1])
                ENDCASE
                newImage[0:2,*,*] = aImage[0:2,*,*]
                newimage[3,*,*] = BytArr(xsize,ysize) + (255 * (1.0 - transparent)) 
          ENDELSE
            END
            
            
         ELSE: Message, 'Cannot process images that are not 2D or True-Color for transparentcy.'
         
    ENDCASE
    RETURN, newImage
END


<span class="comments">;+</span>
<span class="comments">; This routine prepares a transparent image (an image with an alpha channel)</span>
<span class="comments">; for display.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     Returns an image that has been blended with the background image and is</span>
<span class="comments">;     suitable for display with cgImage.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    image: in, required</span>
<span class="comments">;       The input image that is being prepared for display. It will contain</span>
<span class="comments">;       an alpha channel.</span>
<span class="comments">;    alphabackgroundimage: in, required</span>
<span class="comments">;       The background image. The input image will be blended</span>
<span class="comments">;       with the background image.</span>
<span class="comments">;   </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    alphabgposition: in, required, type=fltarr</span>
<span class="comments">;       The normalized position or portion of the background image used to create the alpha image.</span>
<span class="comments">;    alphafgposition: in, required, type=fltarr</span>
<span class="comments">;       The normalized position in the background image where the input image is to be located.</span>
<span class="comments">;    tv: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, the alpha channel is removed from the</span>
<span class="comments">;       input image, because we cannot display an image with an alpha</span>
<span class="comments">;       channel if the cgImage command is acting like a smarter IDL </span>
<span class="comments">;       TV command.</span>
<span class="comments">;-</span>
FUNCTION cgImage_Prepare_Alpha, image, alphaBackgroundImage, $
    ALPHABGPOSITION=alphabgpos, $
    ALPHAFGPOSITION=alphafgpos, $    
    TV=tv

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
       Catch, /Cancel
       ok = Error_Message()
       IF Ptr_Valid(ptr) THEN BEGIN
            image = Temporary(*ptr)
            Ptr_Free, ptr
       ENDIF
       IF N_Elements(thisDevice) NE 0 THEN Set_Plot, thisDevice
       RETURN, image
    ENDIF

    <span class="comments">; Prepare an alpha image, if needed.</span>
    index = Where(Size(image,/DIMENSIONS) EQ 4)
    CASE index OF
         0: aImage = Transpose(image, [1,2,0])
         1: aImage = Transpose(image, [0,2,1])
         ELSE: aImage = image
    ENDCASE
       
    <span class="comments">; Separate the alpha channel.</span>
    alpha_channel = aImage[*,*,3]
       
    <span class="comments">; If this is acting like a TV command, then there is no alpha channel.</span>
    <span class="comments">; Exit now.</span>
    IF Keyword_Set(tv) THEN RETURN, aImage[*,*,0:2]
    
    <span class="comments">; Now we have an alpha channel.</span>
    alpha_channel = (alpha_channel / 255.0) * 1.0
    foregndImage = aImage[*,*,0:2]
           
    <span class="comments">; Get the size and dimensions of the background image.</span>
    ndim = Size(alphaBackgroundImage, /N_DIMENSIONS)
    CASE ndim OF
        2: BEGIN
           TVLCT, r, g, b, /GET
           s = Size(alphaBackgroundImage, /DIMENSIONS)
           bImage = BytArr(s[0], s[1], 3)
           bImage[*,*,0] = r[alphaBackgroundImage]
           bImage[*,*,1] = g[alphaBackgroundImage]
           bImage[*,*,2] = b[alphaBackgroundImage]
           END
        3: BEGIN
           index = Where(Size(alphaBackgroundImage,/DIMENSIONS) EQ 3)
           CASE index OF
              0: bImage = Transpose(alphaBackgroundImage, [1,2,0])
              1: bImage = Transpose(alphaBackgroundImage, [0,2,1])
              ELSE: bImage = alphaBackgroundImage
           ENDCASE
           END
      ELSE: Message, 'Unexpected dimensions of the background image.'
    ENDCASE
    
    <span class="comments">; I need a 24-bit image to work with. This is most easily done</span>
    <span class="comments">; in the Z-Graphics buffer, set to work in 24-bit mode. Unfortunately,</span>
    <span class="comments">; this mode was introduced in IDL 7, so I can't use it with IDL 6.4</span>
    <span class="comments">; or earlier versions. I can, however, TRY to use a pixmap in earlier</span>
    <span class="comments">; versions. I have reports that this works fine. So, I am modifying this</span>
    <span class="comments">; section of code to get the 24-bit image I need out of a pixmap for versions</span>
    <span class="comments">; of IDL before IDL 7.0. </span>
    thisRelease = Float(!Version.Release)

    <span class="comments">; Now that we have a background image, display that in</span>
    <span class="comments">; the Z-Graphics buffer or in a pixmap if IDL 6.4 or earlier.</span>
    sb = Size(bImage, /DIMENSIONS)
    sf = Size(foregndImage, /DIMENSIONS)
    IF thisRelease GE 6.5 THEN BEGIN                       
       thisDevice = !D.Name
       Set_Plot, 'Z'
       Device, Get_Decomposed=theState
       Device, Set_Resolution=sb[0:1], Decomposed=1, Set_Pixel_Depth=24
    ENDIF ELSE BEGIN
       thisDevice = !D.Name
       IF (thisDevice EQ 'PS') OR (thisDevice EQ 'Z') THEN BEGIN
          IF StrUpCase(!Version.OS_Family) EQ 'WINDOWS' THEN setToDev = 'WIN' ELSE setToDev = 'X'
       ENDIF
       currentWindow = !D.Window
       IF N_Elements(setToDev) NE 0 THEN Set_Plot, setToDev
       cgDisplay, /FREE, /PIXMAP, sb[0], sb[1]
       pixmap = !D.Window
    ENDELSE

    <span class="comments">; Turn off !P.MULTI handling for this part.</span>
    multi = !P.Multi
    !P.Multi = 0
    IF N_Elements(alphabgpos) EQ 0 THEN BEGIN
        cgImage, bImage
    ENDIF ELSE BEGIN
        cgImage, bImage, Position=alphabgpos
    ENDELSE
    !P.Multi = multi
    
    <span class="comments">; Calculate the parameters for taking a snapshot of the</span>
    <span class="comments">; relevant portion of the window.</span>
    xstart = alphafgpos[0]*sb[0]
    cols = Round((alphafgpos[2] - alphafgpos[0]) * sb[0])
    ystart = alphafgpos[1]*sb[1]
    rows = Round((alphafgpos[3] - alphafgpos[1]) * sb[1])
            
    <span class="comments">; Take a snapshot</span>
    bsnap = TVRD(xstart, ystart, cols, rows, TRUE=3)
            
    <span class="comments">; Get the size of the snapshot.</span>
    sb = Size(bsnap, /DIMENSIONS)
    
    <span class="comments">; Clean-up</span>
    IF thisRelease GE 6.5 THEN BEGIN 
       Device, Decomposed=theState
       Set_Plot, thisDevice
    ENDIF ELSE BEGIN
       WDelete, pixmap
       IF N_Elements(setToDev) NE 0 THEN Set_Plot, thisDevice
       IF (currentWindow LE 0) AND ((!D.Flags AND 256) NE 0) THEN WSet, currentWindow
    ENDELSE
            
     <span class="comments">; Make the foreground image the right size.</span>
     foregndImage = cgResizeImage(foregndImage, cols, rows)
     alpha = cgResizeImage(alpha_channel, sb[0], sb[1], /INTERPOLATE)
     alpha = Rebin(alpha, sb[0], sb[1], 3)
            
     <span class="comments">; Blend the two images in the location of the POSITION.</span>
     blendImage = foregndImage*alpha + (1 - alpha)*bsnap  
     
     <span class="comments">; Now put this blended portion back into the background image.</span>
     outimage = bimage
     outimage[xstart:xstart+cols-1, ystart:ystart+rows-1, *] = blendImage
            
     <span class="comments">; Put the dimensions back the way they came in.   </span>
     index = Where(Size(foregndImage,/DIMENSIONS) EQ 3)
     CASE index OF
        0: outImage = Transpose(outImage, [2,0,1])
        1: outImage = Transpose(outImage, [1,0,2])
        ELSE: outImage = outImage
     ENDCASE
    
     RETURN, outimage
END
<span class="comments">;--------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This routine scales or otherwise prepares an image to be displayed.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     Returns an image that can be displaye properly.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    image: in, required</span>
<span class="comments">;       The input image that is being prepared for display. </span>
<span class="comments">;    xsize: in, optional</span>
<span class="comments">;       The output X size of the image.</span>
<span class="comments">;    ysize: in, optional</span>
<span class="comments">;       The output Y size of the image.</span>
<span class="comments">;   </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    bottom: in, optional, type=integer, default=0</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP.</span>
<span class="comments">;    beta: in, optional, type=float, default=3.0</span>
<span class="comments">;         The beta factor in a Hyperpolic Sine stretch.</span>
<span class="comments">;    clip: in, optional, type=float, default=2</span>
<span class="comments">;         A number between 0 and 50 that indicates the percentage of pixels to clip</span>
<span class="comments">;         off either end of the image histogram before performing a linear stretch.</span>
<span class="comments">;    exclude: in, optional</span>
<span class="comments">;         The value to exclude in a standard deviation stretch.</span>
<span class="comments">;    exponent: in, optional, type=float, default=4.0</span>
<span class="comments">;         The logarithm exponent in a logarithmic stretch.</span>
<span class="comments">;    gamma: in, optional, type=float, default=1.5</span>
<span class="comments">;         The gamma factor in a gamma stretch.</span>
<span class="comments">;    interpolate: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to interpolate with bilinear interpolation the display image as it </span>
<span class="comments">;         is sized to its final position in the display window. Interpolation will potentially </span>
<span class="comments">;         create image values that do not exist in the original image. The default is to do no</span>
<span class="comments">;         interpolation, so that image values to not change upon resizing. Interpolation can</span>
<span class="comments">;         result in smoother looking final images.</span>
<span class="comments">;    maxvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and MAXVALUE. MAXVALUE is set to MAX(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets `SCALE` to 1. If the maximum value of the </span>
<span class="comments">;         image is greater than 255, this keyword is defined and SCALE=1.</span>
<span class="comments">;    mean: in, optional, type=float, default=0.5</span>
<span class="comments">;         The mean factor in a logarithmic stretch.</span>
<span class="comments">;    minus_one: in, optional, type=boolean, default=0</span>
<span class="comments">;         The value of this keyword is passed along to the cgResizeImage</span>
<span class="comments">;         command. It prevents cgResizeImage from adding an extra row and</span>
<span class="comments">;         column to the resulting array, which can be a problem with</span>
<span class="comments">;         small image arrays. </span>
<span class="comments">;    minvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and `MAXVALUE`. MINVALUE is set to MIN(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets SCALE=1. If the minimum value of the </span>
<span class="comments">;         image is less than 0, this keyword is defined and SCALE=1.</span>
<span class="comments">;    missing_index: in, optional, type=integer, default=255</span>
<span class="comments">;         The index of the missing color in the final byte scaled image.</span>
<span class="comments">;    missing_value: in, optional, type=integer</span>
<span class="comments">;         The number that represents the missing value in the image.</span>
<span class="comments">;    multiplier: in, optional, type=float</span>
<span class="comments">;         The multiplication factor in a standard deviation stretch. The standard deviation</span>
<span class="comments">;         is multiplied by this factor to produce the thresholds for a linear stretch.</span>
<span class="comments">;    negative: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want to display the image with a negative or reverse stretch.</span>
<span class="comments">;    scale: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to byte scale the image before display. If this keyword is not set, </span>
<span class="comments">;         the image is not scaled before display. This keyword will be set automatically by using</span>
<span class="comments">;         any of the keywords normally associated with byte scaling an image.</span>
<span class="comments">;    stretch: in, optional, type=integer/string, default=1</span>
<span class="comments">;         The type of scaling performed prior to display. </span>
<span class="comments">;         May be specified as a number or as a string (e.g, 4 or "Log").</span>
<span class="comments">;</span>
<span class="comments">;           Number   Type of Stretch</span>
<span class="comments">;             0         None           No scaling whatsoever is done.</span>
<span class="comments">;             1         Linear         scaled = BytScl(image, MIN=minValue, MAX=maxValue)</span>
<span class="comments">;             2         Clip           A histogram stretch, with a percentage of pixels clipped at both the top and bottom</span>
<span class="comments">;             3         Gamma          scaled = GmaScl(image, MIN=minValue, MAX=maxValue, Gamma=gamma)</span>
<span class="comments">;             4         Log            scaled = LogScl(image, MIN=minValue, MAX=maxValue, Mean=mean, Exponent=exponent)</span>
<span class="comments">;             5         Asinh          scaled = AsinhScl(image, MIN=minValue, MAX=maxValue, Beta=beta)</span>
<span class="comments">;             6         SquareRoot     A linear stretch of the square root histogram of the image values.</span>
<span class="comments">;             7         Equalization   A linear stretch of the histogram equalized image histogram.</span>
<span class="comments">;             8         Gaussian       A Gaussian normal function is applied to the image histogram.</span>
<span class="comments">;             9         MODIS          Scaling done in the differential manner of the MODIS Rapid Response Team</span>
<span class="comments">;                                      and implemented in the Coyote Library routine ScaleModis.</span>
<span class="comments">;             10        StdDev         A standard deviation stretch. scaled = SDevScl(image, Multiplier=2.0).</span>
<span class="comments">;    sigma: in, optional, type=float, default=1.0</span>
<span class="comments">;         The sigma scale factor in a Gaussian stretch.</span>
<span class="comments">;    top: in, optional, type=integer, default=255</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP.</span>
<span class="comments">;-</span>
FUNCTION cgImage_Prepare_Output, image, xsize, ysize, $
   BOTTOM=bottom, $
   BETA=beta, $
   CLIP=clip, $
   EXCLUDE=exclude, $
   EXPONENT=exponent, $
   GAMMA=gamma, $
   INTERPOLATE=interpolate, $
   MAXVALUE=maxvalue, $
   MEAN=mean, $
   MINUS_ONE=minus_one, $
   MINVALUE=minvalue, $
   MISSING_INDEX=missing_index, $
   MISSING_VALUE=missing_value, $
   MULTIPLIER=multiplier, $
   NEGATIVE=negative, $
   SCALE=scale, $
   STRETCH=stretch, $
   SIGMA=sigma, $
   TOP=top

   Compile_Opt idl2
   
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
       Catch, /Cancel
       ok = Error_Message()
       RETURN, image
    ENDIF
    
   <span class="comments">; I would like to avoid making a copy of the image, if possible.</span>
   <span class="comments">; If nothing needs to be done, just return the image.</span>
   IF (N_Elements(xsize) EQ 0) && $
      (N_Elements(missing_value) EQ 0) && $
      ~scale THEN RETURN, image
      
   <span class="comments">; Is there a missing value to worry about? We can only worry</span>
   <span class="comments">; about missing values with 2D image arrays.</span>
   ndims = Size(image, /N_DIMENSIONS)
   IF (N_Elements(missing_value) NE 0) && (ndims EQ 2) THEN BEGIN
   
       <span class="comments">; Get the image type.</span>
       imageType = Size(image, /TNAME)
       
       <span class="comments">; Create a temporary image variable. If you will be scaling the data,</span>
       <span class="comments">; make the image a float if it is not float or double already.</span>
       CASE imageType OF
          'FLOAT': tempImage = image
          'DOUBLE': tempImage = image
          ELSE: tempImage = Float(image) 
       ENDCASE
       
       <span class="comments">; The missing value may be the symbol for NAN.</span>
       IF Finite(missing_value) THEN BEGIN
           missingIndices = Where(tempImage EQ missing_value, missingCnt)
       ENDIF ELSE BEGIN
           missingIndices = Where(Finite(tempImage) EQ 0, missingCnt)
       ENDELSE
       
       <span class="comments">; Set the missing indices to the correct NAN value.</span>
       IF imageType EQ 'DOUBLE' THEN BEGIN
           IF missingCnt GT 0 THEN tempImage[missingIndices] = !Values.D_NAN
       ENDIF ELSE BEGIN
           IF missingCnt GT 0 THEN tempImage[missingIndices] = !Values.F_NAN
       ENDELSE
   
   ENDIF
   
   <span class="comments">; Do you need scaling?</span>
   IF Keyword_Set(scale) || (stretch NE 0) THEN BEGIN
   
      <span class="comments">; Create a temporary image, if you don't already have one.</span>
      IF N_Elements(tempImage) EQ 0 THEN BEGIN
          imageType = Size(image, /TNAME)
          CASE imageType OF
              'FLOAT': tempimage = image
              'DOUBLE': tempimage = image
              ELSE: tempImage = Float(image) 
          ENDCASE
       ENDIF
      
      <span class="comments">; Select the particular kind of stretch you want to do. Unfortunately, we</span>
      <span class="comments">; can still cause underflow error messages when doing stretch, despite best</span>
      <span class="comments">; attempts to prevent this. Turn these messages off here.</span>
      curExcept = !Except
      !Except = 0      
       CASE stretch OF
       
<span class="comments">;             0         None           No scaling whatsoever is done.</span>
<span class="comments">;             1         Linear         scaled = BytScl(image, MIN=minValue, MAX=maxValue)</span>
<span class="comments">;             2         Clip           A histogram stretch, with a percentage of pixels clipped at both the top and bottom</span>
<span class="comments">;             3         Gamma          scaled = GmaScl(image, MIN=minValue, MAX=maxValue, Gamma=gamma)</span>
<span class="comments">;             4         Log            scaled = LogScl(image, MIN=minValue, MAX=maxValue, Mean=mean, Exponent=exponent)</span>
<span class="comments">;             5         Asinh          scaled = AsinhScl(image, MIN=minValue, MAX=maxValue, Beta=beta)</span>
<span class="comments">;             6         SquareRoot     A linear stretch of the square root histogram of the image values.</span>
<span class="comments">;             7         Equalization   A linear stretch of the histogram equalized image histogram.</span>
<span class="comments">;             8         Gaussian       A Gaussian normal function is applied to the image histogram.</span>
<span class="comments">;             9         MODIS          Scaling done in the differential manner of the MODIS Rapid Response Team</span>
<span class="comments">;             10        StdDev         A standard deviation stretch.</span>

          0: <span class="comments">; No stretch at all. </span>
       
          1: BEGIN <span class="comments">; Linear stretch.</span>
             tempImage = BytScl(tempImage, Max=maxvalue, Min=minvalue, /NAN, TOP=top) + bottom
             IF negative THEN tempImage = Byte(top) - tempImage
             END
    
          2: BEGIN <span class="comments">; Histogram clip stretch.</span>
             tempImage = ClipScl(tempImage, clip, OMIN=bottom, OMAX=top, NEGATIVE=negative)
             END

          3: BEGIN <span class="comments">; Gamma log scale stretch.</span>
             tempImage = GmaScl(tempImage, Max=maxvalue, Min=minvalue, $
                       Gamma=gamma, Negative=negative, OMAX=top, OMIN=bottom)
             END
    
          4: BEGIN <span class="comments">; Log scale stretch.</span>
             tempImage =  LogScl(tempImage, Max=maxvalue, Min=minvalue, $
                       Mean=mean, Exponent=exponent, Negative=negative, $
                       OMIN=bottom, OMAX=top)
             END
    
          5: BEGIN <span class="comments">; Hyperpolic sine stretch.</span>
             tempImage = ASinhScl(tempImage, Max=maxvalue, Min=minvalue, $
                      BETA=beta, Negative=negative, OMAX=top, OMIN=bottom)
             END
               
    
          6: BEGIN <span class="comments">; Square Root stretch.</span>
             tempImage = BytScl(SQRT(tempImage), Max=maxvalue, Min=minvalue, /NAN, TOP=top) + bottom
             IF negative THEN tempImage = Byte(top) - tempImage
             END
    
          7: BEGIN <span class="comments">; Histogram equalization stretch.</span>
             IF (top EQ 255) && (bottom EQ 0) THEN BEGIN
                 tempImage = Hist_Equal(tempImage, MaxV=maxvalue, MinV=minvalue)
             ENDIF ELSE BEGIN
                 tempImage = Bytscl(Float(Hist_Equal(tempImage, MaxV=maxvalue, MinV=minvalue)), /NAN, TOP=top) + bottom
             ENDELSE
             IF negative THEN tempImage = Byte(top) - tempImage
             END
    
          8: BEGIN <span class="comments">; Gaussian stretch.</span>
             tempImage = GaussScl(tempImage, Max=maxvalue, Min=minvalue, $
                       Sigma=sigma, Negative=negative, OMIN=bottom, OMAX=top)
             END
         
          9: BEGIN <span class="comments">; MODIS image stretch.</span>
             tempImage = ScaleModis(tempImage)
             END
             
          10: BEGIN <span class="comments">; Standard deviation stretch.</span>
              tempImage = SDevScl(tempImage, MULTIPLIER=multiplier, EXCLUDE=exclude, $
                   Negative=negative, OMAX=top, OMIN=bottom)
              END
               
            ELSE: Message, 'Unknown scaling index.'
            
       ENDCASE
       
       <span class="comments">; Clear the math error register and turn normal error checking on.</span>
       void = Check_Math()
       !Except = curExcept
       
   ENDIF
   
   
   <span class="comments">; After scaling, you may need to replace missing values with the</span>
   <span class="comments">; missing index.</span>
   IF N_Elements(missingCnt) NE 0 THEN BEGIN
      IF missingCnt GT 0 THEN tempImage[missingIndices] = missing_index
   ENDIF
   
   <span class="comments">; If you created a temporary image, then return that.</span>
   <span class="comments">; Otherwise you can return the original image, modified</span>
   <span class="comments">; to the appropriate size.</span>
   IF N_Elements(tempImage) EQ 0 THEN BEGIN
       IF (N_Elements(xsize) EQ 0) THEN BEGIN
           RETURN, image
       ENDIF ELSE BEGIN
           RETURN, cgResizeImage(image, xsize, ysize, $
                    INTERP=interpolate, MINUS_ONE=minus_one)
       ENDELSE
   ENDIF ELSE BEGIN
       IF (N_Elements(xsize) EQ 0) THEN BEGIN
           RETURN, tempImage
       ENDIF ELSE BEGIN
           RETURN, cgResizeImage(tempImage, xsize, ysize, $
                    INTERP=interpolate, MINUS_ONE=minus_one)
       ENDELSE
   ENDELSE
END


<span class="comments">;+</span>
<span class="comments">; The purpose of this program is to create a TV command that works the way</span>
<span class="comments">; the TV command would be expected to work if it was written today, rather</span>
<span class="comments">; than 25 years ago. In other words, it knows the difference between an</span>
<span class="comments">; 8-bit device and a 24-bit device, it honors the POSITION keyword like </span>
<span class="comments">; other graphics commands in IDL, it honors the !P.MULTI value, like other</span>
<span class="comments">; graphics commands in IDL, it works seamlessly with both 8-bit and 24-bit</span>
<span class="comments">; images. In addition to other modern features, this program can also </span>
<span class="comments">; display images that contain an alpha channel and can display transparent</span>
<span class="comments">; images.</span>
<span class="comments">; </span>
<span class="comments">; Also, two-dimensional image arrays can be manipulated, stretched,</span>
<span class="comments">; and scaled directly with keywords to cgImage. These keywords do not</span>
<span class="comments">; work with alpha channel images, or if the TV keyword is used with</span>
<span class="comments">; cgImage.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    image:  in, required, type=various</span>
<span class="comments">;        An 8-bit (MxN), 24-bit (e.g., MxNx3), or a 24-bit + alpha channel</span>
<span class="comments">;        (e.g., MxNx4) image  to display.</span>
<span class="comments">;    x: in, optional, type=integer</span>
<span class="comments">;        The X position of the lower-left corner of the image in device</span>
<span class="comments">;        coordinates. This parameter is only recognized if the TV keyword </span>
<span class="comments">;        is set. If the Y position is not used, X is taken to be the image</span>
<span class="comments">;        "position" in the window. See the TV command documenation for details. </span>
<span class="comments">;    y: in, optional, type=integer      </span>
<span class="comments">;        The Y position of the lower-left corner of the image in device</span>
<span class="comments">;        coordinates. This parameter is only recognized if the TV keyword </span>
<span class="comments">;        is set.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to add this command to an already open cgWindow to</span>
<span class="comments">;         be executed when the window is resized. If the DISPLAY keyword is also</span>
<span class="comments">;         set, this keyword will act as if the WINDOW keyword were set.</span>
<span class="comments">;    alphabackgroundimage: in, optional, type=varies</span>
<span class="comments">;         Normally, when a image with an alpha channel is displayed, the image is </span>
<span class="comments">;         blended with whatever is currently in the display window. This means, the </span>
<span class="comments">;         program has to obtain that background image. This is not a problem on devices </span>
<span class="comments">;         (e.g., WIN, X, Z) that allow this kind of operation, but it is on devices </span>
<span class="comments">;         (e.g., the PostScript device, PS) that do not. To get around this problem, </span>
<span class="comments">;         you can pass the background image to the cgImage program. This background image</span>
<span class="comments">;         will be blended with the alpha channel image you wish to display. If an alpha </span>
<span class="comments">;         channel image is displayed on a device in which there is no way to obtain the </span>
<span class="comments">;         background image, and this keyword is not used to pass a background image, then</span>
<span class="comments">;         the alpha channel image will be blended with a white background image.</span>
<span class="comments">;         This keyword is only used if an alpha channel image is passed to the </span>
<span class="comments">;         program via the IMAGE parameter. The AlphaBackgroundImage does not need</span>
<span class="comments">;         to have the same dimensions as the alpha channel image. The background image</span>
<span class="comments">;         can be either a 2D image or a 24-bit image.</span>
<span class="comments">;    alphabgposition: in, optional, type=fltarr(4)</span>
<span class="comments">;         The normalized position or portion of the background image that is going to be used</span>
<span class="comments">;         to create the alpha channel image. Normally, and by default, the alphabgposition encompasses </span>
<span class="comments">;         the entire graphics window, [0.0, 0.0, 1.0, 1.0].</span>
<span class="comments">;    alphafgposition: in, optional, type=fltarr(4)</span>
<span class="comments">;         The normalized position in the background image where the input image is to be located.</span>
<span class="comments">;         By default, the input image takes up the entire extent of the background image, [0.0, 0.0, 1.0, 1.0].</span>
<span class="comments">;    axis: in, optional, type=boolean, default=0</span>
<span class="comments">;         A misspelled version of the AXES keyword. Provided as a service to people whose</span>
<span class="comments">;         fingers have minds of their own.</span>
<span class="comments">;    axes: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to display the image with axes surrounding the image. If the POSITION</span>
<span class="comments">;         keyword is not used, a MARGIN of 0.1 is used to allow the axes to show. If you wish</span>
<span class="comments">;         to make the image fit entirely inside the axes, set the `FIT_INSIDE` keyword. Otherwise,</span>
<span class="comments">;         the axis sit on top of the image data.</span>
<span class="comments">;    axkeywords: in, optional, type=structure</span>
<span class="comments">;         A structure of AXIS keywords and values that can be used to configure the axes</span>
<span class="comments">;         in whatever way the user desires. Many of the most often used axis keywords are available </span>
<span class="comments">;         as cgImage keywords. For example::</span>
<span class="comments">;            IDL> axis_format = {XTicks:4, XTickname:['Cow', 'Pig', 'Dog', 'Cat', 'Owl']}</span>
<span class="comments">;            IDL> cgImage, cgDemoData(7), AXKEYWORDS=axis_format, /Axes, XRange=[0,20]</span>
<span class="comments">;    background: in, optional, type=string, default='white'</span>
<span class="comments">;         The name of the background color for the image display. Unlike the TV command in IDL,</span>
<span class="comments">;         the cgImage command will erase the display before executing the command like other</span>
<span class="comments">;         fundamental graphics commands (e.g., Plot, Contour, Surface) in IDL.</span>
<span class="comments">;    beta: in, optional, type=float, default=3.0</span>
<span class="comments">;         The beta factor in a Hyperpolic Sine stretch. Available only with 2D images.</span>
<span class="comments">;    bottom: in, optional, type=integer, default=0</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP. Available only with 2D images.</span>
<span class="comments">;    brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;         This keyword is used only if the `CTIndex` keyword is used to select a color table number.</span>
<span class="comments">;         Setting this keyword allows Brewer color tables to be used.</span>
<span class="comments">;    charsize: in, optional, type=float</span>
<span class="comments">;         Sets the character size. Used only if the AXES keyword is also set. By default, </span>
<span class="comments">;         the value from cgDefCharsize().</span>
<span class="comments">;    clip: in, optional, type=float, default=2</span>
<span class="comments">;         A number between 0 and 50 that indicates the percentage of pixels to clip</span>
<span class="comments">;         off either end of the image histogram before performing a linear stretch.</span>
<span class="comments">;         Available only with 2D images.</span>
<span class="comments">;    color: in, optional, type=string, default='opposite'</span>
<span class="comments">;         The name of the color in which to draw the axes. Used only if the `AXES` keyword is set.</span>
<span class="comments">;    ctindex: in, optional, type=integer</span>
<span class="comments">;         The index number of a color table. The `Brewer` and `Reverse` keywords will be checked</span>
<span class="comments">;         to see how to load the color table into the `Palette` keyword. This keyword will take</span>
<span class="comments">;         precidence over any colors that are loaded with the `Palette` keyword. The default is</span>
<span class="comments">;         to use whatever colors are loaded in the current hardware color table.</span>
<span class="comments">;    display: in, optional, type=boolean, default=0</span>
<span class="comments">;         If this keyword is set, a new display window is created (with cgDisplay) that has the</span>
<span class="comments">;         same aspect ratio as the image. The image is displayed in that window. If the WINDOW</span>
<span class="comments">;         keyword is also set, a new cgWindow is created with the WASPECT keyword set to the image</span>
<span class="comments">;         aspect ratio, and the image is displayed in that new cgwindow. </span>
<span class="comments">;    erase: in, optional, type=boolean, default=1</span>
<span class="comments">;         An obsolete keyword. Used only for compatibility with the earlier TVImage command. The</span>
<span class="comments">;         default for cgImage is to always erase the graphics display before displaying the image</span>
<span class="comments">;         unless told otherwise by setting the `NOERASE` keyword. This makes cgImage consistent with</span>
<span class="comments">;         other IDL graphics commands.</span>
<span class="comments">;    exclude: in, optional</span>
<span class="comments">;         The value to exclude in a standard deviation stretch.</span>
<span class="comments">;    exponent: in, optional, type=float, default=4.0</span>
<span class="comments">;         The logarithm exponent in a logarithmic stretch. Available only with 2D images.</span>
<span class="comments">;    filename: in, optional, type=string</span>
<span class="comments">;         The name of a file that IDL can read with READ_IMAGE (e.g, GEOTIFF, TIF, JPEG, PNG, etc.).</span>
<span class="comments">;         The file is read to obtain the image to be displayed.</span>
<span class="comments">;    fit_inside: in, optional, type=boolean, default=0</span>
<span class="comments">;         When the AXES keyword is set, the default is to position the axes on top of the image</span>
<span class="comments">;         using the POSITION. However, if this keyword is set, the axes are positioned at POSITION</span>
<span class="comments">;         and the image is sized so that it fits entirely inside the axes.</span>
<span class="comments">;    font: in, optional, type=integer</span>
<span class="comments">;         This keyword selects the font used for axis and title display. The default is to use</span>
<span class="comments">;         the value of !P.Font.</span>
<span class="comments">;    gamma: in, optional, type=float, default=1.5</span>
<span class="comments">;         The gamma factor in a gamma stretch. Available only with 2D images.</span>
<span class="comments">;    interpolate: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to interpolate with bilinear interpolation the display image as it </span>
<span class="comments">;         is sized to its final position in the display window. Interpolation will potentially </span>
<span class="comments">;         create image values that do not exist in the original image. The default is to do no</span>
<span class="comments">;         interpolation, so that image values to not change upon resizing. Interpolation can</span>
<span class="comments">;         result in smoother looking final images.</span>
<span class="comments">;    keep_aspect_ratio: in, optional, type=boolean, default=0</span>
<span class="comments">;         By default, the output image is resized into the `POSITION` in the graphics window.</span>
<span class="comments">;         This can result in a distortion of the image aspect ratio (the Y size of the image</span>
<span class="comments">;         divided by the X size of the image). Setting this keyword will preserve the original</span>
<span class="comments">;         aspect ratio of the image in the output display window. In effect, the image will</span>
<span class="comments">;         be placed in the window `POSITION` in a way that preserves its aspect ratio. The</span>
<span class="comments">;         actual final location of the image in the display window can be obtained via the </span>
<span class="comments">;         `OPOSITION` keyword.</span>
<span class="comments">;    layout: in, optional, type=intarr</span>
<span class="comments">;         This keyword specifies a grid with a graphics window and determines </span>
<span class="comments">;         where the graphic should appear. The syntax of LAYOUT is a 3-element </span>
<span class="comments">;         array: [ncolumns, nrows, location]. The grid is determined by the </span>
<span class="comments">;         number of columns (ncolumns) by the number of rows (nrows). The location </span>
<span class="comments">;         of the graphic is determined by the third number. The grid numbering </span>
<span class="comments">;         starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;         by row. Note that using the LAYOUT keyword automatically sets the NOERASE </span>
<span class="comments">;         keyword to 1.</span>
<span class="comments">;    mapcoord: in, optional, type=object</span>
<span class="comments">;         An object reference to a map coordinate object (e.g., cgMap). If present, the</span>
<span class="comments">;         XRANGE and YRANGE keyword values will be obtained from this map object, if they</span>
<span class="comments">;         are not defined otherwise. </span>
<span class="comments">;    margin: in, optional, type=float, default=0.0</span>
<span class="comments">;         A single value, expressed as a normalized coordinate, that</span>
<span class="comments">;         can easily be used to calculate a position in the window.</span>
<span class="comments">;         The margin is used to calculate a `POSITION` that gives</span>
<span class="comments">;         the image an equal margin around the edge of the window.</span>
<span class="comments">;         The margin must be a number in the range 0.0 to 0.333. This</span>
<span class="comments">;         keyword is ignored if the `POSITION` or `OVERPLOT` keywords are</span>
<span class="comments">;         used. It is also ignored when cgImage is executed in a</span>
<span class="comments">;         multi-plot window, EXCEPT if it's value is zero. In this</span>
<span class="comments">;         special case, the image will be drawn into its position in</span>
<span class="comments">;         the multi-plot window with no margins whatsoever. (The</span>
<span class="comments">;         default is to have a slight margin about the image to separate</span>
<span class="comments">;         it from other images or graphics. The default margin is 0.05.)</span>
<span class="comments">;    maxvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and MAXVALUE. MAXVALUE is set to MAX(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets `SCALE` to 1. If the maximum value of the </span>
<span class="comments">;         image is greater than 255, this keyword is defined and SCALE=1.</span>
<span class="comments">;    mean: in, optional, type=float, default=0.5</span>
<span class="comments">;         The mean factor in a logarithmic stretch. Available only with 2D images.</span>
<span class="comments">;    minus_one: in, optional, type=boolean, default=0</span>
<span class="comments">;         The value of this keyword is passed along to the cgResizeImage</span>
<span class="comments">;         command. It prevents cgResizeImage from adding an extra row and</span>
<span class="comments">;         column to the resulting array, which can be a problem with</span>
<span class="comments">;         small image arrays. </span>
<span class="comments">;    minvalue: in, optional, type=varies</span>
<span class="comments">;         If this value is defined, the data is linearly scaled between MINVALUE</span>
<span class="comments">;         and `MAXVALUE`. MINVALUE is set to MIN(image) by default. Setting this </span>
<span class="comments">;         keyword to a value automatically sets SCALE=1. If the minimum value of the </span>
<span class="comments">;         image is less than 0, this keyword is defined and SCALE=1.</span>
<span class="comments">;    missing_color: in, optional, type=string, default='white'</span>
<span class="comments">;         The color name of the missing value. Available only with 2D images.</span>
<span class="comments">;    missing_index: in, optional, type=integer, default=255 </span>
<span class="comments">;         The index of the missing color in the final byte scaled image. Available only with 2D images.</span>
<span class="comments">;    missing_value: in, optional, type=integer</span>
<span class="comments">;         The number that represents the missing value in the image. Available only with 2D images.</span>
<span class="comments">;    multimargin: in, optional, type=varies</span>
<span class="comments">;         Sometimes, when displaying multiple images with !P.Multi, you</span>
<span class="comments">;         want the images to be slightly smaller than the position created</span>
<span class="comments">;         by !P.Multi so you can add, for example, a colorbar or an annotation</span>
<span class="comments">;         to the image. This keyword can be used to adjust the image position</span>
<span class="comments">;         by a small margin. A four-element array, the margins apply to the </span>
<span class="comments">;         [bottom, left, top, right] of the image position. So, to</span>
<span class="comments">;         leave room at the top of an image for a color bar, you might</span>
<span class="comments">;         type this::</span>
<span class="comments">;               </span>
<span class="comments">;             cgImage, image, MultiMargin=[0, 0, 4, 0]</span>
<span class="comments">;                  </span>
<span class="comments">;         This keyword applies *only* to images displayed with !P.Multi, and if</span>
<span class="comments">;         passed a scalar value, will use the same value for all four positions.</span>
<span class="comments">;    multiplier: in, optional, type=float</span>
<span class="comments">;         The multiplication factor in a standard deviation stretch. The standard deviation</span>
<span class="comments">;         is multiplied by this factor to produce the thresholds for a linear stretch.</span>
<span class="comments">;    ncolors: in, optional, type=integer, default=256</span>
<span class="comments">;         If this keyword is supplied, the `TOP` keyword is ignored and the TOP keyword </span>
<span class="comments">;         is set equal to  NCOLORS-1. This keyword is provided to make cgImgScl easier </span>
<span class="comments">;         to use with the color-loading programs such as cgLOADCT::</span>
<span class="comments">;</span>
<span class="comments">;              cgLoadCT, 5, NColors=100, Bottom=100</span>
<span class="comments">;              scaled = cgImgScl(image, NColors=100, Bottom=100)</span>
<span class="comments">;                  </span>
<span class="comments">;         Setting this keyword to a value automatically sets SCALE=1 and STRETCH='LINEAR', if not</span>
<span class="comments">;         defined otherwise. Available only with 2D images.</span>
<span class="comments">;    negative: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want to display the image with a negative or reverse stretch.</span>
<span class="comments">;         Available only with 2D images.</span>
<span class="comments">;    noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to prevent the command from first erasing the graphics</span>
<span class="comments">;         display before displaying the image.</span>
<span class="comments">;    nointerpolation: in, optional, type=boolean, default=0</span>
<span class="comments">;         This is an obsolete keyword that is included here only for compatibility with</span>
<span class="comments">;         the older TVImage command. Use the `INTERPOLATE` keyword.</span>
<span class="comments">;    normal: in, optional, type=boolean, default=0</span>
<span class="comments">;         Setting this keyword means image position coordinates x and y are interpreted </span>
<span class="comments">;         as being in normalized coordinates. This keyword is only valid if the TV </span>
<span class="comments">;         keyword is set.</span>
<span class="comments">;    oposition: out, optional, type=float</span>
<span class="comments">;         Set this keyword to a named variable to obtain the actual position in the</span>
<span class="comments">;         graphics window where the image was located. The output position may be</span>
<span class="comments">;         different from the input `POSITION`, especially if the `KEEP_ASPECT_RATIO`</span>
<span class="comments">;         keyword is set. Note that the output position is also stored in a </span>
<span class="comments">;         FSC_$CGIMAGE common block so that other programs (e.g., cgMap, cgImageInfo, </span>
<span class="comments">;         etc.) can take advantage of this information.</span>
<span class="comments">;    outfilename: in, optional, type=string</span>
<span class="comments">;         If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;         filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;         value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;         presented to the user.</span>
<span class="comments">;    output: in, optional, type=string, default=""</span>
<span class="comments">;         Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;         Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;         file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;         user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;         All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;         PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;         to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;         details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;         plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;         output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;    overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;         Setting this keyword causes the POSITION keyword to be ignored</span>
<span class="comments">;         and the image is positioned in the location established by the</span>
<span class="comments">;         last graphics command. If the XRange and YRange keywords are also</span>
<span class="comments">;         used, the image position is adjusted with respect to the current axes</span>
<span class="comments">;         range.  Setting this keyword also sets the NoErase keyword, if it is not currently set.</span>
<span class="comments">;         It is assumed that the overplotted images fits entirely inside or is coincident with the</span>
<span class="comments">;         position or range of the previous image. If not, an informational error is generated and</span>
<span class="comments">;         the position is forced into the range of 0 to 1.</span>
<span class="comments">;    palette: in, optional, type=byte</span>
<span class="comments">;         Set this keyword to a 3x256 or 256x3 byte array containing the RGB color </span>
<span class="comments">;         vectors to be loaded before the image is displayed. Such vectors can be </span>
<span class="comments">;         obtained, for example, from cgLoadCT with the RGB_TABLE keyword::</span>
<span class="comments">;               </span>
<span class="comments">;                cgLoadCT, 4, /BREWER, /REVERSE, RGB_TABLE=palette</span>
<span class="comments">;                cgImage, cgDemoData(7), PALETTE=palette</span>
<span class="comments">;    position: in, optional, type=float</span>
<span class="comments">;         The location of the image in the output window. This is a four-element </span>
<span class="comments">;         floating array of normalized coordinates of the type given by !P.POSITION </span>
<span class="comments">;         or the POSITION keyword to other IDL graphics commands. The form is [x0, y0, x1, y1].</span>
<span class="comments">;         The default is [0.0, 0.0, 1.0, 1.0]. Note that this keyword is ALSO an output </span>
<span class="comments">;         keyword. That is to say, upon return from cgImage this keyword (if passed by </span>
<span class="comments">;         reference) contains the actual position in the window where the image was </span>
<span class="comments">;         displayed. This may be different from the input values if the KEEP_ASPECT_RATIO</span>
<span class="comments">;         keyword is set, or if you are using cgImage with the POSITION keyword when !P.MULTI </span>
<span class="comments">;         is set to something other than a single plot. Note that the POSITION keyword should </span>
<span class="comments">;         not, normally, be used when displaying multiple images with !P.MULTI. If it is used,</span>
<span class="comments">;         its meaning differs slightly from its normal meaning. !P.MULTI is responsible for </span>
<span class="comments">;         calculating the position of graphics in the display window. Normally, it would be a </span>
<span class="comments">;         mistake to use a POSITION graphics keyword on a graphics command that was being drawn with</span>
<span class="comments">;         !P.MULTI. But in this special case, cgImage will use the POSITION coordinates to calculate </span>
<span class="comments">;         an image position in the actual position calculated for the image by !P.MULTI. The main </span>
<span class="comments">;         purpose of this functionality is to allow the user to display images along with</span>
<span class="comments">;         color bars when using !P.MULTI. </span>
<span class="comments">;    quiet: in, optional, type=boolean, default=0</span>
<span class="comments">;         There are situations when you would prefer that cgIMAGE does not advertise itself by </span>
<span class="comments">;         filling out the FSC_$CGIMAGE common block. For example, if you are using cgImage to </span>
<span class="comments">;         draw a color bar, it would not be necessary. Setting this keyword means that cgImage </span>
<span class="comments">;         just goes quietly about it's business without bothering anyone else.    </span>
<span class="comments">;    reverse: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to reverse the color table vectors selected with the `CTIndex` keyword.</span>
<span class="comments">;    save: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this to cause a data coordinate system to be established for the image. The XRANGE </span>
<span class="comments">;         and YRANGE keyword values will be used to establish a data coordinate system coincident </span>
<span class="comments">;         with the final image position. Setting the `AXES` keyword automatically sets SAVE=1.</span>
<span class="comments">;    scale: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to byte scale the image before display. If this keyword is not set, </span>
<span class="comments">;         the image is not scaled before display. This keyword will be set automatically by using</span>
<span class="comments">;         any of the keywords normally associated with byte scaling an image. Available only with </span>
<span class="comments">;         2D images. If set, STRETCH is set to 1, unless it is set to another value.</span>
<span class="comments">;    stretch: in, optional, type=integer/string, default=0</span>
<span class="comments">;         The type of scaling performed prior to display. May be specified as a number </span>
<span class="comments">;         or as a string (e.g, 3 or "Log"). Available only with 2D images. If  Min(image)</span>
<span class="comments">;         is less than zero or Max(image) is greater than 255, then the default value for</span>
<span class="comments">;         stretch is 1.</span>
<span class="comments">;</span>
<span class="comments">;         Number   Type of Stretch::</span>
<span class="comments">;             0         None           No scaling whatsoever is done.</span>
<span class="comments">;             1         Linear         scaled = BytScl(image, MIN=minValue, MAX=maxValue)</span>
<span class="comments">;             2         Clip           A histogram stretch, with a percentage of pixels clipped at both the top and bottom</span>
<span class="comments">;             3         Gamma          scaled = GmaScl(image, MIN=minValue, MAX=maxValue, Gamma=gamma)</span>
<span class="comments">;             4         Log            scaled = LogScl(image, MIN=minValue, MAX=maxValue, Mean=mean, Exponent=exponent)</span>
<span class="comments">;             5         Asinh          scaled = AsinhScl(image, MIN=minValue, MAX=maxValue, Beta=beta)</span>
<span class="comments">;             6         SquareRoot     A linear stretch of the square root histogram of the image values.</span>
<span class="comments">;             7         Equalization   A linear stretch of the histogram equalized image histogram.</span>
<span class="comments">;             8         Gaussian       A Gaussian normal function is applied to the image histogram.</span>
<span class="comments">;             9         MODIS          Scaling done in the differential manner of the MODIS Rapid Response Team</span>
<span class="comments">;                                      and implemented in the Coyote Library routine ScaleModis.</span>
<span class="comments">;             10        StdDev         Standard deviation stretch. scaled = SDevScl(image, MULTIPLIER=2).</span>
<span class="comments">;             </span>
<span class="comments">;    sigma: in, optional, type=float, default=1.0</span>
<span class="comments">;         The sigma scale factor in a Gaussian stretch. Available only with 2D images.</span>
<span class="comments">;    title: in, optional, type=string, default=""</span>
<span class="comments">;         Set this keyword to the title of the image plot. No title will appear with the</span>
<span class="comments">;         image unless the `AXES` keyword is also set.</span>
<span class="comments">;    top: in, optional, type=integer, default=255</span>
<span class="comments">;         If the SCALE keyword is set, the image is scaled before display so that all </span>
<span class="comments">;         displayed pixels have values greater than or equal to BOTTOM and less than </span>
<span class="comments">;         or equal to TOP. Available only with 2D images.</span>
<span class="comments">;    transparent: in, optional, type=integer, default=50</span>
<span class="comments">;         A number between 0 and 100 that specifies the percent of transparency between the</span>
<span class="comments">;         image being displayed and the background image. Displaying a transparent image does</span>
<span class="comments">;         not advance !P.Multi.</span>
<span class="comments">;    tv: in, optional, type=boolean, default=0</span>
<span class="comments">;         Setting this keyword makes the cgImage command work much like the brain-dead</span>
<span class="comments">;         TV command except that it will get colors right on all output devices. Most of</span>
<span class="comments">;         the cgImage keywords are ignored if this keyword is set.</span>
<span class="comments">;    window: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to replace all the commands in a current cgWindow or to</span>
<span class="comments">;         create a new cgWindow for displaying this command. If the DISPLAY keyword is</span>
<span class="comments">;         also set, a new cgWindow will be created.</span>
<span class="comments">;    xrange: in, optional, type=fltarr(2)</span>
<span class="comments">;         A two element array giving the X range of the image. By default set to</span>
<span class="comments">;         [0, size of image in X].</span>
<span class="comments">;    xtitle: in, optional, type=string, default=""</span>
<span class="comments">;         The X title of the image plot. Used only if `AXES` is set.</span>
<span class="comments">;    yrange: in, optional, type=fltarr(2)</span>
<span class="comments">;         A two element array giving the Y range of the image. By default set to</span>
<span class="comments">;         [0, size of image in Y].</span>
<span class="comments">;    ytitle: in, optional, type=string, default=""</span>
<span class="comments">;         The Y title of the image plot. Used only if `AXES` is set.</span>
<span class="comments">;    _ref_extra: in, optional, type=varies</span>
<span class="comments">;         Any keywords defined for the TV command can be used. This applies only</span>
<span class="comments">;         if the TV keyword is set.</span>
<span class="comments">;-           </span>
PRO cgImage, image, x, y, $
   ADDCMD=addcmd, $
   ALPHABACKGROUNDIMAGE=alphaBackgroundImage, $
   ALPHABGPOSITION=alphabgpos, $
   ALPHAFGPOSITION=alphafgpos, $
   AXIS=axis, $
   AXES=axes, $
   AXKEYWORDS=axkeywords, $
   BACKGROUND=background, $
   BOTTOM=bottom, $
   BETA=beta, $
   BREWER=brewer, $
   CHARSIZE=charsize, $
   CLIP=clip, $
   COLOR=color, $
   CTINDEX=ctindex, $
   DISPLAY=display, $      <span class="comments">; Make sure this keyword is NOT is the list of keywords passed to cgWindow.</span>
   ERASE=obsolete_erase, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
   EXCLUDE=exclude, $
   EXPONENT=exponent, $
   FILENAME=filename, $
   FIT_INSIDE=fit_inside, $
   FONT=font, $
   GAMMA=gamma, $
   INTERPOLATE=interpolate, $
   KEEP_ASPECT_RATIO=keep_aspect, $
   LAYOUT=layout, $
   MAPCOORD=mapcoord, $
   MARGIN=margin, $
   MAXVALUE=max, $
   MEAN=mean, $
   MISSING_COLOR=missing_color, $
   MISSING_INDEX=missing_index, $
   MISSING_VALUE=missing_value, $
   NEGATIVE=negative, $
   MINUS_ONE=minusOne, $
   MINVALUE=min, $
   MULTIMARGIN=multimargin, $
   MULTIPLIER=multiplier, $
   NCOLORS=ncolors, $
   NOERASE=noerase, $
   NOINTERPOLATION=obsolete_nointerpolation, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
   NORMAL=normal, $
   OUTFILENAME=outfilename, $
   OUTPUT=output, $
   OPOSITION=oposition, $
   OVERPLOT=overplot, $
   PALETTE=palette, $
   POSITION=position, $
   QUIET=quiet, $
   REVERSE=reverse, $
   SAVE=save, $
   SCALE=scale, $
   SIGMA=sigma, $
   STRETCH=stretch, $
   TITLE=title, $
   TOP=top, $
   TRANSPARENT=transparent, $
   TV=tv, $
   WINDOW=window, $
   XRANGE=plotxrange, $
   XTITLE=plotxtitle, $
   YRANGE=plotyrange, $
   YTITLE=plotytitle, $
   _REF_EXTRA=extra

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
       Catch, /Cancel
       ok = Error_Message()
       IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
       IF transparentImage THEN image = oldImage
       RETURN
    ENDIF
    
    <span class="comments">; Check parameters.</span>
    IF (N_Params() EQ 0) && (N_Elements(filename) EQ 0) THEN BEGIN
        Print, 'USE SYNTAX: cgImage, image'
        RETURN
    ENDIF
    
    <span class="comments">; Was a filename used to pass in an image filename? Check to see if this is a GeoTiff image</span>
    <span class="comments">; before doing anything else. If it is, use cgGeoMap to read it. Otherwise, read the image</span>
    <span class="comments">; file with READ_IMAGE.</span>
    IF N_Elements(filename) NE 0 THEN BEGIN
        check = Query_Tiff(filename, GEOTIFF=geo)
        IF (check EQ 1) && (Size(geo, /TNAME) EQ 'STRUCT') THEN BEGIN
           mapCoord = cgGeoMap(filename, IMAGE=image, Palette=palette)
        ENDIF ELSE BEGIN
           image = Read_Image(filename, r, g, b)
           IF N_Elements(r) NE 0 THEN palette = [[r],[g],[b]]
        ENDELSE
    ENDIF 
    
    <span class="comments">; Handle obsolete keywords.</span>
    IF N_Elements(obsolete_erase) NE 0 THEN noerase = 1 - obsolete_erase
    IF N_Elements(obsolete_nointerpolation) NE 0 THEN interp = 1 - obsolete_nointerpolation
    
    <span class="comments">; Set up a common block as input to cgImageInfo.</span>
    COMMON FSC_$CGIMAGE, _cgimage_xsize, $    <span class="comments">; The X size of the image.</span>
                         _cgimage_ysize, $    <span class="comments">; The Y size of the imge.</span>
                         _cgimage_winxsize, $ <span class="comments">; The X size of the window displaying the image.</span>
                         _cgimage_winysize, $ <span class="comments">; The Y size of the window displaying the image.</span>
                         _cgimage_position, $ <span class="comments">; The final position of the image in the window.</span>
                         _cgimage_winID, $    <span class="comments">; The window index number of the window displaying the image.</span>
                         _cgimage_current     <span class="comments">; Set to 1 if a call to cgImage is made.</span>
    
    <span class="comments">; Add the command to cgWindow?</span>
    IF Keyword_Set(addcmd) THEN BEGIN
        noerase = 1
        window = 1
    ENDIF
    
    <span class="comments">; Do we want to display the image in a window with the proper aspect ratio?</span>
    IF Keyword_Set(display) THEN BEGIN
    
         <span class="comments">; Are we making a cgWindow?</span>
         IF Keyword_Set(window) THEN BEGIN
             dims = Image_Dimensions(image, XSIZE=xsize, YSIZE=ysize)
             imgaspect = Float(ysize) / xsize
             cgWindow, WASPECT=imgaspect
             addcmd = 0
             noerase = 0
         ENDIF ELSE BEGIN
             IF ~Keyword_Set(addcmd) THEN cgDisplay, /Free, ASPECT=image
         ENDELSE
    
    ENDIF
    
    <span class="comments">; If we want a cgWindow and we can make windows in this device, do so now.</span>
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
        
        <span class="comments">; If we are adding a command, we have to do something different.</span>
        IF Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgImage', image, x, y, $
               ALPHABACKGROUNDIMAGE=alphaBackgroundImage, $
               ALPHABGPOSITION=alphabgpos, $
               ALPHAFGPOSITION=alphafgpos, $
               AXIS=axis, $
               AXES=axes, $
               AXKEYWORDS=axkeywords, $
               BACKGROUND=background, $
               BOTTOM=bottom, $
               BETA=beta, $
               BREWER=brewer, $
               CHARSIZE=charsize, $
               CLIP=clip, $
               COLOR=color, $
               CTINDEX=ctindex, $
               ERASE=obsolete_erase, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
               EXCLUDE=exclude, $
               EXPONENT=exponent, $
               FILENAME=filename, $
               FIT_INSIDE=fit_inside, $
               FONT=font, $
               GAMMA=gamma, $
               INTERPOLATE=interpolate, $
               KEEP_ASPECT_RATIO=keep_aspect, $
               LAYOUT=layout, $
               MAPCOORD=mapcoord, $
               MARGIN=margin, $
               MAXVALUE=max, $
               MEAN=mean, $
               MISSING_COLOR=missing_color, $
               MISSING_INDEX=missing_index, $
               MISSING_VALUE=missing_value, $
               MINUS_ONE=minusOne, $
               MINVALUE=min, $
               MULTIMARGIN=multimargin, $
               MULTIPLIER=multiplier, $
               NCOLORS=ncolors, $
               NEGATIVE=negative, $
               NOERASE=noerase, $
               NOINTERPOLATION=obsolete_nointerpolation, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
               NORMAL=normal, $
               OPOSITION=oposition, $
               OVERPLOT=overplot, $
               PALETTE=palette, $
               POSITION=position, $
               QUIET=quiet, $
               REVERSE=reverse, $
               SAVE=save, $
               SCALE=scale, $
               SIGMA=sigma, $
               STRETCH=stretch, $
               TITLE=title, $
               TOP=top, $
               TRANSPARENT=transparent, $
               TV=tv, $
               XRANGE=plotxrange, $
               XTITLE=plotxtitle, $
               YRANGE=plotyrange, $
               YTITLE=plotytitle, $
               ADDCMD=1, $
               _EXTRA=extra
            RETURN
        ENDIF
        
        <span class="comments">; Otherwise, we are replacing the commands in a new or existing window.</span>
        cgWindow, 'cgImage', image, x, y, $
               ALPHABACKGROUNDIMAGE=alphaBackgroundImage, $
               ALPHABGPOSITION=alphabgpos, $
               ALPHAFGPOSITION=alphafgpos, $
               AXIS=axis, $
               AXES=axes, $
               AXKEYWORDS=axkeywords, $
               BACKGROUND=background, $
               BOTTOM=bottom, $
               BETA=beta, $
               BREWER=brewer, $
               CHARSIZE=charsize, $
               CLIP=clip, $
               COLOR=color, $
               CTINDEX=ctindex, $
               ERASE=obsolete_erase, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
               EXCLUDE=exclude, $
               EXPONENT=exponent, $
               FILENAME=filename, $
               FIT_INSIDE=fit_inside, $
               FONT=font, $
               GAMMA=gamma, $
               INTERPOLATE=interpolate, $
               KEEP_ASPECT_RATIO=keep_aspect, $
               LAYOUT=layout, $
               MAPCOORD=mapcoord, $
               MARGIN=margin, $
               MAXVALUE=max, $
               MEAN=mean, $
               MISSING_COLOR=missing_color, $
               MISSING_INDEX=missing_index, $
               MISSING_VALUE=missing_value, $
               MINUS_ONE=minusOne, $
               MINVALUE=min, $
               MULTIMARGIN=multimargin, $
               MULTIPLIER=multiplier, $
               NCOLORS=ncolors, $
               NEGATIVE=negative, $
               NOERASE=noerase, $
               NOINTERPOLATION=obsolete_nointerpolation, $ <span class="comments">; Added for compatibility with TVIMAGE.</span>
               NORMAL=normal, $
               OPOSITION=oposition, $
               OVERPLOT=overplot, $
               PALETTE=palette, $
               POSITION=position, $
               QUIET=quiet, $
               REVERSE=reverse, $
               SAVE=save, $
               SCALE=scale, $
               SIGMA=sigma, $
               STRETCH=stretch, $
               TITLE=title, $
               TOP=top, $
               TRANSPARENT=transparent, $
               TV=tv, $
               XRANGE=plotxrange, $
               XTITLE=plotxtitle, $
               YRANGE=plotyrange, $
               REPLACECMD=replacecmd, $
               _EXTRA=extra
             RETURN
    ENDIF
    
    <span class="comments">; Obtain information about the size of the image.</span>
    void = Image_Dimensions(image, XSIZE=imgXSize, YSIZE=imgYSize)
    
    <span class="comments">; Doing multiple plots?</span>
    IF (Total(!P.Multi) GT 0) || (N_Elements(layout) NE 0) THEN multi = 1 ELSE multi = 0
    
    <span class="comments">; Did you specify a color table index?</span>
    TVLCT, r_start, g_start, b_start, /Get
    IF N_Elements(ctindex) NE 0 THEN BEGIN
        cgLoadCT, ctindex, Reverse=reverse, Brewer=brewer, RGB_TABLE=palette
    ENDIF
    
    <span class="comments">; If the missing_value (or missing_color) and noerase keywords are set, then </span>
    <span class="comments">; the transparent keyword should be defined and set to zero transparency.</span>
    IF ((N_Elements(missing_value) NE 0) || ( N_Elements(missing_color) NE 0) ) $
      && (N_Elements(transparent) EQ 0) && (N_Elements(missing_index) EQ 0) THEN transparent = 0

    <span class="comments">; If transparent is turned on, and you are not overplotting, and you have a position in the window, then</span>
    <span class="comments">; you have to adjust alphafgpos and position.</span>
    IF (N_Elements(transparent) NE 0) && ~Keyword_Set(overplot) && (N_Elements(position) NE 0) THEN BEGIN
        IF (N_Elements(alphafgpos) EQ 0) THEN BEGIN
             restorePosition = position
             alphafgpos = position
             position = [0,0,1,1]
             Message, 'POSITION keyword value switched to ALPHAFGPOS because TRANSPARENT keyword is set.', /Informational
        ENDIF
    ENDIF
    
    <span class="comments">; Load the color palette if you are using one.</span>
    IF N_Elements(palette) NE 0 THEN BEGIN
        IF Size(palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
        dims = Size(palette, /DIMENSIONS)
        threeIndex = Where(dims EQ 3)
        IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
        IF threeIndex[0] EQ 0 THEN palette = Transpose(palette)
        TVLCT, p_red, p_grn, p_blu, /Get <span class="comments">; Save the color vectors before loading the palette.</span>
    ENDIF
    
    <span class="comments">; Are we doing a transparent image? Please scale the image before passing</span>
    <span class="comments">; it into cgImage.</span>
    transparentImage = 0
    IF N_Elements(transparent) NE 0 THEN BEGIN
    
        <span class="comments">; Do you need a window?</span>
        IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    
        transparent = 0 > transparent &lt<span class="comments">; 100</span>
        oldImage = image
        scaledImage = cgImgScl(image, $
             BOTTOM=bottom, $
             BETA=beta, $
             CLIP=clip, $
             EXCLUDE=exclude, $
             EXPONENT=exponent, $
             GAMMA=gamma, $
             INTERPOLATE=interpolate, $
             MAXVALUE=maxvalue, $
             MEAN=mean, $
             MINUS_ONE=minus_one, $
             MINVALUE=minvalue, $
             MISSING_INDEX=missing_index, $
             MISSING_VALUE=missing_value, $
             MULTIPLIER=multiplier, $
             NCOLORS=ncolors, $
             NEGATIVE=negative, $
             SCALE=scale, $
             STRETCH=stretch, $
             SIGMA=sigma, $
             TOP=top)
          transImage = cgImage_Make_Transparent_Image(scaledImage, transparent, $
             MISSING_VALUE=missing_index, $
             PALETTE=palette, $
             SUCCESS=success)
        IF success THEN BEGIN
            transparentImage = 1
            image = transImage
            IF (N_Elements(alphabackgroundimage) EQ 0) THEN BEGIN
                IF !D.Name NE "PS" THEN BEGIN
                   alphabackgroundimage = cgSnapshot(POSITION=[0,0,1,1])
                ENDIF ELSE Message, 'An AlphaBackgroundImage is required to create transparent images in PostScript.'
            ENDIF
            IF ~multi THEN IF N_Elements(alphabgpos) EQ 0 THEN alphabgpos = [0,0,1,1]
            IF ~multi THEN IF N_Elements(alphafgpos) EQ 0 THEN alphafgpos = [0,0,1,1]
            IF ~multi THEN IF N_Elements(position) EQ 0 THEN position= [0,0,1,1]
            noerase = 1
        ENDIF ELSE BEGIN
            image = oldImage
            RETURN
        ENDELSE
    ENDIF
      
    <span class="comments">; Need a data range? Set it up if you have a map coordinate object. Otherwise,</span>
    <span class="comments">; we will handle it later.</span>
    IF N_Elements(plotxrange) EQ 0 THEN BEGIN
       IF Obj_Valid(mapCoord) THEN BEGIN
             mapCoord -> GetProperty, XRANGE=plotxrange 
             save = 1
       ENDIF 
    ENDIF ELSE save = 1
    IF N_Elements(plotyrange) EQ 0 THEN BEGIN
       IF Obj_Valid(mapCoord) THEN BEGIN
            mapCoord -> GetProperty, YRANGE=plotyrange 
            save = 1
       ENDIF 
    ENDIF ELSE save = 1
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    ENDIF
   
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Which release of IDL is this?</span>
    thisRelease = Float(!Version.Release)
    
    <span class="comments">; If the OVERPLOT keyword is set, also set the NOERASE keyword, unless it is already set.</span>
    IF Keyword_Set(overplot) THEN BEGIN
        IF (N_Elements(noerase) EQ 0) THEN noerase = 1
    ENDIF
            
     <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    keep_aspect = Keyword_Set(keep_aspect)
    
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            overplot = 0
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

    <span class="comments">; Character size has to be determined *after* the layout has been decided.</span>
    IF N_Elements(font) EQ 0 THEN font = !P.Font
    IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize(FONT=font)
    IF N_Elements(color) EQ 0 THEN acolorname = 'opposite' ELSE acolorname = color
    interp = Keyword_Set(interp)
    
    <span class="comments">; Check for image parameter and keywords.</span>
    IF N_Elements(image) EQ 0 THEN MESSAGE, 'You must pass a valid image argument.'
    
    <span class="comments">; Did the user want to scale the image?</span>
    <span class="comments">; If either MIN or MAX are set, this implies SCALE=1.</span>
    <span class="comments">; If min LT 0 or max GT 255, this implies SCALE=1.</span>
    <span class="comments">; If NCOLORS is used, this implies SCALE=1.</span>
    IF N_Elements(min) EQ 0 THEN min = Min(image, /NAN) ELSE scale = 1
    IF N_Elements(max) EQ 0 THEN max = Max(image, /NAN) ELSE scale = 1
    IF (min LT 0) OR (max GT 255) THEN scale = 1
    IF N_Elements(top) EQ 0 THEN top = (N_Elements(missing_value) NE 0) ? !D.TABLE_SIZE - 2 : !D.TABLE_SIZE - 1
    IF N_Elements(bottom) EQ 0 THEN bottom = 0B
    IF N_Elements(ncolors) NE 0 THEN BEGIN
        top = (N_Elements(missing_value) NE 0) ? (ncolors - 2) &lt<span class="comments">; 255 : (ncolors - 1)</span>
        scale = 1
    ENDIF
    
    ncolors = top-bottom+1
    negative = Keyword_Set(negative)
    scale = Keyword_Set(scale)
    IF scale THEN BEGIN
       IF N_Elements(stretch) EQ 0 THEN stretch = 1
    ENDIF 
    
    <span class="comments">; Set default values.</span>
    SetDefaultValue, alphafgpos, [0.0, 0.0, 1.0, 1.0]
    SetDefaultValue, alphabgpos, [0.0, 0.0, 1.0, 1.0]
    SetDefaultValue, beta, 3.0
    SetDefaultValue, clip, 2
    SetDefaultValue, exponent, 4.0
    SetDefaultValue, gamma, 1.5 
    SetDefaultValue, mean, 1.0
    SetDefaultValue, missing_index, 255
    SetDefaultValue, negative, 0
    SetDefaultValue, sigma, 1.0
    SetDefaultValue, stretch, 0
    
    <span class="comments">; Make sure you can specify the type of stretch with a string name.</span>
    IF Size(stretch, /TNAME) EQ 'STRING' THEN BEGIN
        stretches = ['None', 'Linear', 'Clip', 'Gamma', 'Log', 'ASinh', $
              'SquareRoot', 'Equalization', 'Gaussian', 'MODIS', 'StdDev']
       
       index = Where(StrUpCase(stretch) EQ StrUpCase(stretches), count)
       IF count GT 0 THEN stretch=index ELSE Message, 'Cannot find stretch: ' + StrUpCase(stretch)
    ENDIF
    IF stretch NE 0 THEN scale = 1
    
    <span class="comments">; Check for mis-spelling of AXES as AXIS.</span>
    IF Keyword_Set(axis) THEN axes = 1    
    axes = Keyword_Set(axes)
    
    <span class="comments">; If you want axes, then save the coordinate system, unless </span>
    <span class="comments">; specifically asked not to.</span>
    IF axes THEN IF N_Elements(save) EQ 0 THEN save = 1
    
    <span class="comments">; If axes are set and MARGIN and POSITION are NOT set and you are NOT</span>
    <span class="comments">; doing multiplots, then set a normal "plot" margin.</span>
    IF Keyword_Set(axes) && ((N_Elements(margin) EQ 0) && (N_Elements(position) EQ 0) $
        && (multi EQ 0)) THEN position=[0.125, 0.125, 0.925, 0.9]
    
    <span class="comments">; Check other keywords.</span>
    interp = Keyword_Set(interp)
    IF N_Elements(minusOne) EQ 0 THEN minusOne = 0
    minusOne = Keyword_Set(minusOne)
        
    IF N_Elements(background) EQ 0 THEN background = 'white'
    IF Size(background, /TNAME) EQ 'STRING' THEN BEGIN
        IF StrUpCase(background) EQ 'BACKGROUND' THEN BEGIN
           IF N_Elements(acolorname) EQ 0 THEN acolorname = 'opposite'
        ENDIF 
        IF StrUpCase(background) EQ 'WHITE' THEN BEGIN
           IF N_Elements(acolorname) EQ 0 THEN acolorname = 'black' 
        ENDIF 
    ENDIF
    noerase = Keyword_Set(noerase) <span class="comments">; Don't change, used in PS output.</span>
    
    <span class="comments">; Choose an axis color.</span>
    acolor = cgDefaultColor(acolorname, DEFAULT='OPPOSITE')
    
    <span class="comments">; If you have a palette, load it now.</span>
    IF N_Elements(palette) NE 0 THEN TVLCT, palette
    
    <span class="comments">; If you have a missing color, load it at the missing color index.</span>
    IF N_Elements(missing_color) NE 0 THEN TVLCT, cgColor(missing_color, /Triple), missing_index
    
    <span class="comments">; Before you do anything, get the current color table vectors</span>
    <span class="comments">; so they can be restored later. Must do AFTER loading a palette!</span>
    TVLCT, rr, gg, bb, /Get
    
    <span class="comments">; If this is an image with an alpha channel, and there is no alphachannel background image</span>
    <span class="comments">; supplied, you will have to take a snapshot of the current window right now before you</span>
    <span class="comments">; erase the window. If the smallest image dimension is a 4, then we will assume this is</span>
    <span class="comments">; an image with an alpha channel.</span>
    IF Min(Size(image, /DIMENSIONS)) EQ 4 THEN BEGIN
    
       <span class="comments">; We can get the background image on devices that support windows.</span>
       IF (!D.Flags AND 256) NE 0 THEN BEGIN
           IF N_Elements(alphabackgroundImage) EQ 0 THEN BEGIN
               alphabackgroundImage = cgSnapshot()
           ENDIF
       ENDIF ELSE BEGIN
           IF N_Elements(alphabackgroundImage) EQ 0 THEN BEGIN
               <span class="comments">; Otherwise, blend this with a white image.</span>
               alphabackgroundImage = BytArr(100,100) + 255B
           ENDIF
       ENDELSE
    ENDIF
    
    <span class="comments">; If you have an alpha background image, make sure it is a true-color image.</span>
    IF N_Elements(alphaBackgroundImage) NE 0 THEN BEGIN
       IF Size(alphaBackgroundImage, /N_DIMENSIONS) EQ 2 THEN BEGIN
          TVLCT, r, g, b, /Get
          alphaBackgroundImage = [ [[r_start[alphaBackgroundImage]]], $
             [[g_start[alphaBackgroundImage]]], [[b_start[alphaBackgroundImage]]] ]
       ENDIF
    ENDIF
    
    <span class="comments">; Do you need to erase the window before image display?</span>
    IF ~Keyword_Set(noerase) && (!P.MULTI[0] LE 0) && (N_Elements(layout) EQ 0) THEN BEGIN
         IF (!D.Flags AND 256) NE 0 THEN BEGIN
            cgErase, background
         ENDIF ELSE BEGIN
            IF (!D.NAME EQ 'Z') THEN BEGIN
                cgErase, background
            ENDIF
            
            <span class="comments">; Do you need a PostScript background color? Lot's of problems here!</span>
            <span class="comments">; Basically, I MUST draw a plot to advance !P.MULTI. But, drawing a</span>
            <span class="comments">; plot of any sort erases the background color. So, I have to draw a </span>
            <span class="comments">; plot, store the new system variables, then draw my background, etc.</span>
            <span class="comments">; I have tried LOTS of options. This is the only one that worked.</span>
            IF !D.Name EQ 'PS' THEN BEGIN
               IF ~noerase THEN BEGIN
               
                   <span class="comments">; I only have to do this, if this is the first plot.</span>
                   IF !P.MULTI[0] EQ 0 THEN BEGIN
                   
                        <span class="comments">; Save the current system variables. Will need to restore later.</span>
                        bangx = !X
                        bangy = !Y
                        bangp = !P
                        
                        <span class="comments">; Draw the plot that doesn't draw anything.</span>
                        Plot, [0], POSITION=position, /NODATA, XSTYLE=4, YSTYLE=4, ZSTYLE=4
                        
                        <span class="comments">; Save the "after plot" system variables. Will use later. </span>
                        afterx = !X
                        aftery = !Y
                        afterp = !P     
                        
                        <span class="comments">; Draw the background color and set the variables you will need later.</span>
                        PS_Background, background
                        psnodraw = 1
                        tempNoErase = 1
                        
                        <span class="comments">; Restore the original system variables so that it is as if you didn't</span>
                        <span class="comments">; draw the invisible plot.</span>
                        !X = bangx
                        !Y = bangy
                        !P = bangp
                        TVLCT, rr, gg, bb
                    ENDIF ELSE tempNoErase = noerase
                ENDIF ELSE tempNoErase = noerase
             ENDIF ELSE tempNoErase = noerase
         ENDELSE
    ENDIF
    
    <span class="comments">; Need a margin around the plot?</span>
    IF (N_Elements(margin) GT 0) THEN BEGIN
       IF Keyword_Set(margin) EQ 0 THEN BEGIN
          IF N_Elements(multimargin) EQ 0 THEN multimargin=[0., 0., 0., 0.] 
       ENDIF ELSE BEGIN
          IF N_Elements(multimargin) EQ 0 THEN multimargin=[1., 1., 1., 1.]
       ENDELSE
       IF margin[0] EQ 1 THEN margin = 0.075  <span class="comments">; Comes from /MARGIN</span>
    ENDIF 
    
    <span class="comments">; Make sure the multimargin has four elements.</span>
    IF N_Elements(multimargin) EQ 0 THEN multimargin = [0., 0., 0., 0.] 
    IF N_Elements(multimargin) EQ 1 THEN multimargin = [multimargin, multimargin, multimargin, multimargin]
    IF N_Elements(multimargin) NE 4 THEN Message, 'The keyword MULTIMARGIN must be a four-element array.'
    
    <span class="comments">; Check image size.</span>
    s = Size(image)
    IF s[0] LT 2 OR s[0] GT 3 THEN $
       MESSAGE, 'Argument does not appear to be an image. Returning...'
    alphaImage = 0
    
    <span class="comments">; Allow 24-bit images and 2D images that are sent in as 3D</span>
    <span class="comments">; arrays where one dimension is a 1. 24-bit images can have an</span>
    <span class="comments">; alpha channel.</span>
    IF s[0] EQ 3 THEN BEGIN
    
       <span class="comments">; We are going to fake doing something with the alpha channel here.</span>
       i = Where(s[1:3] EQ 3, threeCnt)
       i = Where(s[1:3] EQ 4, fourCnt)
       IF threeCnt EQ 0 AND fourCnt NE 0 THEN BEGIN
            s[i+1] = 3
            alphaImage = 1
       ENDIF ELSE alphaImage = 0
       
       <span class="comments">; Now handle normal 24-bit images and suspect 2D images.</span>
       IF (s[1] NE 3L) AND (s[2] NE 3L) AND (s[3] NE 3L) THEN BEGIN
          IF (s[1] NE 1L) AND (s[2] NE 1L) AND (s[3] NE 1L) THEN BEGIN
             MESSAGE, 'Argument does not appear to be a 24-bit image. Returning...'
          ENDIF ELSE BEGIN
             IF s[1] EQ 1 THEN single = 1
             IF s[2] EQ 1 THEN single = 2
             IF s[3] EQ 1 THEN single = 3
             CASE single OF
                1: image = Reform(image, s[2], s[3])
                2: image = Reform(image, s[1], s[3])
                3: image = Reform(image, s[1], s[2])
             ENDCASE
             s = Size(image)
          ENDELSE
       ENDIF
    ENDIF ELSE s = Size(image)
    
    <span class="comments">; If a window is not open, open one, otherwise in X devices you get incorrect</span>
    <span class="comments">; window size information the first time you call cgImage.</span>
    IF ((!D.FLAGS AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    
    <span class="comments">; Check for position and overplot keywords.</span>
    IF N_Elements(position) EQ 0 THEN BEGIN
       IF Keyword_Set(multi) AND (Keyword_Set(overplot) NE 1) THEN BEGIN
          <span class="comments">; Draw the invisible plot to get plot position.</span>
          IF Size(background, /TNAME) EQ 'STRING' THEN background = cgColor(background)
          Plot, Findgen(11), XStyle=4, YStyle=4, /NoData, Background=background, $
             XMargin=multimargin[[1,3]], YMargin=multimargin[[0,2]], $
             NOERASE=N_Elements(layout) EQ 0 ? tempNoErase : 1
          position = [!X.Window[0], !Y.Window[0], !X.Window[1], !Y.Window[1]]
          TVLCT, rr, gg, bb
       ENDIF ELSE BEGIN
          IF Keyword_Set(overplot) THEN BEGIN
          
             IF (N_Elements(plotxrange) NE 0) && (N_Elements(plotyrange) NE 0) THEN BEGIN
                x0 = !X.S[1]*plotxrange[0] + !X.S[0]
                x1 = !X.S[1]*plotxrange[1] + !X.S[0]
                y0 = !Y.S[1]*plotyrange[0] + !Y.S[0]
                y1 = !Y.S[1]*plotyrange[1] + !Y.S[0]
                position = [x0, y0, x1, y1]
                IF N_Elements(restorePosition) NE 0 THEN restorePosition = position
                
                IF (x0 LT 0.0) || (x1 GT 1.0) || (y0 LT 0.0) || (y1 GT 1.0) THEN BEGIN
                    Message, 'Range of overplotted image is outside the currently established range.', /Informational
                ENDIF
                
                <span class="comments">; Make sure the position is inside of normalized coordinates.</span>
                position = 0.0 > [x0, y0, x1, y1] &lt<span class="comments">; 1.0</span>
                
             ENDIF ELSE BEGIN
                position = [!X.Window[0], !Y.Window[0], !X.Window[1], !Y.Window[1]]
             ENDELSE
          ENDIF ELSE position = [0.0, 0.0, 1.0, 1.0]
       ENDELSE
    ENDIF ELSE BEGIN
       IF Keyword_Set(multi) AND (Keyword_Set(overplot) NE 1)THEN BEGIN
          <span class="comments">; Draw the invisible plot to get plot position.</span>
          IF Size(background, /TNAME) EQ 'STRING' THEN background = cgColor(background)
          IF transparentImage EQ 0 THEN BEGIN
              Plot, Findgen(11), XStyle=4, YStyle=4, /NoData, Background=background, $
                  XMargin=multimargin[[1,3]], YMargin=multimargin[[0,2]], $
                 NOERASE=N_Elements(layout) EQ 0 ? tempNoErase : 1
              TVLCT, rr, gg, bb
              <span class="comments">; Use position coordinates to indicate position in this set of coordinates.</span>
              xrange = !X.Window[1] - !X.Window[0]
              xstart = !X.Window[0] + position[0]*xrange
              xend = xrange * (position[2] - position[0]) + xstart
        
              yrange = !Y.Window[1] - !Y.Window[0]
              ystart = !Y.Window[0] + position[1]*yrange
              yend = yrange * (position[3] - position[1]) + ystart
        
              <span class="comments">; New position based on !P.MULTI position.</span>
              position = [xstart, ystart, xend, yend]
          ENDIF
       ENDIF ELSE BEGIN
          IF Keyword_Set(overplot) THEN BEGIN
             IF (N_Elements(plotxrange) NE 0) && (N_Elements(plotyrange) NE 0) THEN BEGIN
                x0 = !X.S[1]*plotxrange[0] + !X.S[0]
                x1 = !X.S[1]*plotxrange[1] + !X.S[0]
                y0 = !Y.S[1]*plotyrange[0] + !Y.S[0]
                y1 = !Y.S[1]*plotyrange[1] + !Y.S[0]
                position = [x0, y0, x1, y1]

                IF (x0 LT 0.0) || (x1 GT 1.0) || (y0 LT 0.0) || (y1 GT 1.0) THEN BEGIN
                    Message, 'Range of overplotted image is outside the currently established range.', /Informational
                ENDIF
                
                <span class="comments">; Make sure the position is inside of normalized coordinates.</span>
                position = 0.0 > [x0, y0, x1, y1] &lt<span class="comments">; 1.0</span>
                IF N_Elements(restorePosition) NE 0 THEN restorePosition = position
                
             ENDIF ELSE position = Float(position)
             IF N_Elements(transparent) NE 0 THEN BEGIN
                restorePosition = position
                alphafgpos = position
                position = [0,0,1,1]
             ENDIF
          ENDIF
       ENDELSE
    ENDELSE
    
    <span class="comments">; Check to be sure the position is not all zeros.</span>
    IF Total(position) EQ 0.0 THEN BEGIN
        IF Keyword_Set(overplot) $
            THEN Message, 'A previous coordinate system cannot be found for overplotting.' $
            ELSE Message, 'Unable to obtain a valid position for the image.'
    ENDIF
    
    <span class="comments">; Check for margin keyword.</span>
    IF (Keyword_Set(multi) EQ 0) AND (Keyword_Set(overplot) EQ 0) THEN BEGIN
       IF N_Elements(margin) NE 0 THEN BEGIN
               margin = 0.0 > margin &lt<span class="comments">; 0.33</span>
               position = [position[0] + margin, position[1] + margin, $
                           position[2] - margin, position[3] - margin]
       ENDIF
    ENDIF
    
    <span class="comments">; 2D image.</span>
    IF s[0] EQ 2 THEN BEGIN
    
       imgXsize = FLOAT(s[1])
       imgYsize = FLOAT(s[2])
       true = 0
    
       <span class="comments">; Decomposed color off if device supports it.</span>
       CASE  StrUpCase(!D.NAME) OF
            'X': BEGIN
                Device, Get_Visual_Depth=thisDepth
                IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
                Device, Decomposed=0
                ENDCASE
            'WIN': BEGIN
    
                Device, Get_Visual_Depth=thisDepth
                IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
                Device, Decomposed=0
                ENDCASE
            'MAC': BEGIN
                Device, Get_Visual_Depth=thisDepth
                IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
                Device, Decomposed=0
                ENDCASE
            'Z': BEGIN
                <span class="comments">; Fix for 24-bit Z-buffer.</span>
                IF (thisRelease GE 6.4) THEN BEGIN
                   Device, Get_Decomposed=thisDecomposed, Get_Pixel_Depth=thisDepth
                   Device, Decomposed=0
                ENDIF ELSE thisDepth = 8
                ENDCASE
            'PS': BEGIN
                IF (thisRelease GE 7.1) THEN BEGIN
                   thisDecomposed = DecomposedColor(Depth=thisDepth)
                   Device, Decomposed=0
                ENDIF ELSE thisDepth = 8
                ENDCASE
            ELSE: thisDepth = 8
       ENDCASE
    
    ENDIF
    
    <span class="comments">; 3D image.</span>
    IF s[0] EQ 3 THEN BEGIN
    
      <span class="comments">; What kind of pixel interleaving?</span>
      IF s[1] EQ 3 THEN true = 1 <span class="comments">; Pixel interleaved</span>
      IF s[2] EQ 3 THEN true = 2 <span class="comments">; Row interleaved</span>
      IF s[3] EQ 3 THEN true = 3 <span class="comments">; Band interleaved</span>
    
       <span class="comments">; Decomposed color on if device supports it.</span>
       CASE StrUpCase(!D.NAME) OF
          'X': BEGIN
             Device, Get_Visual_Depth=thisDepth
             IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
             IF thisDepth GT 8 THEN Device, Decomposed=1
             ENDCASE
          'WIN': BEGIN
             Device, Get_Visual_Depth=thisDepth
             IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
             IF thisDepth GT 8 THEN Device, Decomposed=1
             ENDCASE
          'MAC': BEGIN
             Device, Get_Visual_Depth=thisDepth
             IF thisRelease GE 5.2 THEN Device, Get_Decomposed=thisDecomposed
             IF thisDepth GT 8 THEN Device, Decomposed=1
             ENDCASE
          'Z': BEGIN
             <span class="comments">; Fix for 24-bit Z-buffer.</span>
             IF (Float(!Version.Release) GE 6.4) THEN BEGIN
                Device, DECOMPOSED=1, Set_Pixel_Depth=24
                thisDepth = 24
             ENDIF ELSE thisDepth = 8
             ENDCASE
          'PS': BEGIN
             IF (Float(!Version.Release) GE 7.1) THEN BEGIN
                   thisDecomposed = DecomposedColor(Depth=thisDepth)
                   TVLCT, r, g, b, /GET
                   LoadCT, 0, /Silent
                   Device, DECOMPOSED=1, BITS_PER_PIXEL=8, COLOR=1
                   TVLCT, r, g, b
             ENDIF ELSE thisDepth = 8
             ENDCASE
          
          ELSE: thisDepth = 8
       ENDCASE
    
       CASE true OF
          1: BEGIN
             imgXsize = FLOAT(s[2])
             imgYsize = FLOAT(s[3])
             ENDCASE
          2: BEGIN
             imgXsize = FLOAT(s[1])
             imgYsize = FLOAT(s[3])
             ENDCASE
          3: BEGIN
             imgXsize = FLOAT(s[1])
             imgYsize = FLOAT(s[2])
             ENDCASE
       ENDCASE
    
    ENDIF
    
    <span class="comments">; Check for TV keyword. If present, then act like a TV command.</span>
    IF Keyword_Set(tv) THEN BEGIN
    
       IF N_Params() GE 3 OR N_Params() EQ 1 THEN BEGIN
         IF N_Elements(x) EQ 0 THEN x = 0
         IF N_Elements(y) EQ 0 THEN y = 0
         IF Keyword_Set(normal) THEN BEGIN
            IF alphaImage THEN BEGIN
               outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                    TV=1, ALPHABGPOSITION=alphapos, ALPHAFGPOSITION=alphafgpos)
               TV, outImage, x, y, True=3, _STRICT_EXTRA=extra, /Normal
            ENDIF ELSE BEGIN
               CASE scale OF
                    0: TV, image, x, y, True=true, _STRICT_EXTRA=extra, /Normal 
                    1: TV, BytScl(image, Top=top, Max=max, Min=min) + bottom, $
                           x, y, True=true, _STRICT_EXTRA=extra, /Normal
                ENDCASE
            ENDELSE
         ENDIF ELSE BEGIN
            IF alphaImage THEN BEGIN
               outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                    TV=1, ALPHABGPOSITION=alphapos, ALPHAFGPOSITION=alphafgpos)
               TV, outImage, x, y, True=3, _STRICT_EXTRA=extra, /Device
            ENDIF ELSE BEGIN
               CASE scale OF
                   0: TV, image, x, y, True=true, _STRICT_EXTRA=extra, /Device
                   1: TV, BytScl(image, Top=top, Max=max, Min=min) + bottom, $
                           x, y, True=true, _STRICT_EXTRA=extra, /Device
                ENDCASE
            ENDELSE
         ENDELSE
       ENDIF ELSE BEGIN
         IF N_Params() EQ 2 THEN BEGIN
            IF Keyword_Set(normal) THEN BEGIN
                IF alphaImage THEN BEGIN
                   outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       TV=1, ALPHABGPOSITION=alphapos, ALPHAFGPOSITION=alphafgpos)
                   TV, outImage, x,  True=3, _STRICT_EXTRA=extra, /Normal
                ENDIF ELSE BEGIN
                   CASE scale OF 
                        0: TV, image, x, True=true, _STRICT_EXTRA=extra, /Normal
                        1: TV, BytScl(image, Top=top, Max=max, Min=min) + bottom, $
                                x, True=true, _STRICT_EXTRA=extra, /Normal
                   ENDCASE
                ENDELSE
             ENDIF ELSE BEGIN
                IF alphaImage THEN BEGIN
                   outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                        TV=1, ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                   TV, outImage, x,  True=3, _STRICT_EXTRA=extra, /Device
                ENDIF ELSE BEGIN
                   CASE scale OF 
                        0: TV, image, x, True=true, _STRICT_EXTRA=extra, /Device
                        1: TV, BytScl(image, Top=top, Max=max, Min=min) + bottom, $
                                x, True=true, _STRICT_EXTRA=extra, /Device
                   ENDCASE
                ENDELSE
             ENDELSE
         ENDIF
       ENDELSE
       GoTo, restoreDecomposed
    
    ENDIF
    
    <span class="comments">; Maintain aspect ratio (ratio of height to width)?</span>
    IF KEYWORD_SET(keep_aspect) THEN BEGIN
    
       <span class="comments">; Find aspect ratio of image.</span>
       ratio = FLOAT(imgYsize) / imgXSize
    
       <span class="comments">; Find the proposed size of the image in pixels without aspect</span>
       <span class="comments">; considerations.</span>
       xpixSize = (position[2] - position[0]) * !D.X_VSize
       ypixSize = (position[3] - position[1]) * !D.Y_VSize
    
       <span class="comments">; Try to fit the image width. If you can't maintain</span>
       <span class="comments">; the aspect ratio, fit the image height.</span>
       trialX = xpixSize
       trialY = trialX * ratio
       IF trialY GT ypixSize THEN BEGIN
          trialY = ypixSize
          trialX = trialY / ratio
       ENDIF
    
       <span class="comments">; Recalculate the position of the image in the window.</span>
       position[0] = (((xpixSize - trialX) / 2.0) / !D.X_VSize) + position[0]
       position[2] = position[0] + (trialX/FLOAT(!D.X_VSize))
       position[1] = (((ypixSize - trialY) / 2.0) / !D.Y_VSize)  + position[1]
       position[3] = position[1] + (trialY/FLOAT(!D.Y_VSize))
    
    ENDIF
    
    <span class="comments">; Calculate the image size and start locations. The plus and minus</span>
    <span class="comments">; factor values are designed to keep the image completely inside the axes.</span>
    <span class="comments">; In other words, if you draw the axes first, then put the image in</span>
    <span class="comments">; the display window, the axes should remain visible and not be covered</span>
    <span class="comments">; up by the image. Do this only if the user requests it with the FIT_INSIDE</span>
    <span class="comments">; keyword.</span>
    IF Keyword_Set(fit_inside) THEN factor = 1 ELSE factor = 0
    xsize = Ceil((position[2] - position[0]) * !D.X_VSIZE) - factor
    ysize = Ceil((position[3] - position[1]) * !D.Y_VSIZE) - factor
    xstart = Round(position[0] * !D.X_VSIZE) + factor
    ystart = Round(position[1] * !D.Y_VSIZE) + factor
    
    <span class="comments">; Display the image. Sizing different for scalable pixels devices.</span>
    IF (!D.Flags AND 1) NE 0 THEN BEGIN
    
       <span class="comments">; Need a gray-scale color table if this is a true</span>
       <span class="comments">; color image.</span>
       IF true GT 0 THEN LOADCT, 0, /Silent
       IF alphaImage THEN BEGIN
           outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
           TV, outImage, xstart, ystart, XSIZE=xsize, YSIZE=ysize, _STRICT_EXTRA=extra, True=3
       ENDIF ELSE BEGIN
           TV, cgImage_Prepare_Output(image, $
                       BOTTOM=bottom, $
                       BETA=beta, $
                       CLIP=clip, $
                       EXCLUDE=exclude, $
                       EXPONENT=exponent, $
                       GAMMA=gamma, $
                       INTERPOLATE=interpolate, $
                       MAXVALUE=max, $
                       MEAN=mean, $
                       MINUS_ONE=minus_one, $
                       MINVALUE=min, $
                       MISSING_INDEX=missing_index, $
                       MISSING_VALUE=missing_value, $
                       MULTIPLIER=multiplier, $
                       NEGATIVE=negative, $
                       SCALE=scale, $
                       STRETCH=stretch, $
                       SIGMA=sigma, $
                       TOP=top), xstart, ystart, XSIZE=xsize, $
                       YSIZE=ysize, _STRICT_EXTRA=extra, True=true
       ENDELSE
    ENDIF ELSE BEGIN <span class="comments">; All other devices.</span>
    
       CASE true OF
          0: BEGIN
               TV, cgImage_Prepare_Output(image, xsize, ysize, $
                       BOTTOM=bottom, $
                       BETA=beta, $
                       CLIP=clip, $
                       EXCLUDE=exclude, $
                       EXPONENT=exponent, $
                       GAMMA=gamma, $
                       INTERPOLATE=interpolate, $
                       MAXVALUE=max, $
                       MEAN=mean, $
                       MINUS_ONE=minus_one, $
                       MINVALUE=min, $
                       MISSING_INDEX=missing_index, $
                       MISSING_VALUE=missing_value, $
                       MULTIPLIER=multiplier, $
                       NEGATIVE=negative, $
                       SCALE=scale, $
                       STRETCH=stretch, $
                       SIGMA=sigma, $
                       TOP=top), xstart, ystart, _STRICT_EXTRA=extra
             END
          1: IF thisDepth GT 8 THEN BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                    TV, cgResizeImage(outImage, xsize, ysize, INTERP=interp, $
                       MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=3
                ENDIF ELSE BEGIN
                    CASE scale OF
                        0: TV, cgResizeImage(image, xsize, ysize, INTERP=interp, $
                                MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=1
                        1: TV, BYTSCL(cgResizeImage(image, xsize, ysize, $
                                INTERP=interp, MINUS_ONE=minusOne), Top=top-bottom, $
                                Max=max, Min=min) + bottom, xstart, ystart, _STRICT_EXTRA=extra, True=1
                     ENDCASE
                ENDELSE
             ENDIF ELSE BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                    image2d = Color_Quan(outImage, 3, r, g, b, _EXTRA=extra)               
                ENDIF ELSE BEGIN
                    image2d = Color_Quan(image, 1, r, g, b, _EXTRA=extra)   
                ENDELSE                
                TVLCT, r, g, b
                TV, cgResizeImage(image2d, xsize, ysize, INTERP=0, $
                   MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=0
             ENDELSE
          2: IF thisDepth GT 8 THEN BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                    TV, cgResizeImage(outImage, xsize, ysize, INTERP=interp, $
                       MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=3
                ENDIF ELSE BEGIN
                    CASE scale OF
                        0: TV, cgResizeImage(image, xsize, ysize, INTERP=interp, $
                                MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=2
                        1: TV, BYTSCL(cgResizeImage(image, xsize, ysize, $
                                INTERP=interp, MINUS_ONE=minusOne), Top=top-bottom, Max=max, $
                                Min=min) + bottom, xstart, ystart, _STRICT_EXTRA=extra, True=2
                    ENDCASE
                ENDELSE
             ENDIF ELSE BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, ALPHABGPOSITION=alphapos)
                    image2d = Color_Quan(outImage, 3, r, g, b, _EXTRA=extra)               
                ENDIF ELSE BEGIN
                    image2d = Color_Quan(image, 2, r, g, b, _EXTRA=extra)
                ENDELSE                
                TVLCT, r, g, b
                TV, cgResizeImage(image2d, xsize, ysize, INTERP=0, $
                   MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=0
             ENDELSE
          3: IF thisDepth GT 8 THEN BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                    TV, cgResizeImage(outImage, xsize, ysize, INTERP=interp, $
                       MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=3
                ENDIF ELSE BEGIN
                    CASE scale OF
                        0: TV, cgResizeImage(image, xsize, ysize, INTERP=interp, $
                                MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=3
                        1: TV, BYTSCL(cgResizeImage(image, xsize, ysize, $
                                INTERP=interp, MINUS_ONE=minusOne), Top=top-bottom, Max=max, $
                                Min=min) + bottom, xstart, ystart, _STRICT_EXTRA=extra, True=3
                    ENDCASE
                ENDELSE
             ENDIF ELSE BEGIN
                IF alphaImage THEN BEGIN
                    outImage = cgImage_Prepare_Alpha(image, alphaBackgroundImage, $
                       ALPHABGPOSITION=alphabgpos, ALPHAFGPOSITION=alphafgpos)
                    image2d = Color_Quan(outImage, 3, r, g, b, _EXTRA=extra)               
                ENDIF ELSE BEGIN
                    image2d = Color_Quan(image, 3, r, g, b, _EXTRA=extra)
                ENDELSE
                TVLCT, r, g, b
                TV, cgResizeImage(image2d, xsize, ysize, INTERP=0, $
                   MINUS_ONE=minusOne), xstart, ystart, _STRICT_EXTRA=extra, True=0
             ENDELSE
      ENDCASE
    ENDELSE
        
    <span class="comments">; Restore Decomposed state if necessary.</span>
    RestoreDecomposed:
    
    <span class="comments">; If this is the first plot in PS, then we have to make it appear that we have</span>
    <span class="comments">; drawn a plot, even though we haven't.</span>
    IF N_Elements(psnodraw) EQ 1 THEN BEGIN
        !X = afterX
        !Y = afterY
        !P = afterP
    ENDIF
     
    CASE StrUpCase(!D.NAME) OF
       'X': BEGIN
          IF thisRelease GE 5.2 THEN Device, Decomposed=thisDecomposed
          ENDCASE
       'WIN': BEGIN
          IF thisRelease GE 5.2 THEN Device, Decomposed=thisDecomposed
          ENDCASE
       'MAC': BEGIN
          IF thisRelease GE 5.2 THEN BEGIN
             Device, Decomposed=thisDecomposed
    
             <span class="comments">; Here is a hack that fixes a longstanding Mac problem with</span>
             <span class="comments">; color tables after changing the decomposed state.</span>
             TV, [0]
          ENDIF
          ENDCASE
       'Z': BEGIN
          IF thisRelease GE 6.4 THEN Device, Decomposed=thisDecomposed
          ENDCASE
       'PS': BEGIN
          IF thisRelease GE 7.1 THEN BEGIN
              Device, DECOMPOSED=thisDecomposed
              IF N_Elements(r) NE 0 THEN TVLCT, r, g, b
          ENDIF
          ENDCASE
       ELSE:
    ENDCASE

    <span class="comments">; Set up common block parameters, but only if device supports windows.</span>
    <span class="comments">; And only if the QUIET flag is not turned on.</span>
    IF ~Keyword_Set(quiet) THEN BEGIN
        IF (!D.FLAGS AND 256) NE 0 THEN BEGIN
            _cgimage_xsize = imgXsize
            _cgimage_ysize = imgYsize
            _cgimage_winID = !D.Window
            _cgimage_winxsize = !D.X_Size
            _cgimage_winysize = !D.Y_Size
            _cgimage_position = position
            _cgimage_current = 1
        ENDIF 
        
        <span class="comments">; Save the position, at least, if you are in PostScript as cgMap may need it.</span>
        IF (!D.NAME EQ 'PS') THEN BEGIN
            _cgimage_position = position
            _cgimage_current = 1
        ENDIF
    ENDIF
    
    <span class="comments">; Save plot system variables.</span>
    bangp = !P
    bangx = !X
    bangy = !Y
     
    <span class="comments">; If you changed the position, restore it.</span>
    IF N_Elements(restorePosition) NE 0 THEN position = RestorePosition
    
    <span class="comments">; Set the output position.</span>
    oposition = position
    
    <span class="comments">; Need a data range?</span>
    IF N_Elements(plotxrange) EQ 0 THEN BEGIN
        plotxrange = [0, imgXSize]
    ENDIF ELSE save = 1
    IF N_Elements(plotyrange) EQ 0 THEN BEGIN
        plotyrange = [0, imgYSize]
    ENDIF ELSE save = 1
    
    <span class="comments">; Check title for cgSymbols.</span>
    IF N_Elements(plotxtitle) NE 0 THEN plotxtitle = cgCheckForSymbols(plotxtitle)
    IF N_Elements(plotytitle) NE 0 THEN plotytitle = cgCheckForSymbols(plotytitle)
    IF N_Elements(title) NE 0 THEN title = cgCheckForSymbols(title)

    <span class="comments">; If the user wanted axes, draw them now.</span>
    IF axes THEN BEGIN
    
        cgPLOT, [0], FONT=font, /NODATA, /NOERASE, XRANGE=plotxrange, YRANGE=plotyrange, $
            XSTYLE=1, YSTYLE=1, POSITION=position, AXISCOLOR=acolor, $
            XTITLE=plotxtitle, YTITLE=plotytitle, TITLE=title, CHARSIZE=charsize, $
            _STRICT_EXTRA=axkeywords
            
    ENDIF ELSE BEGIN
    
        <span class="comments">; If you are saving the data coordinate space, draw invisible axes.</span>
        IF Keyword_Set(save) THEN BEGIN
            PLOT, [0], /NODATA, /NOERASE, XRANGE=plotxrange, YRANGE=plotyrange, $
                XSTYLE=5, YSTYLE=5, POSITION=position, _STRICT_EXTRA=axkeywords
        ENDIF
    
    ENDELSE

    <span class="comments">; Clean up after yourself.</span>
    IF (!D.Name NE 'Z') THEN BEGIN
        TVLCT, rr, gg, bb
        <span class="comments">; If you loaded a color palette, restore the before color vectors.</span>
        IF N_Elements(p_red) NE 0 THEN TVLCT, p_red, p_grn, p_blu
    ENDIF
    IF ~Keyword_Set(save) THEN BEGIN
        !P = bangp
        !X = bangx
        !Y = bangy
    ENDIF

    <span class="comments">; Clean up if you are using a layout.</span>
    IF N_Elements(layout) NE 0 THEN !P.Multi = thisMulti

    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width
              
         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
    <span class="comments">; If you were doing a transparent image, return the original.</span>
    IF transparentImage THEN image = oldImage
    
END
</code>
    </div>
  </body>
</html>