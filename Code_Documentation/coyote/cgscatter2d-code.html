<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:28 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgscatter2d.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgscatter2d.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgScatter2D</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of cgScatter2d is to create a two-dimensional scatter plot with the </span>
<span class="comments">;   option of drawing a correlation coefficient on the plot.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of cgScatter2d is to create a two-dimensional scatter plot with the </span>
<span class="comments">; option of drawing a correlation coefficient on the plot.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;   </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;     x: in, required</span>
<span class="comments">;        The variable along the X or horizontal dimension.</span>
<span class="comments">;     y: in, required</span>
<span class="comments">;        The varaiable along the Y or vertical dimension.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">; </span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;     aspect: in, optional, type=float, default=none</span>
<span class="comments">;        Set this keyword to a floating point ratio that represents the aspect ratio </span>
<span class="comments">;        (ysize/xsize) of the resulting plot. The plot position may change as a result</span>
<span class="comments">;        of setting this keyword. Note that `Aspect` cannot be used when plotting with</span>
<span class="comments">;        !P.MULTI.</span>
<span class="comments">;     axiscolor: in, optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the axis color. May be specified as a color table index number, as well.</span>
<span class="comments">;     axescolor: in, optional, type=string</span>
<span class="comments">;        Provisions for bad spellers.</span>
<span class="comments">;     background: in, optional, type=string, default='background'</span>
<span class="comments">;        The name of the background color. May be specified as a color table index number, as well.</span>
<span class="comments">;     charsize: in, optional, type=float, default=cgDefCharSize()</span>
<span class="comments">;        The character size for axes annotations. Uses cgDefCharSize to select default</span>
<span class="comments">;        character size, unless !P.Charsize is set, in which case !P.Charsize is always used.</span>
<span class="comments">;     color: in, optional, type=string, default='black'</span>
<span class="comments">;        The name of the data or symbol color. May be specified as a color table index or color triple, as well.</span>
<span class="comments">;        May be a vector of the same length as the input data vectors.</span>
<span class="comments">;     coefficient: out, optional, type=double</span>
<span class="comments">;        The Pearson correlation coefficient of the two data sets. Calculated with the IDL routine CORRELATE.</span>
<span class="comments">;     fcharsize: in, optional, type=float</span>
<span class="comments">;        The character size of the fit parameters that are written on the plot. This keyword is only</span>
<span class="comments">;        in effect if the `Fit` keyword is set. The default is the same as `Charsize`.</span>
<span class="comments">;     fcolor: in, optional, type=string, default='red'</span>
<span class="comments">;        The name of the color for the fitting line though the data</span>
<span class="comments">;     fthick: in, optional, type=integer, default=1</span>
<span class="comments">;        The thickness of the fitting line.</span>
<span class="comments">;     fillcolor: in, optional, type=string</span>
<span class="comments">;        If this keyword is set to the name of a color, that color will be used to "fill"</span>
<span class="comments">;        the area of the plot enclosed by the axes. Unfortunately, at this time, the `FillColor`</span>
<span class="comments">;        keyword can NOT be used with multiple plots, just single plots.</span>
<span class="comments">;     fit: in, optional, type=boolean, default=1</span>
<span class="comments">;        If this keyword is set to 1 (the default), a straight line is fit through the data</span>
<span class="comments">;        with the IDL routine LINFIT. If this keyword is set, the Pearson correlation coeffcient</span>
<span class="comments">;        and the equation of the fitted line is displayed on the scatter plot, unless the `NoDisplay`</span>
<span class="comments">;        keyword is set.</span>
<span class="comments">;     font: in, optional, type=integer, default=!P.Font</span>
<span class="comments">;        The type of font desired for axis annotation.</span>
<span class="comments">;     gcolor: in, optional, type=string, default='gray'</span>
<span class="comments">;        The name of the grid color. May be specified as a color table index number, as well.</span>
<span class="comments">;     glinestyle: in, optional, type=integer, default=1</span>
<span class="comments">;        The grid linestyle. Dotted by default. An integer from 0 to 5. See the IDL LineStyle </span>
<span class="comments">;        graphics keyword documentation.</span>
<span class="comments">;     grid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keword to 1 to draw a grid on the plot.</span>
<span class="comments">;     isotropic: in, optional, type=boolean, default=0</span>
<span class="comments">;        A short-hand way of setting the `Aspect` keyword to 1.</span>
<span class="comments">;     layout: in, optional, type=intarr(3)</span>
<span class="comments">;        This keyword specifies a grid with a graphics window and determines where the</span>
<span class="comments">;        graphic should appear. The syntax of LAYOUT is three numbers: [ncolumns, nrows, location].</span>
<span class="comments">;        The grid is determined by the number of columns (ncolumns) by the number of </span>
<span class="comments">;        rows (nrows). The location of the graphic is determined by the third number. The</span>
<span class="comments">;        grid numbering starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;        by row.</span>
<span class="comments">;     nodisplay, in, optional, type=boolean default=0</span>
<span class="comments">;        If this keyword is set, then the Pearson correlation coefficient and the equation</span>
<span class="comments">;        of the fitting line is not displayed on the plot. This keyword is only considered if</span>
<span class="comments">;        the `Fit` keyword is set.</span>
<span class="comments">;     noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw the plot without erasing the display first.</span>
<span class="comments">;     outfilename: in, optional, type=string</span>
<span class="comments">;        If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;        filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;        value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;        presented to the user.</span>
<span class="comments">;     output: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;        Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;        file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;        user will not be prompted to supply the name of the output file.  </span>
<span class="comments">;            </span>
<span class="comments">;        All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;        PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;        to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;        details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;        plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;        output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;     overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to overplot data on an already exisiting set of</span>
<span class="comments">;        axes. It is like calling the IDL OPLOT command.</span>
<span class="comments">;     params: out, optional, type=double</span>
<span class="comments">;        The output line fitting parameters [intercept, slope].</span>
<span class="comments">;     position: in, optional, type=vector</span>
<span class="comments">;        The usual four-element position vector for the Plot comamnd. Only monitored and</span>
<span class="comments">;        possibly changed if the `Aspect` keyword is used.</span>
<span class="comments">;     psym: in, optional, type=integer, default=2</span>
<span class="comments">;        Any normal IDL PSYM values, plus any value supported by the Coyote Library</span>
<span class="comments">;        routine cgSYMCAT. An integer between 1 and 46.</span>
<span class="comments">;     symsize: in, optional, type=float, default=1.0</span>
<span class="comments">;        The symbol size.</span>
<span class="comments">;     title: in, optional, type=string, default=""</span>
<span class="comments">;        The title of the plot.</span>
<span class="comments">;     traditional: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the traditional color scheme of a black background for</span>
<span class="comments">;        graphics windows on the display is used and PostScript files always use a white background.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in a current cgWindow or to</span>
<span class="comments">;        create a new cgWindow for displaying this command.</span>
<span class="comments">;     xrange: in, optional, type=float</span>
<span class="comments">;        The X range of the plot.</span>
<span class="comments">;     xstyle: in, optional, type=integer, default=0</span>
<span class="comments">;        The value sent to the XStyle keyword for the Plot command.</span>
<span class="comments">;     xticklen: in, optional, type=float</span>
<span class="comments">;        The X tick length. Will be set to 1.0 if the `Grid` keyword is set.</span>
<span class="comments">;     xtitle: in, optional, type=string', default=""</span>
<span class="comments">;        The X title of the plot.</span>
<span class="comments">;     yrange: in, optional, type=float</span>
<span class="comments">;        The Y range of the plot.</span>
<span class="comments">;     ystyle: in, optional, type=integer, default=0</span>
<span class="comments">;        The value sent to the YStyle keyword for the Plot command.</span>
<span class="comments">;     yticklen: in, optional, type=float</span>
<span class="comments">;        THe Y tick length. Will be set to 1.0 if the `Grid` keyword is set.</span>
<span class="comments">;     ytitle: in, optional, type=string', default=""</span>
<span class="comments">;        The Y title of the plot.</span>
<span class="comments">;     _ref_extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDL Plot command is allowed in the program.</span>
<span class="comments">;        </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Use to compare two data sets::</span>
<span class="comments">;       data_1 = cgDemoData(1)+ RandomU(seed, 101) * 10</span>
<span class="comments">;       data_2 = cgDemoData(1)+ RandomU(seed, 101) * 10</span>
<span class="comments">;       cgScatter2D, data_1, data_2 </span>
<span class="comments">;       </span>
<span class="comments">;    Add a grid to the plot::</span>
<span class="comments">;       cgScatter2D, data_1, data_2, SymColor='navy', FillColor='rose', /Grid</span>
<span class="comments">;       </span>
<span class="comments">;    Output the plot to a PNG file::</span>
<span class="comments">;       cgScatter2D, data_1, data_2,  SymColor='navy', /Grid, FillColor='rose', Output='scatter.png'</span>
<span class="comments">;    </span>
<span class="comments">;    Display the plot in a resizeable graphics window::</span>
<span class="comments">;       cgScatter2D, data_1, data_2,  SymColor='navy', /Grid, FillColor='rose', /Window</span>
<span class="comments">;    </span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;        David W. Fanning </span>
<span class="comments">;        1645 Sheely Drive</span>
<span class="comments">;        Fort Collins, CO 80526 USA</span>
<span class="comments">;        Phone: 970-221-0438</span>
<span class="comments">;        E-mail: david@idlcoyote.com</span>
<span class="comments">;        Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 12 January 2012. DWF.</span>
<span class="comments">;        Removed an extra COLOR keyword and changed an OPLOT command to a PLOTS command</span>
<span class="comments">;           to allow a vector of colors to be used for the scatter points.</span>
<span class="comments">;         Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;         Bad logic when creating a GRID and setting [XY]Style keywords. 30 Aug 2013. DWF.</span>
<span class="comments">;         </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgScatter2D, x, y, $
    AddCmd=addcmd, $
    Aspect=aspect, $
    AxisColor=saxiscolor, $
    AxesColor=saxescolor, $
    Background=sbackground, $
    Charsize=charsize, $
    Color=scolor, $
    Coefficient=coefficient, $
    FCharsize=fcharsize, $
    FColor=sfcolor, $
    FThick=fthick, $
    FillColor=sfillcolor, $
    Fit=fit, $
    Font=font, $
    GColor=sgcolor, $
    GLinestyle=glinestyle, $
    Grid=grid, $
    Isotropic=isotropic, $
    Layout=layout, $
    NoDisplay=nodisplay, $
    NoErase=noerase, $
    OutFilename=outfilename, $
    Output=output, $
    Overplot=overplot, $
    Params=params, $
    Position=position, $
    PSym=psym, $
    SymSize=symsize, $
    Title=title, $
    Traditional=traditional, $
    Window=window, $
    XRange=xrange, $
    XStyle=xstyle, $
    XTickLen=xticklen, $
    XTitle=xtitle, $
    YRange=yrange, $
    YStyle=ystyle, $
    YTicklen=yticklen, $
    YTitle=ytitle, $
    _REF_EXTRA=extra
    
    Compile_Opt idl2

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        IF (N_Elements(output) NE 0) THEN PS_END, /NOFIX
        RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Check parameters.</span>
    IF N_Params() EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgScatter2D, x, y'
        RETURN
    ENDIF
    
    <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    
    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1

        IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
        
        <span class="comments">; Special treatment for overplotting or adding a command.</span>
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
        cgWindow, 'cgScatter2D', x, y, $
            Aspect=aspect, $
            AxisColor=saxiscolor, $
            AxesColor=saxescolor, $
            Background=sbackground, $
            Charsize=charsize, $
            Color=scolor, $
            Coefficient=coefficient, $
            FCharsize=fcharsize, $
            FColor=sfcolor, $
            FThick=fthick, $
            FillColor=sfillcolor, $
            Fit=fit, $
            Font=font, $
            GColor=sgcolor, $
            GLinestyle=glinestyle, $
            Grid=grid, $
            Isotropic=isotropic, $
            Layout=layout, $
            NoDisplay=nodisplay, $
            NoErase=noerase, $
            OutFilename=outfilename, $
            Output=output, $
            Overplot=overplot, $
            Params=params, $
            Position=position, $
            PSym=psym, $
            SymSize=symsize, $
            Title=title, $
            Traditional=traditional, $
            XRange=xrange, $
            XStyle=xstyle, $
            XTickLen=xticklen, $
            XTitle=xtitle, $
            YRange=yrange, $
            YStyle=ystyle, $
            YTicklen=yticklen, $
            YTitle=ytitle, $
            ADDCMD=1, $
            _Extra=extra
             RETURN
       ENDIF
        
        <span class="comments">; Open a new window or replace the current commands, as required.</span>
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        cgWindow, 'cgScatter2D', x, y, $
            Aspect=aspect, $
            AxisColor=saxiscolor, $
            AxesColor=saxescolor, $
            Background=sbackground, $
            Charsize=charsize, $
            Color=scolor, $
            Coefficient=coefficient, $
            FCharsize=fcharsize, $
            FColor=sfcolor, $
            FThick=fthick, $
            FillColor=sfillcolor, $
            Fit=fit, $
            Font=font, $
            GColor=sgcolor, $
            GLinestyle=glinestyle, $
            Grid=grid, $
            Isotropic=isotropic, $
            Layout=layout, $
            NoDisplay=nodisplay, $
            NoErase=noerase, $
            OutFilename=outfilename, $
            Output=output, $
            Overplot=overplot, $
            Params=params, $
            Position=position, $
            PSym=psym, $
            SymSize=symsize, $
            Title=title, $
            Traditional=traditional, $
            XRange=xrange, $
            XStyle=xstyle, $
            XTitle=xtitle, $
            XTickLen=xticklen, $
            YRange=yrange, $
            YStyle=ystyle, $
            YTicklen=yticklen, $
            YTitle=ytitle, $
            REPLACECMD=replaceCmd, $
            _Extra=extra
            
         RETURN
    ENDIF
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
       
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    
    ENDIF
    
    <span class="comments">; Get the current color table vectors.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; Going to do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState
    
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

    <span class="comments">; Check the color keywords.</span>
    traditional = Keyword_Set(traditional)
    background = cgDefaultColor(sbackground, /BACKGROUND, TRADITIONAL=traditional)
    IF (N_Elements(saxisColor) EQ 0) && (N_Elements(saxesColor) NE 0) THEN saxisColor = saxesColor
    axisColor = cgDefaultColor(saxisColor, TRADITIONAL=traditional)
    color = cgDefaultColor(sColor, DEFAULT=axisColor, TRADITIONAL=traditional)
    fcolor = cgDefaultColor(sfColor, DEFAULT='red', TRADITIONAL=traditional)
    gcolor = cgDefaultColor(sgColor, DEFAULT='gray', TRADITIONAL=traditional)
    
    <span class="comments">; Character size has to be determined *after* the layout has been decided.</span>
    IF N_Elements(font) EQ 0 THEN font = !P.Font
    IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize(FONT=font)
    
    <span class="comments">; Other keywords.</span>
    SetDefaultValue, fit, 1
    SetDefaultValue, fcharsize, charsize
    SetDefaultValue, fthick, 1
    IF !D.Name EQ 'PS' THEN fthick = 3*fthick
    SetDefaultValue, grid, 0, /Boolean
    SetDefaultValue, glinestyle, 1
    IF grid THEN BEGIN
        xticklen = 1
        yticklen = 1
    ENDIF
    SetDefaultValue, symsize, 1.0
    IF Keyword_Set(isotropic) THEN aspect = 1.0
    IF N_Elements(psym) EQ 0 THEN psym = 2 ELSE psym = 1 > psym 
    IF N_Elements(xrange) EQ 0 THEN BEGIN
        range = Max(x) - Min(x)
        IF Min(x) NE 0 THEN minx = Min(x)-(range*0.05) ELSE minx = 0.0
        xrange = [minx, Max(x)+(range*0.05)]
    ENDIF
    IF N_Elements(yrange) EQ 0 THEN BEGIN
        range = Max(y) - Min(y)
        IF Min(y) NE 0 THEN miny = Min(y)-(range*0.05) ELSE miny = 0.0
        yrange = [miny, Max(y)+(range*0.05)]
    ENDIF
    SetDefaultValue, xstyle, 0
    SetDefaultValue, ystyle, 0
    
    IF (N_Elements(aspect) NE 0) AND (Total(!P.MULTI) EQ 0) THEN BEGIN
    
        <span class="comments">; If position is set, then fit the plot into those bounds.</span>
        IF (N_Elements(position) GT 0) THEN BEGIN
          trial_position = Aspect(aspect, margin=0.)
          trial_width = trial_position[2]-trial_position[0]
          trial_height = trial_position[3]-trial_position[1]
          pos_width = position[2]-position[0]
          pos_height = position[3]-position[1]

          <span class="comments">; Same logic as cgImage: try to fit image width, then if you can't get the right aspect</span>
          <span class="comments">; ratio, fit the image height instead.</span>
          fit_ratio = pos_width / trial_width
          IF trial_height * fit_ratio GT pos_height THEN $
             fit_ratio = pos_height / trial_height

          <span class="comments">; new width and height</span>
          trial_width *= fit_ratio
          trial_height *= fit_ratio

          <span class="comments">; calculate position vector based on trial_width and trial_height</span>
          position[0] += 0.5*(pos_width - trial_width)
          position[2] -= 0.5*(pos_width - trial_width)
          position[1] += 0.5*(pos_height - trial_height)
          position[3] -= 0.5*(pos_height - trial_height)
        ENDIF ELSE position=Aspect(aspect)   <span class="comments">; if position isn't set, just use output of Aspect</span>
        
    ENDIF
    
    <span class="comments">; If we don't have a position yet, and we are not doing multiple plots, define a position.</span>
    IF (N_Elements(position) EQ 0) && (Total(!P.Multi) EQ 0) THEN position = [0.15, 0.125, 0.9, 0.9]
    
    <span class="comments">; Do you need a PostScript background color? Lot's of problems here!</span>
    <span class="comments">; Basically, I MUST draw a plot to advance !P.MULTI. But, drawing a</span>
    <span class="comments">; plot of any sort erases the background color. So, I have to draw a </span>
    <span class="comments">; plot, store the new system variables, then draw my background, etc.</span>
    <span class="comments">; I have tried LOTS of options. This is the only one that worked.</span>
    IF !D.Name EQ 'PS' THEN BEGIN
         IF ~noerase THEN BEGIN
       
           <span class="comments">; I only have to do this, if this is the first plot.</span>
           IF !P.MULTI[0] EQ 0 THEN BEGIN
           
                IF Keyword_Set(overplot) NE 1 THEN BEGIN
                
                    <span class="comments">; Save the current system variables. Will need to restore later.</span>
                    bangx = !X
                    bangy = !Y
                    bangp = !P
                    
                    <span class="comments">; Draw the plot that doesn't draw anything.</span>
                    Plot, x, y, POSITION=position, CHARSIZE=charsize, /NODATA, $
                        FONT=font, XRANGE=xrange, YRANGE=yrange, _STRICT_EXTRA=extra  
                    
                    <span class="comments">; Save the "after plot" system variables. Will use later. </span>
                    afterx = !X
                    aftery = !Y
                    afterp = !P     
                    
                    <span class="comments">; Draw the background color and set the variables you will need later.</span>
                    PS_Background, background
                    psnodraw = 1
                    tempNoErase = 1
                    
                    <span class="comments">; Restore the original system variables so that it is as if you didn't</span>
                    <span class="comments">; draw the invisible plot.</span>
                    !X = bangx
                    !Y = bangy
                    !P = bangp
                
                ENDIF
            ENDIF ELSE tempNoErase = noerase
        ENDIF ELSE tempNoErase = noerase
     ENDIF ELSE tempNoErase = noerase
 
    
    <span class="comments">; Load the drawing colors. If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    IF Size(axiscolor, /TNAME) EQ 'STRING' THEN axiscolor = cgColor(axiscolor)
    IF Size(color, /TNAME) EQ 'STRING' THEN color = cgColor(color)
    IF Size(gcolor, /TNAME) EQ 'STRING' THEN gcolor = cgColor(gcolor)
    IF Size(fcolor, /TNAME) EQ 'STRING' THEN fcolor = cgColor(fcolor)
    IF Size(background, /TNAME) EQ 'STRING' THEN background = cgColor(background)
    
    <span class="comments">; Do you need a plot fill color?</span>
    IF (N_Elements(sfillColor) NE 0) && (Total(!P.Multi) EQ 0) THEN BEGIN
        p = position
        fillColor = cgColor(sfillColor)
        IF !D.Name NE 'PS' THEN cgErase, Color=background
        PolyFill, [p[0], p[0], p[2], p[2], p[0]], /Normal, $
                  [p[1], p[3], p[3], p[1], p[1]], Color=fillcolor
        tempNoErase = 1
    ENDIF ELSE BEGIN
         IF (N_Elements(sfillColor) NE 0) && (Total(!P.Multi) NE 0) THEN BEGIN
             Message, 'Cannot use the FillColor keyword with multiple plots.', /Informational
         ENDIF
    ENDELSE
    
    <span class="comments">; Check for symbols in titles.</span>
    IF N_Elements(title) NE 0 THEN title = cgCheckForSymbols(title)
    IF N_Elements(xtitle) NE 0 THEN xtitle = cgCheckForSymbols(xtitle)
    IF N_Elements(ytitle) NE 0 THEN ytitle = cgCheckForSymbols(ytitle)    

    <span class="comments">; Draw the plot.</span>
    IF Keyword_Set(overplot) THEN BEGIN
       IF psym LE 0 THEN OPlot, dep, indep, COLOR=color, _EXTRA=extra
    ENDIF ELSE BEGIN
      IF grid THEN BEGIN
          bangxgrid = !X
          bangygrid = !Y
          bangpgrid = !P
          Plot, x, y, BACKGROUND=background, COLOR=gcolor, CHARSIZE=charsize, $
                POSITION=position, /NODATA, NOERASE=tempNoErase, FONT=font, $
                XTICKLEN=xticklen, YTICKLEN=yticklen, XRANGE=xrange, YRANGE=yrange, $
                XGRIDSTYLE=glinestyle, YGRIDSTYLE=glinestyle, $
                XSTYLE=(2S^16-5) AND xstyle, YSTYLE=(2S^16-5) AND ystyle, $
                _STRICT_EXTRA=extra, XTickFormat='(A1)', YTickFormat='(A1)', $
                XTITLE="", YTITLE="", TITLE=""
           
          aftergridx = !X
          aftergridy = !Y
          aftergridp = !P
          !X = bangxgrid
          !Y = bangygrid    
          !P = bangpgrid 
          Plot, x, y, COLOR=axiscolor, CHARSIZE=charsize, $
                POSITION=position, /NODATA, NOERASE=(!P.Multi[0] GT 0) ? 0 : 1, FONT=font, $
                XRANGE=xrange, YRANGE=yrange, $
                XSTYLE=xstyle, YSTYLE=ystyle, _STRICT_EXTRA=extra, $
                XTITLE=xtitle, YTITLE=ytitle, TITLE=title
          IF !P.Multi[0] EQ 0 THEN BEGIN
             !X = aftergridx
             !Y = aftergridy
             !P = aftergridp
          ENDIF
      ENDIF ELSE BEGIN
          Plot, x, y, BACKGROUND=background, COLOR=axiscolor, CHARSIZE=charsize, $
                POSITION=position, /NODATA, NOERASE=tempNoErase, FONT=font, $
                XTICKLEN=xticklen, YTICKLEN=yticklen, XRANGE=xrange, YRANGE=yrange, $
                XSTYLE=xstyle, YSTYLE=ystyle, _STRICT_EXTRA=extra, $
                XTITLE=xtitle, YTITLE=ytitle, TITLE=title
      ENDELSE
    ENDELSE
    IF Abs(psym) GT 1 THEN BEGIN
        PlotS, x, y, COLOR=color, PSYM=cgSymCat(Abs(psym), _Extra=extra), $
           SYMSIZE=symsize, _EXTRA=extra
    ENDIF 
    
    <span class="comments">; Calculate the Pearson correlation coefficient.</span>
    coefficient = Correlate(x, y, /DOUBLE)
    
    <span class="comments">; Add the fitting line, if needed.</span>
    IF fit THEN BEGIN
       params = LinFit(x, y, /Double, YFIT=yfit)
       OPlot, x, yfit, COLOR=fcolor, THICK=fthick
       
       IF coefficient GE 0 THEN BEGIN
          yloc = !Y.Window[1] - 0.05
          xloc = !X.Window[0] + 0.05
          alignment = 0.0
          y1loc = yloc - ( 2.0 * (!D.Y_CH_SIZE / Float(!D.Y_Size) ) )
       ENDIF ELSE BEGIN
          yloc = !Y.Window[1] - 0.05
          xloc = (!X.Window[1]-!X.Window[0]) * (3.0/5.0) + !X.Window[0]
          alignment = 0.0
          y1loc = yloc - (2.0 * (!D.Y_CH_SIZE / Float(!D.Y_Size)))
       ENDELSE
       
       <span class="comments">; Write the correlation coefficient and the fitting equation on the display,</span>
       <span class="comments">; if allowed to.</span>
       IF Keyword_Set(nodisplay) EQ 0 THEN BEGIN
           cgText, xloc, yloc, /Normal, 'R = ' + String(coefficient, Format='(F0.3)'), $
               Charsize=fcharsize
           cgText, xloc, y1loc, /Normal, 'y = ' + String(params[1], Format='(F0.2)') $
               + 'x + ' + String(params[0], Format='(F0.2)'), Charsize=fcharsize
       ENDIF
    ENDIF
         
    <span class="comments">; If this is the first plot in PS, then we have to make it appear that we have</span>
    <span class="comments">; drawn a plot, even though we haven't.</span>
    IF N_Elements(psnodraw) EQ 1 THEN BEGIN
        !X = afterX
        !Y = afterY
        !P = afterP
    ENDIF
    
    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width

         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
    <span class="comments">; Restore the decomposed color state if you can.</span>
    SetDecomposedState, currentState
    
    <span class="comments">; Restore the color table. Can't do this for the Z-buffer or</span>
    <span class="comments">; the snap shot will be incorrect.</span>
    IF (!D.Name NE 'Z') THEN TVLCT, rr, gg, bb
    
    <span class="comments">; Clean up if you are using a layout.</span>
    IF N_Elements(layout) NE 0 THEN !P.Multi = thisMulti
    
END
    
</code>
    </div>
  </body>
</html>