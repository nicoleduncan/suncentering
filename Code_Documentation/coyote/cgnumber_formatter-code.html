<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:24 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgnumber_formatter.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgnumber_formatter.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgNumber_Formatter</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This is a utility routine format a number into a string. It is used primarily for </span>
<span class="comments">;   formatting numbers that will appear in text widgets in widget programs.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2012, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This is a utility routine format a number into a string. It is used primarily for </span>
<span class="comments">; formatting numbers that will appear in text widgets in widget programs.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Utilities</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    A string with the formatted number or numbers is returned.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    number: in, required</span>
<span class="comments">;       The number to be turned into a string. May be any data type except complex, </span>
<span class="comments">;       double complex, pointer or object. May be an array of numbers.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    decimals: in, optional, type=integer, default=2</span>
<span class="comments">;        Set this keyword to the number of decimal places to be included to the right of </span>
<span class="comments">;        the decimal point in floats and doubles. Set to 2 by default. In numbers with</span>
<span class="comments">;        absolute values between 0 and 1, the number of decimals is equivalent to the</span>
<span class="comments">;        number of significant digits. See the example below.</span>
<span class="comments">;         </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Here is how to use this program::</span>
<span class="comments">;        IDL> array = [45.123456, -30.123456, !Values.F_Nan, !Values.F_Infinity, $</span>
<span class="comments">;                      0.00123456, -0.00123456, 0.0123456, 0.123456, 1.234567]</span>
<span class="comments">;        IDL> FOR j=0,N_Elements(array)-1 DO Print, Number_Formatter(array[j], Decimals=4)</span>
<span class="comments">;        45.1235</span>
<span class="comments">;        -30.1235</span>
<span class="comments">;        NaN</span>
<span class="comments">;        Inf</span>
<span class="comments">;        0.001235</span>
<span class="comments">;        -0.001235</span>
<span class="comments">;        0.01235</span>
<span class="comments">;        0.1235</span>
<span class="comments">;        1.2346</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 8 November 2012 by David W. Fanning from the retired Number_Formatter program.</span>
<span class="comments">;        The algorithm I was using for numbers between 0 and 1 used a LT in the Where function to</span>
<span class="comments">;            find an index. It appears this should have been a LE, instead. 11 Jan 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
FUNCTION cgNumber_Formatter, number, DECIMALS=decimals

   On_Error, 2


   IF N_Elements(number) EQ 0 THEN Message, 'A number must be passed as an argument to the function.'
   IF N_Elements(decimals) EQ 0 THEN decimals = 2
   
   <span class="comments">; If the number is a byte, convert it to an integer and return it.</span>
   IF Size(number[0], /TNAME) EQ 'BYTE' THEN RETURN, StrTrim(String(Fix(number), Format='(I3)'),2)

   <span class="comments">; If the number is a string, trim it and return it directly.</span>
   IF Size(number[0], /TNAME) EQ 'STRING' THEN RETURN, StrTrim(number,2)

   <span class="comments">; Number can be an array. Handle that here.</span>
   numElements = N_Elements(number)
   retValue = StrArr(numElements)
   FOR j=0,numElements-1 DO BEGIN
   
      <span class="comments">; Is the number a NaN?</span>
      IF ~Finite(number[j]) THEN BEGIN
         IF Finite(number[j], /NAN) THEN retValue[j] = 'NaN'
         IF Finite(number[j], /Infinity) THEN retValue[j] = 'Inf'
      ENDIF
      IF ~Finite(number[j]) THEN CONTINUE
      
      <span class="comments">; Is this a number between zero and 1? Then the number of decimals should</span>
      <span class="comments">; be adjusted to save the number of significant decimals in the fractional part of this</span>
      <span class="comments">; number. This works as long as the number of zeros in front of the first</span>
      <span class="comments">; significant digits doesn't exceed the number of decimals points asked for</span>
      <span class="comments">; and the "G" formatting doesn't push into exponetial territory.</span>
      IF (Abs(number[j]) GT 0.0001) && (Abs(number[j]) LT 1.0) THEN BEGIN
          savedecimals = decimals
          exponents = 1. / 10.^Indgen(12)
          index = Where(exponents LE Abs(number[j]), count)
          IF count EQ 0 THEN thisIndex = 11 ELSE thisindex = index[0]
          decimals = ((thisindex-1) + decimals)
      ENDIF
      
      <span class="comments">; Is the number a negative value? Deal only with positive values, until the end.</span>
      IF number[j] LT 0.0 THEN minus = 1 ELSE minus = 0
      theNumber = Abs(number[j])

      <span class="comments">; Do the appropriate thing.</span>
      CASE Size(theNumber, /TNAME) OF

         'INT': retValue[j] = StrTrim(String(theNumber),2)

         'LONG': retValue[j] = StrTrim(String(theNumber),2)

         'FLOAT': BEGIN

            <span class="comments">; Format the number with G format.</span>
            aString = StrTrim(String(theNumber, Format='(G)'), 2)

            <span class="comments">; Split the number into a whole part and a fractional part.</span>
            parts = StrSplit(aString, '.', /Extract)
            IF N_Elements(parts) EQ 1 THEN parts = [parts, '0']
            parts[1] = StrTrim(parts[1],2)

            <span class="comments">; Does the fractional part have an E or a D in it?</span>
            loc = StRegEx(parts[1], '[DE]')
            CASE loc OF

               -1: BEGIN <span class="comments">; No exponent.</span>

                   <span class="comments">; Round to the number of decimals you want.</span>
                   fracpart = StrTrim(Round(Double('1.' + parts[1]) * (10LL^decimals), /L64), 2)
                   IF StrMid(fracpart,0,1) EQ '2' THEN BEGIN
                     parts[0] = StrTrim(Long64(parts[0]) + 1, 2)
                   ENDIF
                   parts[1] = StrMid(fracpart, 1)
                   retValue[j] = StrTrim(parts[0],2) + '.' + parts[1]
                   END

               ELSE: BEGIN

                   <span class="comments">; Divide the fractional part of the number up into parts.</span>
                   <span class="comments">; Treat p[0] as you treated parts[1] above. Then put it all</span>
                   <span class="comments">; back together.</span>
                   p = StrSplit(parts[1], '[DdEe]', /RegEx, /Extract)

                   <span class="comments">; Round to the number of decimals you want.</span>
                   fracpart = StrTrim(Round(Double('1.' + p[0]) * (10LL^decimals), /L64), 2)
                   IF StrMid(fracpart,0,1) EQ '2' THEN BEGIN
                     parts[0] = StrTrim(Long64(parts[0]) + 1, 2)
                   ENDIF
                   p[0] = StrMid(fracpart, 1)

                   <span class="comments">; Get the exponent sign and exponent part.</span>
                   expSign = StrMid(p[1],0,1)
                   expPart = StrMid(p[1],1)

                   <span class="comments">; Trim zeros in exponent.</span>
                   firstChar = StrMid(expPart, 0, 1)
                   WHILE firstChar EQ '0' DO BEGIN
                     expPart = StrMid(expPart, 1)
                     firstChar = StrMid(expPart, 0, 1)
                   ENDWHILE

                   <span class="comments">; Put it all back together.</span>
                   retValue[j] = StrTrim(parts[0],2) + '.' + p[0] + StrLowCase(StrMid(parts[1],loc,1)) + expSign + expPart
                   END

            ENDCASE

            <span class="comments">; If you changed the number of decimals you were using, put it back.</span>
            IF N_Elements(savedecimals) NE 0 THEN decimals = savedecimals
            END

         'DOUBLE': BEGIN
            <span class="comments">; Format the number with G format.</span>
            aString = StrTrim(String(theNumber, Format='(G)'), 2)

            <span class="comments">; Split the number into a whole part and a fractional part.</span>
            parts = StrSplit(aString, '.', /Extract)
            IF N_Elements(parts) EQ 1 THEN parts = [parts, '0']
            parts[1] = StrTrim(parts[1],2)

            <span class="comments">; Does the fractional part have an E or a D in it?</span>
            loc = StRegEx(parts[1], '[DE]')
            CASE loc OF

               -1: BEGIN <span class="comments">; No exponent.</span>

                   <span class="comments">; Round to the number of decimals you want.</span>
                   fracpart = StrTrim(Round(Double('1.' + parts[1]) * (10LL^decimals), /L64), 2)
                   IF StrMid(fracpart,0,1) EQ '2' THEN BEGIN
                     parts[0] = StrTrim(Long64(parts[0]) + 1, 2)
                   ENDIF
                   parts[1] = StrMid(fracpart, 1)
                   retValue[j] = StrTrim(parts[0],2) + '.' + parts[1]
                   END

               ELSE: BEGIN

                   <span class="comments">; Divide the fractional part of the number up into parts.</span>
                   <span class="comments">; Treat p[0] as you treated parts[1] above. Then put it all</span>
                   <span class="comments">; back together.</span>
                   p = StrSplit(parts[1], '[DdEe]', /RegEx, /Extract)

                   <span class="comments">; Round to the number of decimals you want.</span>
                   fracpart = StrTrim(Round(Double('1.' + p[0]) * (10LL^decimals), /L64), 2)
                   IF StrMid(fracpart,0,1) EQ '2' THEN BEGIN
                     parts[0] = StrTrim(Long64(parts[0]) + 1, 2)
                   ENDIF
                   p[0] = StrMid(fracpart, 1)

                   <span class="comments">; Get the exponent sign and exponent part.</span>
                   expSign = StrMid(p[1],0,1)
                   expPart = StrMid(p[1],1)

                   <span class="comments">; Trim zeros in exponent.</span>
                   firstChar = StrMid(expPart, 0, 1)
                   WHILE firstChar EQ '0' DO BEGIN
                     expPart = StrMid(expPart, 1)
                     firstChar = StrMid(expPart, 0, 1)
                   ENDWHILE

                   <span class="comments">; Put it all back together.</span>
                   retValue[j] = StrTrim(parts[0],2) + '.' + p[0] + StrLowCase(StrMid(parts[1],loc,1)) + expSign + expPart
                   END

            ENDCASE

            END

         'UINT': retValue[j] = StrTrim(String(theNumber),2)

         'ULONG': retValue[j] = StrTrim(String(theNumber),2)

         'LONG64': retValue[j] = StrTrim(String(theNumber),2)

         'ULONG64': retValue[j] = StrTrim(String(theNumber),2)

         ELSE: Message, 'Cannot format a number of this type: ' + Size(theNumber, /TNAME) + '.'

      ENDCASE

      <span class="comments">; Need a minus sign?</span>
      IF minus THEN retValue[j] = '-' + retValue[j]

   ENDFOR

   IF N_Elements(retValue) EQ 1 THEN RETURN, retValue[0] ELSE RETURN, retValue

END <span class="comments">;----------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>