<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgbarplot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgbarplot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgBarPlot</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Provides a device-independent and color-model-independent way to create a bar</span>
<span class="comments">;   plot or to overplot on an existing bar plot.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; Provides a device-independent and color-model-independent way to create a bar</span>
<span class="comments">; plot or to overplot on an existing bar plot.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    values: in, required</span>
<span class="comments">;        A vector containing the values to be represented by bars. Each element in</span>
<span class="comments">;        the vector will be represented by a bar. </span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to a cgWindow resizeable graphics window.</span>
<span class="comments">;     axiscolor: in, optional, type=string/integer, default='black'</span>
<span class="comments">;        If this keyword is a string, the name of the axis color. By default, 'black'.</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     background: in, optional, type=string/integer, default='white'</span>
<span class="comments">;        If this keyword is a string, the name of the background color. By default, 'white'.</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     barcoords: out, optional, type=float</span>
<span class="comments">;        A vector of values for the center point of the bars.</span>
<span class="comments">;     barnames: in, optional, type=string, default=""</span>
<span class="comments">;        A string array, containing one string label per bar. If the bars are vertical, </span>
<span class="comments">;        the labels are placed beneath them.  If horizontal (rotated) bars are specified, </span>
<span class="comments">;        the labels are placed to the left of the bars.</span>
<span class="comments">;     baroffset: in, optional, type=float, default=barspace/barwidth*1.5</span>
<span class="comments">;        A scalar that specifies the offset to be applied to the first bar, in units of </span>
<span class="comments">;        "nominal bar width".  This keyword allows, for example, different groups of bars </span>
<span class="comments">;        to be overplotted on the same graph.  </span>
<span class="comments">;     barspace: in, optional, type=float, default=barwidth*0.20</span>
<span class="comments">;        A scalar that specifies, in units of "nominal bar width", the spacing between bars.  </span>
<span class="comments">;        For example, if BARSPACE is 1.0, then all bars will have one bar-width of space </span>
<span class="comments">;        between them. If not specified, the bars are spaced apart by 20% of the bar width.</span>
<span class="comments">;     barthick: in, optional, type=float, default=1.0</span>
<span class="comments">;        A scalar that specifies the thickness of the bar outlines. </span>
<span class="comments">;     barwidth: in, optional, type=float</span>
<span class="comments">;         A floating-point value that specifies the width of the bars in units of "nominal bar </span>
<span class="comments">;         width".  The nominal bar width is computed so that all the bars (and the space </span>
<span class="comments">;         between them will fill the available space (optionally controlled with the BASERANGE </span>
<span class="comments">;         keyword).</span>
<span class="comments">;     baselines: in, optional, type=float, default=0.0</span>
<span class="comments">;         A vector, the same size as VALUES, that contains the base value associated </span>
<span class="comments">;         with each bar.  If not specified, a base value of zero is used for all bars.</span>
<span class="comments">;     baserange: in, optional, type=float, default=1.0</span>
<span class="comments">;         A floating-point scalar in the range 0.0 to 1.0, that determines the fraction of </span>
<span class="comments">;         the total available plotting area (in the direction perpendicular to the bars) to </span>
<span class="comments">;         be used. If not specified, the full available area is used.</span>
<span class="comments">;     colors: in, optional, type=varies</span>
<span class="comments">;         A vector of color values, the same size as VALUES, containing either the color</span>
<span class="comments">;         names, 24-bit color values, or color index numbers (byte values) of the colors to</span>
<span class="comments">;         be used for the bars. If not specified, the colors are selected based on the </span>
<span class="comments">;         available colors in the current color table.</span>
<span class="comments">;     layout: in, optional, type=intarr(3)</span>
<span class="comments">;         This keyword specifies a grid with a graphics window and determines where the</span>
<span class="comments">;         graphic should appear. The syntax of LAYOUT is three numbers: [ncolumns, nrows, location].</span>
<span class="comments">;         The grid is determined by the number of columns (ncolumns) by the number of </span>
<span class="comments">;         rows (nrows). The location of the graphic is determined by the third number. The</span>
<span class="comments">;         grid numbering starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;         by row.</span>
<span class="comments">;     noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to draw the plot without erasing the display first.</span>
<span class="comments">;     outfilename: in, optional, type=string</span>
<span class="comments">;        If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;        filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;        value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;        presented to the user.</span>
<span class="comments">;     outline: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to draw an outline around each bar in the OPLOTCOLORS.</span>
<span class="comments">;     output: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;        Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;        file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;        user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;        All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;        PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;        to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;        details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;        plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;        output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;     oplotcolors: in, optional, type=varies, default='charcoal'</span>
<span class="comments">;         A vector of color values, similar to colors for overplot outlines on the bars.</span>
<span class="comments">;         If a scalar value (e.g., "charcoal") the same value is used for all outlines.</span>
<span class="comments">;     overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you wish to overplot data on an already exisiting set of</span>
<span class="comments">;         axes. It is like calling the IDL OPLOT command.</span>
<span class="comments">;     position: in, optional, type=fltarr(4)</span>
<span class="comments">;         The usual four-element normalized position vector for the Plot comamnd. </span>
<span class="comments">;     rotate: in, optional, type=boolean, default=0</span>
<span class="comments">;         If set, this keyword indicates that horizontal rather than vertical bars should </span>
<span class="comments">;         be drawn.  The bases of horizontal bars are on the left, "Y" axis and the bars </span>
<span class="comments">;         extend to the right.</span>
<span class="comments">;     title: in, optional, type=string, default=""</span>
<span class="comments">;         The title of the plot, if supplied.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want to display the plot in a resizable graphics window.</span>
<span class="comments">;     xstyle: in, optional, type=boolean, default=1</span>
<span class="comments">;         The normal XSTYLE keyword. See "Graphics Keywords" in on-line help.</span>
<span class="comments">;     xtitle: in, optional, type=string, default=""</span>
<span class="comments">;         The X title of the plot, if supplied.</span>
<span class="comments">;     ystyle: in, optional, type=boolean, default=1</span>
<span class="comments">;         The normal YSTYLE keyword. See "Graphics Keywords" in on-line help.</span>
<span class="comments">;     ytitle: in, optional, type=string, default=""</span>
<span class="comments">;         The Y title of the plot, if supplied.</span>
<span class="comments">;     _ref_extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDL Plot command is allowed in the program.</span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    To create bar plots of four different bar classes. Example uses AL_Legend from</span>
<span class="comments">;    the NASA Astronomy Library. Comment out if not available.::</span>
<span class="comments">;       </span>
<span class="comments">;    Create data::</span>
<span class="comments">;    </span>
<span class="comments">;       seed = -5L</span>
<span class="comments">;       data1 = RandomU(seed, 5) * 10.0</span>
<span class="comments">;       data2 = RandomU(seed, 5) * 7.5</span>
<span class="comments">;       data3 = RandomU(seed, 5) * 7.5</span>
<span class="comments">;       data4 = RandomU(seed, 5) * 10.0</span>
<span class="comments">;    </span>
<span class="comments">;    Display as four different plots::</span>
<span class="comments">;    </span>
<span class="comments">;       !P.Multi=[0,2,2]</span>
<span class="comments">;       cgDisplay, WID=0</span>
<span class="comments">;       cgBarPlot, data1, /OUTLINE, OPLOTCOLOR='charcoal', YRANGE=[0, 12], COLORS='red', XTITLE='Class 1'</span>
<span class="comments">;       cgBarPlot, data2, /OUTLINE, OPLOTCOLOR='charcoal', YRANGE=[0, 12], COLORS='blue', XTITLE='Class 2'</span>
<span class="comments">;       cgBarPlot, data3, /OUTLINE, OPLOTCOLOR='charcoal', YRANGE=[0, 12], COLORS='gold', XTITLE='Class 3'</span>
<span class="comments">;       cgBarPlot, data4, /OUTLINE, OPLOTCOLOR='charcoal', YRANGE=[0, 12], COLORS='dark green', XTITLE='Class 4'</span>
<span class="comments">;       !P.Multi=0</span>
<span class="comments">;</span>
<span class="comments">;    Display as accumulated bar plots::</span>
<span class="comments">;    </span>
<span class="comments">;       cgDisplay, WID=1</span>
<span class="comments">;       barnames = ['Exp 1', 'Exp 2', 'Exp 3', 'Exp 4', 'Exp 5']</span>
<span class="comments">;       cgBarPlot, data1, YRANGE=[0, 35], COLORS='red', BARNAMES=barnames</span>
<span class="comments">;       cgBarplot, data2, /OVERPLOT, BASELINE=data1, COLORS='blue'</span>
<span class="comments">;       cgBarplot, data3, /OVERPLOT, BASELINE=data1+data2, COLORS='gold'</span>
<span class="comments">;       cgBarplot, data4, /OVERPLOT, BASELINE=data1+data2+data3, COLORS='dark green'</span>
<span class="comments">;       colors = ['red', 'blue', 'gold', 'dark green']</span>
<span class="comments">;       items = ['Class 1', 'Class 2', 'Class 3', 'Class 4']</span>
<span class="comments">;       Al_Legend, items, /FILL, PSYM=Replicate(15,4), COLORS=colors, SYMSIZE=Replicate(1.75,4), $</span>
<span class="comments">;           POSITION=[0.20, 0.92], /NORMAL, CHARSIZE=cgDefCharSize()</span>
<span class="comments">;</span>
<span class="comments">;    Display all on same plot::</span>
<span class="comments">;    </span>
<span class="comments">;       cgDisplay, WID=2</span>
<span class="comments">;       cgBarPlot, data1, YRANGE=[0, 12], BAROFFSET=2.5, BASERANGE=0.20, COLORS='red'</span>
<span class="comments">;       cgBarplot, data2, /OVERPLOT, BAROFFSET=9.5, BASERANGE=0.20, COLORS='blue'</span>
<span class="comments">;       cgBarplot, data3, /OVERPLOT, BAROFFSET=17.0, BASERANGE=0.20, COLORS='gold'</span>
<span class="comments">;       cgBarplot, data4, /OVERPLOT, BAROFFSET=24.5, BASERANGE=0.20, COLORS='dark green'</span>
<span class="comments">;       colors = ['red', 'blue', 'gold', 'dark green']</span>
<span class="comments">;       items = ['Class 1', 'Class 2', 'Class 3', 'Class 4']</span>
<span class="comments">;       Al_Legend, items, /FILL, PSYM=Replicate(15,4), COLORS=colors, SYMSIZE=Replicate(1.75,4), $</span>
<span class="comments">;           POSITION=[0.45, 0.92], /NORMAL, CHARSIZE=cgDefCharSize()</span>
<span class="comments">;</span>
<span class="comments">; .. image:: cgbarplot.png</span>
<span class="comments">; </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 3 October 2011. DWF. Written as a straight-forward translation of</span>
<span class="comments">;            the IDL Bar_Plot program. In retrospect, maybe not the best idea, as I </span>
<span class="comments">;            don't think the Bar_Plot program actually works and the interface is clunky.</span>
<span class="comments">;            But, this is a start. The interface may change to something more elegant over</span>
<span class="comments">;            time.</span>
<span class="comments">;         Updated the BACKGROUND color selection from lessons learned in 27 Oct 2011 cgContour </span>
<span class="comments">;             corrections. 27 Oct 2011. DWF.</span>
<span class="comments">;         Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;         PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2001. DWF.</span>
<span class="comments">;         Modified to use cgDefaultColor for default color selection. 24 Dec 2011. DWF.</span>
<span class="comments">;         Fixed a problem with keyword inheritance. Added XStyle and YStyle keywords. 25 Jan 2012. DWF.</span>
<span class="comments">;         Added BARCOORDS keyword to return bar plot locations. 25 Jan 2012.</span>
<span class="comments">;         Changes to allow better default colors, based on changes to cgColor and cgDefaultColor. 1 Feb 2012. DWF.</span>
<span class="comments">;         Small problem with setting range keywords and with extraneous marks on the bar plot axis fixed. 6 Feb 2012. DWF.</span>
<span class="comments">;         Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;         Fixed a typo that was interfering with the YTITLE keyword. 3 Oct 2012. DWF.</span>
<span class="comments">;         Fixed a bug in the interaction of the NOERASE and OVERPLOT keywords. 14 Jan 2013. DWF.</span>
<span class="comments">;         Added a BARTHICK keyword to change the thickness of the bar outlines. 28 Feb 2013. DWF.</span>
<span class="comments">;         Further work checking for NANs in the display of the data. NAN data set to length of 0. 3 Sept 2013. DWF.</span>
<span class="comments">;         </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgBarPlot, values, $
    ADDCMD=addcmd, $
    AXISCOLOR=saxiscolor, $
    BACKGROUND=sbackground, $
    BARCOORDS=barcoords, $
    BARNAMES=barnamesIn, $
    BAROFFSET=baroffsetIn, $
    BARSPACE=barspaceIn, $
    BARTHICK=barthickIn, $
    BARWIDTH=barwidthIn, $
    BASELINES=baselines, $
    BASERANGE=baserange, $
    COLORS=scolors, $
    LAYOUT=layout, $
    NOERASE=noerase, $
    OUTFILENAME=outfilename, $
    OUTLINE=outline, $
    OUTPUT=output, $
    OPLOTCOLORS=oplotcolors, $
    OVERPLOT=overplot, $
    POSITION=position, $
    RANGE=range, $
    ROTATE=rotate,  $
    TITLE=title,  $
    WINDOW=window, $
    XSTYLE=xstyle, $
    XTITLE=xtitle, $
    YSTYLE=ystyle, $
    YTITLE=ytitle, $
    _REF_EXTRA=extra
    
    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
       Catch, /CANCEL
       void = Error_Message()
        IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Check parameters.</span>
    IF (N_Elements(values) EQ 0) THEN BEGIN
        Print, 'USE SYNTAX: cgBarPlot, values'
        RETURN
    ENDIF
    
    <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    
    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
        
        <span class="comments">; Special treatment for overplotting or adding a command.</span>
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgBarPlot', values, $
                ADDCMD=1, $
                AXISCOLOR=saxiscolor, $
                BACKGROUND=sbackground, $
                BARCOORDS=barcoords, $
                BARNAMES=barnamesIn, $
                BAROFFSET=baroffsetIn, $
                BARSPACE=barspaceIn, $
                BARTHICK=barthickIn, $
                BARWIDTH=barwidthIn, $
                BASELINES=baselines, $
                BASERANGE=baserange, $
                COLORS=scolors, $
                LAYOUT=layout, $
                NOERASE=noerase, $
                OPLOTCOLORS=oplotcolors, $
                OUTLINE=outline, $
                OVERPLOT=overplot, $
                POSITION=position, $
                RANGE=range, $
                ROTATE=rotate,  $
                XSTYLE=xstyle, $
                XTITLE=xtitle, $
                YSTYLE=ystyle, $
                YTITLE=ytitle, $
               _EXTRA=extra
             RETURN
       ENDIF
        
        <span class="comments">; Open a new window or replace the current commands, as required.</span>
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
            cgWindow, 'cgBarPlot', values, $
                AXISCOLOR=saxiscolor, $
                BACKGROUND=sbackground, $
                BARCOORDS=barcoords, $
                BARNAMES=barnamesIn, $
                BAROFFSET=baroffsetIn, $
                BARSPACE=barspaceIn, $
                BARTHICK=barthickIn, $
                BARWIDTH=barwidthIn, $
                BASELINES=baselines, $
                BASERANGE=baserange, $
                COLORS=scolors, $
                LAYOUT=layout, $
                NOERASE=noerase, $
                OPLOTCOLORS=oplotcolors, $
                OUTLINE=outline, $
                OVERPLOT=overplot, $
                POSITION=position, $
                RANGE=range, $
                ROTATE=rotate,  $
                REPLACECMD=replaceCmd, $
                TITLE=title,  $
                XSTYLE=xstyle, $
                XTITLE=xtitle, $
                YSTYLE=ystyle, $
                YTITLE=ytitle, $
                _EXTRA=extra
            
         RETURN
    ENDIF
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    ENDIF
    
  <span class="comments">; The number of bars to draw.</span>
    nbars = N_Elements(values)

    <span class="comments">; Get the current color table vectors.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; Going to do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState
    
    <span class="comments">; If current state is "indexed color" and colors are represented as long integers then "fix" them.</span>
    IF (currentState EQ 0) THEN BEGIN
      IF Size(sbackground, /TNAME) EQ 'LONG' THEN sbackground = Fix(sbackground)
      IF Size(saxiscolor, /TNAME) EQ 'LONG' THEN saxiscolor = Fix(saxiscolor)
      IF Size(scolors, /TNAME) EQ 'LONG' THEN scolors = Fix(scolors)
    ENDIF
    
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

    <span class="comments">; Check the keywords.</span>
    background = cgDefaultColor(sbackground, /BACKGROUND, TRADITIONAL=traditional)
    axisColor = cgDefaultColor(saxisColor, TRADITIONAL=traditional)
    color = cgDefaultColor(sColor, DEFAULT=axisColor, TRADITIONAL=traditional)
        
    <span class="comments">; Load the drawing colors. If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay

    <span class="comments">; If colors are identical, do something about it.</span>
    IF ColorsAreIdentical(background, axiscolor) THEN BEGIN
        IF ((!D.Flags AND 256) NE 0) THEN BEGIN
           IF (!P.Multi[0] EQ 0) && (~Keyword_Set(overplot) && ~noerase) THEN cgErase, background
        ENDIF
        axiscolor = 'OPPOSITE'
    ENDIF
    
    <span class="comments">; Check other keywords.</span>
    addcmd = Keyword_Set(addcmd)
    barnames = (N_Elements(barnamesIn) EQ 0) ? StrArr(nbars) + ' ' : barnamesIn
    IF N_Elements(barnames) NE nbars THEN Message, 'Number of bar names does not equal the number of bars.'
    barspace = (N_Elements(barspaceIn) EQ 0) ? 0.2 : Float(barspaceIn)
    barthick = (N_Elements(barthickIn) EQ 0) ? 1.0 : Float(barthickIn)
    barwidth = (N_Elements(barwidthIn) EQ 0) ? 1.0 - barspace - (barspace / nbars) : barwidthIn    
    baroffset = (N_Elements(baroffsetIn) EQ 0) ? barspace/barwidth*1.5 : baroffsetIn
    IF N_Elements(baselines) EQ 0 THEN baselines = IntArr(nbars)
    IF N_Elements(baserange) EQ 0 THEN baserange = 0.95
    IF N_Elements(scolors) EQ 0 THEN BEGIN
        scolors=String(Byte((256.0/nbars)*(Indgen(nbars)+0.5)), FORMAT='(i0)')
    ENDIF
    colors = cgDefaultColor(scolors)
    IF N_Elements(colors) EQ 1 THEN colors = Replicate(colors, nbars)
    IF N_Elements(colors) NE nbars THEN $
       Message, 'There is a mismatch between the number of bars and number of bar colors.'
    outline = Keyword_Set(outline)
    overplot = Keyword_Set(overplot)
    IF N_Elements(oplotcolors) EQ 0 THEN oplotColors = Replicate('charcoal', nbars)
    IF N_Elements(oplotColors) EQ 1 THEN oplotColors = Replicate(oplotColors, nbars)
    IF N_Elements(oplotColors) NE nbars THEN $
       Message, 'There is a mismatch between the number of bars and number of overplot colors.'
    noerase = Keyword_set(noerase)
    rotate = Keyword_Set(rotate)
    IF N_Elements(title) EQ 0 THEN title = "" ELSE title = cgCheckForSymbols(title)
    IF rotate THEN BEGIN
        IF N_Elements(ystyle) EQ 0 THEN ystyle = 1 ELSE ystyle = 1 XOR ystyle
    ENDIF ELSE BEGIN
        IF N_Elements(xstyle) EQ 0 THEN xstyle = 1 ELSE xstyle = 1 XOR xstyle    
    ENDELSE
    window = Keyword_Set(window)
    IF N_Elements(xtitle) EQ 0 THEN xtitle = "" ELSE xtitle = cgCheckForSymbols(xtitle)
    IF N_Elements(ytitle) EQ 0 THEN ytitle = "" ELSE ytitle = cgCheckForSymbols(ytitle)
    
    
    <span class="comments">; Find the min and max of the data range. Comparing baselines and values.</span>
    mnB = Min(baselines, MAX=mxB, /NAN)
    mnV = Min(values, MAX=mxV, /NAN)
    IF N_Elements(range) EQ 0 THEN range=[mnB &lt<span class="comments">; mnV, mxB > (mxV + 0.1*mxV)]      </span>
    
    <span class="comments">; Do you want horizontal bars, rather than vertical?</span>
    IF (rotate) THEN BEGIN                
       xrange = range             <span class="comments">;Or, use range specIFied</span>
       yrange = [0, N_Elements(values)]        <span class="comments">;Axis perpend. to bars</span>
       yticks = 1                    <span class="comments">;Suppress ticks in plot</span>
       yticklen = 0.001
       ytickname = strarr(2)+' '
       xticks = 0
       xtickname = strarr(1)+''
    ENDIF ELSE BEGIN                   <span class="comments">;Vertical bars</span>
       yrange = range 
       xrange = [0, N_Elements(values)]                 <span class="comments">;Axis perpend. to bars</span>
       xticks = 1                    <span class="comments">;Suppress ticks in plot</span>
       xticklen=0.001
       xtickname = strarr(2)+' '
       yticks = 0
       ytickname = strarr(1)+''
    ENDELSE

   <span class="comments">; If you are creating your own plot, do it here without data.</span>
    IF (overplot EQ 0) || (noerase EQ 1) THEN BEGIN  <span class="comments">;Create new plot, no data</span>
        cgPlot,[values],/nodata,title=title,xtitle=xtitle,ytitle=ytitle, $
           noerase=noerase,xrange=xrange,yrange=yrange,xticks=xticks, $
           xtickname=xtickname,yticks=yticks,ytickname=ytickname, $
           xstyle=xstyle,ystyle=ystyle,/data,position=position, $
           background=background, axiscolor=axiscolor,_strict_extra=extra, $
           xticklen=xticklen, yticklen=yticklen
   ENDIF
    IF (rotate) THEN BEGIN               <span class="comments">; Horizontal bars</span>
       base_win = !y.window              <span class="comments">; Window range in Y</span>
       scal_fact = !x.s                  <span class="comments">; Scaling factors</span>
       tick_scal_fact = !y.s             <span class="comments">; Tick scaling factors</span>
    ENDIF ELSE BEGIN                     <span class="comments">; Vertical bars</span>
       base_win = !x.window              <span class="comments">; Window range in X</span>
       scal_fact = !y.s                  <span class="comments">; Scaling factors</span>
       tick_scal_fact = !x.s             <span class="comments">; Tick scaling factors</span>
    ENDELSE
    winrange = baserange*(base_win[1]-base_win[0])   <span class="comments">; Normal. window range</span>
    barsize = barwidth*winrange/nbars                <span class="comments">; Normal. bar width</span>
    winoffset = base_win[0]+(baroffset*barsize)      <span class="comments">; Normal. first offset</span>
    bases = scal_fact[0]+(scal_fact[1]*baselines)    <span class="comments">; Baselines, in normal coordinates</span>
    normal = scal_fact[0]+(scal_fact[1]*values)      <span class="comments">; Values, in normal coordinates</span>
    barstart = Lindgen(nbars)*(barsize+barspace*(winrange/nbars)) <span class="comments">; Coor. at left edges</span>
    tickv = winoffset+barstart+(0.5*barsize)         <span class="comments">; Tick coordinates. (centered)</span>
    
    FOR i=0,nbars-1 do BEGIN               <span class="comments">; Draw the bars</span>
       width = winoffset+[barstart[i],barstart[i], $     <span class="comments">; Compute bar width</span>
         (barstart[i]+barsize),(barstart[i]+barsize)]
       IF Finite(values[i]) EQ 0 THEN BEGIN
          length = 0.0
       ENDIF ELSE BEGIN
          length = [baselines[i], baselines[i]+values[i], baselines[i]+values[i], baselines[i]]
       ENDELSE
       IF (rotate) THEN BEGIN              <span class="comments">; Horizontal bars</span>
          xy = Convert_Coord(length, [0,1,1,0], /DATA, /TO_NORMAL)  <span class="comments">; Compute bar length</span>
          length=Transpose(xy[0,*])
          x = length                       <span class="comments">; X-axis is "length" axis</span>
          y = width                        <span class="comments">; Y-axis is "width" axis</span>
       ENDIF ELSE BEGIN                    <span class="comments">; Vertical bars</span>
          xy = Convert_Coord([0,1,1,0], length, /DATA, /TO_NORMAL)  <span class="comments">; Compute bar length</span>
          length=Transpose(xy[1,*])
          x = width                        <span class="comments">; X-axis is "width" axis</span>
          y = length                       <span class="comments">; Y-axis is "length" axis</span>
       ENDELSE
       cgColorFill, x, y, COLOR=colors[i], /NORMAL                    <span class="comments">; Polyfill with color</span>
       IF (outline) THEN cgPlots, x, y, /NORMAL, COLOR=OplotColors[i], THICK=barThick <span class="comments">; Outline using !p.color</span>
    ENDFOR
    
    tickv = (tickv-tick_scal_fact[0])/tick_scal_fact[1]  <span class="comments">; Locations of the ticks</span>
    barcoords = tickv
        
    IF (rotate) THEN BEGIN <span class="comments">; Label the bars (Y-axis)</span>
       cgAxis,yaxis=0,ystyle=ystyle,yticks=(nbars-1),ytickv=tickv,ytickname=barnames, $
          yticklen=0.0, _extra=extra
    ENDIF ELSE BEGIN       <span class="comments">; Label the bars (X-axis)</span>
       cgAxis,xaxis=0,xstyle=xstyle,xticks=(nbars-1),xtickv=tickv,xtickname=barnames, $
          xticklen=0.0, _extra=extra
    ENDELSE

    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width

         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
END
</code>
    </div>
  </body>
</html>