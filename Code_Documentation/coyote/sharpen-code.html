<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:12 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sharpen.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sharpen.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       Sharpen</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;        This function sharpens an image using a Laplacian kernel.</span>
<span class="comments">;        The final result is color adjusted to match the histogram</span>
<span class="comments">;        of the input image.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Image Processing</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       sharp_image = Sharpen(image)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       image - The input image to be sharpened. Assumed to be a 2D byte array.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       sharp_image - The sharpened image.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       KERNEL -- By default the image is convolved with this 3-by-3 Laplacian kernel:</span>
<span class="comments">;           [ [-1, -1, -1], [-1, +8, -1], [-1, -1, -1] ].  You can pass in any  kernel</span>
<span class="comments">;           of odd width. The filtered image is added back to the original image to provide</span>
<span class="comments">;           the sharpening effect.</span>
<span class="comments">;</span>
<span class="comments">;       DISPLAY -- If this keyword is set a window is opened and the details of the sharpening</span>
<span class="comments">;           process are displayed.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; DEPENDENCIES:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; METHOD:</span>
<span class="comments">;</span>
<span class="comments">;       This function is based on the Laplacian kernel sharpening method on pages 128-131</span>
<span class="comments">;       of Digital Image Processing, 2nd Edition, Rafael C. Gonzalez and Richard E. Woods,</span>
<span class="comments">;       ISBN 0-20-118075-8.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       There is an example program at the end of this file.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;       Written by David W. Fanning, January 2003.</span>
<span class="comments">;       Updated slightly to use Coyote Library routines. 3 Dec. 2010. DWF.</span>
<span class="comments">;       Modified the example to work with cgImage. 29 March 2011. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>

FUNCTION Sharpen_HistoMatch, image, histogram_to_match

   <span class="comments">; Error handling.</span>

Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel

      <span class="comments">; Get the call stack and the calling routine's name.</span>

   Help, Calls=callStack
   IF Float(!Version.Release) GE 5.2 THEN $
      callingRoutine = (StrSplit(StrCompress(callStack[1])," ", /Extract))[0] ELSE $
      callingRoutine = (Str_Sep(StrCompress(callStack[1])," "))[0]

      <span class="comments">; Print a traceback.</span>

   Help, /Last_Message, Output=traceback
   Print,''
   Print, 'Traceback Report from ' + StrUpCase(callingRoutine) + ':'
   Print, ''
   FOR j=0,N_Elements(traceback)-1 DO Print, "     " + traceback[j]

   IF N_Elements(image) NE 0 THEN RETURN, image ELSE RETURN, -1L
ENDIF

   <span class="comments">; We require two input parameters.</span>

IF N_Params() NE 2 THEN Message, 'Two arguments required. Please read the program documentation.'

   <span class="comments">; Must have 2D image array.</span>

IF Size(image, /N_Dimensions) NE 2 THEN Message, 'Image argument must be 2D. Returning.'

   <span class="comments">; Is the histogram_to_match variable a 1D or 2D array? Branch accordingly.</span>

CASE Size(histogram_to_match, /N_Dimensions) OF
   1: BEGIN
      IF N_Elements(histogram_to_match) NE 256 THEN $
         Message, 'Histogram to match has incorrect size. Returning.'
      match_histogram =    histogram_to_match
      END
   2: match_histogram = Histogram(Byte(histogram_to_match), Min=0, Max=255, Binsize=1)
   ELSE: Message, 'Histogram to match has incorrect number of dimensions. Returning.'
ENDCASE

   <span class="comments">; Calculate the histogram of the input image.</span>

h = Histogram(Byte(image), Binsize=1, Min=0, Max=255)

   <span class="comments">; Make sure the two histograms have the same number of pixels. This will</span>
   <span class="comments">; be a problem if the two images are different sizes, you are matching a</span>
   <span class="comments">; histogram from an image subset, etc.</span>

totalPixels = Float(N_Elements(image))
totalHistogramPixels = Float(Total(match_histogram))

IF totalPixels NE totalHistogramPixels THEN $
   factor = totalPixels / totalHistogramPixels ELSE $
   factor = 1.0

match_histogram = match_histogram * factor

   <span class="comments">; Find a mapping from the input pixels to the transformation function s.</span>

s = FltArr(256)
FOR k=0,255 DO BEGIN
  s[k] = Total(h(0:k) / totalPixels)
ENDFOR

   <span class="comments">; Find a mapping from input histogram to the transformation function v.</span>

v = FltArr(256)
FOR q=0,255 DO BEGIN
  v[q] = Total(match_histogram(0:q) / Total(match_histogram))
ENDFOR

   <span class="comments">; Find probablitly density function z from v and s.</span>

z = BytArr(256)
FOR j=0,255 DO BEGIN
   i = Where(v LT s[j], count)
   IF count GT 0 THEN z[j] = (Reverse(i))[0] ELSE z[j]=0
ENDFOR

   <span class="comments">; Create the matched image.</span>

matchedImage = z[Byte(image)]
RETURN, matchedImage
END
<span class="comments">; ----------------------------------------------------------------------------</span>



FUNCTION Sharpen, image, Display=display, Kernel=kernel

   <span class="comments">; Error handling.</span>

Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel

      <span class="comments">; Get the call stack and the calling routine's name.</span>

   Help, Calls=callStack
   IF Float(!Version.Release) GE 5.2 THEN $
      callingRoutine = (StrSplit(StrCompress(callStack[1])," ", /Extract))[0] ELSE $
      callingRoutine = (Str_Sep(StrCompress(callStack[1])," "))[0]

      <span class="comments">; Print a traceback.</span>

   Help, /Last_Message, Output=traceback
   Print,''
   Print, 'Traceback Report from ' + StrUpCase(callingRoutine) + ':'
   Print, ''
   FOR j=0,N_Elements(traceback)-1 DO Print, "     " + traceback[j]

   IF N_Elements(image) NE 0 THEN RETURN, image ELSE RETURN, -1L
ENDIF

   <span class="comments">; If an image is not provided. Issue an error message.</span>

IF N_Elements(image) EQ 0 THEN $
   Message, 'A 2D image is required as an argument.'

IF Size(image, /N_Dimensions) NE 2 THEN Message, 'Image must be a 2D array in this program.'

   <span class="comments">; Resize the image, if required.</span>

previewSize = 512
wxsize = previewSize
wysize = previewSize

   <span class="comments">; Set up the convolution kernel for Laplacian filtering.</span>

IF N_Elements(kernel) EQ 0 THEN BEGIN
   k = Replicate(-1, 3, 3)
   k[1,1] = 8
ENDIF ELSE BEGIN
   s = Size(kernel, /Dimensions)
   IF s[0] MOD 2 NE 1 THEN Message, 'Kernel must be an odd width.'
   k = kernel
ENDELSE

   <span class="comments">; Are we doing a display?</span>

IF Keyword_Set(display) THEN BEGIN
   s = Size(image, /Dimensions)
   xsize = s[0]
   ysize = s[1]
   needresize = 1
   IF xsize NE ysize THEN BEGIN
      needresize = 1
      aspect = Float(ysize) / xsize
      IF aspect LT 1 THEN BEGIN
         wxsize = previewSize
         wysize = (previewSize * aspect) &lt<span class="comments">; previewSize</span>
      ENDIF ELSE BEGIN
         wysize = previewSize
         wxsize = (previewSize / aspect) &lt<span class="comments">; previewSize</span>
      ENDELSE
   ENDIF

   Window, /Free, XSize=2*wxsize, YSize=2*wysize, Title='Image Sharpening-Laplacian'

ENDIF ELSE needresize = 0

   <span class="comments">; Need a resize?</span>

IF needresize THEN thisImage = Byte(Congrid(image, wxsize, wysize)) ELSE $
   thisImage = image

   <span class="comments">; Display the original image.</span>

IF Keyword_Set(display) THEN BEGIN $
   cgImage, thisImage, 0, 0, /TV
   XYOUTS, wxsize/2, 10,  /Device, 'Original Image', Font=0, $
      Alignment=0.5, Color=cgColor('red6')
ENDIF

   <span class="comments">; Create the Laplacian filtered image.</span>

filteredImage = Convol(Float(thisImage), k, Center=1, /Edge_Truncate, /NAN)

   <span class="comments">; Display the filtered image.</span>

IF Keyword_Set(display) THEN BEGIN
   fimage = Convol(thisImage, k, Center=1, /Edge_Truncate, /NAN)
   cgImage, fimage, wxsize, wysize, /TV
   XYOUTS, (2*wxsize/4)*3, wysize + 10, /Device, 'Filtered Image', Font=0, $
      Alignment=0.5, Color=cgColor('red6')
ENDIF

   <span class="comments">; Scale the Laplacian filtered image. Note conversion of</span>
   <span class="comments">; image to integer values and use of 255 as a FLOAT value.</span>

filteredImage = filteredImage - (Min(filteredImage))
filteredImage = filteredImage * (255./Max(filteredImage))
IF Keyword_Set(display) THEN BEGIN
   cgImage, filteredImage, 0, wysize, /TV
   XYOUTS, wxsize/2, wysize + 10, /Device, 'Scaled Filter', Font=0, $
      Alignment=0.5, Color=cgColor('red6')
ENDIF

   <span class="comments">; Create the sharpened image by adding the Laplacian filtered image</span>
   <span class="comments">; back to the original image and re-scaling.</span>

sharpened = thisImage + filteredImage
sharpened = sharpened - (Min(sharpened))
sharpened = sharpened * (255./Max(sharpened))

   <span class="comments">; Adjust the sharpened image to match the histogram of the original.</span>

adjusted = Sharpen_HistoMatch(sharpened, image)

   <span class="comments">; Display the adjusted image.</span>

IF Keyword_Set(display) THEN BEGIN
   cgImage, BytScl(adjusted), wxsize, 0, /TV
   XYOUTS, (2*wxsize/4)*3, 10, /Device, 'Sharpened Image', Font=0, $
      Alignment=0.5, Color=cgColor('red6')
ENDIF

RETURN, adjusted
END


PRO Example

image = cgDemoData(13)
s = Size(image, /Dimensions)
LoadCT, 0, /Silent
Window, /Free, XSize=s[0]*2, YSize=s[1], Title='Image Sharpening'
cgImage, image, 0, /TV
XYOuts, 0.25, 0.1, /Normal, Alignment=0.5, 'Original Image', Font=0, Color=cgColor('red6')
cgImage, Sharpen(image), 1, /NoErase, /TV
XYOuts, 0.75, 0.1, /Normal, Alignment=0.5, 'Sharpened Image', Font=0, Color=cgColor('red6')
END
</code>
    </div>
  </body>
</html>