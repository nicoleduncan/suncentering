<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:13 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>texture_surface.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="texture_surface.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       TEXTURE_SURFACE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The purpose of this program is to demonstrate how to</span>
<span class="comments">;       create a simple surface plot with an image applied as</span>
<span class="comments">;       a texture in object graphics.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Widgets, Object Graphics.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       TEXTURE_SURFACE, data, x, y, Image=image</span>
<span class="comments">;</span>
<span class="comments">; REQUIRED INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       None. Fake data will be used if no data is supplied in call.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS</span>
<span class="comments">;</span>
<span class="comments">;       data: A 2D array of surface data.</span>
<span class="comments">;</span>
<span class="comments">;       x: A vector of X data values.</span>
<span class="comments">;</span>
<span class="comments">;       y: A vector of Y data values.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       BORDERCOLOR : A three element array [R, G, B] describing the color</span>
<span class="comments">;       used to draw the non-textured part of the surface if POSITION is</span>
<span class="comments">;       specified.</span>
<span class="comments">;</span>
<span class="comments">;       COLORTABLE: The number of an IDL color table to use for the image</span>
<span class="comments">;       texture. Used only if the supplied image is 2D. Ignored otherwise.</span>
<span class="comments">;</span>
<span class="comments">;       EXACT:  Set this keyword to get exact axis scaling.</span>
<span class="comments">;</span>
<span class="comments">;       _EXTRA: This keyword collects otherwise undefined keywords that are</span>
<span class="comments">;        passed to the surface initialization routine.</span>
<span class="comments">;</span>
<span class="comments">;       GROUP_LEADER: The group leader for this program. When the group leader</span>
<span class="comments">;       is destroyed, this program will be destroyed.</span>
<span class="comments">;</span>
<span class="comments">;       IMAGE: An 8-bit or 24-bit image you wish to use for the image texture.</span>
<span class="comments">;</span>
<span class="comments">;       LANDSCAPE: Set this keyword if you are printing in landscape mode. The</span>
<span class="comments">;       default is Portrait mode. The Landscape keyword on the PRINTER object</span>
<span class="comments">;       is set, but not all printers will honor this keyword setting. If yours</span>
<span class="comments">;       does not, set Landscape mode in the Printer Setup dialog.</span>
<span class="comments">;</span>
<span class="comments">;       POSITION: A four element array of the form [x1, y1, x2, y2] that will</span>
<span class="comments">;       position the image with its lower-left corner at (x1,y1) and its upper-</span>
<span class="comments">;       right corner at (x2,y2) in the device coordinate system of the surface.</span>
<span class="comments">;       In other words, if my surface is a 41 by 41 array, and I want the image</span>
<span class="comments">;       positioned with lower-left at (5,10) and upper-right at (25,18), then</span>
<span class="comments">;       I call the program like this: Texture_Surface, Position=[5, 10, 25, 18].</span>
<span class="comments">;</span>
<span class="comments">;       VECTOR: Set this keyword if you want vector printing (as opposed to</span>
<span class="comments">;       the default bitmap printing).</span>
<span class="comments">;</span>
<span class="comments">;       XTITLE: A string used as the X title of the plot.</span>
<span class="comments">;</span>
<span class="comments">;       YTITLE: A string used as the Y title of the plot.</span>
<span class="comments">;</span>
<span class="comments">;       ZSCALE: A number larger than or equal to 0.001 and less than or equal to 1.0 that affects Z scaling.</span>
<span class="comments">;</span>
<span class="comments">;       ZTITLE: A string used as the Z title of the plot.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       To use this program with your surface data and 2D image, type:</span>
<span class="comments">;</span>
<span class="comments">;        IDL> data = cgDemoData(2)</span>
<span class="comments">;        IDL> image = cgDemoData(7)</span>
<span class="comments">;        IDL> Texture_Surface, data, Image=image, Colortable=33</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;</span>
<span class="comments">;        Requires the ASPECT program from the Coyote Library:</span>
<span class="comments">;</span>
<span class="comments">;           http://www.idlcoyote.com/programs/aspect.pro</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY</span>
<span class="comments">;</span>
<span class="comments">;       Written by David W. Fanning, 1 Nov 2001, from previous Simple_Surface code.</span>
<span class="comments">;       Modifications suggested by Karl Shultz added to allow surface color</span>
<span class="comments">;          specification and improved resolution about image edges when</span>
<span class="comments">;          positioning images. BORDERCOLOR keyword added. DWF. 4 Nov 2001.</span>
<span class="comments">;       The surface now maintains the same X/Y aspect ratio as the surface data. DWF. 8 April 2002.</span>
<span class="comments">;       Added ZSCALE keyword. DWF. 8 April 2002.</span>
<span class="comments">;       Changed FSC_Normalize to cgNormalize to reflect new name. 6 Feb 2013. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
Pro Texture_Surface_Cleanup, tlb

    <span class="comments">; Come here when program dies. Free all created objects.</span>

Widget_Control, tlb, Get_UValue=info
IF N_Elements(info) NE 0 THEN Obj_Destroy, info.thisContainer
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface_Draw_Events, event

     <span class="comments">; Draw widget events handled here: expose events and trackball</span>
     <span class="comments">; events. The trackball uses RSI-supplied TRACKBALL oject.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

drawTypes = ['PRESS', 'RELEASE', 'MOTION', 'SCROLL', 'EXPOSE']
thisEvent = drawTypes(event.type)

CASE thisEvent OF

   'EXPOSE':  <span class="comments">; Nothing required except to draw the view.</span>
   'PRESS': Widget_Control, event.id, Draw_Motion_Events=1 <span class="comments">; Motion events ON.</span>
   'RELEASE': Widget_Control, event.id, Draw_Motion_Events=0 <span class="comments">; Motion events OFF.</span>
   'MOTION':  <span class="comments">; Just update trackball.</span>
   ELSE:

ENDCASE

   <span class="comments">; Does the trackball need updating? If so, update.</span>

needUpdate = info.thisTrackball->Update(event, Transform=thisTransform)
IF needUpdate THEN BEGIN
   info.thisModel->GetProperty, Transform=modelTransform
   info.thisModel->SetProperty, Transform=modelTransform # thisTransform
ENDIF

    <span class="comments">; Draw the view.</span>

info.thisWindow->Draw, info.thisView

    <span class="comments">;Put the info structure back.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface_Style, event

     <span class="comments">; Event handler to select surface style.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

    <span class="comments">; What style is wanted?</span>

Widget_Control, event.id, Get_UValue=newStyle
CASE newStyle OF

   'DOTS': info.thisSurface->SetProperty, Style=0
   'MESH': info.thisSurface->SetProperty, Style=1
   'SOLID': info.thisSurface->SetProperty, Style=2, Shading=1
   'XPARALLEL': info.thisSurface->SetProperty, Style=3
   'YPARALLEL': info.thisSurface->SetProperty, Style=4
   'HIDDEN': BEGIN
       Widget_Control, event.id, Get_Value=buttonValue
       IF buttonValue EQ 'Hidden Lines OFF' THEN BEGIN
          setting = 0
          hlvalue = 'Hidden Lines ON'
       ENDIF ELSE BEGIN
          setting = 1
          hlvalue = 'Hidden Lines OFF'
       ENDELSE
       Widget_Control, event.id, Set_Value=hlvalue
       info.thisSurface->SetProperty, Hidden_Lines=setting
       ENDCASE

ENDCASE

    <span class="comments">; Redraw the graphic.</span>

info.thisWindow->Draw, info.thisView

    <span class="comments">;Put the info structure back.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface_Output, event

   <span class="comments">; This event handler creates GIF and JPEG files.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Get a snapshop of window contents. (TVRD equivalent.)</span>

info.thisWindow->GetProperty, Image_Data=snapshot

   <span class="comments">; What kind of file is wanted?</span>

Widget_Control, event.id, GET_UValue=whichFileType
CASE whichFileType OF

   'GIF': BEGIN

         <span class="comments">; Because we are using RGB color for this model, we have</span>
         <span class="comments">; a 3-m-n array. Use Color_Quan to create a 2D image and</span>
         <span class="comments">; appropriate color tables for the GIF file.</span>

      image2D = Color_Quan(snapshot, 1, r, g, b)
      filename = Dialog_Pickfile(/Write, File='texture_surface.gif')
      IF filename NE '' THEN Write_GIF, filename, image2d, r, g, b
      END

   'JPEG': BEGIN

      filename = Dialog_Pickfile(/Write, File='texture_surface.jpg')
      IF filename NE '' THEN Write_JPEG, filename, snapshot, True=1
      END


   'TIFF': BEGIN

      filename = Dialog_Pickfile(/Write, File='texture_surface.tif')
      IF filename NE '' THEN BEGIN

         <span class="comments">; TIFF files should have their Y direction reversed for</span>
         <span class="comments">; compatibility with most other software.</span>

         Write_TIFF, filename, Reverse(snapshot,3)
      ENDIF
      END

ENDCASE

    <span class="comments">;Put the info structure back.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>


PRO Texture_Surface_Exit, event

   <span class="comments">; Exit the program. This will cause the CLEANUP</span>
   <span class="comments">; routine to be called automatically.</span>

Widget_Control, event.top, /Destroy
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface_Printing, event

   <span class="comments">; PostScript printing and printer setup handled here.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

   <span class="comments">; Configure printer and print if user OKs.</span>

result = Dialog_PrinterSetup(info.thisPrinter)
IF result EQ 1 THEN BEGIN

      <span class="comments">; Background colors can use a lot of toner. Change background</span>
      <span class="comments">; color to white and axes to black before printing.</span>

   info.xaxis->GetProperty, Color=axisColor
   info.thisView->GetProperty, Color=backgroundColor
   info.thisSurface->GetProperty, Color=surfaceColor

   info.xaxis->SetProperty, Color=[0,0,0]
   info.yaxis->SetProperty, Color=[0,0,0]
   info.zaxis->SetProperty, Color=[0,0,0]
   info.thisView->SetProperty, Color=[255, 255, 255]
   info.thisSurface->SetProperty, Color=[70,70,70]

   <span class="comments">; I want the output on the page to have the same aspect ratio</span>
   <span class="comments">; (ratio of height to width) as I see in the display window.</span>
   <span class="comments">; I use the Aspect function to calculate the correct viewport</span>
   <span class="comments">; position in normalized coordinates. The return value of</span>
   <span class="comments">; Aspect is the position of the viewport on the output page.</span>

info.thisWindow->GetProperty, Dimensions=wdims
info.thisPrinter->GetProperty, Dimensions=pdims
plotAspect = Float(wdims[1]) / wdims[0]
printerAspect = Float(pdims[1]) / pdims[0]
position = Aspect(plotAspect, WindowAspect=printerAspect, Margin=0)

   <span class="comments">; Change the dimensions and postion of the viewport on the output page.</span>
   <span class="comments">; Be sure to use normalized coordinates (units=3).</span>

info.thisView->SetProperty, Dimensions=[position[2]-position[0], position[3]-position[1]], $
   Location=[position[0], position[1]], Units=3

      <span class="comments">; Print the document.</span>

   Widget_Control, Hourglass=1
   info.thisPrinter->Draw, info.thisView, Vector=info.vector
   info.thisPrinter->NewDocument
    Widget_Control, Hourglass=0

      <span class="comments">; Set colors and the view back to original values.</span>

   info.xaxis->SetProperty, Color=axisColor
   info.yaxis->SetProperty, Color=axisColor
   info.zaxis->SetProperty, Color=axisColor
   info.thisView->SetProperty, Color=backgroundColor, Location=[0,0], Dimensions=[0,0]
   info.thisSurface->SetProperty, Color=surfaceColor

ENDIF

   <span class="comments">; Put the info structure back.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface_Resize, event

     <span class="comments">; The only events generated by this simple program are resize</span>
     <span class="comments">; events, which are handled here.</span>

     <span class="comments">; Get the info structure.</span>

Widget_Control, event.top, Get_UValue=info, /No_Copy

    <span class="comments">; Resize the draw widget. This is the proper way to do this</span>
    <span class="comments">; in object graphics, but it does not always work in UNIX</span>
    <span class="comments">; versions of IDL. If it doesn't work for you, comment the</span>
    <span class="comments">; first line out and try the second. The second line is more</span>
    <span class="comments">; portable, but not exactly the proper "object" way. :-(</span>

info.thisWindow->SetProperty, Dimension=[event.x, event.y]
<span class="comments">;Widget_Control, info.drawID, Draw_XSize=event.x, Draw_YSize=event.y</span>


    <span class="comments">; Redisplay the graphic.</span>

info.thisWindow->Draw, info.thisView

    <span class="comments">; Update the trackball objects location in the center of the</span>
    <span class="comments">; window.</span>

info.thisTrackball->Reset, [event.x/2, event.y/2], $
    (event.y/2) &lt<span class="comments">; (event.x/2)</span>

    <span class="comments">;Put the info structure back.</span>

Widget_Control, event.top, Set_UValue=info, /No_Copy
END
<span class="comments">;-------------------------------------------------------------------</span>



PRO Texture_Surface, surfaceData, x, y, _Extra=extra, XTitle=xtitle, $
   YTitle=ytitle, ZTitle=ztitle, Group_Leader=groupLeader, $
   Hidden_Lines=hidden_lines, Vector=vector, Exact=exact, $
   Landscape=landscape, Image=image, Colortable=colortable, $
   Position=position, BorderColor=borderColor, ZScale=zscale

On_Error, 2

    <span class="comments">; Check for keywords.</span>

IF N_Elements(xtitle) EQ 0 THEN xtitle='X Axis'
IF N_Elements(ytitle) EQ 0 THEN ytitle='Y Axis'
IF N_Elements(ztitle) EQ 0 THEN ztitle='Z Axis'
IF N_Elements(zscale) EQ 0 THEN zscale = 1.0 ELSE zscale = (0.001 > zscale &lt<span class="comments">; 1.0)</span>
hidden_lines = Keyword_Set(hidden_lines)
landscape = Keyword_Set(landscape)
vector = Keyword_Set(vector)

   <span class="comments">; Need fake data?</span>

IF N_Elements(surfaceData) EQ 0 THEN BEGIN
   a = Shift(-Dist(41, 41), 25, 15)
   FOR j=0,4 DO a = Smooth(a, 5)
   surfaceData = a - Min(a)
ENDIF

   <span class="comments">; Need an image for the texture map?</span>

IF N_Elements(image) EQ 0 THEN BEGIN
   filename = Filepath(SubDir=['examples','data'], 'rose.jpg')
   Read_JPEG, filename, image
ENDIF

   <span class="comments">; Check image size.</span>

CASE size(image, /N_Dimensions) OF
   2: IF N_Elements(colortable) EQ 0 THEN colortable = 0
   3:
   ELSE: Message, 'Image data must be either 8-bit or 24-bit.'
ENDCASE

   <span class="comments">; Add a border around the image when positioning image on surface.</span>
   <span class="comments">; This is necessary to be able to specify the color of the rest</span>
   <span class="comments">; of the surface. Note that this will displace the original image</span>
   <span class="comments">; slightly. This could potentially be a problem in some applications.</span>

IF N_Elements(position) NE 0 THEN BEGIN
    imageDims = Image_Dimensions(image, XSize=xsize, YSize=ysize, TrueIndex=trueindex)
    xsize = xsize + 1
    ysize = ysize + 1
    IF trueindex GE 0 THEN BEGIN
      imageBorder = BytArr(imageDims[trueindex], xsize, ysize)
      IF N_Elements(borderColor) NE 0 THEN BEGIN
         imageBorder[0,*,*] = Replicate(borderColor[0], xsize, ysize)
         imageBorder[1,*,*] = Replicate(borderColor[1], xsize, ysize)
         imageBorder[2,*,*] = Replicate(borderColor[2], xsize, ysize)
      ENDIF
      imageBorder[*,1:xsize-1, 1:ysize-1] = image
    ENDIF ELSE BEGIN
      temp = BytArr(3, xsize-1, ysize-1)
      IF N_Elements(colortable) NE 0 THEN LoadCT, colortable, /Silent
      TVLCT, r, g, b, /Get
      temp[0,*,*] = r[image]
      temp[1,*,*] = g[image]
      temp[2,*,*] = b[image]
      imageBorder = BytArr(3, xsize, ysize)
      IF N_Elements(borderColor) NE 0 THEN BEGIN
         imageBorder[0,*,*] = Replicate(borderColor[0], xsize, ysize)
         imageBorder[1,*,*] = Replicate(borderColor[1], xsize, ysize)
         imageBorder[2,*,*] = Replicate(borderColor[2], xsize, ysize)
      ENDIF
      imageBorder[*,1:xsize-1, 1:ysize-1] = Temporary(temp)
   ENDELSE
   border = 1
ENDIF ELSE border = 0

   <span class="comments">; Get dimensions of the surface data.</span>

s = Size(surfaceData, /Dimensions)

   <span class="comments">; Fill out X and Y vectors if necessary.</span>

IF N_Elements(x) EQ 0 THEN x = Findgen(s[0])
IF N_Elements(y) EQ 0 THEN y = Findgen(s[1])

    <span class="comments">; Create a view. Use RGB color. Charcoal background.</span>
    <span class="comments">; The coodinate system is chosen so that (0,0,0) is in the</span>
    <span class="comments">; center of the window. This will make rotations easier.</span>

thisView = OBJ_NEW('IDLgrView', Color=[80,80,80], $
   Viewplane_Rect=[-1.2,-1.1,2.3,2.1])

   <span class="comments">; I want the surface to have the same aspect ratio as the data itself</span>
   <span class="comments">; in the X and Y directions.</span>

surfaceAspect = Float(s[1]) / s[0]
windowAspect = 1.0
pos = Aspect(surfaceAspect, WindowAspect=windowAspect, Margin=0)
pos = pos - 0.5

    <span class="comments">; Create a model for the surface and axes and add it to the view.</span>
    <span class="comments">; This model will rotate under the direction of the trackball object.</span>

thisModel = OBJ_NEW('IDLgrModel')
thisView->Add, thisModel

    <span class="comments">; Create helper objects. First, create title objects</span>
    <span class="comments">; for the axes and plot. Color them green.</span>

xTitleObj = Obj_New('IDLgrText', xtitle, Color=[0,255,0])
yTitleObj = Obj_New('IDLgrText', ytitle, Color=[0,255,0])
zTitleObj = Obj_New('IDLgrText', ztitle, Color=[0,255,0])

    <span class="comments">; Create font objects.</span>

helvetica10pt = Obj_New('IDLgrFont', 'Helvetica', Size=10)
helvetica14pt = Obj_New('IDLgrFont', 'Helvetica', Size=14)

    <span class="comments">; Create a trackball for surface rotations. Center it in</span>
    <span class="comments">; the 400-by-400 window. Give it a 200 pixel diameter.</span>

thisTrackball = OBJ_NEW('Trackball', [200, 200], 200)

   <span class="comments">; Add a palette object to the image, if the image is 2D.</span>

dim = Size(image, /N_Dimensions)
IF dim EQ 2 THEN BEGIN
   imgpal = Obj_New('IDLgrPalette')
   imgpal->LoadCT, colortable
ENDIF ELSE imgpal = Obj_New()

   <span class="comments">; Create the image object.</span>

IF border THEN $
   thisImage = Obj_New('IDLgrImage', imageBorder, Palette=imgpal) ELSE $
   thisImage = Obj_New('IDLgrImage', image, Palette=imgpal)

   <span class="comments">; Create the texture map coordinates. Use a sub-set if the POSITION keyword is used.</span>

s = Size(surfaceData, /Dimensions)
IF N_Elements(position) NE 0 THEN BEGIN

      <span class="comments">; Normal texcoords positions.</span>

   texcoords = FltArr(2, s[0], s[1])
   texcoords[0,position[0]:position[2],position[1]:position[3]] = (Findgen(position[2]-position[0]+1) # $
      Replicate(1,position[3]-position[1]+1)) / (position[2]-position[0])
   texcoords[1,position[0]:position[2],position[1]:position[3]] = (Replicate(1,position[3]-position[1]+1)) # $
      Findgen(position[2]-position[0]+1) / (position[2]-position[0])

      <span class="comments">; Extend texcoords in unused areas to prevent interpolation problems</span>
      <span class="comments">; at image boundaries.</span>

      <span class="comments">; Bottom (and Y for LL and LR corners).</span>

   texcoords[0,position[0]:position[2],0:position[1]-1] = $
      (Findgen(position[2]-position[0]+1) # $
       Replicate(1,position[1])) $
       / (position[2]-position[0])
   texcoords[1,*,0:position[1]-1] = 0.0

      <span class="comments">; Top (and Y for UL and UR corners).</span>

   texcoords[0,position[0]:position[2],position[3]+1:*] = $
      (Findgen(position[2]-position[0]+1) # $
       Replicate(1,s[1]-position[3]-1)) $
       / (position[2]-position[0])
   texcoords[1,*,position[3]+1:*] = 1.0

      <span class="comments">; Left (and X for LL and UL corners).</span>

   texcoords[0,0:position[0]-1,*] = 0.0
   texcoords[1,0:position[0]-1,position[1]:position[3]] = $
      (Findgen(position[3]-position[1]+1) # $
       Replicate(1,position[0])) $
       / (position[3]-position[1])

      <span class="comments">; Right (and X for LR and UR corners).</span>

   texcoords[0,position[2]+1:*,*] = 1.0
   texcoords[1,position[2]+1:*,position[1]:position[3]] = $
      (Findgen(position[3]-position[1]+1) # $
       Replicate(1,s[0]-position[2]-1)) $
       / (position[3]-position[1])

ENDIF ELSE BEGIN
   texcoords = FltArr(2, s[0], s[1])
   texcoords[0,*,*] = (Findgen(s[0])#Replicate(1,s[1])) / (s[0]-1)
   texcoords[1,*,*] = (Replicate(1,s[1])#Findgen(s[0])) / (s[0]-1)
ENDELSE

   <span class="comments">; Create a surface object. Add the image to it as a texture map.</span>
   <span class="comments">; The image is positioned with the Texture_Coord keyword and the</span>
   <span class="comments">; texcoords values.</span>

thisSurface = OBJ_NEW('IDLgrSurface', surfaceData, x, y, Style=2, $
   Color=[255,255,255], _Extra=extra, Hidden_Lines=hidden_lines)
 thisSurface->SetProperty, Texture_Map=thisImage, Texture_Coord=texcoords

    <span class="comments">; Get the data ranges of the surface.</span>

thisSurface->GetProperty, XRange=xrange, YRange=yrange, ZRange=zrange

    <span class="comments">; Create axes objects for the surface. Color them green.</span>
    <span class="comments">; Axes are created after the surface so the range can be</span>
    <span class="comments">; set correctly. Note how I set the font to 10 point Helvetica</span>
    <span class="comments">; by creating the axis with the title object, then getting the</span>
    <span class="comments">; actual axis text from the axis object itself, and switching it.</span>

xAxis = Obj_New("IDLgrAxis", 0, Color=[0,255,0], Ticklen=0.1, $
   Minor=4, Title=xtitleObj, Range=xrange, Exact=Keyword_Set(exact))
xAxis->GetProperty, Ticktext=xAxisText
xAxisText->SetProperty, Font=helvetica10pt

yAxis = Obj_New("IDLgrAxis", 1, Color=[0,255,0], Ticklen=0.1, $
   Minor=4, Title=ytitleObj, Range=yrange, Exact=Keyword_Set(exact))
yAxis->GetProperty, Ticktext=yAxisText
yAxisText->SetProperty, Font=helvetica10pt

zAxis = Obj_New("IDLgrAxis", 2, Color=[0,255,0], Ticklen=0.1, $
   Minor=4, Title=ztitleObj, Range=zrange, Exact=Keyword_Set(exact))
zAxis->GetProperty, Ticktext=zAxisText
zAxisText->SetProperty, Font=helvetica10pt

    <span class="comments">; The axes may not use exact axis scaling, so the ranges may</span>
    <span class="comments">; have changed from what they were originally set to. Get</span>
    <span class="comments">; and update the range variables.</span>

xAxis->GetProperty, CRange=xrange
yAxis->GetProperty, CRange=yrange
zAxis->GetProperty, CRange=zrange

    <span class="comments">; Set scaling parameters for the surface and axes so that everything</span>
    <span class="comments">; is scaled into the range -0.5 to 0.5. We do this so that when the</span>
    <span class="comments">; surface is rotated we don't have to worry about translations. In</span>
    <span class="comments">; other words, the rotations occur about the point (0,0,0).</span>

xs = cgNormalize(xrange, Position=[pos[0], pos[2]])
ys = cgNormalize(yrange, Position=[pos[1], pos[3]])
zs = cgNormalize(zrange, Position=[-0.5,0.5]*zscale)

    <span class="comments">; Scale the axes and place them in the coordinate space.</span>
    <span class="comments">; Note that not all values in the Location keyword are</span>
    <span class="comments">; used. (I've put really large values into the positions</span>
    <span class="comments">; that are not being used to demonstate this.) For</span>
    <span class="comments">; example, with the X axis only the Y and Z locations are used.</span>

xAxis->SetProperty, Location=[9999.0, pos[1], -0.5*zscale], XCoord_Conv=xs
yAxis->SetProperty, Location=[pos[0], 9999.0, -0.5*zscale], YCoord_Conv=ys
zAxis->SetProperty, Location=[pos[0],  pos[3], 9999.0], ZCoord_Conv=zs

    <span class="comments">; Scale the surface. Notice the surface is scaled *AFTER* the</span>
    <span class="comments">; actual data range is obtained from the axes (CRANGE, above).</span>
    <span class="comments">; Failure to do this can result in inaccurate results.</span>

thisSurface->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs

    <span class="comments">; Add the surface and axes objects to the model.</span>

thisModel->Add, thisSurface
thisModel->Add, xAxis
thisModel->Add, yAxis
thisModel->Add, zAxis

    <span class="comments">; Rotate the surface model to the standard surface view.</span>

thisModel->Rotate,[1,0,0], -90  <span class="comments">; To get the Z-axis vertical.</span>
thisModel->Rotate,[0,1,0],  30  <span class="comments">; Rotate it slightly to the right.</span>
thisModel->Rotate,[1,0,0],  30  <span class="comments">; Rotate it down slightly.</span>

<span class="comments">; Create some lights to view the surface. Surfaces will look</span>
<span class="comments">; best if there is some ambient lighting to illuminate them</span>
<span class="comments">; uniformly, and some positional lights to give the surface</span>
<span class="comments">; definition. We will create three positional lights: one,</span>
<span class="comments">; non-rotating light will provide overhead definition. Two</span>
<span class="comments">; rotating lights will provide specific surface definition.</span>

    <span class="comments">; First create the ambient light. Don't turn it on too much,</span>
    <span class="comments">; or the surface will appear washed out. If you have an image</span>
    <span class="comments">; as a texture map, turn it on full.</span>

ambientLight = Obj_New('IDLgrLight', Type=0, Intensity=0.2)
IF N_Elements(image) NE 0 THEN ambientLight->SetProperty, Intensity=1.0
thisModel->Add, ambientLight

    <span class="comments">; Shaded surfaces will not look shaded unless there is a</span>
    <span class="comments">; positional light source to give the surface edges definition.</span>
    <span class="comments">; This light will rotate with the surface.</span>

rotatingLight = Obj_New('IDLgrLight', Type=1, Intensity=0.60, $
    Location=[xrange[1], yrange[1], 4*zrange[1]], $
    Direction=[xrange[0], yrange[0], zrange[0]])
thisModel->Add, rotatingLight

    <span class="comments">; Create a fill light source so you can see the underside</span>
    <span class="comments">; of the surface. Otherwise, just the top surface will be visible.</span>
    <span class="comments">; This light will also rotate with the surface.</span>

fillLight = Obj_New('IDLgrLight', Type=1, Intensity=0.4, $
   Location=[(xrange[1]-xrange[0])/2.0, (yrange[1]-yrange[0])/2.0, -2*Abs(zrange[0])], $
   Direction=[(xrange[1]-xrange[0])/2.0, (yrange[1]-yrange[0])/2.0, zrange[1]])
thisModel->Add, fillLight

    <span class="comments">; Create a non-rotating overhead side light.</span>

nonrotatingLight = Obj_New('IDLgrLight', Type=1, Intensity=0.8, $
    Location=[-xrange[1], (yrange[1]-yrange[0])/2.0, 4*zrange[1]], $
    Direction=[xrange[1], (yrange[1]-yrange[0])/2.0, zrange[0]])
nonrotatingModel = Obj_New('IDLgrModel')
nonrotatingModel->Add, nonrotatingLight

   <span class="comments">; Be sure to add the non-rotating model to the view, or it won't be visualized.</span>

thisView->Add, nonrotatingModel

    <span class="comments">; Scale the light sources.</span>

rotatingLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
fillLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs
nonrotatingLight->SetProperty, XCoord_Conv=xs, YCoord_Conv=ys, ZCoord_Conv=zs

    <span class="comments">; Rotate the non-rotating model to the standard surface view.</span>

nonrotatingModel->Rotate,[1,0,0], -90  <span class="comments">; To get the Z-axis vertical.</span>
nonrotatingModel->Rotate,[0,1,0],  30  <span class="comments">; Rotate it slightly to the right.</span>
nonrotatingModel->Rotate,[1,0,0],  30  <span class="comments">; Rotate it down slightly.</span>

   <span class="comments">; Check for availability of GIF files.</span>

thisVersion = Float(!Version.Release)
IF thisVersion LT 5.4 THEN haveGif = 1 ELSE haveGIF = 0

    <span class="comments">; Create the widgets to view the surface. Set expose events</span>
    <span class="comments">; on the draw widget so that it refreshes itself whenever necessary.</span>
    <span class="comments">; Button events are on to enable trackball movement.</span>

tlb = Widget_Base(Title='Texture Surface Example', Column=1, $
   TLB_Size_Events=1, MBar=menubase)
drawID = Widget_Draw(tlb, XSize=400, YSize=400, Graphics_Level=2, Retain=0, $
   Expose_Events=1, Event_Pro='Texture_Surface_Draw_Events', Button_Events=1)

    <span class="comments">; Create FILE menu buttons for printing and exiting.</span>

fileID = Widget_Button(menubase, Value='File')

outputID = Widget_Button(fileID, Value='Save As...', /Menu)
IF havegif THEN dummy = Widget_Button(outputID, Value='GIF File', $
   UValue='GIF', Event_Pro='FSC_Surface_Output')
dummy = Widget_Button(outputID, Value='JPEG File', $
   UValue='JPEG', Event_Pro='FSC_Surface_Output')
dummy = Widget_Button(outputID, Value='TIFF File', $
   UValue='TIFF', Event_Pro='FSC_Surface_Output')

dummy = Widget_Button(fileID, Value='Print', Event_Pro='Texture_Surface_Printing')

dummy = Widget_Button(fileID, /Separator, Value='Exit', $
   Event_Pro='Texture_Surface_Exit')

   <span class="comments">; Create STYLE menu buttons for surface style.</span>

styleID = Widget_Button(menubase, Value='Style', Event_Pro='Texture_Surface_Style', /Menu)
dummy = Widget_Button(styleID, Value='Dot Surface', UValue='DOTS')
dummy = Widget_Button(styleID, Value='Wire Mesh', UValue='MESH')
dummy = Widget_Button(styleID, Value='Solid', UValue='SOLID')
dummy = Widget_Button(styleID, Value='Parallel X Lines', UValue='XPARALLEL')
dummy = Widget_Button(styleID, Value='Parallel Y Lines', UValue='YPARALLEL')
IF hidden_lines THEN hlValue = 'Hidden Lines OFF' ELSE hlValue='Hidden Lines ON'
dummy = Widget_Button(styleID, Value=hlvalue, UValue='HIDDEN')

   <span class="comments">; Realize the widgets.</span>

Widget_Control, tlb, /Realize

    <span class="comments">; Get the window destination object, which is the value of</span>
    <span class="comments">; an object draw widget. The view will be drawn in the window</span>
    <span class="comments">; when the window is exposed.</span>

Widget_Control, drawID, Get_Value=thisWindow

   <span class="comments">; Get a printer object for this graphic.</span>

thisPrinter = Obj_New('IDLgrPrinter', Print_Quality=2, Landscape=landscape)

   <span class="comments">; Create a container object to hold all the other</span>
   <span class="comments">; objects. This will make it easy to free all the</span>
   <span class="comments">; objects when we are finished with the program.</span>

thisContainer = Obj_New('IDL_Container')

   <span class="comments">; Add created objects to the container. No need to add objects</span>
   <span class="comments">; that have been added to the model, since a model object is</span>
   <span class="comments">; a subclass of a container object. But helper objects that</span>
   <span class="comments">; are NOT added to the model directly MUST be destroyed properly.</span>

thisContainer->Add, thisView
thisContainer->Add, thisPrinter
thisContainer->Add, thisTrackball
thisContainer->Add, xTitleObj
thisContainer->Add, yTitleObj
thisContainer->Add, zTitleObj
thisContainer->Add, thisModel
thisContainer->Add, helvetica10pt
thisContainer->Add, helvetica14pt
IF Obj_Valid(thisImage) THEN thisContainer->Add, thisImage
IF Obj_Valid(imgpal) THEN thisContainer->Add, imgpal

   <span class="comments">; Create an INFO structure to hold needed program information.</span>

info = { thisContainer:thisContainer, $ <span class="comments">; The object container.</span>
         thisWindow:thisWindow, $       <span class="comments">; The window object.</span>
         thisPrinter:thisPrinter, $     <span class="comments">; The printer object.</span>
         thisSurface:thisSurface, $     <span class="comments">; The surface object.</span>
         thisTrackball:thisTrackball, $ <span class="comments">; The trackball object.</span>
         thisModel:thisModel, $         <span class="comments">; The model object.</span>
         thisView:thisView, $           <span class="comments">; The view object.</span>
         xaxis:xaxis, $                 <span class="comments">; The X axis object.</span>
         yaxis:yaxis, $                 <span class="comments">; The Y axis object.</span>
         zaxis:zaxis, $                 <span class="comments">; The Z axis object.</span>
         drawID:drawID, $               <span class="comments">; The widget identifier of the draw widget.</span>
         landscape:landscape, $         <span class="comments">; A flag for landscape output.</span>
         vector:vector }                <span class="comments">; A flag for vector output.</span>

   <span class="comments">; Store the info structure in the UValue of the TLB.</span>

Widget_Control, tlb, Set_UValue=info, /No_Copy

   <span class="comments">; Call XManager. Set a cleanup routine so the objects</span>
   <span class="comments">; can be freed upon exit from this program.</span>

XManager, 'texture_surface', tlb, Cleanup='Texture_Surface_Cleanup', /No_Block, $
   Event_Handler='Texture_Surface_Resize', Group_Leader=groupLeader
END
<span class="comments">;-------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>