<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>name_selector.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="name_selector.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   NAME_SELECTOR</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   The purpose of this function is to implement a pop-up dialog widget</span>
<span class="comments">;   for the purpose of selecting "names". Names can be names of variables,</span>
<span class="comments">;   names of files, etc. Any string array can be used.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   selectedNames = Name_Selector(theNames)</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;   theNames:       A string array of potential "names" that can be selected.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ALL:            Set this keyword if you wish all the names to be selected</span>
<span class="comments">;                   initially.</span>
<span class="comments">;</span>
<span class="comments">;   CANCEL:         An output keyword set to 1 if the user cancels or quits the</span>
<span class="comments">;                   program without hitting the Accept button. Set to 0 if a proper</span>
<span class="comments">;                   selection was made and the use hits the Accept button.</span>
<span class="comments">;                    </span>
<span class="comments">;   COUNT:          An output keyword containing the number of elements in the return array.</span>
<span class="comments">;</span>
<span class="comments">;   GROUP_LEADER:   The widget identifier of a widget who will be the group leader</span>
<span class="comments">;                   for this dialog. Passing a group leader is the *only* way to</span>
<span class="comments">;                   assure the dialog will be a MODAL dialog (as opposed to a blocking</span>
<span class="comments">;                   dialog). A GROUP_LEADER is required if you will be using this</span>
<span class="comments">;                   function in an IDL Virtual Machine application.</span>
<span class="comments">;                   </span>
<span class="comments">;   LABEL:          A string that will be placed on a label above the selections.</span>
<span class="comments">;                   If not used, no label is used in the program.</span>
<span class="comments">;                   </span>
<span class="comments">;   NUMCOLS:        The number of columns to organize the string array in. The default</span>
<span class="comments">;                   is to use one column per approximately 20 strings.</span>
<span class="comments">;                   </span>
<span class="comments">;   TITLE:          A string that is used for the title of the dialog window. If</span>
<span class="comments">;                   undefined, then "Selection Widget" is used.</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;   selectedNames:  Typically, an array of selected names. If there is only one item</span>
<span class="comments">;                   in the selection, the variable will be a scalar string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   See the Name_Selector_Test procedure below. I use the program to allow the</span>
<span class="comments">;   user to select the names of scientific data sets in an HDF file for further</span>
<span class="comments">;   reading and processing.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;   Written by David W. Fanning, 21 December 2008.</span>
<span class="comments">;   Added a COUNT keyword. DWF. 6 January 2009.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008-2009, by Fanning Software Consulting, Inc.                           ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
PRO Name_Selector_Button_Events, event

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
   ENDIF
   
   Widget_Control, event.id, GET_UVALUE=buttonValue
   Widget_Control, event.top, GET_UVALUE=info
   
   CASE buttonValue OF
   
      'SELECT_ALL': BEGIN
         FOR j=0,N_Elements((*info).listbuttons)-1 DO BEGIN
            Widget_Control, (*info).listbuttons[j], SET_BUTTON=1
         ENDFOR
         END
         
      'DESELECT_ALL': BEGIN
         FOR j=0,N_Elements((*info).listbuttons)-1 DO BEGIN
            Widget_Control, (*info).listbuttons[j], SET_BUTTON=0
         ENDFOR
         END
         
      'DISMISS': BEGIN
         Widget_Control, event.top, /Destroy
         END
         
      'ACCEPT': BEGIN
         buttonsOn = IntArr(N_Elements((*info).listbuttons))
         FOR j=0,N_Elements((*info).listbuttons)-1 DO BEGIN
            buttonsOn[j] = Widget_Info((*info).listbuttons[j], /BUTTON_SET)
         ENDFOR
         index = Where(buttonsOn EQ 1, count)
         IF count GT 0 THEN BEGIN
            *(*info).selectedNamePtr = {cancel:0, theNames:((*info).theNames)[index]}
         ENDIF ELSE BEGIN
              void = Dialog_Message('No items were selected. Returning...')
              RETURN
         ENDELSE
         Widget_Control, event.top, /Destroy
         END
         
      ELSE:
         
   ENDCASE
END <span class="comments">;--------------------------------------------------------------------------------</span>


PRO Name_Selector_Null_Events, event
<span class="comments">; Events coming here do nothing whatsoever.</span>
END <span class="comments">;--------------------------------------------------------------------------------</span>



PRO Name_Selector_Size_Events, event

<span class="comments">;  This event handler handles the size events from the TLB.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
   ENDIF
   
   Widget_Control, event.top, GET_UVALUE=info

   Widget_Control, (*info).selectionBase, XSIZE=event.x > (*info).xmin, $
        YSIZE=(event.y - (*info).yoffset)
        
END <span class="comments">;--------------------------------------------------------------------------------</span>


PRO Name_Selector_Test, MORENAMES=morenames, NUMCOLS=numcols

    names = ['dog', 'cow', 'coyote', 'pig', 'elephant', 'donkey', 'aligator', 'croc', $
            'goat', 'snake', 'possum', 'bird', 'eagle', 'hamster']
     IF Keyword_Set(morenames) THEN names = [names, names, names]
     names = name_selector(names, LABEL='Select Animals for Processing', $
         CANCEL=cancelled, NUMCOLS=numcols)
     IF ~cancelled THEN Print, 'Names: ', names
END <span class="comments">;--------------------------------------------------------------------------------</span>


FUNCTION Name_Selector, theNames, $
    ALL=all, $
    CANCEL=cancel, $
    COUNT=count, $
    LABEL=label, $
    NUMCOLS=numcols, $
    TITLE=title, $
    GROUP_LEADER=group_leader

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, ""
   ENDIF  
   
   <span class="comments">; Check arguments and keywords.</span>
   IF N_Elements(theNames) EQ 0 THEN Message, 'Must pass string arguments to select.'
   numNames = N_Elements(theNames)
   all = Keyword_Set(all)
   SetDefaultValue, title, 'Selection Widget'
   
   <span class="comments">; Define TLB as a modal widget, if the group leader is present. Otherwise,</span>
   <span class="comments">; hope like hell it blocks on the XMANAGER command line! :-(</span>
   IF N_Elements(group_leader) NE 0 THEN BEGIN
      tlb = Widget_Base(Title=title, COLUMN=1, GROUP_LEADER=group_leader, MODAL=1, $
            /BASE_ALIGN_CENTER, /TLB_SIZE_EVENTS)   
   ENDIF ELSE BEGIN
      tlb = Widget_Base(Title=title, COLUMN=1, /BASE_ALIGN_CENTER, /TLB_SIZE_EVENTS)
   ENDELSE
   IF N_Elements(label) NE 0 THEN labelID = Widget_Label(tlb, Value=label)
   
   <span class="comments">; Appearance fudges for different machines.</span>
   IF !D.NAME EQ 'WIN' THEN sizeFudge = 14 ELSE sizeFudge = 18
   
   <span class="comments">; Calculate the size of the selection widget based on how many names you have.</span>
   IF numNames GT 20 THEN BEGIN
       IF N_Elements(numcols) EQ 0 THEN numcols = (numNames/20)+1
       selectionBase = Widget_Base(tlb, COLUMN=numcols, /NONEXCLUSIVE, /FRAME, $
          Y_SCROLL_SIZE=( ((numNames/numcols) + 1) * (!D.Y_CH_SIZE + sizeFudge) )&lt<span class="comments">; 600, $</span>
          X_SCROLL_SIZE=( ( (Max(StrLen(theNames))*!D.X_CH_SIZE ) + 50) * (numNames/((numNames/numcols) + 1)) ) &lt<span class="comments">; 1000, $</span>
          EVENT_PRO='Name_Selector_Null_Events')
   ENDIF ELSE BEGIN
       IF N_Elements(numcols) EQ 0 THEN numcols = 1
       selectionBase = Widget_Base(tlb, COLUMN=numcols, /NONEXCLUSIVE, /FRAME, $
          Y_SCROLL_SIZE=(((numNames/numcols) + 1) * (!D.Y_CH_SIZE + sizeFudge)) &lt<span class="comments">; 600, $</span>
          X_SCROLL_SIZE=( ( (Max(StrLen(theNames))*!D.X_CH_SIZE ) + 50) * (numNames/((numNames/numcols) + 1)) ) &lt<span class="comments">; 1000, $</span>
          EVENT_PRO='Name_Selector_Button_Events')
   ENDELSE
   listbuttons = LonArr(numNames)
   FOR j=0, numNames-1 DO BEGIN
      listbuttons[j] = Widget_Button(selectionBase, Value=theNames[j], $
         UVALUE=STRUPCASE(theNames[j]))
   ENDFOR   
   buttonBase = Widget_Base(tlb, ROW=1, XPAD=0, YPAD=0, EVENT_PRO='Name_Selector_Button_Events')
   button = Widget_Button(buttonBase, Value='Dismiss', UVALUE='DISMISS')
   button = Widget_Button(buttonBase, Value='Deselect All', UVALUE='DESELECT_ALL')
   button = Widget_Button(buttonBase, Value='Select All', UVALUE='SELECT_ALL')
   button = Widget_Button(buttonBase, Value='Accept', UVALUE='ACCEPT')
   
   <span class="comments">; Set all the buttons to selected?</span>
   IF all THEN BEGIN
      FOR j=0,numNames-1 DO Widget_Control, listbuttons[j], SET_BUTTON=1
   ENDIF
   
   <span class="comments">; Display pop-up widgets in the center of the display.</span>
   cgCenterTLB, tlb
   
   <span class="comments">; Need sizes for sizing the TLB, if required.</span>
   IF N_Elements(labelID) NE 0 THEN BEGIN
        labelGeo = Widget_Info(labelID, /GEOMETRY)
        label_y = labelGeo.scr_ysize
   ENDIF ELSE label_y = 0.0
   butGeo = Widget_Info(buttonBase, /GEOMETRY)
   yoffset = label_y + butGeo.scr_ysize
   xmin = butGeo.scr_xsize
   
   <span class="comments">; Minimum size for selection base.</span>
   sbgeo = Widget_Info(selectionBase, /GEOMETRY)
   IF sbgeo.scr_xsize LT xmin THEN BEGIN
      Widget_Control, selectionBase, SCR_XSIZE=xmin
   ENDIF
   Widget_Control, tlb, /Realize
   
   <span class="comments">; Set up pointers for passing info around the program and for storing results.</span>
   selectedNamePtr = Ptr_New({cancel:1})
   info = Ptr_New({listbuttons:listbuttons, selectedNamePtr:selectedNamePtr, $
        theNames:theNames, yoffset:yoffset, xmin:xmin, selectionBase:selectionBase}, /NO_COPY)
   Widget_Control, tlb, SET_UVALUE=info
   
   <span class="comments">; This *should* block the IDL command line, but if you called this from</span>
   <span class="comments">; a blocking widget program, you could run though this block with disasterous</span>
   <span class="comments">; results. This is a *common* problem with Virtual Machine applications, which</span>
   <span class="comments">; by definition block the IDL command line. Maybe you should have used a GROUP_LEADER.</span>
   XManager, 'name_selector', tlb, EVENT_HANDLER='Name_Selector_Size_Events'
   
   <span class="comments">; Return here after block is released. Set the CANCEL flag, get the names, free the pointers.</span>
   cancel = (*selectedNamePtr).cancel
   IF cancel EQ 0 THEN selectedNames = (*selectedNamePtr).theNames ELSE selectedNames = ""
   Ptr_Free, selectedNamePtr, info
   
   <span class="comments">; Count them.</span>
   count = N_Elements(selectedNames)
   
   <span class="comments">; Return the selected names.</span>
   IF N_Elements(selectedNames) EQ 1 THEN RETURN, selectedNames[0] ELSE RETURN, selectedNames

END <span class="comments">; ----------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>