<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:10 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cghistogram.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cghistogram.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgHistogram</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This program is used as a wrapper to the Histogram command in IDL. It removes the </span>
<span class="comments">;   very real possibility that the Histogram command will return incorrect values silently.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2013, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This program is used as a wrapper to the Histogram command in IDL. It works around a bug</span>
<span class="comments">; in the Histogram command when byte data is binned in versions prior to IDL 8.2, and it takes</span>
<span class="comments">; care to match the data type of the `BinSize` keyword to the data type of the data being binned.</span>
<span class="comments">; If this matching is not done, Histogram silently returns incorrect results. I have added the ability to</span>
<span class="comments">; smooth the data (with the `Smooth` keyword) and to return the relative frequency of the histogram,</span>
<span class="comments">; rather than the histogram counts (with the `Frequency` keyword). The relative frequency is a </span>
<span class="comments">; number between 0 and 1. I have also added the ability to specify "missing" data that should not be</span>
<span class="comments">; binned.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    General</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, </span>
<span class="comments">;       The data from which the histogram is created.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    binsize: in, optional</span>
<span class="comments">;       The binsize of the histogram. By default, Scott's Choice of bin size for histograms is used::</span>
<span class="comments">;                         </span>
<span class="comments">;           binsize = (3.5 * StdDev(data)) / N_Elements(data)^(0.3333)</span>
<span class="comments">;                            </span>
<span class="comments">;       If BINSIZE in not defined, and NBINS is defined, the BINSIZE is calcuated as::</span>
<span class="comments">;                         </span>
<span class="comments">;            binsize = (Max(dataToHistogram) - Min(dataToHistogram)) / (NBINS -1)</span>
<span class="comments">;                             </span>
<span class="comments">;       While it is pointed out in the HISTOGRAM documentation, it is extremely</span>
<span class="comments">;       important that the BINSIZE be of the same data type as the data you are going to</span>
<span class="comments">;       calculate the histogram of. If it is not, VERY strange things can happen, but the</span>
<span class="comments">;       worst is that HISTOGRAM silently returns incorrect results. I try hard to avoid this</span>
<span class="comments">;       result in this program.</span>
<span class="comments">;    frequency: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, the relative frequency is returned, rather than the </span>
<span class="comments">;       histogram counts. Relative frequency is a number between 0 and 1. The total of</span>
<span class="comments">;       all the relative frequencies should equal 1.0.</span>
<span class="comments">;    input: in, optional</span>
<span class="comments">;       Set this keyword to a named variable that contains an array to be added to the </span>
<span class="comments">;       output of cgHistogram. The density function of `data` is added to the existing </span>
<span class="comments">;       contents of `Input` and returned as the result. The array is converted to </span>
<span class="comments">;       longword type if necessary and must have at least as many elements as are </span>
<span class="comments">;       required to form the histogram. Multiple histograms can be efficiently </span>
<span class="comments">;       accumulated by specifying partial sums via this keyword.</span>
<span class="comments">;    l64: in, optional, type=boolean, default=0                       </span>
<span class="comments">;       If set, the return value of HISTOGRAM are 64-bit integers, rather than</span>
<span class="comments">;       the default 32-bit integers. Set by default if 64-bit integers are passed in.</span>
<span class="comments">;    locations: out, optional</span>
<span class="comments">;       Starting locations of each bin. `Locations` has the same number of elements as the result, </span>
<span class="comments">;       and has the same data type as the input data array.</span>
<span class="comments">;    max: in, optional</span>
<span class="comments">;       The maximum value to use in calculating input histogram. </span>
<span class="comments">;    min: in, optional</span>
<span class="comments">;       The minimum value to use in calculating input histogram. </span>
<span class="comments">;    missing: in, optional</span>
<span class="comments">;       The value that should be represented as "missing" and not used in the histogram.</span>
<span class="comments">;       Be aware that if the input data is not of type "float" or "double" that the input</span>
<span class="comments">;       data will be converted to floating point prior to calculating the histogram.</span>
<span class="comments">;    nan: in, optional, type=boolean, default=0   </span>
<span class="comments">;       If set, ignore NAN values in calculating and plotting histogram. Set by default if the</span>
<span class="comments">;       `Missing` keyword is used.</span>
<span class="comments">;    nbins: in, optional, type=integer</span>
<span class="comments">;       The number of output bins in the histogram. The meaning is slightly different from</span>
<span class="comments">;       the meaning in the HISTOGRAM command. Used only to calculate BINSIZE when BINSIZE is</span>
<span class="comments">;       not specified. In this case, binsize = rangeofData/(nbins-1). When the number of bins</span>
<span class="comments">;       is low, the results can be non-intuitive. For this reason, I would discourage the use</span>
<span class="comments">;       of `NBins` in favor of the `BinSize` keyword.</span>
<span class="comments">;    omax: out, optional</span>
<span class="comments">;       The maximum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    omin: out, optional</span>
<span class="comments">;       The minimum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    reverse_indices: out, optional</span>
<span class="comments">;       The list of reverse indices returned from the HISTOGRAM command. (See HISTOGRAM documentation.)</span>
<span class="comments">;    smooth: in, optional, type=integer, default=0</span>
<span class="comments">;       Set this keyword to an odd positive integer to smooth the histogram output before plotting.</span>
<span class="comments">;       The integer will set the width of a smoothing box to be applied to the histogram data with</span>
<span class="comments">;       the Smooth function. This keyword is ignored if the `Frequency` keyword is set.</span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Create a normal distribution of random numbers and take the histogram::</span>
<span class="comments">;    </span>
<span class="comments">;       numbers = RandomU(-3L, 1000, /Normal)</span>
<span class="comments">;       histResults = cgHistogram(numbers, Binsize=0.25)</span>
<span class="comments">;       cgPlot, histResults</span>
<span class="comments">;       </span>
<span class="comments">;    Additional examples of histogram plots can be found here::</span>
<span class="comments">;    </span>
<span class="comments">;        http://www.idlcoyote.com/gallery/index.html</span>
<span class="comments">;        </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Change History::</span>
<span class="comments">;       Written by:  David W. Fanning, 7 March 2013.</span>
<span class="comments">;        </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
FUNCTION cgHistogram, $       <span class="comments">; The program name.</span>
   data, $                    <span class="comments">; The data to draw a histogram of.</span>
   BINSIZE=binsize, $         <span class="comments">; The histogram bin size.</span>
   FREQUENCY=frequency, $     <span class="comments">; Plot relative frequency, rather than density.</span>
   INPUT=input, $             <span class="comments">; Add this array to output of cgHistogram.</span>
   L64=l64, $                 <span class="comments">; Input for HISTOGRAM.</span>
   LOCATIONS=locations, $     <span class="comments">; The starting locations of each bin.</span>
   MAX=max, $                 <span class="comments">; The maximum value to HISTOGRAM.</span>
   MIN=min, $                 <span class="comments">; The minimum value to HISTOGRAM.</span>
   MISSING=missing, $         <span class="comments">; The value that indicates "missing" data to be excluded from the histgram.</span>
   NAN=nan, $                 <span class="comments">; Check for NAN.</span>
   NBINS=nbins, $             <span class="comments">; The number of bins to display.</span>
   OMAX=omax, $               <span class="comments">; The maximum value used to construct the histogram.</span>
   OMIN=omin, $               <span class="comments">; The minimum value used to construct the histogram.</span>
   REVERSE_INDICES=ri, $      <span class="comments">; The vector that identifies indices in each bin.</span>
   SMOOTH=smooth              <span class="comments">; Run a smoothing filter of this width over the histogram data before returning.</span>
    
   Compile_Opt idl2

   <span class="comments">; Catch any error in the cgHistogram program.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(nancount) EQ 0 THEN BEGIN
         IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
      ENDIF ELSE BEGIN
         IF nancount EQ 0 THEN BEGIN
             IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
         ENDIF
      ENDELSE
      RETURN, data
   ENDIF

   <span class="comments">; Check for parameters.</span>
   IF N_Elements(data) EQ 0 THEN Message, 'Must pass data to cgHistogram.'
   frequency = Keyword_Set(frequency)
   l64 = Keyword_Set(l64)
   IF N_Elements(smooth) NE 0 THEN BEGIN
     IF (smooth MOD 2) NE 0 THEN smooth = smooth + 1
   ENDIF
   
   <span class="comments">; What kind of data are we doing a HISTOGRAM on?</span>
   dataType = Size(data, /TYPE)
   
   <span class="comments">; If this is 64-bit integers, set the L64 flag.</span>
   IF dataType GE 14 THEN L64 =1 
      
   <span class="comments">; Check the data for NANs and alert the user if the NAN keyword is not set.</span>
   IF dataType EQ 4 OR datatype EQ 5 THEN BEGIN
        goodIndices = Where(Finite(data), count, NCOMPLEMENT=nancount, COMPLEMENT=nanIndices)
        IF nancount GT 0 THEN BEGIN
           IF ~Keyword_Set(nan) THEN BEGIN
               Message, 'NANs found in the data. NAN keyword is set to 1.', /INFORMATIONAL
               nan = 1
           ENDIF
        ENDIF 
   ENDIF 
   
   <span class="comments">; The only sensible way to proceed is to make a copy of the data. Otherwise, I'll have</span>
   <span class="comments">; a devil of a time putting it back together again at the end. There is a bug in</span>
   <span class="comments">; HISTOGRAM when using BYTE data, so convert that here</span>
   IF N_Elements(_data) EQ 0 THEN BEGIN
      IF Size(data, /TNAME) EQ 'BYTE' THEN BEGIN
          _data = Fix(data) 
       ENDIF ELSE BEGIN
          _data = data
       ENDELSE
   ENDIF
   
   <span class="comments">; If you have any "missing" data, then the data needs to be converted to float</span>
   <span class="comments">; and the missing data set to F_NAN.</span>
   IF N_Elements(missing) NE 0 THEN BEGIN
      missingIndices = Where(_data EQ missing, missingCount)
      IF missingCount GT 0 THEN BEGIN
         CASE datatype OF
            4: _data[missingIndices] = !Values.F_NAN
            5: _data[missingIndices] = !Values.D_NAN
            ELSE: BEGIN
                _data = Float(_data)
                dataType = 4
                _data[missingIndices] = !Values.F_NAN
                END
         ENDCASE
         nan = 1
      ENDIF ELSE BEGIN
        IF missingCount EQ N_Elements(_data) THEN $
            Message, 'All values are "missing"!'
      ENDELSE
   ENDIF
   
   <span class="comments">; Define minimum and maximum input values, if not defined otherwise.</span>
   IF N_Elements(min) EQ 0 THEN min = Min(_data, NAN=nan)
   IF N_Elements(max) EQ 0 THEN max = Max(_data, NAN=nan)

   <span class="comments">; Check for histogram keywords.</span>
   IF N_Elements(binsize) EQ 0 THEN BEGIN
      range = Max(_data &lt<span class="comments">; max, /NAN) - Min(_data > min, /NAN)</span>
      IF N_Elements(nbins) EQ 0 THEN BEGIN  <span class="comments">; Scott's Choice</span>
         binsize = (3.5D * StdDev(min > _data &lt<span class="comments">; max, /NAN))/N_Elements(_data)^(1./3.0D) </span>
         IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDIF ELSE BEGIN
         binsize = range / (nbins -1)
         IF dataType LE 3 THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDELSE
   ENDIF ELSE BEGIN
       IF Size(binsize, /TYPE) NE dataType THEN BEGIN
          IF dataType LE 3 THEN binsize = Round(binsize) > 1
          binsize = Convert_To_Type(binsize, dataType)
       ENDIF
   ENDELSE

   <span class="comments">; Calculate the histogram. Can't use the INPUT keyword unless you actuall</span>
   <span class="comments">; have something in it.</span>
   IF N_Elements(input) EQ 0 THEN BEGIN
        histdata = Histogram(_data, $
          BINSIZE=binsize, $
          L64=l64, $
          MAX=max, $
          MIN=min, $
          NAN=nan, $
          LOCATIONS=locations, $
          OMAX=omax, $
          OMIN=omin, $
          REVERSE_INDICES=ri)
   ENDIF ELSE BEGIN
        histdata = Histogram(_data, $
          BINSIZE=binsize, $
          INPUT=input, $
          L64=l64, $
          MAX=max, $
          MIN=min, $
          NAN=nan, $
          LOCATIONS=locations, $
          OMAX=omax, $
          OMIN=omin, $
          REVERSE_INDICES=ri)
   ENDELSE
   <span class="comments">; Are you returning the frequency rather than the count? You can't smooth the frequency data.</span>
   IF frequency THEN BEGIN
    
       histdata = Float(histdata)/N_Elements(_data)
       
   ENDIF ELSE BEGIN
   
      <span class="comments">; Do you need to smooth the data?</span>
       IF N_Elements(smooth) NE 0 THEN histdata = Smooth(histdata, smooth)
       
   ENDELSE
   
   <span class="comments">; Return the data.</span>
   RETURN, histdata
   
END
</code>
    </div>
  </body>
</html>