<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>list_selector.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="list_selector.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   LIST_SELECTOR</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   The purpose of this function is to implement a pop-up dialog widget</span>
<span class="comments">;   for the purpose of selecting "names". Names can be names of variables,</span>
<span class="comments">;   names of files, etc. Any string array can be used.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   selectedNames = List_Selector(theNames)</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;   theNames:       A string array of potential "names" that can be selected.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ALL:            Set this keyword if you wish all the names to be selected</span>
<span class="comments">;                   initially.</span>
<span class="comments">;</span>
<span class="comments">;   CANCEL:         An output keyword set to 1 if the user cancels or quits the</span>
<span class="comments">;                   program without hitting the Accept button. Set to 0 if a proper</span>
<span class="comments">;                   selection was made and the use hits the Accept button.</span>
<span class="comments">;                    </span>
<span class="comments">;   COUNT:          An output keyword containing the number of elements in the return array.</span>
<span class="comments">;</span>
<span class="comments">;   GROUP_LEADER:   The widget identifier of a widget who will be the group leader</span>
<span class="comments">;                   for this dialog. Passing a group leader is the *only* way to</span>
<span class="comments">;                   assure the dialog will be a MODAL dialog (as opposed to a blocking</span>
<span class="comments">;                   dialog). A GROUP_LEADER is required if you will be using this</span>
<span class="comments">;                   function in an IDL Virtual Machine application.</span>
<span class="comments">;                   </span>
<span class="comments">;   LABEL:          A string that will be placed on a label above the selections.</span>
<span class="comments">;                   If not used, no label is used in the program.</span>
<span class="comments">;                   </span>
<span class="comments">;   LIST_COUNTER:   If this keyword is set, a number is associated and displayed with </span>
<span class="comments">;                   each list item, starting with the number 1.</span>
<span class="comments">;                   </span>
<span class="comments">;   TITLE:          A string that is used for the title of the dialog window. If</span>
<span class="comments">;                   undefined, then "Selection Widget" is used.</span>
<span class="comments">;                   </span>
<span class="comments">;   SELECTED_INDICES: An output vector of the selected indices from theNames array.</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;   selectedNames:  Typically, an array of selected names. If there is only one item</span>
<span class="comments">;                   in the selection, the variable will be a scalar string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   See the List_Selector_Test procedure below. I use the program to allow the</span>
<span class="comments">;   user to select the names of scientific data sets in an HDF file for further</span>
<span class="comments">;   reading and processing.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;   Written by David W. Fanning, 11 January 2009, based on Name_Selector program.</span>
<span class="comments">;   Added "Accept on Double-Click" functionality. 14 January 2009. DWF.</span>
<span class="comments">;   Added LIST_COUNTER keyword. 25 May 2009. DWF.</span>
<span class="comments">;   Well, basically a RE-DO of yesterday's work, although done correctly today. 26 May 2009. DWF.</span>
<span class="comments">;   Fixed a problem when the user double-clicks an item in the list. 8 August 2009. DWF.</span>
<span class="comments">;   Double clicks are a problem with UNIX machines because &lt;CR> sets event.clicks = 2</span>
<span class="comments">;      prematurely. Removed double-click functionality from all but Windows machines. 9 Feb 2012. DWF.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2009-2012, by Fanning Software Consulting, Inc.                           ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
PRO List_Selector_Button_Events, event

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
   ENDIF
   
   Widget_Control, event.id, GET_UVALUE=buttonValue
   Widget_Control, event.top, GET_UVALUE=info
   
   CASE buttonValue OF
   
      'SELECT_ALL': Widget_Control, (*info).listID, SET_LIST_SELECT=Indgen(N_Elements((*info).theNames))
      
      'DESELECT_ALL': Widget_Control, (*info).listID, SET_LIST_SELECT=N_Elements((*info).theNames)
               
      'DISMISS': Widget_Control, event.top, /Destroy
         
      'ACCEPT': BEGIN
         indices = Widget_Info((*info).listID, LIST_SELECT=1)
         IF indices[0] EQ -1 THEN count = 0 ELSE count = N_Elements(indices)
         IF count GT 0 THEN BEGIN
            *(*info).selectedNamePtr = {cancel:0, theNames:((*info).theNames)[indices], $
                           selectedIndices:indices}
         ENDIF ELSE BEGIN
              void = Dialog_Message('No items were selected. Returning...')
              RETURN
         ENDELSE
         Widget_Control, event.top, /Destroy
         END
         
      ELSE:
         
   ENDCASE
END <span class="comments">;--------------------------------------------------------------------------------</span>


PRO List_Selector_Click_Events, event

    <span class="comments">; Events coming here do nothing whatsoever unless event.clicks EQ 2.</span>
    <span class="comments">; UNIX machines set event.clicks = 2 whenever the Carriage Return is selected,</span>
    <span class="comments">; which precludes me from using this functionality in anything other than </span>
    <span class="comments">; Windows machines.</span>
    IF (event.clicks NE 2) || (StrUpCase(!Version.OS_Family) NE 'WINDOWS') THEN RETURN

    <span class="comments">; Act as if you had selected this item.</span>
    Widget_Control, event.top, GET_UVALUE=info
    indices = event.index
    IF indices[0] EQ -1 THEN count = 0 ELSE count = N_Elements(indices)
    IF count GT 0 THEN BEGIN
        *(*info).selectedNamePtr = {cancel:0, theNames:((*info).theNames)[indices], $
                           selectedIndices:indices}
    ENDIF 
    Widget_Control, event.top, /Destroy
    
END <span class="comments">;--------------------------------------------------------------------------------</span>



PRO List_Selector_Size_Events, event

<span class="comments">;  This event handler handles the size events from the TLB.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN
   ENDIF
   
   Widget_Control, event.top, GET_UVALUE=info
   Widget_Control, (*info).listID, SCR_XSIZE=event.x > (*info).xmin, $
        SCR_YSIZE=(event.y - (*info).yoffset)
        
END <span class="comments">;--------------------------------------------------------------------------------</span>


PRO List_Selector_Test, MORENAMES=morenames, LIST_COUNTER=list_counter, SELECTED_INDICES=selected_indices


     names = ['dog', 'cow', 'coyote', 'pig', 'elephant', 'donkey', 'aligator', 'croc', $
            'goat', 'snake', 'possum', 'bird', 'eagle', 'hamster']
     IF Keyword_Set(morenames) THEN names = [names, names, names]
     names = List_Selector(names, LABEL='Select Animals for Processing', CANCEL=cancelled, $
          LIST_COUNTER=Keyword_Set(list_counter), SELECTED_INDICES=selected_indices)
     IF ~cancelled THEN BEGIN
         Print, 'Names: ', names
         Print, 'Selected Indices: ', selected_indices
     ENDIF
END <span class="comments">;--------------------------------------------------------------------------------</span>


FUNCTION List_Selector, theNames, $
    ALL=all, $
    CANCEL=cancel, $
    COUNT=count, $
    LABEL=label, $
    LIST_COUNTER=list_counter, $
    NUMCOLS=numcols, $
    SELECTED_INDICES=selected_indices, $
    TITLE=title, $
    GROUP_LEADER=group_leader

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      RETURN, ""
   ENDIF  
   
   <span class="comments">; Check arguments and keywords.</span>
   IF N_Elements(theNames) EQ 0 THEN Message, 'Must pass string arguments to select.'
   numNames = N_Elements(theNames)
   IF Keyword_Set(list_counter) THEN BEGIN
        CASE 1 OF
            numNames LT 10: numbers = String(IndGen(numNames)+1, Format='(I1)')
            numNames LT 100: numbers = String(IndGen(numNames)+1, Format='(I2.2)')
            numNames LT 1000: numbers = String(IndGen(numNames)+1, Format='(I3.3)')
            ELSE: numbers = String(IndGen(numNames)+1, Format='(I4.4)')
        ENDCASE
        _theNames = numbers + ' ' + theNames
   ENDIF ELSE _theNames = theNames
   
   all = Keyword_Set(all)
   SetDefaultValue, title, 'Selection Widget'
   
   <span class="comments">; Define TLB as a modal widget, if the group leader is present. Otherwise,</span>
   <span class="comments">; hope like hell it blocks on the XMANAGER command line! :-(</span>
   IF N_Elements(group_leader) NE 0 THEN BEGIN
      tlb = Widget_Base(Title=title, COLUMN=1, GROUP_LEADER=group_leader, MODAL=1, $
            /BASE_ALIGN_CENTER, /TLB_SIZE_EVENTS)   
   ENDIF ELSE BEGIN
      tlb = Widget_Base(Title=title, COLUMN=1, /BASE_ALIGN_CENTER, /TLB_SIZE_EVENTS)
   ENDELSE
   IF N_Elements(label) NE 0 THEN labelID = Widget_Label(tlb, Value=label)
   
   <span class="comments">; Appearance fudges for different machines.</span>
   IF !D.NAME EQ 'WIN' THEN sizeFudge = 14 ELSE sizeFudge = 18
   
   <span class="comments">; Calculate the size of the selection widget based on how many names you have.</span>
   ysize = 30 &lt<span class="comments">; N_Elements(theNames)</span>
   listID = Widget_List(tlb, VALUE=_theNames, YSIZE=ysize, /MULTIPLE, EVENT_PRO='List_Selector_Click_Events')
   buttonBase = Widget_Base(tlb, ROW=1, XPAD=0, YPAD=0, EVENT_PRO='List_Selector_Button_Events')
   button = Widget_Button(buttonBase, Value='Dismiss', UVALUE='DISMISS')
   button = Widget_Button(buttonBase, Value='Deselect All', UVALUE='DESELECT_ALL')
   button = Widget_Button(buttonBase, Value='Select All', UVALUE='SELECT_ALL')
   button = Widget_Button(buttonBase, Value='Accept', UVALUE='ACCEPT')
   bgeo = Widget_Info(buttonBase, /GEOMETRY)
   
   <span class="comments">; Set all the buttons to selected?</span>
   IF all THEN BEGIN
      FOR j=0,numNames-1 DO Widget_Control, listID, SET_LIST_SELECT=Indgen(N_Elements(theStrings))
   ENDIF
   
   <span class="comments">; Display pop-up widgets in the center of the display.</span>
   cgCenterTLB, tlb
   
   <span class="comments">; Need sizes for sizing the TLB, if required.</span>
   IF N_Elements(labelID) NE 0 THEN BEGIN
        labelGeo = Widget_Info(labelID, /GEOMETRY)
        label_y = labelGeo.scr_ysize
   ENDIF ELSE label_y = 0.0
   butGeo = Widget_Info(buttonBase, /GEOMETRY)
   yoffset = label_y + butGeo.scr_ysize
   xmin = butGeo.scr_xsize
   
   <span class="comments">; Minimum size for selection base.</span>
   sbgeo = Widget_Info(listID, /GEOMETRY)
   IF sbgeo.scr_xsize LT xmin THEN BEGIN
      Widget_Control, listID, SCR_XSIZE=xmin
   ENDIF
   Widget_Control, tlb, /Realize
   
   <span class="comments">; Set up pointers for passing info around the program and for storing results.</span>
   selectedNamePtr = Ptr_New({cancel:1})
   info = Ptr_New({listID:listID, selectedNamePtr:selectedNamePtr, $
        theNames:theNames, yoffset:yoffset, xmin:xmin}, /NO_COPY)
   Widget_Control, tlb, SET_UVALUE=info
   
   <span class="comments">; This *should* block the IDL command line, but if you called this from</span>
   <span class="comments">; a blocking widget program, you could run though this block with disasterous</span>
   <span class="comments">; results. This is a *common* problem with Virtual Machine applications, which</span>
   <span class="comments">; by definition block the IDL command line. Maybe you should have used a GROUP_LEADER.</span>
   XManager, 'name_selector', tlb, EVENT_HANDLER='List_Selector_Size_Events'
   
   <span class="comments">; Return here after block is released. Set the CANCEL flag, get the names, free the pointers.</span>
   cancel = (*selectedNamePtr).cancel
   IF cancel EQ 0 THEN BEGIN
      selectedNames    = (*selectedNamePtr).theNames 
      selected_indices = (*selectedNamePtr).selectedIndices
   ENDIF ELSE selectedNames = ""
   IF N_Elements(selected_indices) EQ 1 THEN selected_indices = selected_indices[0]
   Ptr_Free, selectedNamePtr, info
   
   <span class="comments">; Count them.</span>
   count = N_Elements(selectedNames)
   
   <span class="comments">; Return the selected names.</span>
   IF N_Elements(selectedNames) EQ 1 THEN RETURN, selectedNames[0] ELSE RETURN, selectedNames

END <span class="comments">; ----------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>