<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:05 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ncdf_file__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ncdf_file__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       NCDF_FILE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The pupose of this NCDF_File object is three-fold. (1) Allow the user to easily</span>
<span class="comments">;       determine what information is inside a netCDF file and allow easy access</span>
<span class="comments">;       to such information. (2) Allow the user to easily create a netCDF file from</span>
<span class="comments">;       scratch. (3) Allow the user to easily copy information from one netCDF </span>
<span class="comments">;       file to another.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       File I/O</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       IDL> nCDFObject = Obj_New('NCDF_FILE', filename)</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename:  The name of a netCDF file to read, write to, or browse.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       </span>
<span class="comments">;       ALERT:     Set this keyword if you wish to have alert from the object's error logger.</span>
<span class="comments">;                  Input. Default is 1.</span>
<span class="comments">;       </span>
<span class="comments">;       BROWSE:    If this keyword is set, the Browse Window is invoked as soon</span>
<span class="comments">;                  as the object is initiated. Input. Default is 0.</span>
<span class="comments">;</span>
<span class="comments">;       CLOBBER:   Set this keyword if you are opening a netCDF file that already exists and </span>
<span class="comments">;                  you want to overwrite the existing file. Input. Default is 0.</span>
<span class="comments">;                  </span>
<span class="comments">;       CREATE:    Set this keyword if you wish to create a new netCDF file to write</span>
<span class="comments">;                  into. Input. Default is 0, which means the file will be opened as </span>
<span class="comments">;                  "read-only".</span>
<span class="comments">;       </span>
<span class="comments">;       DELETE_ON_DESTROY:  Set this keyword if you wish to delete the error log file when</span>
<span class="comments">;                  the ErrorLogger object is destroyed. This will only happen if the ErrorLogger</span>
<span class="comments">;                  object is not in an error state. Input. Default is 1.</span>
<span class="comments">;                  </span>
<span class="comments">;       MODIFY:    Set this keyword if you wish to modify (write to) a file you are opening.</span>
<span class="comments">;                  If not set, the file will be opened as "read-only".</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; REQUIRES:</span>
<span class="comments">;</span>
<span class="comments">;     The following programs are required from the Coyote Library. And it is always a</span>
<span class="comments">;     good idea to make sure you have the latest version of the Coyote Library code,</span>
<span class="comments">;     as updates are irregular and frequent.</span>
<span class="comments">;</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_attribute__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_data__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_browser.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_castdatatype.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_container__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_dimension__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/ncdf_variable__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/errorlogger__define.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/error_message.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/cgcentertlb.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/undefine.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/textbox.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/cgrootname.pro</span>
<span class="comments">;              http://www.idlcoyote.com/programs/textlineformat.pro</span>
<span class="comments">;              </span>
<span class="comments">;     These files may be (almost certainly are!) dependent on other Coyote Library files.</span>
<span class="comments">;</span>
<span class="comments">; METHODS:</span>
<span class="comments">;</span>
<span class="comments">;     The following methods are available. Each is documented in front of the method.</span>
<span class="comments">;</span>
<span class="comments">;     ncdfObject -> Browse </span>
<span class="comments">;     ncdfObject -> CopyVarAttrTo, varName, attrName, destObj</span>
<span class="comments">;     ncdfObject -> CopyVarDataTo, varName, destObj, COUNT=count, OFFSET=offset, STRIDE=stride</span>
<span class="comments">;     ncdfObject -> CopyVarDefTo, varName, destObj</span>
<span class="comments">;     ncdfObject -> CopyGlobalAttrTo, attrName, destObj</span>
<span class="comments">;     ncdfObject -> CopyDimTo, dimName, destObj</span>
<span class="comments">;     dimNames = ncdfObject -> GetDimNames(COUNT=dimCount)</span>
<span class="comments">;     dimValue = ncdfObject -> GetDimValue(dimName)</span>
<span class="comments">;     fileID = ncdfObject -> GetFileID()</span>
<span class="comments">;     globalAttrNames = ncdfObject -> GetGlobalAttrNames(COUNT=attrCount)</span>
<span class="comments">;     attrValue = ncdfObject -> GetGlobalAttrValue(attrName, DATATYPE=datatype)</span>
<span class="comments">;     ncdfObject -> GetProperty, ....</span>
<span class="comments">;     property = ncdfObject -> GetProperty(thisProperty)</span>
<span class="comments">;     varAttrNames = ncdfObject -> GetVarAttrNames(varName, COUNT=attrCount)</span>
<span class="comments">;     varAttrValue = ncdfObject -> GetVarAttrValue(varName, varAttrName, COUNT=attrCount)</span>
<span class="comments">;     varNames = ncdfObject -> GetVarNames(COUNT=varCount)</span>
<span class="comments">;     varData = ncdfObject -> GetVarData(varName, COUNT=count, OFFSET=offset, STRIDE=stride)</span>
<span class="comments">;     answer = ncdfObject -> HasGlobalAttr(attrName, OBJECT=object)</span>
<span class="comments">;     answer = ncdfObject -> HasDim(dimName, OBJECT=object)</span>
<span class="comments">;     answer = ncdfObject -> HasVar(varName, OBJECT=object)</span>
<span class="comments">;     answer = ncdfObject -> HasVarAttr(varName, attrName, OBJECT=object)</span>
<span class="comments">;     ncdfObject -> PrintFileInfo </span>
<span class="comments">;     ncdfObject -> ParseFile</span>
<span class="comments">;     ncdfObject -> SetMode, DEFINE=define, DATA=data</span>
<span class="comments">;     ncdfObject -> WriteVarData, varName, data, COUNT=count, OFFSET=offset, STRIDE=stride</span>
<span class="comments">;     ncdfObject -> WriteVarDef, varName, dimNames, DATATYPE=datatype, VAROBJ=varObj</span>
<span class="comments">;     ncdfObject -> WriteDim, dimName, dimSize, UNLIMITED=unlimited</span>
<span class="comments">;     ncdfObject -> WriteGlobalAttr, attrName, attrValue, DATATYPE=datatype</span>
<span class="comments">;     ncdfObject -> WriteVarAttr, attrName, attrValue, varObj, DATATYPE=datatype</span>
<span class="comments">;     </span>
<span class="comments">; NOTES:</span>
<span class="comments">; </span>
<span class="comments">;     Note that all variable, attribute, and dimension names in a netCDF file are CASE SENSITIIVE!!</span>
<span class="comments">;     Thus, it is a good idea to use the methods provided in this object to obtain and examine</span>
<span class="comments">;     information in the file, as these names are handled in a case sensitive manner.</span>
<span class="comments">;     </span>
<span class="comments">;     Whenever you are creating a new netCDF file, you should try to create the file in</span>
<span class="comments">;     the following way.</span>
<span class="comments">;        1. Create your global attributes.</span>
<span class="comments">;        2. Create the dimensions you will be using to describe the variables.</span>
<span class="comments">;        3. Define the variables. To do this correctly, dimensions MUST be defined.</span>
<span class="comments">;        4. Define variable attributes.</span>
<span class="comments">;        5. Load your variables with data.</span>
<span class="comments">;        </span>
<span class="comments">;        Note that the data type of the _FillValue variable attribute MUST match the</span>
<span class="comments">;        data type of the variable data. Otherwise, you will have MANY problems! This</span>
<span class="comments">;        is a common source of error.</span>
<span class="comments">;        </span>
<span class="comments">;        Note that in almost all cases where you see the names "varName", "dimName", or</span>
<span class="comments">;        "attrName" used as input variables, you can substitute the proper object </span>
<span class="comments">;        reference in place of the actual name. In other words, you could get the value</span>
<span class="comments">;        of a variable attribute by doing something like this:</span>
<span class="comments">;        </span>
<span class="comments">;            check = ncdfObject -> HasAttr('history', OBJECT=attrObj)</span>
<span class="comments">;            IF check THEN attrValue = ncdfObject -> GetGlobalAttrValue(attrObj)</span>
<span class="comments">;           </span>
<span class="comments">;         as opposed to this:</span>
<span class="comments">;            </span>
<span class="comments">;            IF check THEN attrValue = ncdfObject -> GetGlobalAttrValue('history')</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       IDL> filename = 'example.nc'</span>
<span class="comments">;       IDL> ncdfObj = Obj_New('NCDF_FILE', filename)</span>
<span class="comments">;       IDL> ncdfObj -> Browse</span>
<span class="comments">;       IDL> Obj_Destroy, ncdfObj</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by:  David W. Fanning, 3 Feb 2010, using (stealing, really) plenty of ideas</span>
<span class="comments">;          from Mark Hadfield's Motley Library. Mark's mghncfile object is terrific, but it</span>
<span class="comments">;          had a number of limitations for my particular application, which I have attemped</span>
<span class="comments">;          to correct in my version of the software. But I wouldn't have even attempted this</span>
<span class="comments">;          had Mark not blazed the trail and Matt Savoie not insisted that I look at Mark's</span>
<span class="comments">;          wonderful library.</span>
<span class="comments">;       Changes in the way dimensions with a zero length are handled. 11 Feb 2010, DWF.</span>
<span class="comments">;       Added GetVarInfo method. 20 March 2010. DWF.</span>
<span class="comments">;       Added MISSINGINIDCES and FILLVALUE output keywords to GetVarData method. 20 March 2010. DWF.</span>
<span class="comments">;       Added output keywords SCALE_FACTOR, ADD_OFFSET, and DATATYPE to GetVarData method</span>
<span class="comments">;           so that these values can be obtained with the data. 29 Apr 2010. DWF.</span>
<span class="comments">;       I changed "missingValue" to "fillValue" some time ago, but I missed one in</span>
<span class="comments">;           the GetVarData method. Fixed. 7 June 2010. DWF.</span>
<span class="comments">;       Used the undefine procedure OBJ_DELETE, rather than OBJ_DESTROY. Sheesh! 18 June 2010. DWF.</span>
<span class="comments">;       Added NETCDF4_FORMAT keyword. 13 Feb 2012. DWF.</span>
<span class="comments">;       Added a bunch of new IDL 8.0 and 8.1 keyword to the WriteVarDef method to allow</span>
<span class="comments">;           access to these keywords in NCDF_VarDef. Also modified the NETCDF4_FORMAT keyword</span>
<span class="comments">;           to apply only in IDL versions 8.0 and higher. 21 Feb 2012. DWF.</span>
<span class="comments">;       Small typo fixed in setting CHAR datatype for IDL 8.1 and higher. 22 May 2013. DWF.</span>
<span class="comments">;       Typo (CONTINUOUS->CONTIGUOUS) fixed in WriteDefVar method. 30 July 2013. DWF.</span>
<span class="comments">;       Modified CopyVarDefTo method to allow new NCDF4 keywords. 30 July 2013. DWF.</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c)2010, by Fanning Software Consulting, Inc.                                 ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::Browse                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Allows the user to browse the netCDF file interactively. Variables, attributes,    </span>
<span class="comments">;    and dimensions can be saved to the main IDL level or command line where they can   </span>
<span class="comments">;    be manipulated further.                                                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> Browse                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    TITLE:       A text string that will be the title of the browser window. (Optional)</span>
<span class="comments">;    XOFFSET:     The X offset of the top-left corner of the browser. (Optional)        </span>
<span class="comments">;    YOFFSET:     The Y offset of the top-left corner of the browser. (Optional)        </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::Browse, TITLE=title, XOFFSET=xoffset, YOFFSET=yoffset

    NCDF_Browser, self.filename, $
        /NO_NEW_FILE, $
        TITLE=title, $
        XOFFSET=xoffset, $
        YOFFSET=yoffset

END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::Close_File                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Closes the netCDF file, if open.                                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> Browse                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::Close_File
    IF self.fileID GT 0 THEN NCDF_Close, self.fileID
    self.fileID = -1
END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CreateVarObj                                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Creates a NCDF_Variable object and adds it the the variable container.                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CreateVarObj, varName                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:  The case sensitive name of the variable.                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: An internal method.                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CreateVarObj, varName

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
 
    varObj = Obj_New('NCDF_Variable', varName, self)
    self.vars -> Add, varObj

END   


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CreateAttrObj                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Creates a NCDF_Attribute object and adds it the the attribute container.                                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CreateAttrObj, attrName                                         </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrName:  The case sensitive name of the attribute.                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: An internal method.                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CreateAttrObj, attrName

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
   attrObj = Obj_New('NCDF_Attribute', attrName, self)
   self.attrs -> Add, attrObj
   
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CreateDimObj                                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Creates a NCDF_Dimension object and adds it the the dimension container.                                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CreateDimObj, dimensionName                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimensionName:  The case sensitive name of the dimension.              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: An internal method.                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CreateDimObj, dimensionName

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    dimObj = Obj_New('NCDF_Dimension', dimensionName, self)
    self.dims -> Add, dimObj
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyVarAttrTo                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Copies a variable attribute from this object to another NCDF_FILE object.                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyVarAttrTo, varName, attrName, destObj                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to copy.  </span>
<span class="comments">;    attrName:   The case sensitive name of the variable attribute you wish to copy.    </span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy</span>
<span class="comments">;                the variable attribute to.                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: The variable will have had to have been previously defined for the file.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyVarAttrTo, varName, attrName, destObj

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'
    IF N_Elements(attrName) EQ 0 THEN $
               Message, 'An attribute name or object reference is required.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get and return the variable's attribute value.</span>
    attrValue = varObj -> GetAttrValue(attrName, DATATYPE=attrDataType)
    
    <span class="comments">; Write the variable attribute in the destination object.</span>
    destObj -> WriteVarAttr, varName, attrName, attrValue, DATATYPE=attrDataType
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyVariableTo                                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    The NCDF_File object has methods to do low-level manipulation of netCDF files, but</span>
<span class="comments">;    this method is a high-level method to copy a variable from one file to another.</span>
<span class="comments">;    This method will find all of the variable parts it needs in the file (dimensions, </span>
<span class="comments">;    variable definition, variable attributes, and even variable data) and will copy </span>
<span class="comments">;    everything it finds (if needed!) into the destination file. This eliminates a lot </span>
<span class="comments">;    of the druge work that goes into understanding exactly how everything works.                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyVariableTo, varName, destObj                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to copy   </span>
<span class="comments">;                the variable definition from.                              </span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy the        </span>
<span class="comments">;                variable definition to.                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    NODATA:     If this keyword is set, the variable's data is not copied to the file.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyVariableTo, varName, destObj

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'
    IF N_Elements(destObj) EQ 0 THEN $
               Message, 'A destination NCDF_FILE object is required.'
    IF ~Obj_Valid(destObj) THEN $
               Message, 'The destination NCDF_FILE object is not valid.'
    IF ~destObj -> GetProperty('Writable') THEN $
               Message, 'The destination NCDF_FILE object is not writeable.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=strCount, /CASE_SENSITIVE)
            IF strCount EQ 0 THEN Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Start with this variable's dimensions. Have these been defined</span>
    <span class="comments">; for the variable in the destination object? If not, define them.</span>
    dimNames = VarObj -> GetDimNames(COUNT=dimCount)
    FOR j=0,dimCount-1 DO BEGIN
        thisName = dimNames[j]
        IF ~destObj->HasDim(thisName) THEN self -> CopyDimTo, thisName, destObj
    ENDFOR
    
    <span class="comments">; Has this variable been defined in the destination object. ? If not, do it.</span>
    IF ~destObj->HasVar(varName) THEN self -> CopyVarDefTo, varName, destObj
    
    <span class="comments">; Does the variable have attributes? Copy these, too.</span>
    varAttrNames = varObj -> GetAttrNames(COUNT=attrCount)
    FOR j=0,attrCount-1 DO BEGIN
        thisAttrName = varAttrNames[j]
        IF ~destObj->HasVarAttr(varName, thisAttrName) THEN $
            self -> CopyVarAttrTo, varName, thisAttrName, destObj
    ENDFOR
    
    <span class="comments">; Finally, copy the variable's data to the destination object.</span>
    IF ~Keyword_Set(nodata) THEN self -> CopyVarDataTo, varName, destObj

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyVarDataTo                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Copies variable data from this object to another NCDF_FILE object.                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyVarDataTo, varName, destObj, COUNT=count, OFFSET=offset, STRIDE=stride  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to copy the data from.</span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy the data to.  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:      An optional vector containing the counts to be used in reading the     </span>
<span class="comments">;                variable. Count is a 1-based vector with an element for each dimension. </span>
<span class="comments">;                The default matches the size of the variable so that all data is       </span>
<span class="comments">;                written out.                                                 </span>
<span class="comments">;    OFFSET:     An optional vector containing the starting position for the read.      </span>
<span class="comments">;                The default start position is [0, 0, ...].                   </span>
<span class="comments">;    STRIDE:     An optional vector containing the strides, or sampling intervals,      </span>
<span class="comments">;                between accessed values of the netCDF variable. The default stride     </span>
<span class="comments">;                vector is that for a contiguous read, [1, 1, ...].           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: The variable will have had to have been previously defined for the file.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyVarDataTo, varName, destObj, COUNT=count, OFFSET=offset, STRIDE=stride

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'
    IF N_Elements(destObj) EQ 0 THEN $
               Message, 'A destination NCDF_FILE object is required.'
    IF ~Obj_Valid(destObj) THEN $
               Message, 'The destination NCDF_FILE object is not valid.'
    IF ~destObj -> GetProperty('Writable') THEN $
               Message, 'The destination NCDF_FILE object is not writeable.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=strCount, /CASE_SENSITIVE)
            IF strCount EQ 0 THEN Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Gather information.</span>
    data = varObj ->GetValue(COUNT=count, OFFSET=offset, STRIDE=stride)
    
    <span class="comments">; Copy the information to the destination object.</span>
    destObj -> WriteVarData, varName, data, COUNT=count, OFFSET=offset, STRIDE=stride
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyVarDefTo                                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Copies a variable definition from this object to another NCDF_FILE object.         </span>
<span class="comments">;    Note that dimension IDs are required to define a variable. This method assumes           </span>
<span class="comments">;    that whatever dimensions are defined for the variable you are copying are already  </span>
<span class="comments">;    defined in the file object you are copying this variable to.                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyVarDefTo, varName, destObj                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to copy   </span>
<span class="comments">;                the variable definition from.                              </span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy the        </span>
<span class="comments">;                variable definition to.                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    CHUNK_DIMENSIONS: Set this keyword equal to a vector containing the chunk dimensions for the variable.</span>
<span class="comments">;                A new NetCDF variable is chunked by default, using a default chunk value that is </span>
<span class="comments">;                the full dimension size for limited dimensions, and 1 for unlimited dimensions.</span>
<span class="comments">;                CHUNK_DIMENSIONS must have the same number of elements as the number of dimensions </span>
<span class="comments">;                specified by Dim. If the CONTIGUOUS keyword is set, the value of the </span>
<span class="comments">;                CHUNK_DIMENSIONS keyword is ignored. Available only in IDL 8.0 and higher.</span>
<span class="comments">;    GZIP:       Set this keyword to an integer between zero and nine to specify the level </span>
<span class="comments">;                of GZIP compression applied to the variable. Lower compression values result </span>
<span class="comments">;                in faster but less efficient compression. This keyword is ignored if the </span>
<span class="comments">;                CHUNK_DIMENSIONS keyword is not set. This keyword is ignored if the CONTIGUOUS </span>
<span class="comments">;                keyword is set. If the GZIP keyword is set, the CONTIGUOUS keyword is ignored.</span>
<span class="comments">;                You can only use GZIP compression with NCDF 4 files. Available only in </span>
<span class="comments">;                IDL 8.0 and higher.    </span>
<span class="comments">;    SHUFFLE:    Set this keyword to apply the shuffle filter to the variable. If the GZIP </span>
<span class="comments">;                keyword is not set, this keyword is ignored. The shuffle filter de-interlaces blocks </span>
<span class="comments">;                of data by reordering individual bytes. Byte shuffling can sometimes </span>
<span class="comments">;                increase compression density because bytes in the same block positions </span>
<span class="comments">;                often have similar values, and grouping similar values together often </span>
<span class="comments">;                leads to more efficient compression. Available only in IDL 8.0 and higher.                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyVarDefTo, varName, destObj, $
    CHUNK_DIMENSIONS=chunk_dimensions, $
    GZIP=gzip, $
    SHUFFLE=shuffle

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'
    IF N_Elements(destObj) EQ 0 THEN $
               Message, 'A destination NCDF_FILE object is required.'
    IF ~Obj_Valid(destObj) THEN $
               Message, 'The destination NCDF_FILE object is not valid.'
    IF ~destObj -> GetProperty('Writable') THEN $
               Message, 'The destination NCDF_FILE object is not writeable.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
                Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Gather information.</span>
    dimNames = varObj -> GetDimNames(COUNT=dimCount)
    datatype = varObj -> GetProperty('DATATYPE')
    
    <span class="comments">; See if you can match the names of the dimensions with the dimensions</span>
    <span class="comments">; that are current defined for the destination object.</span>
    IF dimCount GT 0 THEN BEGIN
        destDimContainer = destObj -> GetProperty('DIMS')
        dimIDs = LonArr(dimCount)
        FOR j=0,dimCount-1 DO BEGIN
            thisObj = destDimContainer -> FindByName(dimNames[j], COUNT=found)
            IF found EQ 0 THEN Message, 'Cannot find a dimension named "' + $
                dimNames[j] + '" in the destination object.'
            dimIDs[j] = thisObj -> GetID()
        ENDFOR
    ENDIF
    
    <span class="comments">; Copy the information to the destination object.</span>
    IF dimCount EQ 0 THEN BEGIN
      destObj -> WriteVarDef, varName, DATATYPE=datatype, $
        CHUNK_DIMENSIONS=chunk_dimensions, $
        GZIP=gzip, $
        SHUFFLE=shuffle
    ENDIF ELSE BEGIN
      destObj -> WriteVarDef, varName, dimIDs, DATATYPE=datatype, $
        CHUNK_DIMENSIONS=chunk_dimensions, $
        GZIP=gzip, $
        SHUFFLE=shuffle
    ENDELSE
    
END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyGlobalAttrTo                                                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Copies a global attribute from this object to another NCDF_FILE object.</span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyGlobalAttrTo, attrName, destObj                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrName:   The case sensitive name of the global attribute you wish to copy       </span>
<span class="comments">;                to the destination object.                                 </span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy the        </span>
<span class="comments">;                variable definition to.                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyGlobalAttrTo, attrName, destObj

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(attrName) EQ 0 THEN $
               Message, 'A global attrubute name or object reference is required.'
    IF N_Elements(destObj) EQ 0 THEN $
               Message, 'A destination NCDF_FILE object is required.'
    IF ~Obj_Valid(destObj) THEN $
               Message, 'The destination NCDF_FILE object is not valid.'
    IF ~destObj -> GetProperty('Writable') THEN $
               Message, 'The destination NCDF_FILE object is not writeable.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of an attribute or an attribute object?</span>
    CASE Size(attrName, /TNAME) OF
    
        'STRING': BEGIN
            attrObj = self.attrs -> FindByName(attrName, COUNT=attrCount, /CASE_SENSITIVE)
            IF attrCount EQ 0 THEN Message, 'Cannot find a dimension object with name ' + attrName + '.'
            IF ~Obj_Valid(attrObj) THEN Message, 'Invalid object with name "' + attrName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            attrObj = attrName
            END
    
        ELSE: Message, 'Input global attribute name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Gather information.</span>
    attrValue = attrObj -> GetValue()
    dataType = attrObj -> GetProperty('DATATYPE')
    
    <span class="comments">; Copy the information to the destination object. </span>
        destObj -> WriteGlobalAttr, attrName, attrValue, DATATYPE=datatype
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::CopyDimTo                                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Copies a dimension from this object to another NCDF_FILE object.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> CopyDimTo, dimName, destObj                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimName:    The case sensitive name of the dimension you wish to copy to the       </span>
<span class="comments">;                destination object.                                        </span>
<span class="comments">;    destObj:    The object reference of a NCDF_FILE object you wish to copy the        </span>
<span class="comments">;                dimension to.                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::CopyDimTo, dimName, destObj

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF

    IF N_Elements(dimName) EQ 0 THEN $
               Message, 'A dimension name or object reference is required.'
    IF N_Elements(destObj) EQ 0 THEN $
               Message, 'A destination NCDF_FILE object is required.'
    IF ~Obj_Valid(destObj) THEN $
               Message, 'The destination NCDF_FILE object is not valid.'
    IF ~destObj -> GetProperty('Writable') THEN $
        Message, 'The destination NCDF_FILE object is not writeable.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a dimension or an dimenison object?</span>
    CASE Size(dimName, /TNAME) OF
    
        'STRING': BEGIN
            dimObj = self.dims -> FindByName(dimName, COUNT=dimCount, /CASE_SENSITIVE)
            IF dimCount EQ 0 THEN $
               Message, 'Cannot find a dimension object with name ' + dimName + '.'
             IF ~Obj_Valid(dimObj) THEN $
               Message, 'Invalid object with name "' + dimName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            dimObj = dimName
            END
    
        ELSE: Message, 'Input dimension name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Gather information.</span>
    dimSize = dimObj -> GetValue()
    unlimited = dimObj -> GetProperty('UNLIMITED')
    
    <span class="comments">; Copy the information to the destination object.</span>
    destObj -> WriteDim, dimName, dimSize, UNLIMITED=unlimited
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetDimNames                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the names of all the dimensions in the file.                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimNames = obj -> GetDimNames(COUNT=dimCount)                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:     An output keyword that reports the number of dimension names found.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimNames:  A string array containing the names of the dimensions in the file.      </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetDimNames, COUNT=dimCount

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile
 
    <span class="comments">; Count the number of dimension objects.</span>
    dimCount = self.dims -> Count()
    
    <span class="comments">; If there are no dimensions, return null string.</span>
    IF dimCount EQ 0 THEN RETURN, ""
    
    dimNames = StrArr(dimCount)
    FOR j=0,dimCount-1 DO BEGIN
        thisObj = self.dims -> Get(POSITION=j)
        dimNames[j] = thisObj -> GetName()
    ENDFOR
    
    <span class="comments">; Return a scalar if necessary.</span>
    IF N_Elements(dimNames) EQ 1 THEN dimNames = dimNames[0]
    
    RETURN, dimNames

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetDimValue                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the value (the size) of a dimension.                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimValue = obj -> GetDimValue(dimName)                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimName:    The case sensitive name of the dimension you want the value (size) of. </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimValue:  An integer that gives the size of the dimension.            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetDimValue, dimName

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(dimName) EQ 0 THEN $
               Message, 'A dimension name or object reference is required.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a dimension or dimension object?</span>
    CASE Size(dimName, /TNAME) OF
    
        'STRING': BEGIN
            dimObj = self.dims -> FindByName(dimName, COUNT=dimCount, /CASE_SENSITIVE)
            IF dimCount EQ 0 THEN $
               Message, 'Cannot find a dimension object with name ' + dimName + '.'
            IF ~Obj_Valid(dimObj) THEN $
               Message, 'Invalid object with name "' + dimName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            dimObj = dimName
            END
    
        ELSE: Message, 'Input dimension name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get the data.</span>
    dimData = dimObj -> GetValue()
    
    RETURN, dimData
    
END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetFileID                                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the netCDF file identifier.                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    fileID = obj -> GetFileID()                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    fileID:  The netCDF file identifier that is required to interact with the file.       ;</span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetFileID
    RETURN, self.fileID
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetGlobalAttrNames                                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the names of all the global attributes in the file.            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrNames = obj -> GetGlobalAttrNames(COUNT=attrCount)                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:     An output keyword that reports the number of dimension names found.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrNames:  A string array containing the names of the global attributes in the file. </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetGlobalAttrNames, COUNT=attrCount

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile
 
    <span class="comments">; Count the number of global attribute objects.</span>
    attrCount = self.attrs -> Count()
    
    <span class="comments">; If there are no global attributes, return null string.</span>
    IF attrCount EQ 0 THEN RETURN, ""
    
    attrNames = StrArr(attrCount)
    FOR j=0,attrCount-1 DO BEGIN
        thisObj = self.attrs -> Get(POSITION=j)
        attrNames[j] = thisObj -> GetName()
    ENDFOR
    
    <span class="comments">; Return a scalar if necessary.</span>
    IF N_Elements(attrNames) EQ 1 THEN attrNames = attrNames[0]
    
    RETURN, attrNames

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetGlobalAttrValue                                                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the value of a global attributes in the file.                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrValue = obj -> GetGlobalAttrValue(attrName, DATATYPE=datatype)     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrName:    The case sensitive name of a global attribute.            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    DATATYPE:    An output keyword that contains the data type of the global attribute.  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrValue:   The value of the global attribute.                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetGlobalAttrValue, attrName, DATATYPE=datatype

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(attrName) EQ 0 THEN $
               Message, 'A global attribute name or object reference is required.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of an attribute or an attribute object?</span>
    CASE Size(attrName, /TNAME) OF
    
        'STRING': BEGIN
            attrObj = self.attrs -> FindByName(attrName, COUNT=attrCount, /CASE_SENSITIVE)
            IF attrCount EQ 0 THEN $
               Message, 'Cannot find an attribute object with name ' + attrName + '.'
            IF ~Obj_Valid(attrObj) THEN $
               Message, 'Invalid object with name "' + attrName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            attrObj = attrName
            END
    
        ELSE: Message, 'Input attribute name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get the data.</span>
    attrData = attrObj -> GetValue(DATATYPE=datatype)
    
    RETURN, attrData
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetProperty                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns various properties of the object via output keyword parameters.</span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> GetProperty, ....                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    ALL:            If set, return all properties of the object in a structure variable.    </span>
<span class="comments">;    ATTRNAMES:      This output variable returns all the global attribute names.       </span>
<span class="comments">;    DEFINE:         This output variable returns a 1 if the file is in DEFINE mode.    </span>
<span class="comments">;    DIMNAMES:       This output variable returns all the dimension names.  </span>
<span class="comments">;    ERRORLOGGER:    This output variable returns the errorlogger object.   </span>
<span class="comments">;    FILEID:         This output variable returns the netCDF file identifier.           </span>
<span class="comments">;    FILENAME:       This output variable returns the name of the netCDF file.          </span>
<span class="comments">;    FILEHASBEENPARSED:  This output variable returns a 1 if the file has been parsed.  </span>
<span class="comments">;    N_ATTRS:         This output variable returns the number of global attributes in   </span>
<span class="comments">;                     the file.    </span>
<span class="comments">;    N_DIMS:          This output variable returns the number of dimensions in the file.</span>
<span class="comments">;    N_VARS:          This output variable returns the number of variables in the file. </span>
<span class="comments">;    UNLIMITED:       This output variable returns a vector of 0s and 1s, one element   </span>
<span class="comments">;                     for each dimension, indicating if the dimension is unlimited or not. </span>
<span class="comments">;    VARNAMES:        This output variable returns the names of variables in the file.  </span>
<span class="comments">;    WRITEABLE:       This output variable returns a 1 if the file is writable.                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::GetProperty, $
     ALL=all, $
     ATTRNAMES=attrnames, $
     DEFINE=define, $
     DIMNAMES=dim_names, $
     DIMENSIONS=dimensions, $
     ERRORLOGGER=errorLogger, $
     FILEID=fileID, $
     FILENAME=filename, $
     FILEHASBEENPARSED=fileHasBeenParsed, $
     N_DIMS=n_dims, $
     N_VARS=n_vars, $
     N_ATTRS=n_attrs, $
     UNLIMITED=unlimited, $
     VARNAMES=varnames, $
     WRITABLE=writable

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile
    
    <span class="comments">; Easily returned information.</span>
    errorLogger = self.errorLogger
    filename = self.filename
    fileID = self.fileID
    fileHasBeenParsed = self.fileHasBeenParsed
    define = self.define
    writable = self.writable

    <span class="comments">; What's in the file?</span>
    info = NCDF_Inquire(self.fileID)
    n_dims  = info.ndims
    n_vars  = info.nvars
    n_attrs = info.ngatts

    <span class="comments">; Get the attribute names, if needed.</span>
    IF Arg_Present(attrnames) || Arg_Present(all) THEN BEGIN
       IF n_attrs EQ 0 THEN BEGIN
            attrnames = ""
       ENDIF ELSE BEGIN
            attrnames = StrArr(n_attrs)
            FOR j=0,n_attrs-1 DO BEGIN
                thisAttr = self.attrs -> Get(POSITION=j)
                attrnames[j] = thisAttr -> GetProperty('NAME')
            ENDFOR
       ENDELSE
     ENDIF
     
     <span class="comments">; Get the dimension names, and dimension IDs, if needed.</span>
     IF Arg_Present(dimNames) || Arg_Present(dimensions) || Arg_Present(all) THEN BEGIN
            IF n_dims EQ 0 THEN BEGIN
                dimNames = ""
                dimensions = 0
                unlimited = 0
            ENDIF ELSE BEGIN
                dimNames = StrArr(n_dims)
                dimensions = LonArr(n_dims)
                unlimited = BytArr(n_dims)
                FOR j=0, n_dims-1 DO BEGIN
                    dimsObj = self.dims -> Get(POSITION=j)
                    dimNames[j] = dimsObj -> GetProperty('NAME')
                    dimensions[j] = dimsObj -> GetProperty('SIZE')
                    unlimited[j] = dimsObj -> GetProperty('UNLIMITED')
                ENDFOR
            ENDELSE
     ENDIF

     <span class="comments">; Get the variable names, if needed.</span>
     IF Arg_Present(varNames) || Arg_Present(all) THEN BEGIN
        IF n_vars EQ 0 THEN BEGIN
            varNames = ""
        ENDIF ELSE BEGIN
            varNames = StrArr(n_vars)
            FOR j=0,n_vars-1 DO BEGIN
                thisVar = self.vars -> Get(POSITION=j)
                varNames[j] = thisVar -> GetProperty('NAME')
            ENDFOR
        ENDELSE
     ENDIF

     IF Arg_Present(all) THEN BEGIN
        all = { ATTRNAMES:attrnames, $
                DEFINE:define, $
                DIMNAMES:dim_names, $
                DIMENSIONS:dimensions, $
                ERRORLOGGER:errorLogger, $
                FILEID:fileID, $
                FILENAME:filename, $
                FILEHASBEENPARSED:fileHasBeenParsed, $
                N_DIMS:n_dims, $
                N_VARS:n_vars, $
                N_ATTRS:n_attrs, $
                UNLIMITED:unlimited, $
                VARNAMES:varnames, $
                WRITABLE:writable }
     ENDIF

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetProperty                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns various properties of the object one at a time. This is a shorthand and    </span>
<span class="comments">;    generic way to get the value of an object's "properties", which are defined as     </span>
<span class="comments">;    the IDL variables in the object's class structure.                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    propertyValue = obj -> GetProperty(thisProperty)                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    thisProperty:   A string variable that is equivalent to a field in the object's    </span>
<span class="comments">;                    class structure. See the *__DEFINE procedure for which properties  </span>
<span class="comments">;                    can be returned. The property is case insensitive.     </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    propertyValue:  The value of a particular object property. Note that pointer       </span>
<span class="comments">;                    properties will return the variable the pointer points to.         </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetProperty, thisProperty

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, 0
    ENDIF
    
    <span class="comments">; Get the self structure as a structure, rather than as an object.</span>
    Call_Procedure, StrLowCase(Obj_Class(self)) + '__define', classStruct

    <span class="comments">; Find the property in this class structure.</span>
    index = Where(StrPos(Tag_Names(classStruct), StrUpCase(thisProperty)) EQ 0, count)
    index = index[0]
    
    <span class="comments">; What happened?</span>
    CASE count OF
        0: Message, 'Property ' + StrUpCase(thisProperty) + ' could not be found.'
        1: propertyValue = self.(index)
        ELSE: Message, 'Ambiguous property. Use more characters to specify it.'
    ENDCASE

    <span class="comments">; If this is a pointer, you want the thing pointed to.</span>
    IF Size(propertyValue, /TNAME) EQ 'POINTER' THEN propertyValue = *propertyValue
    RETURN, propertyValue
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetVarAttrNames                                                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the names of variable attributes in the file.                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrNames = obj -> GetVarAttrNames(varName, COUNT=varAttrCount)        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you want the attributes of.    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:    The number of variable attributes found.                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrNames:   A string array containing the names of the variable attributes.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetVarAttrNames, varName, COUNT=varAttrCount

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get the variable attribute names.</span>
    attrNames = varObj -> GetAttrNames(COUNT=varAttrCount)
    
    RETURN, attrNames
    
END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetVarAttrValue                                                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the value of a variable attribute in the file.                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrValue = obj -> GetVarAttrValue(varName, attrName, DATATYPE=datatype)           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:     The case sensitive name of a variable whose attribute you want        </span>
<span class="comments">;                 to obtain.                                                </span>
<span class="comments">;    attrName:    The case sensitive name of a global attribute.            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    DATATYPE:    An output keyword that contains the data type of the attribute.         </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrValue:   The value of the variable attribute.                      </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetVarAttrValue, varName, attrName, DATATYPE=datatype

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or object reference is required.'
    IF N_Elements(attrName) EQ 0 THEN $
               Message, 'An attribute name or object reference is required.'

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get and return the variable's attribute value.</span>
    attrValue = varObj -> GetAttrValue(attrName, DATATYPE=datatype)
    RETURN, attrValue
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetVarNames                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the names of the variables in the file.                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varNames = obj -> GetVarNames(COUNT=varCount)                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:    The number of variables found.                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varNames:   A string array containing the names of the variables in the file.      </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetVarNames, COUNT=varCount

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF

    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile
 
    <span class="comments">; Count the number of global attribute objects.</span>
    varCount = self.vars -> Count()
    
    <span class="comments">; If there are no global attributes, return null string.</span>
    IF varCount EQ 0 THEN RETURN, ""
    
    varNames = StrArr(varCount)
    FOR j=0,varCount-1 DO BEGIN
        thisObj = self.vars -> Get(POSITION=j)
        varNames[j] = thisObj -> GetName()
    ENDFOR
    
    <span class="comments">; Return a scalar if necessary.</span>
    IF varCount EQ 1 THEN varNames = varNames[0]
    
    RETURN, varNames

END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetVarData                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns the variable data from the file.                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    data = obj -> GetVarData(varName, COUNT=count, OFFSET=offset, STRIDE=stride)       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:   The case sensitive name of a variable whose data you want to obtain.    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Input Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:      An optional vector containing the counts to be used in reading the     </span>
<span class="comments">;                variable. Count is a 1-based vector with an element for each dimension. </span>
<span class="comments">;                The default matches the size of the variable so that all data is       </span>
<span class="comments">;                written out.                                                 </span>
<span class="comments">;    OFFSET:     An optional vector containing the starting position for the read.      </span>
<span class="comments">;                The default start position is [0, 0, ...].                   </span>
<span class="comments">;    STRIDE:     An optional vector containing the strides, or sampling intervals,      </span>
<span class="comments">;                between accessed values of the netCDF variable. The default stride     </span>
<span class="comments">;                vector is that for a contiguous read, [1, 1, ...].           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Output Keywords:                                                                    </span>
<span class="comments">;                                                                              </span>
<span class="comments">;    ADD_OFFSET:  The add_offset value for the variable, if there is one.</span>
<span class="comments">;</span>
<span class="comments">;    DATATYPE:    The data type of the variable, before the scale and offset are applied.</span>
<span class="comments">;                 The same as what comes back from datatype = Size(rawVariable, /TNAME).</span>
<span class="comments">;</span>
<span class="comments">;    FILLVALUE:   The value that is being used for the "missing" value in this variable.</span>
<span class="comments">;                                                                              </span>
<span class="comments">;    MISSINGINDICES: A vector containing the missing indices in the returned data. Missing</span>
<span class="comments">;                 data is identified by either the depreciated "missing_value" attribute</span>
<span class="comments">;                 or the approved "_FillValue" attribute.  </span>
<span class="comments">;       </span>
<span class="comments">;    SCALE_FACTOR: The scale factor for the variable, if there is one.</span>
<span class="comments">; </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    data:       The data obtained from the variable. If there is an ADD_OFFSET and</span>
<span class="comments">;                SCALE_FACTOR attribute for this variable, the returned data is scaled</span>
<span class="comments">;                and offset before returning. The "missing" or "fill value" is not </span>
<span class="comments">;                changed by scaling and offsetting.                     </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetVarData, varName, $
    ADD_OFFSET=add_offset, $
    COUNT=count, $
    DATATYPE=datatype, $
    FILLVALUE=fillValue, $
    OFFSET=offset, $
    SCALE_FACTOR=scale_factor, $
    STRIDE=stride, $
    MISSINGINDICES=missingIndices

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or variable object reference is required.'
     
    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get the data.</span>
    varData = varObj -> GetValue( $
        ADD_OFFSET=add_offset, $
        COUNT=count, $
        DATATYPE=datatype, $
        FILLVALUE=fillvalue, $
        OFFSET=offset, $
        MISSINGINDICES=missingindices, $
        SCALE_FACTOR=scale_factor, $
        STRIDE=stride)
    
    RETURN, varData
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::GetVarInfo                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Returns information about a specified variable from the file.                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    info = obj -> GetVarInfo(varName)       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:   The case sensitive name of a variable whose information you want to obtain.    </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.</span>
<span class="comments">;         </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    info:       A structure contains the following fields.</span>
<span class="comments">;    </span>
<span class="comments">;                    info = { dims: varObj -> GetDimSizes(), $</span>
<span class="comments">;                             dimNames: varObj -> GetDimNames(), $</span>
<span class="comments">;                             attrNames: varObj -> GetAttrNames(), $</span>
<span class="comments">;                             dataType: varObj -> GetProperty('datatype'), $</span>
<span class="comments">;                             nattrs: varObj -> GetProperty('nattrs'), $</span>
<span class="comments">;                             ndims: varObj -> GetProperty('ndims') }</span>
<span class="comments">;                            </span>
<span class="comments">;                In addition, the structure will contain the fields "scale_factor," "add_offset,"</span>
<span class="comments">;                and "_FillValue" if these attributes are available for the variable.</span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::GetVarInfo, varName

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
    
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or variable object reference is required.'
     
    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile

    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE

    <span class="comments">; Get the information you need.</span>
    hasVar = self -> HasVar(varName, OBJECT=varObj)
    IF ~hasVar THEN Message, 'Cannot find a variable with the name ' + varName + '.'
    
    RETURN, varObj -> GetInfo()
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::HasGlobalAttr                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Indicates, by returning a 1, that this particular global attribute is found in the </span>
<span class="comments">;    file. If not found, this function returns a 0.                                                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound = obj -> HasGlobalAttr(attrName, OBJECT=object)                </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrName:     The case sensitive name of a global attribute.           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    OBJECT:        If the attribute exists, this keyword returns the global attribute's</span>
<span class="comments">;                   object reference. Such a reference can be used in place of the      </span>
<span class="comments">;                   global attribute's name in most methods.                </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound:       If an attribute with this name is found, this variable is set to    </span>
<span class="comments">;                   1. It is set to 0 otherwise.                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::HasGlobalAttr, attrName, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF

    <span class="comments">; Can you find a global attribute object with this name?</span>
    object = self.attrs -> FindByName(attrName, COUNT=count)
    
    IF count GT 0 THEN RETURN, 1 ELSE RETURN, 0
    
END

<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::HasDim                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Indicates, by returning a 1, that this particular dimension is found in the        </span>
<span class="comments">;    file. If not found, this function returns a 0.                                                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound = obj -> HasDim(dimName, OBJECT=object)                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimName:     The case sensitive name of a dimension.                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    OBJECT:        If the dimension exists, this keyword returns the dimension's       </span>
<span class="comments">;                   object reference. Such a reference can be used in place of the      </span>
<span class="comments">;                   dimension's name in most methods.                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound:       If a dimension with this name is found, this variable is set to     </span>
<span class="comments">;                   1. It is set to 0 otherwise.                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::HasDim, dimName, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
 
    <span class="comments">; Can you find a dimension object with this name?</span>
    object = self.dims -> FindByName(dimName, COUNT=count)
    
    IF count GT 0 THEN RETURN, 1 ELSE RETURN, 0
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::HasVar                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Indicates, by returning a 1, that this particular variable is found in the         </span>
<span class="comments">;    file. If not found, this function returns a 0.                                                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound = obj -> HasVar(varName, OBJECT=object)                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:      The case sensitive name of a variable.                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    OBJECT:        If the variable exists, this keyword returns the variable's         </span>
<span class="comments">;                   object reference. Such a reference can be used in place of the      </span>
<span class="comments">;                   variable's name in most methods.                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound:       If a variable with this name is found, this variable is set to      </span>
<span class="comments">;                   1. It is set to 0 otherwise.                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::HasVar, varName, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF
 
    <span class="comments">; Can you find a variable object with this name?</span>
    object = self.vars -> FindByName(varName, COUNT=count)
    
    IF count GT 0 THEN RETURN, 1 ELSE RETURN, 0
    

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::HasVarAttr                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Indicates, by returning a 1, that this particular variable attribute is found in the  ;</span>
<span class="comments">;    file. If not found, this function returns a 0.                                                                   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound = obj -> HasVarAttr(varName, attrName, OBJECT=object)          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:      The case sensitive name of a variable whose attribute we want to find.</span>
<span class="comments">;    attrName:     The case sensitive name of a variable attribute.         </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    OBJECT:        If the variable exists, this keyword returns the variable attribute's </span>
<span class="comments">;                   object reference. Such a reference can be used in place of the      </span>
<span class="comments">;                   variable attribute's name in most methods.              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Return Value:                                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    isFound:       If a variable attribute with this name is found, this variable      </span>
<span class="comments">;                   is set to 1. It is set to 0 otherwise.                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
FUNCTION NCDF_File::HasVarAttr, varName, varAttrName, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN, ""
    ENDIF

    <span class="comments">; Can you find a variable object with this name?</span>
    varObj = self.vars -> FindByName(varName, COUNT=count)
    
    IF count EQ 0 THEN Message, 'Cannot find a variable with name "' + varName + '".'
    
    <span class="comments">; Can you find a variable attribute with this name.</span>
    hasAttr = varObj[0] -> HasAttr(varAttrName, OBJECT=object)
        
    RETURN, hasAttr
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::PrintFileInfo                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Prints file information out to the IDL console window or, optionally, to a file.                                             </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> PrintFileInfo, outputFile                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    outputFile:      An optional filename. If present, the output is written to this   </span>
<span class="comments">;                     file instead of to the console.                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::PrintFileInfo, outputFile

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        IF lun NE -1 THEN Free_Lun, lun
        RETURN
    ENDIF
    
    <span class="comments">; Make sure the file has been parsed.</span>
    IF ~self.fileHasBeenParsed THEN self -> ParseFile
    
    <span class="comments">; Are we writing to a file or to standard output?</span>
    IF N_Elements(outputFile) NE 0 THEN BEGIN
        OpenW, lun, outputFile, /GET_LUN
    ENDIF ELSE lun = -1
    
    <span class="comments">; Gather information.</span>
    numGAttrs = self.attrs -> Count()
    numDims = self.dims -> Count()
    numVars = self.vars -> Count()
    PrintF, lun, 'File Information: ', self.filename
    PrintF, lun, 'Number of Global Attributes: ', StrTrim(numGAttrs,2)
    PrintF, lun, 'Number of Dimensions: ', StrTrim(numDims,2)
    PrintF, lun, 'Number of Variables: ', StrTrim(numVars,2)
    PrintF, lun, ''
    
    PrintF, lun, 'Global Attributes: '
    FOR j=0,numGAttrs-1 DO BEGIN
        attrObj = self.attrs -> Get(POSITION=j)
        name = attrObj -> GetProperty('NAME')
        PrintF, lun, '     ', name
    ENDFOR
    PrintF, lun, ''
    
    PrintF, lun, 'Dimensions: '
    FOR j=0,numDims-1 DO BEGIN
        dimsObj = self.dims -> Get(POSITION=j)
        name = dimsObj -> GetProperty('NAME')
        size = dimsObj -> GetProperty('SIZE')
        unlimited = dimsObj -> GetProperty('UNLIMITED')
        IF unlimited EQ 1 THEN unlimited = ' (unlimited)' ELSE unlimited = ""
        PrintF, lun, '     ', name, ': ', StrTrim(size,2), unlimited
    ENDFOR
    PrintF, lun, ''
    
    PrintF, lun, 'Variables: '
    FOR j=0,numVars-1 DO BEGIN
        varObj = self.vars -> Get(POSITION=j)
        name = varObj -> GetProperty('NAME')
        attrs = varObj -> GetProperty('ATTRS')
        PrintF, lun, '     ', name
        nattrs = attrs -> Count()
        FOR k=0,nattrs-1 DO BEGIN
            attrObj = attrs -> Get(POSITION=k)
            attrname = attrObj -> GetProperty('NAME')
            PrintF, lun, '          ', attrname
        ENDFOR
    ENDFOR
    PrintF, lun, ''
    
    <span class="comments">; Clean up.</span>
    IF lun NE -1 THEN Free_Lun, lun
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::ParseFile                                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Parses the file and creates the appropriate file objects for all subsequent        </span>
<span class="comments">;    object operations.                                                                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> ParseFile                                                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::ParseFile

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; Only need to parse this file once.</span>
    IF self.fileHasBeenParsed THEN RETURN
    
    <span class="comments">; Purge all containers and destroy all objects in the container.</span>
    theseObjects = self.attrs -> Get(/ALL, COUNT=objCount)
    self.attrs -> Remove, /ALL
    FOR j=0,objCount-1 DO Obj_Destroy, theseObjects[j]
    
    theseObjects = self.dims -> Get(/ALL, COUNT=objCount)
    self.dims -> Remove, /ALL
    FOR j=0,objCount-1 DO Obj_Destroy, theseObjects[j]

    theseObjects = self.vars -> Get(/ALL, COUNT=objCount)
    self.vars -> Remove, /ALL
    FOR j=0,objCount-1 DO Obj_Destroy, theseObjects[j]
    
    <span class="comments">; Gather information about the file.</span>
    info = NCDF_Inquire(self.fileID)
    
    <span class="comments">; Parse the global variables.</span>
    num_attr = info.ngatts
    IF num_attr GT 0 THEN BEGIN
       FOR j=0,num_attr-1 DO BEGIN
           attribute_name = NCDF_AttName(self.fileID, j, /GLOBAL)
           NCDF_AttGet, self.fileID, attribute_name, theAttribute, /GLOBAL
           self -> CreateAttrObj, attribute_name
       ENDFOR
    ENDIF
    
    <span class="comments">; Parse the dimensions.</span>
    num_dims = info.ndims
    IF num_dims GT 0 THEN BEGIN
        FOR j=0,num_dims-1 DO BEGIN
            NCDF_DIMINQ, self.fileID, j, dimension_name, dimension_size
            self -> CreateDimObj, dimension_name
        ENDFOR
    ENDIF

    <span class="comments">; Parse the variables.</span>
    num_vars = info.nvars
    IF num_vars GT 0 THEN BEGIN
        FOR j=0,num_vars-1 DO BEGIN
            varinfo = NCDF_VarInq(self.fileID, j)
            self -> CreateVarObj, varinfo.name
         ENDFOR
    ENDIF
      
    self.fileHasBeenParsed = 1
      
END



<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::SetMode                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Sets the file mode to DEFINE or DATA, as needed. Only one of the two keywords      </span>
<span class="comments">;    should be used.                                                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> SetMode, DATA=data , DEFINE=define                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    DATA:       If this keyword is set, the file is put into DATA mode.    </span>
<span class="comments">;    DEFINE:     If this keyword is set, the file is put into DEFINE mode.  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::SetMode, DATA=data, DEFINE=define

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling. </span>
    CATCH, theError
    IF theError NE 0 THEN BEGIN
       CATCH, /CANCEL
       self.errorLogger -> AddError
       RETURN
    ENDIF
    
    <span class="comments">; Can't have both keywords set.</span>
    IF Keyword_Set(define) && Keyword_Set(data) THEN BEGIN
        Message, 'You cannot set both DEFINE and DATA keywords.'
    ENDIF
    
    <span class="comments">; If nothing is set, put us into DEFINE mode.</span>
    IF ~Keyword_Set(define) && ~Keyword_Set(data) THEN define = 1

    <span class="comments">; Set define mode.</span>
    IF Keyword_Set(define) THEN BEGIN
        data = 0
        IF self.define NE 1 THEN BEGIN
            NCDF_Control, self.fileID, /REDEF
            self.define = 1
        ENDIF
    ENDIF

    <span class="comments">; Set data mode.</span>
    IF Keyword_Set(data) THEN BEGIN
        IF self.define NE 0 THEN BEGIN
            NCDF_Control, self.fileID, /ENDEF
            self.define = 0
        ENDIF
    ENDIF

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::Sync                                                              </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes data in memory to the disk.                                                                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> Sync                                                       </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    None.                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::Sync

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling. </span>
    CATCH, theError
    IF theError NE 0 THEN BEGIN
       CATCH, /CANCEL
       self.errorLogger -> AddError
       RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to sync the file.</span>
    IF ~self.writable THEN Message, 'Cannot sync a READ-ONLY file.'

    <span class="comments">; The file has to be in DATA mode.</span>
    self -> SetMode, /DATA
    
    <span class="comments">; Sync the file.</span>
    NCDF_Control, self.fileID, /SYNC
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::WriteVarData                                                          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes variable data into this netCDF file. It assumes the variable has previously </span>
<span class="comments">;    been defined for this file.                                                                                      </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> WriteVarData, varName, data, COUNT=count, OFFSET=offset, STRIDE=stride      </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to write data to.     </span>
<span class="comments">;    data:       The data to be written into this variable.                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    COUNT:      An optional vector containing the counts to be used in reading the     </span>
<span class="comments">;                variable. Count is a 1-based vector with an element for each dimension. </span>
<span class="comments">;                The default matches the size of the variable so that all data is       </span>
<span class="comments">;                written out.                                                 </span>
<span class="comments">;    OFFSET:     An optional vector containing the starting position for the read.      </span>
<span class="comments">;                The default start position is [0, 0, ...].                   </span>
<span class="comments">;    STRIDE:     An optional vector containing the strides, or sampling intervals,      </span>
<span class="comments">;                between accessed values of the netCDF variable. The default stride     </span>
<span class="comments">;                vector is that for a contiguous read, [1, 1, ...].           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Notes: The variable will have had to have been previously defined for the file.       </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::WriteVarData, varName, data, COUNT=count, OFFSET=offset, STRIDE=stride

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to add a variable definition.</span>
    IF ~self.writable THEN Message, 'Cannot add a variable definition to a READ-ONLY file.'

    <span class="comments">; Check parameters.</span>
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'A variable name or variable object reference is required.'
    IF N_Elements(data) EQ 0 THEN $
               Message, 'Data is required to write the variable into the file.'
    
    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
               Message, 'Invalid object with name ' + varName + ' has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Get the variable ID.</span>
    varName = varObj -> GetName()
    
    <span class="comments">; Put the file into data mode.</span>
    self -> SetMode, /DATA

    <span class="comments">; Write the data to the file.</span>
    NCDF_VarPut, self.fileID, varName, data, COUNT=count, OFFSET=offset, STRIDE=stride
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::WriteVarDef                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes the variable definition into this netCDF file.                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> WriteVarDef, varName, dimNames, DATATYPE=datatype, OBJECT=object</span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive name of the variable you wish to define.</span>
<span class="comments">;    dimNames:   The names of dimensions that have been previously defined in the       </span>
<span class="comments">;                file and that are associated with this variable. A string array.       </span>
<span class="comments">;                If dimNames is missing, then the variable is assumed to be a scalar.   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:        </span>
<span class="comments">; </span>
<span class="comments">;    CHUNK_DIMENSIONS: Set this keyword equal to a vector containing the chunk dimensions for the variable.</span>
<span class="comments">;                A new NetCDF variable is chunked by default, using a default chunk value that is </span>
<span class="comments">;                the full dimension size for limited dimensions, and 1 for unlimited dimensions.</span>
<span class="comments">;                CHUNK_DIMENSIONS must have the same number of elements as the number of dimensions </span>
<span class="comments">;                specified by Dim. If the CONTIGUOUS keyword is set, the value of the </span>
<span class="comments">;                CHUNK_DIMENSIONS keyword is ignored. Available only in IDL 8.0 and higher.</span>
<span class="comments">;    CONTIGUOUS: Set this keyword to store a NetCDF variable as a single array in a file. </span>
<span class="comments">;                Contiguous storage works well for smaller variables such as coordinate variables.</span>
<span class="comments">;                Contiguous storage works only for fixed-sized datasets (those without any unlimited </span>
<span class="comments">;                dimensions). You cant use compression or other filters with contiguous data.</span>
<span class="comments">;                If the CONTIGUOUS keyword is set, the value of the CHUNK_DIMENSIONS keyword is ignored.</span>
<span class="comments">;                The CONTIGUOUS keyword is ignored if the GZIP keyword is set. Available only in </span>
<span class="comments">;                IDL 8.0 and higher.</span>
<span class="comments">;    DATATYPE:   The netCDF data type of the variable. This is REQUIRED. The appropriate</span>
<span class="comments">;                netCDF data types are: "BYTE", "CHAR", "SHORT", "LONG" "FLOAT", or     </span>
<span class="comments">;                "DOUBLE". In IDL 8.1, the data types "STRING", "UBYTE", UINT64",</span>
<span class="comments">;                "ULONG" and "USHORT" were added.      </span>
<span class="comments">;    GZIP:       Set this keyword to an integer between zero and nine to specify the level </span>
<span class="comments">;                of GZIP compression applied to the variable. Lower compression values result </span>
<span class="comments">;                in faster but less efficient compression. This keyword is ignored if the </span>
<span class="comments">;                CHUNK_DIMENSIONS keyword is not set. This keyword is ignored if the CONTIGUOUS </span>
<span class="comments">;                keyword is set. If the GZIP keyword is set, the CONTIGUOUS keyword is ignored.</span>
<span class="comments">;                You can only use GZIP compression with NCDF 4 files. Available only in </span>
<span class="comments">;                IDL 8.0 and higher.</span>
<span class="comments">;                </span>
<span class="comments">;    OBJECT:     If a variable is successfully defined, this keyword will return the    </span>
<span class="comments">;                object reference to that variable.         </span>
<span class="comments">;    SHUFFLE:    Set this keyword to apply the shuffle filter to the variable. If the GZIP </span>
<span class="comments">;                keyword is not set, this keyword is ignored. The shuffle filter de-interlaces blocks </span>
<span class="comments">;                of data by reordering individual bytes. Byte shuffling can sometimes </span>
<span class="comments">;                increase compression density because bytes in the same block positions </span>
<span class="comments">;                often have similar values, and grouping similar values together often </span>
<span class="comments">;                leads to more efficient compression. Available only in IDL 8.0 and higher.             </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::WriteVarDef, varName, dimNames, $
    CHUNK_DIMENSIONS=chunk_dimensions, $
    CONTIGUOUS=contiguous, $
    DATATYPE=datatype, $
    GZIP=gzip, $
    OBJECT=object, $
    SHUFFLE=shuffle

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to add a variable definition.</span>
    IF ~self.writable THEN $
               Message, 'Cannot add a variable definition to a READ-ONLY file.'

    <span class="comments">; Check parameters.</span>
    IF N_Elements(varName) EQ 0 THEN $
               Message, 'Variable name is required for variable definition.'
    IF N_Elements(datatype) EQ 0 THEN Message, 'Variable data type is required.'
    
    <span class="comments">; Check the data type to see that it conforms to netCDF protocol.</span>
    CASE StrUpCase(datatype) OF
        'BYTE': tbyte = 1
        'CHAR': tchar = 1
        'DOUBLE': tdouble = 1
        'FLOAT': tfloat = 1
        'LONG': tlong = 1
        'SHORT': tshort = 1
        'INT': tshort = 1
        'STRING': tchar = 1
        'UBYTE': tubtye = 1
        'ULONG': tulong = 1
        'UINT64': tuint64 = 1
        'UINT': tuint = 1
        'USHORT': tushort = 1
        ELSE: Message, 'Unknown DATATYPE for netCDF files: ' + datatype
    ENDCASE
    
    <span class="comments">; If the dimension names are present, use them to get the dimension IDs, which are</span>
    <span class="comments">; needed to define the variable.</span>
    ndims = N_Elements(dimNames)
    IF ndims NE 0 THEN BEGIN
        dimIDs = LonArr(ndims)
        IF Size(dimNames, /TNAME) EQ 'STRING' THEN BEGIN
            FOR j=0,ndims-1 DO BEGIN
                dimObj = self.dims -> FindByName(dimNames[j],  COUNT=dimCount, /CASE_SENSITIVE)
                CASE dimCount OF
                    0: Message, 'Cannot find dimension object with the name: ' + dimNames[j]
                    1: BEGIN
                       dimIDs[j] = dimObj -> GetID()
                       END
                    2: Message, 'Found more than one dimension with the name: ' + dimNames[j]
                 ENDCASE
            ENDFOR
        ENDIF ELSE BEGIN
            dimIDs = dimNames
        ENDELSE
    ENDIF
    
    <span class="comments">; Put the file into define mode.</span>
    self -> SetMode, /DEFINE
    
    <span class="comments">; Define the variable.</span>
    IF N_Elements(dimIDs) EQ 0 THEN BEGIN
    
        release = Float(!Version.Release)
        CASE 1 OF
        
            (release LT 8.0) && (!Version.Release NE '7.1.1'): BEGIN
                varID = NCDF_VarDef(self.fileID, varName, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    LONG=tlong, $
                    SHORT=tshort)
                 END
                 
            (!Version.Release EQ '7.1.1') || ((release GE 7.2) && (release LT 8.1)): BEGIN
                varID = NCDF_VarDef(self.fileID, varName, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    CHUNK_DIMENSIONS=chunk_dimensions, $
                    CONTIGUOUS=contiguous, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    GZIP=gzip, $
                    LONG=tlong, $
                    SHORT=tshort, $
                    SHUFFLE=shuffle)
                 END
                 
            release GE 8.1: BEGIN
                varID = NCDF_VarDef(self.fileID, varName, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    CHUNK_DIMENSIONS=chunk_dimensions, $
                    CONTIGUOUS=contiguous, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    GZIP=gzip, $
                    LONG=tlong, $
                    SHORT=tshort, $
                    SHUFFLE=shuffle, $
                    STRING=tstring, $
                    UBYTE=tubyte, $
                    UINT64=tuint64, $
                    ULONG=tulong, $
                    USHORT=tushort)
                 END
        ENDCASE
        
    ENDIF ELSE BEGIN
    
        release = Float(!Version.Release)
        CASE 1 OF
        
            (release LT 8.0) && (!Version.Release NE '7.1.1'): BEGIN
                varID = NCDF_VarDef(self.fileID, varName, dimIDs, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    LONG=tlong, $
                    SHORT=tshort)
                 END
                 
            (!Version.Release EQ '7.1.1') || ((release GE 7.2) && (release LT 8.1)): BEGIN
                varID = NCDF_VarDef(self.fileID, varName, dimIDs, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    CHUNK_DIMENSIONS=chunk_dimensions, $
                    CONTIGUOUS=contiguous, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    GZIP=gzip, $
                    LONG=tlong, $
                    SHORT=tshort, $
                    SHUFFLE=shuffle)
                 END
                 
            release GE 8.1: BEGIN
                varID = NCDF_VarDef(self.fileID, varName, dimIDs, $
                    BYTE=tbyte, $
                    CHAR=tchar, $
                    CHUNK_DIMENSIONS=chunk_dimensions, $
                    CONTIGUOUS=contiguous, $
                    DOUBLE=tdouble, $
                    FLOAT=tfloat, $
                    GZIP=gzip, $
                    LONG=tlong, $
                    SHORT=tshort, $
                    SHUFFLE=shuffle, $
                    STRING=tstring, $
                    UBYTE=tubyte, $
                    UINT64=tuint64, $
                    ULONG=tulong, $
                    USHORT=tushort)
                 END
         ENDCASE
    ENDELSE
    
    <span class="comments">; Create a variable object and add it to the variable list.</span>
    self -> CreateVarObj, varName
    
    <span class="comments">; Need to return the variable object?</span>
    IF Arg_Present(object) THEN BEGIN
        object = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
        IF varCount EQ 0 THEN $
            Message, 'Cannot find an object with name ' + varName + $
                ' in the object container.'
    ENDIF
    
END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::WriteDim                                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes the variable definition into this netCDF file.                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> WriteDim, dimName, dimSize, UNLIMITED=unlimited, OBJECT=object  </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    dimName:    The case sensitive name of the dimension you wish to define.           </span>
<span class="comments">;    dimSize:    The size of the dimension. Required, unless UNLIMITED is set.          </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    UNLIMITED:  Set this keyword if you wish this to be an unlimited dimension.        </span>
<span class="comments">;                In general, only one unlimited dimension is allowed per netCDF file.   </span>
<span class="comments">;    OBJECT:     If a dimension is successfully defined, this keyword will return the   </span>
<span class="comments">;                dimension object reference to that dimension.                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::WriteDim, dimName, dimSize, UNLIMITED=unlimited, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to add a dimension.</span>
    IF ~self.writable THEN Message, 'Cannot add a dimension to a READ-ONLY file.'

    <span class="comments">; Check parameters.</span>
    IF N_Elements(dimName) EQ 0 THEN $
               Message, 'The name of the dimension is required.'
    IF ~Keyword_Set(unlimited) THEN BEGIN
        IF N_Elements(dimSize) EQ 0 THEN $
               Message, 'The size of the dimension is required.'
    ENDIF
    
    <span class="comments">; Put the file into define mode</span>
    self -> SetMode, /DEFINE
    
    <span class="comments">; Add the dimension to the file.</span>
    IF Keyword_Set(unlimited) THEN BEGIN
        void = NCDF_DimDef(self.fileID, dimName, /UNLIMITED)
    ENDIF ELSE BEGIN
        void = NCDF_DimDef(self.fileID, dimName, dimSize)
    ENDELSE
    
    <span class="comments">; Create a dimension object and add it to the dimension container.</span>
    self -> CreateDimObj, dimName
    
    <span class="comments">; Need to return the dimension object?</span>
    IF Arg_Present(object) THEN BEGIN
        object = self.dims -> FindByName(dimName, COUNT=dimCount, /CASE_SENSITIVE)
        IF dimCount EQ 0 THEN $
            Message, 'Cannot find an object with name ' + dimName + $
                ' in the object container.'
    ENDIF

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::WriteGlobalAttr                                                        </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes a global attribute into this netCDF file.                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> WriteGlobalAttr, attrName, attrValue, DATATYPE=datatype, OBJECT=object      </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    attrName:   The case sensitive name of the global attribute you wish to write.     </span>
<span class="comments">;    attrValue:  The value of the attribute. Required.                      </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    DATATYPE:   The netCDF data type of the variable. This is REQUIRED. The appropriate</span>
<span class="comments">;                netCDF data types are: "BYTE", "CHAR", "SHORT", "LONG" "FLOAT", or     </span>
<span class="comments">;                "DOUBLE".                                                  </span>
<span class="comments">;    OBJECT:     If a dimension is successfully defined, this keyword will return the   </span>
<span class="comments">;                dimension object reference to that dimension.                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::WriteGlobalAttr, attrName, attrValue, DATATYPE=datatype, OBJECT=object

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to add a global attribute.</span>
    IF ~self.writable THEN $
               Message, 'Cannot add a global attribute to a READ-ONLY file.'
    
    <span class="comments">; Check parameters.</span>
    IF N_Elements(attrName) EQ 0 THEN Message, 'The attribute name is required.'
    IF N_Elements(attrValue) EQ 0 THEN Message, 'The attribute value is required.'
    IF N_Elements(datatype) EQ 0 THEN datatype = NCDF_CastDataType(attrValue)
    
    <span class="comments">; Make sure the attribute name doesn't have spaces.</span>
    parts = StrSplit(attrName, /EXTRACT)
    IF N_Elements(parts) GT 1 THEN $
        Message, 'Global attribute names cannot have spaces in them.'
    
    <span class="comments">; Set the appropriate netCDF data type keyword.</span>
    CASE StrUpCase(datatype) OF
        'BYTE': tbyte = 1
        'CHAR': tchar = 1
        'DOUBLE': tdouble = 1
        'FLOAT': tfloat = 1
        'LONG': tlong = 1
        'SHORT': tshort = 1
        'INT': tshort = 1
        'STRING': tchar = 1
        'ULONG': tlong = 1
        'UINT': tlong = 1
        ELSE: Message, 'Unknown DATATYPE for netCDF files: ' + datatype        
    ENDCASE
    
    <span class="comments">; Put the file into define mode</span>
    self -> SetMode, /DEFINE
    
    <span class="comments">; Add the attribute to the file.</span>
    NCDF_AttPut, self.fileID, attrName, attrValue, $
        /GLOBAL, $
        BYTE=tbyte, $
        CHAR=tchar, $
        DOUBLE=tdouble, $
        FLOAT=tfloat, $
        LENGTH=length, $
        LONG=tlong, $
        SHORT=tshort
    
    <span class="comments">; Create an attribute object and add it to the attribute container.</span>
    self -> CreateAttrObj, attrName
    
    <span class="comments">; Need to return the dimension object?</span>
    IF Arg_Present(object) THEN BEGIN
        object = self.attrs -> FindByName(attrName, COUNT=attrCount, /CASE_SENSITIVE)
        IF attrCount EQ 0 THEN $
            Message, 'Cannot find an object with name ' + attrName + $
                ' in the object container.'
    ENDIF

END


<span class="comments">;------------------------------------------------------------------------------------------;</span>
<span class="comments">;                                                                           </span>
<span class="comments">; NAME:                                                                     </span>
<span class="comments">;    NCDF_File::WriteVarAttr                                                           </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Purpose:                                                                  </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    Writes a variable attribute into this netCDF file.                                                               </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Method Syntax:                                                            </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    obj -> WriteVarAttr, varName, attrName, attrValue, DATATYPE=datatype   </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Auguments:                                                                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    varName:    The case sensitive variable name for which the attribute is being      </span>
<span class="comments">;                defined.                                                   </span>
<span class="comments">;    attrName:   The case sensitive name of the global attribute you wish to write.     </span>
<span class="comments">;    attrValue:  The value of the attribute. Required.                      </span>
<span class="comments">;                                                                           </span>
<span class="comments">; Keywords:                                                                 </span>
<span class="comments">;                                                                           </span>
<span class="comments">;    DATATYPE:   The netCDF data type of the variable. The appropriate netCDF data types</span>
<span class="comments">;                are: "BYTE", "CHAR", "SHORT", "LONG" "FLOAT", or "DOUBLE". </span>
<span class="comments">;    OBJECT:     If a dimension is successfully defined, this keyword will return the   </span>
<span class="comments">;                dimension object reference to that dimension.                </span>
<span class="comments">;                                                                           </span>
<span class="comments">;------------------------------------------------------------------------------------------;</span>
PRO NCDF_File::WriteVarAttr, varName, attrName, attrValue, DATATYPE=datatype

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        self.errorLogger -> AddError
        RETURN
    ENDIF
    
    <span class="comments">; The file has to be writable to add a variable attribute.</span>
    IF ~self.writable THEN Message, 'Cannot add a variable attribute to a READ-ONLY file.'
    
    <span class="comments">; Check parameters.</span>
    IF N_Elements(attrName) EQ 0 THEN Message, 'The attribute name is required.'
    IF N_Elements(attrValue) EQ 0 THEN Message, 'The attribute value is required.'
    IF N_Elements(varName) EQ 0 THEN Message, 'A variable name or object is required.'
    IF N_Elements(datatype) EQ 0 THEN datatype = NCDF_CastDataType(attrValue)
    
    <span class="comments">; Make sure the attribute name doesn't have spaces.</span>
    parts = StrSplit(attrName, /EXTRACT)
    IF N_Elements(parts) GT 1 THEN $
        Message, 'Variable attribute names cannot have spaces in them.'
    
    <span class="comments">; Were you passed the name of a variable or a variable object?</span>
    CASE Size(varName, /TNAME) OF
    
        'STRING': BEGIN
            varObj = self.vars -> FindByName(varName, COUNT=varCount, /CASE_SENSITIVE)
            IF varCount EQ 0 THEN $
               Message, 'Cannot find a variable object with name ' + varName + '.'
            IF ~Obj_Valid(varObj) THEN $
                Message, 'Invalid object with name "' + varName + '" has been found.'
            END
            
         'OBJREF': BEGIN
            varObj = varName
            END
    
        ELSE: Message, 'Input variable name or object is the wrong data type.'
    ENDCASE
    
    <span class="comments">; Is this a valid variable object?</span>
    IF ~Obj_Valid(varObj) THEN Message, 'Invalid variable object. Cannot add attribute.'
    
    <span class="comments">; Put the file into define mode</span>
    self -> SetMode, /DEFINE
    
    <span class="comments">; Add the attribute to the variable.</span>
    varObj -> AddAttr, attrName, attrValue, DATATYPE=datatype
    
END


<span class="comments">;</span>
<span class="comments">;--------------------------------------------------------------------------------------------------</span>
<span class="comments">; NAME:</span>
<span class="comments">;       NCDF_FILE::CLEANUP</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The cleanup method for the NCDF_FILE object.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       </span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">;----------------------------------------------------------------------------------------------</span>
PRO NCDF_File::CLEANUP

   IF self.fileID GT 0 THEN NCDF_Close, self.fileID
   self.errorLogger -> CloseFile
   Obj_Destroy, self.errorLogger
   Obj_Destroy, self.vars
   Obj_Destroy, self.attrs
   Obj_Destroy, self.dims
   
END
   

<span class="comments">;--------------------------------------------------------------------------------------------------</span>
<span class="comments">; NAME:</span>
<span class="comments">;       NCDF_FILE::INIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The initialization method for the NCDF_FILE object.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename:  The name of a netCDF file to open.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       </span>
<span class="comments">;       ALERT:     Set this keyword if you wish to have alert from the object's error logger.</span>
<span class="comments">;                  Input. Default is 1.</span>
<span class="comments">;       </span>
<span class="comments">;       BROWSE:    If this keyword is set, the Browse Window is invoked as soon</span>
<span class="comments">;                  as the object is initiated. Input. Default is 0.</span>
<span class="comments">;</span>
<span class="comments">;       CLOBBER:   Set this keyword if you are opening a netCDF file that already exists and </span>
<span class="comments">;                  you want to overwrite the existing file. Input. Default is 0.</span>
<span class="comments">;                  </span>
<span class="comments">;       CREATE:    Set this keyword if you wish to create a new netCDF file to write</span>
<span class="comments">;                  into. Input. Default is 0, which means the file will be opened as </span>
<span class="comments">;                  "read-only".</span>
<span class="comments">;       </span>
<span class="comments">;       DELETE_ON_DESTROY:  Set this keyword if you wish to delete the error log file when</span>
<span class="comments">;                  the ErrorLogger object is destroyed. This will only happen if the ErrorLogger</span>
<span class="comments">;                  object is not in an error state. Input. Default is 1.</span>
<span class="comments">;                  </span>
<span class="comments">;       ERRORLOGGERNAME: The name of the ErrorLogger filename that captures errors from this</span>
<span class="comments">;                   program. Optional. If not provided a default name will be provided, based</span>
<span class="comments">;                   on the current local system time.</span>
<span class="comments">;                  </span>
<span class="comments">;       MODIFY:    Set this keyword if you wish to modify (write to) a file you are opening.</span>
<span class="comments">;                  If not set, the file will be opened as "read-only".</span>
<span class="comments">;                  </span>
<span class="comments">;       NETCDF4_FORMAT: Set this keyowrd to create a new NetCDF 4 file. In NetCDF 4 files, data </span>
<span class="comments">;                  is created and accessed with the HDF5 library. NetCDF 4 files are valid HDF5 files, </span>
<span class="comments">;                  and may be read with HDF5 routines. Note that if a NetCDF 4 file is modified using </span>
<span class="comments">;                  the HDF5 routines, rather than with the NetCDF 4 routines, the file is no longer a </span>
<span class="comments">;                  valid NetCDF 4 file, and may no longer be readable with the NetCDF routines.</span>
<span class="comments">;                  You need IDL 8.0 to use this keyword.</span>
<span class="comments">;                  </span>
<span class="comments">;       NOCLUTTER: Set the keyword to set the ErrorLogger NOCLUTTER keyword.</span>
<span class="comments">;</span>
<span class="comments">;       TIMESTAMP: Set this keyword is you want the ErrorLogger filename to have a time stamp</span>
<span class="comments">;                  appended to it.</span>
<span class="comments">;</span>
<span class="comments">;----------------------------------------------------------------------------------------------</span>
FUNCTION NCDF_FILE::INIT, filename, $
    ALERT=alert, $
    BROWSE=browse, $
    CLOBBER=clobber, $
    CREATE=create, $
    DELETE_ON_DESTROY=delete_on_destroy, $
    ERRORLOGGERNAME=errorLoggerName, $
    MODIFY=modify, $
    NETCDF4_FORMAT=netcdf4_format, $
    NOCLUTTER=noclutter, $
    TIMESTAMP=timestamp

    <span class="comments">; Compiler options.</span>
    Compile_Opt DEFINT32
    Compile_Opt STRICTARR
    Compile_Opt STRICTARRSUBS
    Compile_Opt LOGICAL_PREDICATE

    <span class="comments">; Error handling. Return 0 if can't finish.</span>
    CATCH, theError
    IF theError NE 0 THEN BEGIN
       CATCH, /CANCEL
       self.errorLogger -> AddError
       Obj_Destroy, self.errorLogger
       IF self.fileID GT 0 THEN NCDF_Close, self.fileID
       RETURN, 0
    ENDIF
   
    <span class="comments">; Create the error logger.</span>
    self.errorLogger = Obj_New('ErrorLogger', errorLoggerName, ALERT=1, $
        DELETE_ON_DESTROY=1, TIMESTAMP=Keyword_Set(timestamp), NOCLUTTER=noclutter)
        
    <span class="comments">; Check keywords.</span>
    IF N_Elements(filename) EQ 0 THEN BEGIN
        filters = ['*.nc', '*.ncdf*']
        filename = Dialog_Pickfile(FILTER=filters, TITLE='Select netCDF File...')
        IF filename EQ "" THEN RETURN, 0
    ENDIF

    <span class="comments">; Make sure you have an absolute filename.</span>
    root_name = File_Basename(filename)
    IF root_name EQ filename THEN BEGIN
        CD, CURRENT=thisDir
        absFilename = FilePath(ROOT_DIR=thisDir, filename)
        filename = absFilename
    ENDIF
    
    <span class="comments">; Set default values, if keywords are not already set.</span>
    SetDefaultValue, alert, 1, /Boolean
    SetDefaultValue, create, 0, /Boolean
    SetDefaultValue, clobber, 0, /Boolean
    SetDefaultValue, modify, 0, /Boolean
    SetDefaultValue, delete_on_destroy, 1, /Boolean
    SetDefaultValue, noclutter, 0, /Boolean
    SetDefaultValue, netcdf4_format, 0, /Boolean
    self.errorLogger -> SetProperty, ALERT=alert, DELETE_ON_DESTROY=delete_on_destroy, NOCLUTTER=noclutter
    
    <span class="comments">; If you are not going to create the file, you are going to open it.</span>
    <span class="comments">; If you want to modify the file, it is going to be writable.</span>
    mode = create ? 'CREATE' : 'OPEN'
    self.writable = (mode EQ 'OPEN' && modify) || mode EQ 'CREATE'
    
    <span class="comments">; Are you creating the file? Make sure it doesn't already exist. If it does,</span>
    <span class="comments">; you will have to clobber it.</span>
    IF mode EQ 'CREATE' THEN BEGIN
        IF File_Test(filename) THEN BEGIN
            CASE clobber OF
                1: File_Delete, filename, /ALLOW_NONEXISTENT
                0: Message, "The specified netCDF file already exists and cannot " + $
                        "be overwritten unless CLOBBER is set."
            ENDCASE
        ENDIF
    ENDIF

    <span class="comments">; If the user wants to open the file, make sure it is possible.</span>
    IF mode EQ 'OPEN' THEN BEGIN
        IF ~File_Test(filename, /READ) THEN $
            Message, "The specified netCDF file cannot be opened for reading: " + filename
        IF modify THEN BEGIN
            IF ~File_Test(filename, /WRITE) THEN $
                Message, "The specified netCDF file cannot be opened for writing: " + filename
        ENDIF
    ENDIF
    
    <span class="comments">; Store the filename.</span>
    self.filename = filename

    <span class="comments">; Open or create the file.</span>
    CASE mode OF
        'OPEN': BEGIN
               self.fileID = NCDF_Open(self.filename, WRITE=self.writable)
               self.define = 0
               END
        'CREATE': BEGIN
               IF (!Version.Release EQ '7.1.1') || (Float(!Version.Release) GE 7.2) THEN BEGIN
                   self.fileID = NCDF_Create(self.filename, CLOBBER=clobber, NETCDF4_FORMAT=netcdf4_format)
               ENDIF ELSE BEGIN
                   self.fileID = NCDF_Create(self.filename, CLOBBER=clobber)
               ENDELSE
               self.define = 1
               END
    ENDCASE
    
    <span class="comments">; Initialize object containers for contents.</span>
    self.vars = Obj_New('NCDF_Container')
    self.attrs = Obj_New('NCDF_Container')
    self.dims = Obj_New('NCDF_Container')
    
    <span class="comments">; Did the user want to browse this file?</span>
    IF Keyword_Set(browse) THEN self -> Browse
    
    <span class="comments">; If this file has been opened for reading or modifying, then parse it.</span>
    IF ~self.writable THEN self -> Parsefile
    IF Keyword_Set(modify) THEN self -> Parsefile
        
    RETURN, 1
    
END <span class="comments">; --------------------------------------------------------------------------------------------</span>


PRO NCDF_File__DEFINE, class

    class = { NCDF_FILE, $
              filename: "", $           <span class="comments">; The name of the netCDF file.</span>
              fileID: 0L, $             <span class="comments">; The netCDF file ID.</span>
              errorlogger: Obj_New(), $ <span class="comments">; The error logger object.</span>
              vars: Obj_New(), $        <span class="comments">; An object container containing variable objects.</span>
              attrs: Obj_New(), $       <span class="comments">; An object container containing global attribute objects.</span>
              dims: Obj_New(), $        <span class="comments">; An object container containing dimension objects.</span>
              writable: 0B, $           <span class="comments">; A flag that indicates the file is writable.</span>
              fileHasBeenParsed: 0B, $  <span class="comments">; A flag that is 1 when the file has been parsed.</span>
              file_extension: "", $     <span class="comments">; A file extension that is used with Dialog_Pickfile()</span>
              define: 0B  $             <span class="comments">; A flag that indicates the file is in define mode. </span>
            }
            
END <span class="comments">; --------------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>