<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:24 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgotsu_threshold.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgotsu_threshold.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgOTSU_THRESHOLD</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of this function is to find an optimal threshold for separating</span>
<span class="comments">;   a bimodal distribution of pixels in an image histogram. The Otsu Threshold method</span>
<span class="comments">;   is explained here: http://www.labbookpages.co.uk/software/imgProc/otsuThreshold.html.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2012, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of this function is to find an optimal threshold for separating</span>
<span class="comments">; a bimodal distribution of pixels in an image histogram. The algorithm used is the</span>
<span class="comments">; "faster approach" algorithm explained </span>
<span class="comments">; `on this web page &lt;http://www.labbookpages.co.uk/software/imgProc/otsuThreshold.html>`.</span>
<span class="comments">;</span>
<span class="comments">; .. image:: cgotsu_threshold.png</span>
<span class="comments">; </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Utility</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     The optimal threshold that separates two populations of pixels is returned.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, </span>
<span class="comments">;       The data from which the histogram is created.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    binsize: in, optional</span>
<span class="comments">;       The binsize of the histogram. By default, Scott's Choice of bin size for histograms is used::</span>
<span class="comments">;                         </span>
<span class="comments">;           binsize = (3.5 * StdDev(data)) / N_Elements(data)^(0.3333)</span>
<span class="comments">;           </span>
<span class="comments">;       unless the data is byte type. Then a BINSIZE of 1 is used by default</span>
<span class="comments">;                            </span>
<span class="comments">;       If BINSIZE in not defined, and NBINS is defined, the BINSIZE is calcuated as::</span>
<span class="comments">;                         </span>
<span class="comments">;            binsize = (Max(dataToHistogram) - Min(dataToHistogram)) / (NBINS -1)</span>
<span class="comments">;                             </span>
<span class="comments">;       While it is pointed out in the HISTOGRAM documentation, it is extremely</span>
<span class="comments">;       important that the BINSIZE be of the same data type as the data you are going to</span>
<span class="comments">;       calculate the histogram of. If it is not VERY strange things can happen. I've</span>
<span class="comments">;       tried to protect you from most of the bad things, but I don't have a high confidence</span>
<span class="comments">;       level that I have done it for every situation. If you see something that "just don't</span>
<span class="comments">;       look right", I would check first to see if your data types match. That might solve</span>
<span class="comments">;       all your problems.</span>
<span class="comments">;    example: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if you wish to use the example data from the </span>
<span class="comments">;       `reference documentation &lt;http://www.labbookpages.co.uk/software/imgProc/otsuThreshold.html>`.</span>
<span class="comments">;    histdata: out, optional</span>
<span class="comments">;       The output value of the internal HISTOGRAM command.</span>
<span class="comments">;    l64: in, optional, type=boolean, default=0                       </span>
<span class="comments">;       If set, the return value of HISTOGRAM are 64-bit integers, rather than</span>
<span class="comments">;       the default 32-bit integers. Set by default for data types greater than or</span>
<span class="comments">;       equal to 12.</span>
<span class="comments">;    locations: out, optional</span>
<span class="comments">;       Starting locations of each bin. (See the HISTOGRAM documentation for details.)</span>
<span class="comments">;    max: in, optional</span>
<span class="comments">;       The maximum value to use in calculating input histogram. Equivalent to the MAX keyword</span>
<span class="comments">;       in the HISTOGRAM documentation.</span>
<span class="comments">;    min: in, optional</span>
<span class="comments">;       The minimum value to use in calculating input histogram. Equivalent to the MIN keyword</span>
<span class="comments">;       in the HISTOGRAM documentation.</span>
<span class="comments">;    missing: in, optional</span>
<span class="comments">;       The value that should be represented as "missing" and not used in the histogram.</span>
<span class="comments">;       Be aware that if the input data is not of type "float" or "double" that the input</span>
<span class="comments">;       data will be converted to floating point prior to calculating the histogram.</span>
<span class="comments">;    nan: in, optional, type=boolean, default=0   </span>
<span class="comments">;       If set, ignore NAN values in calculating and plotting histogram.</span>
<span class="comments">;    nbins: in, optional, type=integer</span>
<span class="comments">;       The number of output bins in the histogram. Meaning is slightly different from</span>
<span class="comments">;       meaning in the HISTOGRAM command. Used only to calculate BINSIZE when BINSIZE is</span>
<span class="comments">;       not specified. In this case, binsize = rangeofData/(nbins-1).</span>
<span class="comments">;    omax: out, optional</span>
<span class="comments">;       The maximum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    omin: out, optional</span>
<span class="comments">;       The minimum output value used to construct the histogram. (See HISTOGRAM documentation.)</span>
<span class="comments">;    plotit: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, a histogram of the data is plotted along with a plot of the</span>
<span class="comments">;       between class variance to show the selected threshold.</span>
<span class="comments">;    reverse_indices: out, optional</span>
<span class="comments">;       The list of reverse indices returned from the HISTOGRAM command. (See HISTOGRAM documentation.)</span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Set the `Example` keyword to use the data from the reference page.</span>
<span class="comments">;        </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Change History::</span>
<span class="comments">;       Written by:  David W. Fanning, 13 November 2012, from a program named OTSU_THRESHOLD by Carl Salvaggio and</span>
<span class="comments">;           modified by Gianguido Cianci.</span>
<span class="comments">;       The OTSU_THRESHOLD algorithm used previously made many assumptions about the data. The algorithm used here</span>
<span class="comments">;           has been completely rewritten to comply with the values in the reference page and to avoid making </span>
<span class="comments">;           assumptions about the data used to create the histogram. 21 November 2012. DWF.</span>
<span class="comments">;       Modified to set L64 keyword if data type GE 14 (suggested by user). 22 November 2012. DWF.</span>
<span class="comments">;       Modified the threshold value to use DIndGen instead of IndGen, which was causing incorrect</span>
<span class="comments">;           results with integer data. 24 November 2012. DWF.</span>
<span class="comments">;         </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
FUNCTION cgOTSU_THRESHOLD, $        <span class="comments">; The program name.</span>
   data, $                          <span class="comments">; The data to threshold.</span>
   BINSIZE=binsize, $               <span class="comments">; The histogram bin size.</span>
   EXAMPLE=example, $               <span class="comments">; Set this keyword to see the reference page example.</span>
   HISTDATA=histdata, $             <span class="comments">; The output of the HISTOGRAM command.</span>
   L64=l64, $                       <span class="comments">; Input for HISTOGRAM.</span>
   LOCATIONS=locations, $           <span class="comments">; The histogram bin locations.</span>
   MAX=max, $                       <span class="comments">; The maximum value to HISTOGRAM.</span>
   MIN=min, $                       <span class="comments">; The minimum value to HISTOGRAM.</span>
   MISSING=missing, $               <span class="comments">; The value that indicates "missing" data to be excluded from the histgram.</span>
   NAN=nan, $                       <span class="comments">; Check for NAN.</span>
   NBINS=nbins, $                   <span class="comments">; The number of bins to display.</span>
   OMAX=omax, $                     <span class="comments">; The maximum value of the histogram on output.</span>
   OMIN=omin, $                     <span class="comments">; The minimum value of the histogram on output.</span>
   PLOTIT=plotit, $                 <span class="comments">; Set this keyword to see the results of the thresholding algorithm.</span>
   REVERSE_INDICES=ri               <span class="comments">; The reverse indices of the histogram.</span>
    
   Compile_Opt idl2

   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message()
      IF N_Elements(nancount) EQ 0 THEN BEGIN
            IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
      ENDIF ELSE BEGIN
            IF nancount EQ 0 THEN BEGIN
                IF N_Elements(_data) NE 0 THEN data = Temporary(_data)
            ENDIF
      ENDELSE
      RETURN, -9999
   ENDIF
   
   <span class="comments">; Need data or the EXAMPLE keyword to continue.</span>
   IF N_Elements(data) EQ 0 && ~Keyword_Set(example) THEN BEGIN
       Message, 'Data values to threshold are required.'
   ENDIF
   
   <span class="comments">; Are we doing an example? Use the data from the reference page at</span>
   <span class="comments">; http://www.labbookpages.co.uk/software/imgProc/otsuThreshold.html.</span>
   IF Keyword_Set(example) THEN BEGIN
      data = [Replicate(0,8), Replicate(1,7), Replicate(2,2), Replicate(3,6), Replicate(4,9), Replicate(5,4)]
      binsize = 1
   ENDIF
   
   <span class="comments">; Get the data type. Important to match data type with binsize type. Otherwise</span>
   <span class="comments">; strange things occur in the Histogram command.</span>
   dataType = Size(data, /TYPE)
   
   <span class="comments">; If this is byte data, then use a BINSIZE of 1, unless instructed otherwise.</span>
   IF dataType EQ 1 THEN BEGIN
      IF (N_Elements(binsize) EQ 0) && (N_Elements(nbins) EQ 0) THEN binsize = 1B
   ENDIF
   
   <span class="comments">; If the data type is 14 or above, set the L64 keyword. Necessary to give enough</span>
   <span class="comments">; precision in the Otsu calculations.</span>
   IF dataType GE 14 THEN L64 = 1
      
   <span class="comments">; Check the data for NANs and alert the user if the NAN keyword is not set.</span>
   IF dataType EQ 4 OR datatype EQ 5 THEN BEGIN
        goodIndices = Where(Finite(data), count, NCOMPLEMENT=nancount, COMPLEMENT=nanIndices)
        IF nancount GT 0 THEN BEGIN
           IF ~Keyword_Set(nan) THEN BEGIN
               Message, 'NANs found in the data. NAN keyword is set to 1.', /INFORMATIONAL
               nan = 1
           ENDIF
        ENDIF 
   ENDIF 

   <span class="comments">; The only sensible way to proceed is to make a copy of the data. Otherwise, I'll have</span>
   <span class="comments">; a devil of a time putting it back together again at the end. There is a bug in</span>
   <span class="comments">; HISTOGRAM when using BYTE data, so convert that here</span>
   IF N_Elements(_data) EQ 0 THEN BEGIN
      IF Size(data, /TNAME) EQ 'BYTE' THEN BEGIN
          _data = Fix(data) 
       ENDIF ELSE BEGIN
          _data = data
       ENDELSE
   ENDIF
   
   <span class="comments">; If you have any "missing" data, then the data needs to be converted to float</span>
   <span class="comments">; and the missing data set to F_NAN.</span>
   IF N_Elements(missing) NE 0 THEN BEGIN
      missingIndices = Where(_data EQ missing, missingCount)
      IF missingCount GT 0 THEN BEGIN
         CASE datatype OF
            4: _data[missingIndices] = !Values.F_NAN
            5: _data[missingIndices] = !Values.D_NAN
            ELSE: BEGIN
                _data = Float(_data)
                dataType = 4
                _data[missingIndices] = !Values.F_NAN
                END
         ENDCASE
         nan = 1
      ENDIF ELSE BEGIN
        IF missingCount EQ N_Elements(_data) THEN $
            Message, 'All values are "missing"!'
      ENDELSE
   ENDIF
   
   <span class="comments">; Check for histogram keywords.</span>
   IF N_Elements(binsize) EQ 0 THEN BEGIN
      range = Max(_data, /NAN) - Min(_data, /NAN)
      IF N_Elements(nbins) EQ 0 THEN BEGIN  <span class="comments">; Scott's Choice</span>
         binsize = (3.5D * StdDev(_data, /NAN))/N_Elements(_data)^(1./3.0D) 
         IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDIF ELSE BEGIN
         binsize = range / (nbins -1)
         IF dataType LE 3 THEN binsize = Round(binsize) > 1
         binsize = Convert_To_Type(binsize, dataType)
      ENDELSE
   ENDIF ELSE BEGIN
       IF Size(binsize, /TYPE) NE dataType THEN BEGIN
          IF dataType LE 3 THEN binsize = Round(binsize) > 1
          binsize = Convert_To_Type(binsize, dataType)
       ENDIF
   ENDELSE
   IF N_Elements(min) EQ 0 THEN min = Min(_data, NAN=nan)
   IF N_Elements(max) EQ 0 THEN max = Max(_data, NAN=nan)

   <span class="comments">; Calculate the histogram.</span>
    histdata = Histogram(_data, $
      BINSIZE=binsize, $
      L64=l64, $
      MAX=max, $
      MIN=min, $
      NAN=nan, $
      LOCATIONS=locations, $
      OMAX=omax, $
      OMIN=omin, $
      REVERSE_INDICES=ri)
      
   <span class="comments">; Lot's of bad things can happen next. Let's pretend we don't know about them.</span>
   except = !Except
   !Except = 0
   
   <span class="comments">; The threshold values to evaluate.</span>
   thresholds = DIndGen(N_Elements(histdata)) * binsize + oMin
   
   <span class="comments">; Create a cumulative distribution to calculate the weighting factors.</span>
   <span class="comments">; Subscripting of the background weights and addition of a 0 value</span>
   <span class="comments">; is necessary to conform with the outputs in the reference documenation.</span>
   <span class="comments">; I presume it is because the first threshold should be on the near side</span>
   <span class="comments">; of the first bin, rather than on the far side.</span>
   cdf = Total(histdata, /DOUBLE, /CUMULATIVE)
   reverseCDF = Total(Reverse(histdata), /DOUBLE, /CUMULATIVE)
   Wb = [0,cdf[0:N_Elements(cdf)-2]] / Total(histdata)
   Wf = Reverse(reverseCDF / Total(histdata))
   
   <span class="comments">; Find the means. </span>
   mu_b = Total(histdata * thresholds, /DOUBLE, /CUMULATIVE) / cdf
   mu_b = [0, mu_b[0:N_Elements(mu_b)-2]]
   mu_f = Reverse(Total(Reverse(histdata) * Reverse(thresholds), /DOUBLE, /CUMULATIVE) / reverseCDF)

   <span class="comments">; Calculate the Between-Class variance.</span>
   betweenClassVariance = Wb * Wf * (mu_b - mu_f)^2
   
   <span class="comments">; The threshold is found by locating the maximum value and</span>
   <span class="comments">; obtaining the index into the array.</span>
   maximumVariance = Max(betweenClassVariance, thresholdIndex)
   threshold = thresholdIndex*binsize + oMin

   <span class="comments">; Useful printouts if we are doing the example.</span>
   IF Keyword_Set(example) THEN BEGIN
       Print, 'Wb:        ', Wb
       Print, 'Wf:        ', Wf
       Print, 'Mu_b:      ', mu_b
       Print, 'Mu_f:      ', mu_f
       Print, 'Variance:  ', betweenClassVariance
       Print, 'Threshold: ', threshold
       
       cgDisplay, Title='Example OTSU Threshold Method', /Free
       !P.Multi = [0,1,2]
       cgHistoplot, _data, Binsize=binsize, /Fill
       cgPlots, [threshold, threshold], !Y.CRange, Color='blue', Thick=2
       cgPlot, betweenClassVariance, Title='Between Class Variance'
       cgPlots, [threshold, threshold], !Y.CRange, Color='blue', Thick=2
       cgText, 0.23, 2.60, 'Threshold: ' + String(threshold, Format='(I0)'), Color='blue', Font=0
       !P.Multi = 0
   ENDIF
   
   <span class="comments">; Need a plot?</span>
   IF Keyword_Set(plotit) THEN BEGIN
       cgDisplay, Title='OTSU Threshold Results', /Free
       !P.Multi = [0,1,2]
       cgHistoplot, _data, $
          BINSIZE=binsize, $
          L64=l64, $
          LOCATIONS=locations, $
          MAXINPUT=max, $
          MININPUT=min, $
          NAN=nan, $
          /Fill
       cgPlots, [threshold, threshold], !Y.CRange, Color='blue', Thick=2
       cgPlot, locations, betweenClassVariance, Title='Between Class Variance Threshold: ' + $
           String(threshold,Format='(F0.2)'), XStyle=1
       cgPlots, [threshold, threshold], !Y.CRange, Color='blue', Thick=2
       !P.Multi = 0
   ENDIF
   
   <span class="comments">; Clean up.</span>
   !Except = except
   
   <span class="comments">; Return result.</span>
   RETURN, threshold
   
END
</code>
    </div>
  </body>
</html>