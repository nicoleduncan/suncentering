<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:23 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgmapvector__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgmapvector__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgMapVector</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This object allows vectors (arrows) to be placed as annotations on map </span>
<span class="comments">;   projections created with the cgMap coordinate object.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This object allows vectors (arrows) to be placed as annotations on map </span>
<span class="comments">;   projections created with the cgMap coordinate object.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Map Projections</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;   FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;      David W. Fanning </span>
<span class="comments">;      1645 Sheely Drive</span>
<span class="comments">;      Fort Collins, CO 80526 USA</span>
<span class="comments">;      Phone: 970-221-0438</span>
<span class="comments">;      E-mail: david@idlcoyote.com</span>
<span class="comments">;      Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by David W. Fanning, 21 November 2011.</span>
<span class="comments">;        Tested and bugs fixed. 17 Sept 2012. DWF.</span>
<span class="comments">;        Bug fix in draw method when passing lat/lon vectors. 6 Jan 2013. DWF.</span>
<span class="comments">;        Added PALETTE keyword to allow the vectors to be drawn in colors scaled</span>
<span class="comments">;           to vector magnitude. 6 Jan 2012. DWF.</span>
<span class="comments">;        The CLIP keyword was not working correctly and was fixed 29 April 2013. DWF.</span>
<span class="comments">;        </span>
<span class="comments">;                </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   The initialization method for the object.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    mapCoord: in, required, type=object</span>
<span class="comments">;       A map coordinate object that will set up a map coordinate data space.</span>
<span class="comments">;       Required to convert lat/lon values to projected meter space. A cgMap object.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object is added to the resizeable graphics</span>
<span class="comments">;        window, cgWindow. The DRAW method of the object is called in cgWindow.</span>
<span class="comments">;     clip: in, optional, type=fltarr(4)</span>
<span class="comments">;        The coordinates of a rectangle used to clip the graphics output. </span>
<span class="comments">;        The rectangle is specified as a vector of the form [X0, Y0, X1, Y1], </span>
<span class="comments">;        giving coordinates of the lower left and upper right corners, </span>
<span class="comments">;        respectively. The default clipping rectangle is the plot window set</span>
<span class="comments">;        up by the cgMap object. </span>
<span class="comments">;     color: in, optional, type=string, default="opposite"</span>
<span class="comments">;        The name of the color to draw the arrows lines in. </span>
<span class="comments">;     hsize: in, optional, type=float, default=0.35</span>
<span class="comments">;        The value of this keyword sets the length of the arrowhead. See the documenation</span>
<span class="comments">;        for the ARROW command in IDL for further explanation.</span>
<span class="comments">;     lats: in, optional, type=float</span>
<span class="comments">;        The latitude values where the vector is to be drawn.</span>
<span class="comments">;     length, in, optional, type=float</span>
<span class="comments">;        The length of the UV vectors. The default value calculates a maximum length,</span>
<span class="comments">;        which is the larger of either the latitude or longitude range. This value is </span>
<span class="comments">;        then divided by 100. To scale the UV values, the values are divided by the </span>
<span class="comments">;        maximum magnitude of the UV vectors and then multiplied by the length. The code </span>
<span class="comments">;        looks like this for the default case::</span>
<span class="comments">;            maxlength = Max( [Max(lons)-Min(lons), Max(lats)-Min(lats)] )</span>
<span class="comments">;            length = maxlength / 100.0</span>
<span class="comments">;            maxMagnitude = Max(Sqrt(u^2 + v^2))</span>
<span class="comments">;            uscaled = (u/maxMagnitude) * length</span>
<span class="comments">;            vscaled = (v/maxMagnitude) * length</span>
<span class="comments">;        The default length value is likely to be too large for polar plots, but seems</span>
<span class="comments">;        adequate for other map projections. If you need to adjust the length, get the</span>
<span class="comments">;        current length with the GetProperty method and the LENGTH keyword, and adjust</span>
<span class="comments">;        accordingly. The length is not set finally, until the vectors are first drawn.</span>
<span class="comments">;     linestyle: out, optional, type=integer, default=1 </span>
<span class="comments">;        Set this keyword to the type of linestyle desired. See Graphics Keywords in</span>
<span class="comments">;        the on-line help for additional information.</span>
<span class="comments">;     lons: in, optional, type=float</span>
<span class="comments">;        The longitude values where the vector is to be drawn.</span>
<span class="comments">;     noclip: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to supress clipping of the plot.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;        A (256x3) color palette containing the RGB color vectors to use for coloring the vectors</span>
<span class="comments">;        according to the magitude of the vectors. If the color palette is not 256 colors in length</span>
<span class="comments">;        then the magitude is scaled into the number of colors available. If a color palette is</span>
<span class="comments">;        used, then the `Color` keyword is ignored.</span>
<span class="comments">;     solid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw solid arrow heads.</span>
<span class="comments">;     t3d: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this graphics keyword if you wish to draw using the T3D transformation matrix.</span>
<span class="comments">;     thick: in, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to the thickness of the line used to draw the grid.</span>
<span class="comments">;     umagnitude: in, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the U direction.</span>
<span class="comments">;     uvcoords: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if the LONS and LATS are specified in UV (XY) coordinates, rather than</span>
<span class="comments">;        longitude and latitude coordinates.</span>
<span class="comments">;     vmagnitude: in, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the V direction.</span>
<span class="comments">;     zvalue: in, optional, type=float, default=0.0</span>
<span class="comments">;        Set this keyword to the ZVALUE where the output should be drawn.</span>
<span class="comments">;     _extra: in, optional</span>
<span class="comments">;        Any keywords appropriate for superclass objects are also permitted.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMapVector::INIT, mapCoord, $
    ADDCMD=addcmd, $
    CLIP=clip, $
    COLOR=color, $
    HSIZE=hsize, $
    LATS=lats, $
    LENGTH=length, $
    LINESTYLE=linestyle, $
    LONS=lons, $
    NOCLIP=noclip, $
    PALETTE=palette, $
    SOLID=solid, $
    T3d=t3d, $
    THICK=thick, $
    UMAGNITUDE=u, $
    UVCOORDS=uvcoords, $
    VMAGNITUDE=v, $
    ZVALUE=zvalue, $
    _EXTRA=extra
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN, 0
    ENDIF
    
    <span class="comments">; Make sure you have a valid map object or there is no point in going ahead.</span>
    IF ~Obj_Valid(mapCoord) THEN Message, 'A valid map object is required to create a cgMapPlotS object.'
    
    <span class="comments">; Initialize superclass object,</span>
     ok = self -> cgContainer::INIT( _EXTRA=extra) 
     IF ~ok THEN RETURN, 0

    <span class="comments">; Default values.</span>
    SetDefaultValue, color, 'White'
    SetDefaultValue, hsize, -0.35
    SetDefaultValue, length, !Values.F_NAN
    SetDefaultValue, linestyle, 0
    SetDefaultValue, noclip, 1
    SetDefaultValue, solid, 0
    SetDefaultValue, t3d, 0
    SetDefaultValue, thick, 1.0
    SetDefaultValue, uvcoords, 0B
    SetDefaultValue, zvalue, 0.0

    IF N_Elements(clip) NE 0 THEN self.clip = clip
    self.color = color
    self.hsize = hsize
    self.length = length
    self.linestyle = linestyle
    self.noclip = noclip
    self.solid = solid
    self.t3d = t3d
    self.thick = thick
    self.uvcoords = uvcoords
    self.zvalue = zvalue
    
    IF N_Elements(lons) EQ 0 $
        THEN self.lons = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self.lons = Ptr_New(lons)
    IF N_Elements(lats) EQ 0 $
        THEN self.lats = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self.lats = Ptr_New(lats)
        
    IF N_Elements(u) EQ 0 $
        THEN self.u = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self.u = Ptr_New(u)
        
    IF N_Elements(v) EQ 0 $
        THEN self.v = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self.v = Ptr_New(v)
        
    <span class="comments">; Store the map object. </span>
    self.mapCoord = mapCoord
    
    <span class="comments">; Do you have a color palette?</span>
    IF N_Elements(palette) NE 0 THEN BEGIN
       self.color = ""
       s = Size(palette, /DIMENSIONS)
       IF s[1] GT s[0] THEN palette = Transpose(palette)
       s = Size(palette, /DIMENSIONS)
       ncolors = s[0]
       self.palette = Ptr_New(palette)
       self.magcolors = Ptr_New(BytScl(Sqrt((*self.v)^2 + (*self.u)^2), TOP=ncolors-1))
    ENDIF

    <span class="comments">; Need to add this command to a resizeable cgWindow?</span>
    IF Keyword_Set(addcmd) THEN BEGIN
       window = cgQuery(/Current, OBJECT=winObject)
       IF Obj_Valid(winObject) THEN BEGIN
           cgWindow, 'Draw', self, /Method, /AddCmd
       ENDIF ELSE BEGIN
          cgWindow, 'Draw', self, /Method
       ENDELSE
       
    ENDIF
    RETURN, 1
    
END 



<span class="comments">;+</span>
<span class="comments">;   This is a heavily modified IDL ARROW procedure, with extra keywords added</span>
<span class="comments">;   and the COLOR keyword modified to accept color names. It assumes drawing</span>
<span class="comments">;   in the device coordinate space, unless the DATA or NORMALIZED keywords</span>
<span class="comments">;   are set.</span>
<span class="comments">; </span>
<span class="comments">;   Copyright (c) 1993-2004, Research Systems, Inc.  All rights reserved.</span>
<span class="comments">;   </span>
<span class="comments">; :Params:</span>
<span class="comments">;     x0: in, required, type=float</span>
<span class="comments">;         The X value at the butt end of the arrow.</span>
<span class="comments">;     x1: in, required, type=float</span>
<span class="comments">;         The X value at the tip end of the arrow.</span>
<span class="comments">;     y0: in, required, type=float</span>
<span class="comments">;         The Y value at the butt end of the arrow.</span>
<span class="comments">;     y1: in, required, type=float</span>
<span class="comments">;         The Y value at the tip end of the arrow.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     color: in, optional, type=string, default="opposite"</span>
<span class="comments">;        The name of the color to draw the grid lines in. </span>
<span class="comments">;     data: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw in the data coordinate space.</span>
<span class="comments">;     linestyle: in, optional, type=integer, default=0</span>
<span class="comments">;        The graphics linestyle to draw the vector in.</span>
<span class="comments">;     normalized: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw in the normalized data coordinate space.</span>
<span class="comments">;     thick: in, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to the thickness of the line used to draw the grid.</span>
<span class="comments">;     solid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to fill the arrow head with a solid color. Otherwise,</span>
<span class="comments">;        draw the arrow head as an outline.</span>
<span class="comments">;     _extra: in, optional</span>
<span class="comments">;        Any keywords appropriate PlotS or PolyFill.</span>
<span class="comments">;-</span>
PRO cgMapVector::DrawArrow, x0, y0, x1, y1, $
   CLIP=clip, $
   COLOR = color, $
   DATA = data, $
   HSIZE = hsize, $
   HTHICK = hthick, $
   LINESTYLE=linestyle, $
   NORMALIZED = norm, $
   THICK = thick, $
   SOLID = solid, $
   _EXTRA=extra

    COMPILE_OPT idl2
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">;  Set up keyword params</span>
    IF N_Elements(thick) EQ 0 THEN thick = 1.
    IF N_Elements(hthick) EQ 0 THEN hthick = thick
    
    <span class="comments">; Head size in device units</span>
    IF N_Elements(hsize) EQ 0 THEN arrowsize = !d.x_size/50. * (hthick/2. > 1) $
        ELSE arrowsize = Float(hsize)
    IF N_Elements(color) EQ 0 THEN color = "opposite"
    
    <span class="comments">; If arrowsize GT 15, THEN use 20% arrow. Otherwise use 30%.</span>
    IF arrowsize LT 15 THEN BEGIN
       mcost = -0.866D
       sint = 0.500D
       msint = -sint
    ENDIF ELSE BEGIN
       mcost = - 0.939693D
       sint = 0.342020D
       msint = -sint
    ENDELSE
    
    <span class="comments">; Do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENT=currentState
    
    FOR i = 0L, N_Elements(x0)-1 DO BEGIN   <span class="comments">;Each vector</span>

       <span class="comments">; Clip the vectors.</span>
       IF ~Keyword_Set(noclip) THEN BEGIN
           IF (x0 LT clip[0]) || (x0 GT clip[2]) || (y0 LT clip[1]) || (y0 GT clip[3]) THEN Continue
           x1 = clip[0] > x1 &lt<span class="comments">; clip[2]</span>
           y1 = clip[1] > y1 &lt<span class="comments">; clip[3] </span>
       ENDIF
       
       <span class="comments">; Convert to DEVICE coordinates.</span>
       IF Keyword_Set(data) THEN $   <span class="comments">;Convert?</span>
           p = Convert_Coord([x0[i],x1[i]],[y0[i],y1[i]], /DATA, /TO_DEVICE) $
       ELSE IF Keyword_Set(norm) THEN $
           p = Convert_Coord([x0[i],x1[i]],[y0[i],y1[i]], /NORMAL, /TO_DEVICE) $
       ELSE p = [[x0[i], y0[i]],[x1[i], y1[i]]]
    
       xp0 = p[0,0]
       xp1 = p[0,1]
       yp0 = p[1,0]
       yp1 = p[1,1]
    
       dx = xp1 - xp0
       dy = yp1 - yp0
       zz = SQRT(dx^2d + dy^2d)  <span class="comments">;Length</span>
    
       IF zz gt 0 THEN BEGIN
         dx = dx/zz     <span class="comments">;Cos th</span>
         dy = dy/zz     <span class="comments">;Sin th</span>
       ENDIF ELSE BEGIN
         dx = 1.
         dy = 0.
         zz = 1.
       ENDELSE
       IF arrowsize gt 0 THEN a = arrowsize $  <span class="comments">;a = length of head</span>
       ELSE a = -zz * arrowsize
    
       xxp0 = xp1 + a * (dx*mcost - dy * msint)
       yyp0 = yp1 + a * (dx*msint + dy * mcost)
       xxp1 = xp1 + a * (dx*mcost - dy * sint)
       yyp1 = yp1 + a * (dx*sint  + dy * mcost)
       
    
       IF Keyword_Set(solid) THEN BEGIN   <span class="comments">;Use polyfill?</span>
         b = a * mcost*.9d <span class="comments">;End of arrow shaft (Fudge to force join)</span>
         Plots, [xp0, xp1+b*dx], [yp0, yp1+b*dy], /DEVICE, $
            COLOR = cgColor(color), THICK = thick, LINESTYLE=linestyle, _Extra=extra
         Polyfill, [xxp0, xxp1, xp1, xxp0], [yyp0, yyp1, yp1, yyp0], $
            /DEVICE, COLOR = cgColor(color)
       ENDIF ELSE BEGIN
         Plots, [xp0, xp1], [yp0, yp1], /DEVICE, COLOR=cgColor(color), THICK=thick, $
            LINESTYLE=linestyle, _Extra=extra
         Plots, [xxp0,xp1,xxp1],[yyp0,yp1,yyp1], /DEVICE, COLOR=cgColor(color), $
            THICK=hthick, LINESTYLE=linestyle, _Extra=extra
       ENDELSE
    ENDFOR
    
    <span class="comments">; Restore color state.</span>
    SetDecomposedState, currentState
    
END


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Draws the vectors on the map projection.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapVector::Draw

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; You have to have data to plot. If not exit quietly.</span>
    IF (N_Elements(*self.lons) EQ 0) OR (N_Elements(*self.lats) EQ 0) THEN RETURN
    IF (N_Elements(*self.u) EQ 0) OR (N_Elements(*self.v) EQ 0) THEN RETURN
    
    <span class="comments">; If the vectors don't all have the same number of elements, there is an error.</span>
    IF N_Elements(*self.lons) NE N_Elements(*self.lats) THEN BEGIN
        Message, 'The number of elements in the latitude and longitude arrays must be the same.'
    ENDIF
    IF N_Elements(*self.u) NE N_Elements(*self.v) THEN BEGIN
        Message, 'The number of elements in the U and V arrays must be the same.'
    ENDIF
    IF N_Elements(*self.lons) NE N_Elements(*self.v) THEN BEGIN
        Message, 'The number of elements in the lon, lat, u, and v arrays must be the same.'
    ENDIF
   
    
    <span class="comments">; Find a map structure, IF you can.</span>
    IF Obj_Valid(self.mapCoord) THEN BEGIN
        mapStruct = self.mapCoord -> GetMapStruct() 
        self.mapCoord -> Draw, /NoGraphics
    ENDIF ELSE Message, 'There is no valid map object from which a map structure can be obtained.'

    <span class="comments">; If you have a map structure, then determine if the locations to plot</span>
    <span class="comments">; are in lat/lon or UV coordinate space. The MapCoord object sets up</span>
    <span class="comments">; a UV coordinate space. The locations to be plotted here are in lat/lon</span>
    <span class="comments">; space, so they have to be converted to XY space to be plotted.</span>
    IF N_Elements(mapStruct) NE 0 THEN BEGIN
    
        <span class="comments">; If the "lons and lats" are already in UVCOORDS, leave them alone.</span>
        IF self.uvcoords THEN BEGIN
            lon = *self.lons
            lat = *self.lats
        ENDIF ELSE BEGIN
        
            <span class="comments">; Otherwise, convert them, since the map is *always* in UVCoords.</span>
            uv = MAP_PROJ_FORWARD(*self.lons, *self.lats, MAP_STRUCTURE=mapStruct)
            lon = Reform(uv[0,*])
            lat = Reform(uv[1,*])
        ENDELSE
    ENDIF ELSE BEGIN
        lon = *self.lons
        lat = *self.lats
    ENDELSE
    
    <span class="comments">; Do we have to assign a value to length?</span>
    IF ~Finite(self.length) THEN BEGIN
        maxlen = Max( [Max(*self.lons)-Min(*self.lons), Max(*self.lats)-Min(*self.lats)] )
        length = maxlen / 100.0
    ENDIF ELSE length = self.length 
    Print, 'Vector Length: ', length
    
    <span class="comments">; Scale the U and V values by the length.</span>
    maxmag = Max(Sqrt(*self.u^2 + *self.v^2))
    uscaled = (*self.u/maxmag) * length 
    vscaled = (*self.v/maxmag) * length 
    
    <span class="comments">; If clip is not defined, then set it here.</span>
    IF Total(self.clip) EQ 0 $
        THEN clip = [!X.CRange[0], !Y.CRange[0], !X.CRange[1], !Y.CRange[1]] $
        ELSE clip = self.clip
        
    <span class="comments">; Load colors if you have them.</span>
    IF Ptr_Valid(self.palette) THEN BEGIN
        TVLCT, r, g, b, /Get
        TVLCT, *self.palette
    ENDIF

    <span class="comments">; Calculate the endpoints of the arrow and draw it.</span>
    FOR j=0L,N_Elements(*self.u)-1 DO BEGIN
        x0 = (*self.lons)[j]
        y0 = (*self.lats)[j]
        x1 = x0 + uscaled[j]
        y1 = y0 + vscaled[j]
        xhalf = (x1-x0)/2.0
        yhalf = (y1-y0)/2.0
        x0 = x0 - xhalf
        y0 = y0 - yhalf
        x1 = x1 - xhalf
        y1 = y1 - yhalf
        uv = self.mapCoord -> Forward([x0,x1], [y0,y1])
        x0 = uv[0,0]
        x1 = uv[0,1]
        y0 = uv[1,0] 
        y1 = uv[1,1]     
        IF self.color EQ "" THEN color = (*self.magcolors)[j] ELSE color = self.color
        self -> DrawArrow, x0, y0, x1, y1, HSIZE=self.hsize, CLIP=clip, THICK=self.thick, $
           HTHICK=self.thick, LENGTH=length, COLOR=color, SOLID=self.solid, $
           _EXTRA=extrakeywords, /DATA, LINESTYLE=self.linestyle
    ENDFOR
    IF Ptr_Valid(self.palette) THEN TVLCT, r, g, b
END 

    
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; This method allows the user to get various properties of the object. </span>
<span class="comments">; The same keywords that are used for the INIT method can be used here.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     clip: out, optional, type=fltarr(4)</span>
<span class="comments">;        The coordinates of a rectangle used to clip the graphics output. </span>
<span class="comments">;        The rectangle is specified as a vector of the form [X0, Y0, X1, Y1], </span>
<span class="comments">;        giving coordinates of the lower left and upper right corners, </span>
<span class="comments">;        respectively. The default clipping rectangle is the plot window set</span>
<span class="comments">;        up by the cgMap object. </span>
<span class="comments">;     color: out, optional, type=string, default="opposite"</span>
<span class="comments">;        The name of the color to draw the grid lines in. </span>
<span class="comments">;     hsize: out, optional, type=float, default=0.35</span>
<span class="comments">;        The value of this keyword sets the length of the arrowhead. See the documenation</span>
<span class="comments">;        for the ARROW command ind IDL for further explanation.</span>
<span class="comments">;     lats: out, optional, type=float</span>
<span class="comments">;        The latitude values where the vector is to be drawn.</span>
<span class="comments">;     length, out, optional, type=float</span>
<span class="comments">;        The U and V vectors are mutiplied by LENGTH before they are used</span>
<span class="comments">;        to calculate the (x1,y1) endpoint of the vector. By default, the length is set</span>
<span class="comments">;        to 1/100th of the XRANGE of the MapCoord object. This means that the maximum</span>
<span class="comments">;        length of a vector will be approximately LENGTH * SQRT(2).</span>
<span class="comments">;     linestyle: out, optional, type=integer, default=1 </span>
<span class="comments">;        Set this keyword to the type of linestyle desired. See Graphics Keywords in</span>
<span class="comments">;        the on-line help for additional information.</span>
<span class="comments">;     lons: out, optional, type=float</span>
<span class="comments">;        The longitude values where the vector is to be drawn.</span>
<span class="comments">;     noclip: out, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to supress clipping of the plot.</span>
<span class="comments">;     mapcoord: out, optional, type=object</span>
<span class="comments">;        The map coordinate for the object.</span>
<span class="comments">;     solid: out, optional, type=boolean</span>
<span class="comments">;        This keyword is set if solid arrow heads are currently being drawn.</span>
<span class="comments">;     t3d: out, optional, type=boolean, default=0</span>
<span class="comments">;        Set this graphics keyword if you wish to draw using the T3D transformation matrix.</span>
<span class="comments">;     thick: out, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to the thickness of the line used to draw the grid.</span>
<span class="comments">;     umagnitude: out, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the U direction.</span>
<span class="comments">;     uvcoords: out, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if the LONS and LATS are specified in UV (XY) coordinates, rather than</span>
<span class="comments">;        longitude and latitude coordinates.</span>
<span class="comments">;     vmagnitude: out, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the V direction.</span>
<span class="comments">;     zvalue: out, optional, type=float, default=0.0</span>
<span class="comments">;        Set this keyword to the ZVALUE where the output should be drawn.</span>
<span class="comments">;     _ref_extra: in, optional</span>
<span class="comments">;        Any keywords appropriate for superclass objects are also permitted.</span>
<span class="comments">;</span>
<span class="comments">;-----------------------------------------------------------------------------------------------</span>
PRO cgMapVector::GetProperty, $
    CLIP=clip, $
    COLOR=color, $
    HSIZE=hsize, $
    LATS=lats, $
    LENGTH=length, $
    LINESTYLE=linestyle, $
    LONS=lons, $
    MAPCOORD=mapcoord, $
    NOCLIP=noclip, $
    SOLID=solid, $
    T3D=t3d, $
    THICK=thick, $
    UMAGNITUDE=u, $
    UVCOORDS=uvcoords, $
    VMAGNITUDE=v, $
    ZVALUE=zvalue, $
    _REF_EXTRA=extra

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
    
    clip = self.clip
    color = self.color
    hsize = self.hsize
    length = self.length
    linestyle = self.linestyle
    noclip = self.noclip
    solid  = self.solid
    t3d = self.t3d
    thick = self.thick
    uvcoords = self.uvcoords
    IF Arg_Present(lats) THEN lats = *self.lats
    IF Arg_Present(lons) THEN lons = *self.lons
    IF Arg_Present(u) THEN u = *self.u
    IF Arg_Present(v) THEN v = *self.v
    zvalue = self.zvalue
    mapCoord = self.mapCoord
    
    IF N_Elements(extra) NE 0 THEN self -> cgContainer::GetProperty, _EXTRA=extra
    
END 

    
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method allows the user to set various properties of the object. </span>
<span class="comments">;   The same keywords that are used for the INIT method can be used here.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object is added to the resizeable graphics</span>
<span class="comments">;        window, cgWindow. The DRAW method of the object is called in cgWindow.</span>
<span class="comments">;     clip: in, optional, type=fltarr(4)</span>
<span class="comments">;        The coordinates of a rectangle used to clip the graphics output. </span>
<span class="comments">;        The rectangle is specified as a vector of the form [X0, Y0, X1, Y1], </span>
<span class="comments">;        giving coordinates of the lower left and upper right corners, </span>
<span class="comments">;        respectively. The default clipping rectangle is the plot window set</span>
<span class="comments">;        up by the cgMap object. </span>
<span class="comments">;     color: in, optional, type=string, default="opposite"</span>
<span class="comments">;        The name of the color to draw the grid lines in. </span>
<span class="comments">;     hsize: in, optional, type=float, default=0.35</span>
<span class="comments">;        The value of this keyword sets the length of the arrowhead. See the documenation</span>
<span class="comments">;        for the ARROW command ind IDL for further explanation.</span>
<span class="comments">;     lats: in, optional, type=float</span>
<span class="comments">;        The latitude values where the vector is to be drawn.</span>
<span class="comments">;     length, in, optional, type=float</span>
<span class="comments">;        The U and V vectors are mutiplied by LENGTH before they are used</span>
<span class="comments">;        to calculate the (x1,y1) endpoint of the vector. By default, the length is set</span>
<span class="comments">;        to 1/100th of the XRANGE of the MapCoord object. This means that the maximum</span>
<span class="comments">;        length of a vector will be approximately LENGTH * SQRT(2).</span>
<span class="comments">;     linestyle: out, optional, type=integer, default=1 </span>
<span class="comments">;        Set this keyword to the type of linestyle desired. See Graphics Keywords in</span>
<span class="comments">;        the on-line help for additional information.</span>
<span class="comments">;     lons: in, optional, type=float</span>
<span class="comments">;        The longitude values where the vector is to be drawn.</span>
<span class="comments">;     noclip: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to supress clipping of the plot.</span>
<span class="comments">;     mapcoord: in, optional, type=object</span>
<span class="comments">;        The map coordinate for the object.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;        A (256x3) color palette containing the RGB color vectors to use for coloring the vectors</span>
<span class="comments">;        according to the magitude of the vectors. If the color palette is not 256 colors in length</span>
<span class="comments">;        then the magitude is scaled into the number of colors available. If a color palette is</span>
<span class="comments">;        used, then the `Color` keyword is ignored.</span>
<span class="comments">;     solid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw solid arrow heads.</span>
<span class="comments">;     t3d: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this graphics keyword if you wish to draw using the T3D transformation matrix.</span>
<span class="comments">;     thick: in, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to the thickness of the line used to draw the grid.</span>
<span class="comments">;     umagnitude: in, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the U direction.</span>
<span class="comments">;     uvcoords: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if the LONS and LATS are specified in UV (XY) coordinates, rather than</span>
<span class="comments">;        longitude and latitude coordinates.</span>
<span class="comments">;     vmagnitude: in, optional, type=float</span>
<span class="comments">;        The magnitude of the vector in the V direction.</span>
<span class="comments">;     zvalue: in, optional, type=float, default=0.0</span>
<span class="comments">;        Set this keyword to the ZVALUE where the output should be drawn.</span>
<span class="comments">;     _extra: in, optional</span>
<span class="comments">;        Any keywords appropriate for superclass objects are also permitted.</span>
<span class="comments">;</span>
<span class="comments">;-----------------------------------------------------------------------------------------------</span>
PRO cgMapVector::SetProperty, $
    ADDCMD=addcmd, $
    CLIP=clip, $
    COLOR=color, $
    HSIZE=hsize, $
    LATS=lats, $
    LENGTH=length, $
    LINESTYLE=linestyle, $
    LONS=lons, $
    MAPCOORD=mapCoord, $
    NOCLIP=noclip, $
    PALETTE=palette, $
    SOLID=solid, $
    T3D=t3d, $
    THICK=thick, $
    UMAGNITUDE=u, $
    UVCOORDS=uvcoords, $
    VMAGNITUDE=v, $
    ZVALUE=zvalue, $
    _EXTRA=extra

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
    IF N_Elements(lon) NE 0 THEN BEGIN
    <span class="comments">;print, 'lon:', lon</span>
        *self.lons = lons
    ENDIF
    IF N_Elements(lat) NE 0 THEN BEGIN
        *self.lats = lats
    <span class="comments">;print, 'lat:',  lats</span>
    ENDIF
    IF N_Elements(u) NE 0 THEN BEGIN
    <span class="comments">;print, 'u:', u</span>
        *self.u = u
    ENDIF
    IF N_Elements(v) NE 0 THEN BEGIN
        *self.v = v
    <span class="comments">;print, 'v',  v</span>
    ENDIF

    IF N_Elements(clip) NE 0 THEN self.clip = clip
    IF N_Elements(color) NE 0 THEN self.color = color
    IF N_Elements(hsize) NE 0 THEN self.hsize = hsize
    IF N_Elements(length) NE 0 THEN self.length = length
    IF N_Elements(mapCoord) NE 0 THEN self.mapCoord = mapCoord
    IF N_Elements(linestyle) NE 0 THEN self.linestyle = linestyle
    IF N_Elements(noclip) NE 0 THEN self.noclip = noclip
    IF N_Elements(solid) NE 0 THEN self.solid = Keyword_Set(solid)
    IF N_Elements(t3d) NE 0 THEN self.t3d = t3d
    IF N_Elements(thick) NE 0 THEN self.thick = thick
    IF N_Elements(zvalue) NE 0 THEN self.zvalue = zvalue
    
    <span class="comments">; Do you have a color palette?</span>
    IF N_Elements(palette) NE 0 THEN BEGIN
       Ptr_Free, self.palette
       Ptr_Free, self.magcolors
       self.color = ""
       s = Size(palette, /DIMENSIONS)
       IF s[1] GT s[0] THEN palette = Transpose(palette)
       s = Size(palette, /DIMENSIONS)
       ncolors = s[0]
       self.palette = Ptr_New(palette)
       self.magcolors = Ptr_New(BytScl(Sqrt((*self.v)^2 + (*self.u)^2), TOP=ncolors-1))
    ENDIF

    IF N_Elements(extra) NE 0 THEN self -> cgContainer::SetProperty, _EXTRA=extra

END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the clean-up routine for the object.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapVector::CLEANUP

    Ptr_Free, self.lons
    Ptr_Free, self.lats
    Ptr_Free, self.u
    Ptr_Free, self.v
    Ptr_Free, self.palette
    Ptr_Free, self.magcolors
    
    self -> cgContainer::CLEANUP
END


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the class definition module. </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    class: out, optional, type=structure</span>
<span class="comments">;       Occasionally, it is useful to have an object class definition as</span>
<span class="comments">;       a structure variable. Using this output keyword will allow that.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapVector__DEFINE, class

    class = { cgMapVector, $
              lons: Ptr_New(), $      
              lats: Ptr_New(), $ 
              u: Ptr_New(), $
              v: Ptr_New(), $  
              length: 0.0D, $
              clip: DblArr(4),$   
              color: "", $
              hsize: 0.0, $
              linestyle: 0, $
              magcolors: Ptr_New(), $
              noclip: 0B, $
              palette: Ptr_New(), $
              solid: 0, $
              t3d: 0B, $
              thick: 0, $
              uvcoords: 0B, $
              zvalue: 0.0, $
              mapCoord: Obj_New(), $
              INHERITS cgContainer $
            }

END <span class="comments">; -------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>