<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:02 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgcontour.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgcontour.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgContour</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of cgContour is to create a wrapper for the traditional IDL graphics</span>
<span class="comments">;   command, Contour. The Contour command has a number of deficiencies that make it</span>
<span class="comments">;   difficult to use in a modern computing environment. cgContour corrects these</span>
<span class="comments">;   deficiencies and allows the user to produce traditional contour plots in a device</span>
<span class="comments">;   and machine independent manner.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of cgContour is to create a wrapper for the traditional IDL graphics</span>
<span class="comments">; command, Contour. The Contour command has a number of deficiencies that make it</span>
<span class="comments">; difficult to use in a modern computing environment. cgContour corrects these</span>
<span class="comments">; deficiencies and allows the user to produce traditional contour plots in a device</span>
<span class="comments">; and machine independent manner.</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgcontour.png</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, type=any</span>
<span class="comments">;         A one- or two-dimensional array containing the values that make </span>
<span class="comments">;         up the contour surface.</span>
<span class="comments">;    x: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the X coordinates for</span>
<span class="comments">;         the contour surface.</span>
<span class="comments">;    y: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the Y coordinates for</span>
<span class="comments">;         the contour surface.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to an cgWindow. Setting this keyword</span>
<span class="comments">;        automatically sets the WINDOW keyword, but the command does not erase the</span>
<span class="comments">;        graphics window as it would normally.</span>
<span class="comments">;     aspect: in, optional, type=float, default=none</span>
<span class="comments">;        Set this keyword to a floating point ratio that represents the aspect ratio </span>
<span class="comments">;        (ysize/xsize) of the resulting plot. The plot position may change as a result</span>
<span class="comments">;        of setting this keyword. Note that `Aspect` cannot be used when plotting with</span>
<span class="comments">;        !P.MULTI.</span>
<span class="comments">;     axiscolor: in, optional, type=string/integer, default='opposite'</span>
<span class="comments">;        If this keyword is a string, the name of the axis color. </span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     axescolor: in, optional, type=string/integer</span>
<span class="comments">;        Provisions for bad spellers.</span>
<span class="comments">;     background: in, optional, type=string/integer, default='background'</span>
<span class="comments">;        If this keyword is a string, the name of the background color. </span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     c_annotation: in, optional, type=string</span>
<span class="comments">;        The label to be drawn on each contour. Normally contours are labeled with their</span>
<span class="comments">;        value. This vector of strings may substitute for those values.</span>
<span class="comments">;     c_colors: in, optional, type=integer/string vector</span>
<span class="comments">;        Set to the index values of the contour colors or to named colors. Must contain</span>
<span class="comments">;        the same number of colors as the number of requested contour levels.</span>
<span class="comments">;     c_labels: in, optional, type=integer</span>
<span class="comments">;        A vector that specifies which contour levels to label. If used, the LABEL</span>
<span class="comments">;        keyword is ignored.</span>
<span class="comments">;     c_charsize: in, optional, type=float</span>
<span class="comments">;        The character size of the annotations used on the contour lines themselves.</span>
<span class="comments">;        By default, 75% of `Charsize`.</span>
<span class="comments">;     cell_fill: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set to indicate filled contours should be created using the "cell fill" method.</span>
<span class="comments">;        This keyword should always be set if displaying filled contours on map projections</span>
<span class="comments">;        or if missing data is present in the data you are contouring.</span>
<span class="comments">;     charsize: in, optional, type=float, default=cgDefCharSize()</span>
<span class="comments">;        The character size for axes annotations. Uses cgDefCharSize to select default</span>
<span class="comments">;        character size, unless !P.Charsize is set, in which case !P.Charsize is always used.</span>
<span class="comments">;     color: in, optional, type=string/integer, default='black'</span>
<span class="comments">;        If this keyword is a string, the name of the data color. By default, same as AXISCOLOR.</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     font: in, optional, type=integer, default=!P.Font</span>
<span class="comments">;        The type of font desired for axis annotation.</span>
<span class="comments">;     fill: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set to indicate filled contours should be created.</span>
<span class="comments">;     isotropic: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to set the `Aspect` keyword to the plot aspect ratio that preserves</span>
<span class="comments">;         identical scaling for the X and Y axes. This keyword cannot be used with multiple</span>
<span class="comments">;         contour plots on the page.</span>
<span class="comments">;     irregular: in, optional, type=boolean</span>
<span class="comments">;        If this keyword is set, the data, x, and y input parameters are taken to be</span>
<span class="comments">;        irregularly gridded data, the the data is gridded for use in the contour plot</span>
<span class="comments">;        using the Triangulate and Trigrid method. The resolution of the gridded output</span>
<span class="comments">;        is set by the RESOLUTION keyword.</span>
<span class="comments">;     label: in, optional, type=integer, default=1</span>
<span class="comments">;        An number that tells how to label contour levels. A 0 means</span>
<span class="comments">;        no contour levels are labelled. A 1 (the default) means all contour levels are</span>
<span class="comments">;        labelled. A 2 means label every 2nd contour level is labelled. A 3 means every </span>
<span class="comments">;        3rd contour level is labelled, and so on.</span>
<span class="comments">;     layout: in, optional, type=intarr(3)</span>
<span class="comments">;        This keyword specifies a grid with a graphics window and determines where the</span>
<span class="comments">;        graphic should appear. The syntax of LAYOUT is three numbers: [ncolumns, nrows, location].</span>
<span class="comments">;        The grid is determined by the number of columns (ncolumns) by the number of </span>
<span class="comments">;        rows (nrows). The location of the graphic is determined by the third number. The</span>
<span class="comments">;        grid numbering starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;        by row.</span>
<span class="comments">;     levels: in, optional, type=any</span>
<span class="comments">;        A vector of data levels to contour. If used, NLEVELS is ignored. If missing, </span>
<span class="comments">;        NLEVELS is used to construct N equally-spaced contour levels.</span>
<span class="comments">;     map_object: in, optional, type=object</span>
<span class="comments">;        If you are overplotting (OVERPLOT=1) on a map projection set up with Map_Proj_Init</span>
<span class="comments">;        and using projected meter space, rather than lat/lon space, then you can use this</span>
<span class="comments">;        keyword to provide a cgMap object that will allow you to convert the `x` and `y`</span>
<span class="comments">;        grid parameters from longitude and latitude, respectively, to projected meter space</span>
<span class="comments">;        before the contour is displayed. Note, you MUST pass the `x` and `y` grid parameters </span>
<span class="comments">;        to cgContour if you are overplotting on a map projection. There is no checking to</span>
<span class="comments">;        be sure these parameters are in the correct longitude and latitude range, respectively.</span>
<span class="comments">;     missingvalue: in, optional, type=any</span>
<span class="comments">;        Use this keyword to identify any missing data in the input data values.</span>
<span class="comments">;     noclip: in, optional, type=boolean, default=0</span>
<span class="comments">;        Normally, the plot is clipped to the axes boundaries. Setting this keyword prevents</span>
<span class="comments">;        such clipping. Normally, this keyword is only used when there is a problem displaying</span>
<span class="comments">;        contour plots in 3D space.</span>
<span class="comments">;     nlevels: in, optional, type=integer, default=6</span>
<span class="comments">;        If the Contour plot LEVELS keyword is not used, this keyword will produce this</span>
<span class="comments">;        number of equally spaced contour intervals. Unlike the Contour NLEVELS keyword,</span>
<span class="comments">;        this keyword actually works!</span>
<span class="comments">;     noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to prevent the window from erasing the contents before displaying</span>
<span class="comments">;        the contour plot.</span>
<span class="comments">;     olevels: out, optional</span>
<span class="comments">;        Set to a named variable to return the actual contour levels used in the program.</span>
<span class="comments">;        Unfortunately, output variables cannot be returned if the cgContour command is</span>
<span class="comments">;        being executed in a cgWindow.</span>
<span class="comments">;     onimage: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, and an image has been display previously with cgImage,</span>
<span class="comments">;        then the contour plot will determine the location of the image in the display</span>
<span class="comments">;        window and overplot itself onto that image.</span>
<span class="comments">;     outcolor: in, optional, type=string, default='charcoal'</span>
<span class="comments">;        The color of the contour lines when the `Outline` keyword is used.</span>
<span class="comments">;     outfilename: in, optional, type=string</span>
<span class="comments">;        If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;        filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;        value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;        presented to the user.</span>
<span class="comments">;     outline: in, optional, type=boolean, default=0</span>
<span class="comments">;        This keyword applies only if the `Fill` keyword is set. It will draw the</span>
<span class="comments">;        contour lines on top of the filled contour. It draws the outline in the `OutColor`.</span>
<span class="comments">;     output: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;        Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;        file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;        user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;        All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;        PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;        to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;        details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;        plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;        output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;     overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to overplot the contours onto a previously established</span>
<span class="comments">;        data coordinate system.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;        A (256x3) color palette containing the RGB color vectors to use for coloring contours.</span>
<span class="comments">;        Contour colors will be sampled from the color table palette into the number </span>
<span class="comments">;        of contour levels required. If the palette is NOT 256 elements in length, then</span>
<span class="comments">;        it is assumed that the length corresponds to the number of levels to be contoured.</span>
<span class="comments">;     position: in, optional, type=float</span>
<span class="comments">;        Set this keyword to a four-element [x0,y0,x1,y1] array giving the contour plot</span>
<span class="comments">;        position in normalized coordinates. </span>
<span class="comments">;     resolution: in, optional, type=integer array, default=[41\,41]</span>
<span class="comments">;        If the IRREGULAR keyword is set, this keyword specifies the X and Y resolution</span>
<span class="comments">;        in a two element integer array of the final gridded data that is sent to the </span>
<span class="comments">;        contour plot.</span>
<span class="comments">;     t3d: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to use the 3D axis rotation matrix in !P.T3D.</span>
<span class="comments">;     title: in, optional, type=string</span>
<span class="comments">;        Set this keyword to the title of the plot.</span>
<span class="comments">;     traditional: in, optional, type=boolean, default=0</span>
<span class="comments">;         If this keyword is set, the traditional color scheme of a black background for</span>
<span class="comments">;         graphics windows on the display is used and PostScript files always use a white background.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in the current cgWindow or to</span>
<span class="comments">;        create a new cgWindow, if one doesn't currenly exist, for displaying this command.</span>
<span class="comments">;        To create a new cgWindow if one currenly exists, use the `cgWindow` command</span>
<span class="comments">;     xstyle: in, optional, type=integer, default=1</span>
<span class="comments">;        If unused in the program, set to 1 to force exact axis scaling.</span>
<span class="comments">;     xthick: in, optional, type=integer, default=1</span>
<span class="comments">;        The thickness of the X axis annotations.</span>
<span class="comments">;     xticklen: in, optional, type=float, default=0.025</span>
<span class="comments">;        The length of the X tick marks. Set to a negative value to create outward</span>
<span class="comments">;        facing tick marks.</span>
<span class="comments">;     xticks: in, optional, type=integer</span>
<span class="comments">;        The number of tick intervals on the X axis.</span>
<span class="comments">;     xtickv: in, optional, type=string</span>
<span class="comments">;        A vector of tick values to use with the tick marks. See IDL documentation for</span>
<span class="comments">;        graphics keywords for additional information.</span>
<span class="comments">;     xtitle: in, optional, type=string</span>
<span class="comments">;        Set this keyword to the X title of the plot.</span>
<span class="comments">;     ystyle: in, optional, type=integer, default=1</span>
<span class="comments">;        If unused in the program, set to 1 to force exact axis scaling.</span>
<span class="comments">;     ythick: in, optional, type=integer, default=1</span>
<span class="comments">;        The thickness of the Y axis annotations.</span>
<span class="comments">;     yticklen: in, optional, type=float, default=0.025</span>
<span class="comments">;        The length of the Y tick marks. Set to a negative value to create outward</span>
<span class="comments">;        facing tick marks.</span>
<span class="comments">;     yticks: in, optional, type=integer</span>
<span class="comments">;        The number of tick intervals on the Y axis.</span>
<span class="comments">;     ytickv: in, optional, type=string</span>
<span class="comments">;        A vector of tick values to use with the tick marks. See IDL documentation for</span>
<span class="comments">;        graphics keywords for additional information.</span>
<span class="comments">;     ytitle: in, optional, type=string</span>
<span class="comments">;        Set this keyword to the Y title of the plot.</span>
<span class="comments">;     _ref_extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the `IDL Contour command &lt;http://www.exelisvis.com/docs/CONTOUR_Procedure.html>` </span>
<span class="comments">;        is allowed in the program.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Use as you would use the IDL CONTOUR command::</span>
<span class="comments">;       data = dist(51)</span>
<span class="comments">;       cgContour, data</span>
<span class="comments">;       LoadCT, 33</span>
<span class="comments">;       cgContour, data, /FILL</span>
<span class="comments">;       cgContour, data, /OVERPLOT</span>
<span class="comments">;       </span>
<span class="comments">;    If you wish to overplot on top of an image, use the ONIMAGE keyword, rather</span>
<span class="comments">;    than the OVERPLOT keyword:</span>
<span class="comments">;       cgImage, data, /SCALE, XRANGE=[-10, 10], YRANGE=[-5,5], /AXES</span>
<span class="comments">;       cgContour, data, /ONIMAGE</span>
<span class="comments">;          </span>
<span class="comments">;       </span>
<span class="comments">;       See `Device Independent Contour Plots &lt;http://www.idlcoyote.com/graphics_tips/cgcontour.html>` </span>
<span class="comments">;       for additional examples.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 11 November 2010. DWF.</span>
<span class="comments">;        Restored the CELL_FILL keyword, which had been accidentally removed in</span>
<span class="comments">;           the earlier version. 12 November 2010. DWF.</span>
<span class="comments">;        Add the ability to specify the contour colors as color names. 16 November 2010. DWF.</span>
<span class="comments">;        Now setting decomposition state by calling SetDecomposedState. 16 November 2010. DWF.</span>
<span class="comments">;        Final color table restoration skipped in Z-graphics buffer. 17 November 2010. DWF.</span>
<span class="comments">;        Background keyword now applies in PostScript file as well. 17 November 2010. DWF.</span>
<span class="comments">;        Many changes after BACKGROUND changes to get !P.MULTI working again! 18 November 2010. DWF.</span>
<span class="comments">;        Fixed a small problem with the OVERPLOT keyword. 18 Nov 2010. DWF.</span>
<span class="comments">;        Changes so that color variables don't change type. 23 Nov 2010. DWF.</span>
<span class="comments">;        Added WINDOW keyword to allow graphic to be displayed in a resizable graphics window. 8 Dec 2010. DWF</span>
<span class="comments">;        Modifications to allow cgContour to be drop-in replacement for old Contour commands in </span>
<span class="comments">;            indexed color mode. 24 Dec 2010. DWF.</span>
<span class="comments">;        Previous changes introduced problems with OVERPLOT that have now been fixed. 28 Dec 2010. DWF.</span>
<span class="comments">;        Set NOERASE keyword from !P.NoErase system variable when appropriate. 28 Dec 2010. DWF.</span>
<span class="comments">;        Additional problems with NOERASE discovered and solved. 29 Dec 2010. DWF.</span>
<span class="comments">;        Change to DECOMPOSED color was using incorrect color tables. 29 Dec 2010. DWF.</span>
<span class="comments">;        In some cases, I was turning BYTE values to strings without converting to </span>
<span class="comments">;            INTEGERS first. 30 Dec 2010. DWF.</span>
<span class="comments">;        Still working on getting contour colors to work in decomposed color mode in all </span>
<span class="comments">;             circumstances. 2 Jan 2011. DWF.</span>
<span class="comments">;        Fixed problem with FILL when no contour colors (C_COLORS) are specified. 3 Jan 2011. DWF.</span>
<span class="comments">;        Fixed a problem that preventing output keyword (e.g., PATH_INFO) from being returned properly. </span>
<span class="comments">;             3 Jan 2011. DWF.</span>
<span class="comments">;        Fixed a problem calculating NLEVELS when LEVELS keyword was used instead. 3 Jan 2011. DWF.</span>
<span class="comments">;        TVLCT commands protected from NULL device. 4 Jan 2011. DWF.</span>
<span class="comments">;        Fixed a no color problem when CELL_FILL was set. 11 Jan 2011. DWF.</span>
<span class="comments">;        Fixed a problem with overlaying filled contours with /OVERPLOT. 11 Jan 2011. DWF.</span>
<span class="comments">;        Selecting character size now with cgDefCharSize. 11 Jan 2011. DWF.      </span>
<span class="comments">;        Moved setting to decomposed color before color selection process to avoid PostScript</span>
<span class="comments">;             background problems when passed 24-bit color integers. 12 Jan 2011. DWF.   </span>
<span class="comments">;        Fixed a problem in which I assumed the background color was a string. 18 Jan 2011. DWF.  </span>
<span class="comments">;        Added ADDCMD keyword. 26 Jan 2011. DWF.</span>
<span class="comments">;        Added LAYOUT keyword. 28 Jan 2011. DWF.</span>
<span class="comments">;        Added PALETTE keyword. 4 Feb 2011. DWF.</span>
<span class="comments">;        Color table vectors must be obtained AFTER loading the color palette. 6 March 2011. DWF.</span>
<span class="comments">;        Modified error handler to restore the entry decomposition state if there is an error. 17 March 2011. DWF</span>
<span class="comments">;        Modifications to allow palettes of less than 256 elememts in length to be used. 1 April 2011. DWF.</span>
<span class="comments">;        Modifications to repair axes and tickmarks when creating filled contour plots. 28 May 2011. DWF.</span>
<span class="comments">;        Whoops! Last fix shouldn't apply to OVERPLOTTING. Fixed. 22 June 2011. DWF.</span>
<span class="comments">;        Still more work to get axes overplotting to work correct. 5 July 2011. DWF.</span>
<span class="comments">;        Added an ONIMAGE keyword that allows the contours to be overplotted on top of an image that</span>
<span class="comments">;           has been displayed with cgImage. This requires that the SAVE keyword is set in the </span>
<span class="comments">;           cgImage call.</span>
<span class="comments">;        Improved error handling. 26 Aug 2011. DWF.</span>
<span class="comments">;        Got the data type correct in the part of the code that creates levels. 6 Sept 2011. DWF.</span>
<span class="comments">;        Small change to allow cgWindow to set the current graphics window if it is the only</span>
<span class="comments">;           window on the display. 15 Sept 2011. DWF.</span>
<span class="comments">;        Had to add XTICKV, YTICKV, XTICKS, and YTICKS keywords to get repaired axes to work</span>
<span class="comments">;            properly on filled contour plots. There may be other keywords needed, but I am </span>
<span class="comments">;            going to add them on an as-needed basis. 30 Sept 2011. DWF.</span>
<span class="comments">;        Other keywords WERE needed! I added XTICKLEN and YTICKLEN keywords to the repaired axes</span>
<span class="comments">;            code. 3 Oct 2011. DWF.</span>
<span class="comments">;        Change from 15 Sept 2011 forgot to include the possibility of pixmap windows. Algorithm</span>
<span class="comments">;            made more robust. 27 Oct 2011. DWF.</span>
<span class="comments">;        There was a problem with axes when plotting contours in 3D that has been fixed. 18 Nov 2011. DWF.</span>
<span class="comments">;        Added OLEVELS keyword. 7 Dec 2011. DWF.</span>
<span class="comments">;        Added OUTLINE and OUTCOLOR keywords. 8 Dec 2011. DWF.</span>
<span class="comments">;        Modified the way the axes are drawn when given a negative tick length. 9 Dec 2011. DWF.</span>
<span class="comments">;        Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;        PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2001. DWF.</span>
<span class="comments">;        Made sure the OUTLINE keyword works with CELL_FILL, too. 16 Dec 2011. DWF.</span>
<span class="comments">;        Modified to use cgDefaultColor for default color selection. 24 Dec 2011. DWF.</span>
<span class="comments">;        Added MAP_OBJECT keyword. 28 Dec 2011. DWF.</span>
<span class="comments">;        Changes to allow better default colors, based on changes to cgColor and cgDefaultColor. 1 Feb 2012. DWF.</span>
<span class="comments">;        Axis repair for filled contour plots (done with AXIS) results in incorrect tick labeling with</span>
<span class="comments">;            date/time axes. Replaced repair code with actual Contour command. 9 March 2012. DWF.</span>
<span class="comments">;        Fixed a problem with color palettes by defining NLEVELS according to the number of colors</span>
<span class="comments">;            in the palette. 19 March 2012. DWF.</span>
<span class="comments">;        Now allowing the user to draw in the "background" color, if the COLOR or AXISCOLOR is "BACKGROUND". 19 March 2012. DWF.</span>
<span class="comments">;        The axis repair change on 9 March was not working in multi plots because the plot was already</span>
<span class="comments">;            advanced. Added a fix to make sure the repair is to the correct multi plot. 20 April 2012. DWF.           </span>
<span class="comments">;        Added an ASPECT keyword to maintain the program aspect ratio. 12 July 2012. DWF.</span>
<span class="comments">;        Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;        Added C_ANNOTATION keyword. 10 Nov 2012. DWF.</span>
<span class="comments">;        Modified the way default colors are selected when the background color is "white". 4 Dec 2012. DWF.</span>
<span class="comments">;        Making more effort to set the CELL_FILL keyword instead of FILL if filling contours on maps. 7 Jan 2013. DWF.</span>
<span class="comments">;        Added C_ORIENTATION and C_SPACING keywords and modified the program to allow line filling. 28 Jan 2013. DWF.</span>
<span class="comments">;        Added ISOTROPIC keyword. 27 June 2013. DWF.</span>
<span class="comments">;        </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2010-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgContour, data, x, y, $
    ADDCMD=addcmd, $
    ASPECT=aspect, $
    AXISCOLOR=saxiscolor, $
    AXESCOLOR=saxescolor, $
    BACKGROUND=sbackground, $
    C_ANNOTATION=c_annotation, $
    C_CHARSIZE=c_charsize, $
    C_COLORS=c_colors, $
    C_LABELS=c_labels, $
    C_ORIENTATION=c_orientation, $
    C_SPACING=c_spacing, $
    CELL_FILL=cell_fill, $
    CHARSIZE=charsize, $
    COLOR=scolor, $
    FILL=fill, $
    FONT=font, $
    ISOTROPIC=isotropic, $
    IRREGULAR=irregular, $
    LABEL=label, $
    LAYOUT=layout, $
    LEVELS=levels, $
    NLEVELS=nlevels, $
    NOCLIP=noclip, $
    NOERASE=noerase, $
    MAP_OBJECT=map_object, $
    MISSINGVALUE=missingvalue, $
    OLEVELS=olevels, $
    ONIMAGE=onImage, $
    OUTCOLOR=outcolor, $
    OUTFILENAME=outfilename, $
    OUTLINE=outline, $
    OUTPUT=output, $
    OVERPLOT=overplot, $
    PALETTE=palette, $
    POSITION=position, $
    RESOLUTION=resolution, $
    T3D=t3d, $
    TITLE=title, $
    TRADITIONAL=traditional, $
    WINDOW=window, $
    XSTYLE=xstyle, $
    XTHICK=xthick, $
    XTICKLEN=xticklen, $
    XTICKV=xtickv, $
    XTICKS=xticks, $
    XTITLE=xtitle, $
    YSTYLE=ystyle, $
    YTHICK=ythick, $
    YTICKLEN=yticklen, $
    YTICKV=ytickv, $
    YTICKS=yticks, $
    YTITLE=ytitle, $
    ZVALUE=zvalue, $
    _REF_EXTRA=extra
    
    Compile_Opt idl2

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
        IF (!D.Name NE "NULL") && (N_Elements(rr) NE 0) THEN TVLCT, rr, gg, bb
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        RETURN
    ENDIF
    
    <span class="comments">; Check parameters.</span>
    IF N_Elements(data) EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgContour, data, x, y, NLEVELS=10'
        RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Check parameters.</span>
    IF N_Params() EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgContour, data, x, y'
        RETURN
    ENDIF

    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
            
        IF Keyword_Set(overplot) OR Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgContour', data, x, y, $
                ASPECT=aspect, $
                AXISCOLOR=saxiscolor, $
                AXESCOLOR=saxescolor, $
                BACKGROUND=sbackground, $
                C_ANNOTATION=c_annotation, $
                C_CHARSIZE=c_charsize, $
                C_COLORS=c_colors, $
                C_LABELS=c_labels, $
                C_ORIENTATION=c_orientation, $
                C_SPACING=c_spacing, $
                CELL_FILL=cell_fill, $
                CHARSIZE=charsize, $
                COLOR=scolor, $
                FONT=font, $
                FILL=fill, $
                ISOTROPIC=isotropic, $
                IRREGULAR=irregular, $
                LABEL=label, $
                LAYOUT=layout, $
                LEVELS=levels, $
                NLEVELS=nlevels, $
                NOCLIP=noclip, $
                NOERASE=noerase, $
                MAP_OBJECT=map_object, $
                MISSINGVALUE=missingvalue, $
                OLEVELS=olevels, $
                ONIMAGE=onimage, $
                OUTCOLOR=outcolor, $
                OUTLINE=outline, $
                OVERPLOT=overplot, $
                PALETTE=palette, $
                POSITION=position, $
                RESOLUTION=resolution, $
                T3D=t3d, $
                TITLE=title, $
                TRADITIONAL=traditional, $
                XSTYLE=xstyle, $
                XTHICK=xthick, $
                XTICKLEN=xticklen, $
                XTICKV=xtickv, $
                XTICKS=xticks, $
                XTITLE=xtitle, $
                YSTYLE=ystyle, $
                YTHICK=ythick, $
                YTICKLEN=yticklen, $
                YTICKV=ytickv, $
                YTICKS=yticks, $
                YTITLE=ytitle, $
                ZVALUE=zvalue, $
                ADDCMD=1, $
                _Extra=extra
             RETURN
       ENDIF
        
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        cgWindow, 'cgContour', data, x, y, $
            ASPECT=aspect, $
            AXISCOLOR=saxiscolor, $
            AXESCOLOR=saxescolor, $
            BACKGROUND=sbackground, $
            C_ANNOTATION=c_annotation, $
            C_CHARSIZE=c_charsize, $
            C_COLORS=c_colors, $
            C_LABELS=c_labels, $
            C_ORIENTATION=c_orientation, $
            C_SPACING=c_spacing, $
            CELL_FILL=cell_fill, $
            CHARSIZE=charsize, $
            COLOR=scolor, $
            FONT=font, $
            FILL=fill, $
            ISOTROPIC=isotropic, $
            IRREGULAR=irregular, $
            LABEL=label, $
            LAYOUT=layout, $
            LEVELS=levels, $
            NLEVELS=nlevels, $
            NOCLIP=noclip, $
            NOERASE=noerase, $
            MAP_OBJECT=map_object, $
            MISSINGVALUE=missingvalue, $
            OLEVELS=olevels, $
            ONIMAGE=onimage, $
            OUTCOLOR=outcolor, $
            OUTLINE=outline, $
            OVERPLOT=overplot, $
            PALETTE=palette, $
            POSITION=position, $
            RESOLUTION=resolution, $
            T3D=t3d, $
            TITLE=title, $
            TRADITIONAL=traditional, $
            XSTYLE=xstyle, $
            XTHICK=xthick, $
            XTICKLEN=xticklen, $
            XTICKV=xtickv, $
            XTICKS=xticks, $
            XTITLE=xtitle, $
            YSTYLE=ystyle, $
            YTHICK=ythick, $
            YTICKLEN=yticklen, $
            YTICKV=ytickv, $
            YTICKS=yticks, $
            YTITLE=ytitle, $
            ZVALUE=zvalue, $
            REPLACECMD=replaceCmd, $
            _Extra=extra
            
         RETURN
    ENDIF

    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    ENDIF
    
    <span class="comments">; If you supplied annotation, check it for embedded symbols.</span>
    IF N_Elements(c_annotation) NE 0 THEN BEGIN
        FOR j=0,N_Elements(c_annotation)-1 DO c_annotation[j] = cgCheckForSymbols(c_annotation[j])
    ENDIF
    
    <span class="comments">; Is the ISOTROPIC keyword set?</span>
    IF Keyword_Set(isotropic) THEN BEGIN
        IF N_Elements(x) NE 0 THEN xrange = Max(x, /NaN) - Min(x, /NaN)
        IF N_Elements(y) NE 0 THEN yrange = Max(y, /NaN) - Min(y, /NaN)
        dims = Size(data, /Dimensions)
        IF N_Elements(x) EQ 0 THEN xrange = dims[0]
        IF N_Elements(y) EQ 0 THEN yrange = dims[1]
        aspect = Float(yrange) / xrange
    ENDIF
   
    IF (N_Elements(aspect) NE 0) && (Total(!P.MULTI) EQ 0) THEN BEGIN
    
        <span class="comments">; If position is set, then fit the plot into those bounds.</span>
        IF (N_Elements(position) GT 0) THEN BEGIN
          trial_position = Aspect(aspect, margin=0.)
          trial_width = trial_position[2]-trial_position[0]
          trial_height = trial_position[3]-trial_position[1]
          pos_width = position[2]-position[0]
          pos_height = position[3]-position[1]

          <span class="comments">; Same logic as cgImage: try to fit image width, then if you can't get the right aspect</span>
          <span class="comments">; ratio, fit the image height instead.</span>
          fit_ratio = pos_width / trial_width
          IF trial_height * fit_ratio GT pos_height THEN $
             fit_ratio = pos_height / trial_height

          <span class="comments">; new width and height</span>
          trial_width *= fit_ratio
          trial_height *= fit_ratio

          <span class="comments">; calculate position vector based on trial_width and trial_height</span>
          position[0] += 0.5*(pos_width - trial_width)
          position[2] -= 0.5*(pos_width - trial_width)
          position[1] += 0.5*(pos_height - trial_height)
          position[3] -= 0.5*(pos_height - trial_height)
        ENDIF ELSE position=Aspect(aspect)   <span class="comments">; if position isn't set, just use output of Aspect</span>
        
    ENDIF
    
    <span class="comments">; If you want to overplot on an image, set the OVERPLOT keyword.</span>
    IF Keyword_Set(onImage) THEN overplot = 1
    
    <span class="comments">; Going to have to do all of this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState
    
    <span class="comments">; If current state is "indexed color" and colors are represented as long integers then "fix" them.</span>
    IF (currentState EQ 0) THEN BEGIN
      IF Size(sbackground, /TNAME) EQ 'LONG' THEN sbackground = Fix(sbackground)
      IF Size(saxiscolor, /TNAME) EQ 'LONG' THEN saxiscolor = Fix(saxiscolor)
      IF Size(saxescolor, /TNAME) EQ 'LONG' THEN saxescolor = Fix(saxescolor)
      IF Size(scolor, /TNAME) EQ 'LONG' THEN scolor = Fix(scolor)
    ENDIF
    
    <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)
    
    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

    <span class="comments">; Character size has to be determined *after* the layout has been decided.</span>
    IF N_Elements(font) EQ 0 THEN font = !P.Font
    IF Keyword_Set(t3d) && (!D.Name EQ 'PS') THEN font = -1
    IF N_Elements(title) EQ 0 THEN title = "" ELSE title = cgCheckForSymbols(title)
    IF N_Elements(xtitle) EQ 0 THEN xtitle = "" ELSE xtitle = cgCheckForSymbols(xtitle)
    IF N_Elements(ytitle) EQ 0 THEN ytitle = "" ELSE ytitle = cgCheckForSymbols(ytitle)
    IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize(FONT=font)
    IF N_Elements(c_charsize) EQ 0 THEN c_charsize = charsize * 0.75
    
    <span class="comments">; Handle data properly.</span>
    ndims = Size(data, /N_DIMENSIONS)
    s = Size(data, /DIMENSIONS)
    CASE ndims OF
        1: BEGIN
           IF N_Elements(x) EQ 0 THEN BEGIN
               IF Keyword_Set(onImage) THEN BEGIN
                   CASE !X.TYPE OF
                      0: xgrid = cgScaleVector(Indgen(s[0]), !X.CRange[0], !X.CRange[1])
                      1: xgrid = cgScaleVector(Indgen(s[0]), 10^!X.CRange[0], 10^!X.CRange[1])
                      3: Message, 'Must supply LONGITUDE vector when overplotting on map projections'
                   ENDCASE
               ENDIF ELSE BEGIN
                  xgrid = Indgen(s[0])
               ENDELSE
           ENDIF ELSE xgrid = x
           IF N_Elements(y) EQ 0 THEN BEGIN
               IF Keyword_Set(onImage) THEN BEGIN
                   CASE !Y.TYPE OF
                      0: ygrid = cgScaleVector(Indgen(s[1]), !Y.CRange[0], !Y.CRange[1])
                      1: ygrid = cgScaleVector(Indgen(s[1]), 10^!Y.CRange[0], 10^!Y.CRange[1])
                      3: Message, 'Must supply LATITUDE vector when overplotting on map projections'
                   ENDCASE
               ENDIF ELSE BEGIN
                  ygrid = Indgen(s[1])
               ENDELSE
           ENDIF ELSE ygrid = y
           END
        2: BEGIN
           IF N_Elements(x) EQ 0 THEN BEGIN
               IF Keyword_Set(onImage) THEN BEGIN
                   CASE !X.TYPE OF
                      0: xgrid = cgScaleVector(Indgen(s[0]), !X.CRange[0], !X.CRange[1])
                      1: xgrid = cgScaleVector(Indgen(s[0]), 10^!X.CRange[0], 10^!X.CRange[1])
                      3: Message, 'Must supply LONGITUDE vector when overplotting on map projections'
                   ENDCASE
               ENDIF ELSE BEGIN
                  xgrid = Indgen(s[0])
               ENDELSE
           ENDIF ELSE xgrid = x
           IF N_Elements(y) EQ 0 THEN BEGIN
               IF Keyword_Set(onImage) THEN BEGIN
                   CASE !Y.TYPE OF
                      0: ygrid = cgScaleVector(Indgen(s[1]), !Y.CRange[0], !Y.CRange[1])
                      1: ygrid = cgScaleVector(Indgen(s[1]), 10^!Y.CRange[0], 10^!Y.CRange[1])
                      3: Message, 'Must supply LATITUDE vector when overplotting on map projections'
                   ENDCASE
               ENDIF ELSE BEGIN
                  ygrid = Indgen(s[1])
               ENDELSE
           ENDIF ELSE ygrid = y
           END
        ELSE: Message, 'Contour data must be 1D or 2D.'
    ENDCASE
    
    <span class="comments">; Get the current color table vectors. The NULL business was put here at</span>
    <span class="comments">; the request of Wayne Landsman in support of NASA Astronomy Library. It</span>
    <span class="comments">; is important for programs NASA runs.</span>
    IF (!D.Name NE 'NULL') THEN BEGIN
         
        <span class="comments">; If you have a palette, load the colors now. Otherwise whatever colors</span>
        <span class="comments">; are in the current color table will be used. If you are using a palette,</span>
        <span class="comments">; you should NOT use C_COLORS, so I undefine it.</span>
        IF N_Elements(palette) NE 0 THEN BEGIN
            IF Size(palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
            dims = Size(palette, /DIMENSIONS)
            threeIndex = Where(dims EQ 3)
            IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
            IF threeIndex[0] EQ 0 THEN palette = Transpose(palette)
            TVLCT, p_red, p_grn, p_blu, /Get <span class="comments">; Save the color vectors before loading the palette.</span>
            TVLCT, palette
            
            <span class="comments">; Set up contour colors for the palette. If you passed contour colors,</span>
            <span class="comments">; then I assume these are indices into the color palette.</span>
            IF N_Elements(c_colors) NE 0 THEN con_colors = cgColor24(palette[c_colors,*])
            
            <span class="comments">; If the palette contains fewer colors than the color table, then I assume</span>
            <span class="comments">; the palette is just for contour colors.</span>
            IF (N_Elements(c_colors) EQ 0) && ((N_Elements(palette)/3) LT 256) THEN BEGIN
                con_colors = cgColor24(palette)
            ENDIF
            
            <span class="comments">; If the number of contour colors is less than 256, and LEVELS and NLEVELS are</span>
            <span class="comments">; both undefined, then let's define NLEVELS to be equal to the number of contour</span>
            <span class="comments">; colors in the color palette.</span>
            dims = Size(palette, /DIMENSIONS) <span class="comments">; First dimension is now the number of colors.</span>
            IF (dims[0] LT 256) && (N_Elements(levels) EQ 0) && (N_Elements(nlevels) EQ 0) THEN BEGIN
               nlevels = dims[0]
            ENDIF
        ENDIF

       <span class="comments">; Get the color table vectors. Must do AFTER loading the palette, or</span>
       <span class="comments">; PostScript can't be produced properly.</span>
       TVLCT, rr, gg, bb, /GET
    ENDIF
    
    <span class="comments">; Check the color keywords.</span>
    background = cgDefaultColor(sbackground, /BACKGROUND, TRADITIONAL=traditional)
    IF Size(background, /TNAME) EQ 'STRING' && (StrUpCase(background[0]) EQ 'WHITE') THEN BEGIN
       IF (N_Elements(saxisColor) EQ 0) && (N_Elements(saxesColor) NE 0) THEN saxisColor = saxesColor
       axisColor = cgDefaultColor(saxisColor, DEFAULT='black', TRADITIONAL=traditional)
       color = cgDefaultColor(sColor, DEFAULT='black', TRADITIONAL=traditional)
    ENDIF ELSE BEGIN
       IF (N_Elements(saxisColor) EQ 0) && (N_Elements(saxesColor) NE 0) THEN saxisColor = saxesColor
       axisColor = cgDefaultColor(saxisColor, TRADITIONAL=traditional)
       color = cgDefaultColor(sColor, DEFAULT=axisColor, TRADITIONAL=traditional)
    ENDELSE

    <span class="comments">; If color is the same as background, do something. Since this precludes drawing the the</span>
    <span class="comments">; background color (perhaps you want to "erase" something), I offer an exception. If the</span>
    <span class="comments">; COLOR is "Background", I am going to assume you know what you are doing!</span>
    IF ColorsAreIdentical(background, color) THEN BEGIN
        IF ((!D.Flags AND 256) NE 0) THEN BEGIN
           IF (!P.Multi[0] EQ 0) && (~Keyword_Set(overplot) && ~noerase) THEN cgErase, background
        ENDIF
        IF (Size(color, /TNAME) EQ 'STRING') THEN BEGIN
            IF (StrUpCase(color) NE 'BACKGROUND') THEN color = 'OPPOSITE'
        ENDIF ELSE color = 'OPPOSITE'
    ENDIF
    IF ColorsAreIdentical(background, axiscolor) THEN BEGIN
        IF ((!D.Flags AND 256) NE 0) THEN BEGIN
           IF (!P.Multi[0] EQ 0) && (~Keyword_Set(overplot) && ~noerase) THEN cgErase, background
        ENDIF
        IF (Size(axiscolor, /TNAME) EQ 'STRING') THEN BEGIN
           IF (StrUpCase(axiscolor) NE 'BACKGROUND') THEN axiscolor = 'OPPOSITE'
        ENDIF ELSE axiscolor = 'OPPOSITE'
    ENDIF
    
    <span class="comments">; Default values for keywords.</span>
    fill = Keyword_Set(fill)
    
    <span class="comments">; Really need CELL_FILL instead of FILL if you are overplotting onto a map projection.</span>
    IF fill && ((N_Elements(map_object) NE 0) || (!X.Type EQ 3)) && Keyword_Set(overplot) THEN BEGIN
        fill = 0
        cell_fill = 1
    ENDIF
    cell_fill = Keyword_Set(cell_fill)
    irregular = Keyword_Set(irregular)
    SetDefaultValue, label, 1
    SetDefaultValue, resolution, [41,41]
    SetDefaultValue, outcolor, 'charcoal'
    outline = Keyword_Set(outline)
    IF N_Elements(nlevels) EQ 0 THEN BEGIN
        IF N_Elements(levels) EQ 0 THEN nlevels = 6 ELSE nlevels = N_Elements(levels)
    ENDIF    
    t3d = Keyword_Set(t3d)
    IF t3d THEN BEGIN
        IF N_Elements(zvalue) EQ 0 THEN zvalue = 0
        IF N_Elements(noclip) EQ 0 THEN noclip = 1
    ENDIF
    noclip = Keyword_Set(noclip)
    SetDefaultValue, xstyle, 1
    SetDefaultValue, ystyle, 1
    IF N_Elements(missingvalue) NE 0 THEN BEGIN
        IF  (Size(data, /TNAME) NE 'FLOAT') $
        AND (Size(data, /TNAME) NE 'DOUBLE') $
        THEN contourData = Float(data) ELSE contourData = data
        missingIndices = Where(contourData EQ missingValue[0], missingCount)
        IF missingCount GT 0 THEN BEGIN
            contourData[missingIndices] = !Values.F_NAN
            IF Keyword_Set(fill) THEN BEGIN
               fill = 0
               cell_fill = 1
            ENDIF
        ENDIF
    ENDIF ELSE contourData = data
    
    <span class="comments">; Handle gridding of irregular data.</span>
    IF irregular THEN BEGIN
        Triangulate, xgrid, ygrid, triangles
        contourData = Trigrid(xgrid, ygrid, contourData, triangles, $
            NX=resolution[0], NY=resolution[1], $
            XGRID=xgrid, YGRID=ygrid, MISSING=!Values.F_NAN)
        IF Keyword_Set(fill) THEN BEGIN
           fill = 0
           cell_fill = 1
        ENDIF
     ENDIF
  
    <span class="comments">; Do you need to calculate levels.</span>
    IF N_Elements(levels) EQ 0 THEN BEGIN
        minData = Min(contourData, /NAN, MAX=maxData)
        IF Size(minData, /TYPE) EQ 2 THEN minData = Float(minData)     <span class="comments">;Avoid 16 bit integer overflow</span>
        levels = ((maxData - minData) / Float(nlevels)) * Indgen(nlevels) + minData
    ENDIF
    
    <span class="comments">; Need to make sure contour colors are integers if they are indices. </span>
    IF N_Elements(c_colors) NE 0 THEN BEGIN
        IF Size(c_colors, /TNAME) NE 'STRING' THEN BEGIN
           IF (Size(c_colors, /TYPE) EQ 3) && (Max(c_colors) LE 255) THEN BEGIN
                con_colors = Fix(c_colors)
           ENDIF ELSE BEGIN
                IF N_Elements(palette) NE 0 THEN BEGIN
                    TVLCT, palette
                    IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, /Get
                    rrr = Congrid(rrr, nlevels)
                    ggg = Congrid(ggg, nlevels)
                    bbb = Congrid(bbb, nlevels)
                    IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, 1
                    IF N_Elements(con_colors) EQ 0 THEN con_colors = StrTrim(Indgen(nlevels)+1,2)
                ENDIF ELSE BEGIN
                    con_colors = c_colors
                ENDELSE
           ENDELSE
        ENDIF ELSE con_colors = c_colors
    ENDIF ELSE BEGIN
        IF Keyword_Set(fill) OR Keyword_Set(cell_fill) THEN BEGIN
            IF N_Elements(palette) NE 0 THEN IF (!D.Name NE 'NULL') THEN TVLCT, palette
            IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, /Get
            rrr = Congrid(rrr, nlevels)
            ggg = Congrid(ggg, nlevels)
            bbb = Congrid(bbb, nlevels)
            IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, 1
            IF N_Elements(con_colors) EQ 0 THEN con_colors = StrTrim(Indgen(nlevels)+1,2)
        ENDIF ELSE BEGIN
            con_colors = Replicate(color, nlevels)
        ENDELSE
        IF Size(con_colors, /TYPE) EQ 3 THEN IF GetDecomposedState() EQ 0 THEN con_colors = Byte(con_colors)
        IF Size(con_colors, /TYPE) LE 2 THEN con_colors = StrTrim(Fix(c_colors),2)
    ENDELSE
    
    <span class="comments">; Set up the appropriate contour labeling. Only can do if C_LABELS not passed in.</span>
    IF N_Elements(c_labels) EQ 0 THEN BEGIN
        indices = Indgen(N_Elements(levels))
        IF label EQ 0 THEN BEGIN
           c_labels = Replicate(0,N_Elements(levels))
        ENDIF ELSE c_labels = Reverse((indices MOD label) EQ 0)
    ENDIF

    <span class="comments">; Load the drawing colors. If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    IF Size(axiscolor, /TNAME) EQ 'STRING' THEN axiscolor = cgColor(axiscolor)
    IF Size(color, /TNAME) EQ 'STRING' THEN color = cgColor(color)
    IF Size(background, /TNAME) EQ 'STRING' THEN background = cgColor(background)
    IF (Size(con_colors, /TYPE) LE 2) && (Size(con_colors, /TYPE) NE 0) THEN con_colors = StrTrim(Fix(con_colors),2)
    IF Size(con_colors, /TNAME) EQ 'STRING' THEN con_colors = cgColor(con_colors)
    
    <span class="comments">; If you get here with no position defined, and no layout, and no !P.Multi and no nothing,</span>
    <span class="comments">; then for God's sake, define a reasonable position in the window!</span>
    IF (N_Elements(position) EQ 0) && (Total(!P.Position) EQ 0) && $
        (N_Elements(layout) EQ 0) && (Total(!P.Multi) LE 0) && ~Keyword_Set(overplot) THEN BEGIN
        position = [0.125, 0.125, 0.925, 0.9]
    ENDIF
    
    <span class="comments">; Do you need a PostScript background color? Lot's of problems here!</span>
    <span class="comments">; Basically, I MUST draw a plot to advance !P.MULTI. But, drawing a</span>
    <span class="comments">; plot of any sort erases the background color. So, I have to draw a </span>
    <span class="comments">; plot, store the new system variables, then draw my background, etc.</span>
    <span class="comments">; I have tried LOTS of options. This is the only one that worked.</span>
    IF !D.Name EQ 'PS' THEN BEGIN
       IF Keyword_Set(noerase) EQ 0 THEN BEGIN
       
           <span class="comments">; I only have to do this, if this is the first plot.</span>
           IF !P.MULTI[0] EQ 0 THEN BEGIN
           
                IF Keyword_Set(overplot) NE 1 THEN BEGIN

                    <span class="comments">; Save the current system variables. Will need to restore later.</span>
                    bangx = !X
                    bangy = !Y
                    bangp = !P
 
                    <span class="comments">; Make sure axis are turned off. I don't really want to draw anything,</span>
                    <span class="comments">; just advance !P.MULTI or "erase" the display for the next plot.</span>
                    IF BitGet(xstyle, 2) NE 1 THEN xxstyle = xstyle + 4 ELSE xxstyle = xstyle
                    IF BitGet(ystyle, 2) NE 1 THEN yystyle = xstyle + 4 ELSE yystyle = ystyle
                    
                    <span class="comments">; Draw the plot that doesn't draw anything.</span>
                     Contour, contourData, xgrid, ygrid, COLOR=axiscolor, CHARSIZE=charsize, $
                        BACKGROUND=background, LEVELS=levels, XSTYLE=xstyle, YSTYLE=xstyle, $
                        POSITION=position, _STRICT_EXTRA=extra, T3D=t3d, XTHICK=xthick, YTHICK=ythick, $
                        FONT=font, /NODATA, C_CHARSIZE=c_charsize, XTICKV=xtickv, XTICKS=xticks, $
                        YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip
                    
                    <span class="comments">; Save the "after plot" system variables. Will use later. </span>
                    afterx = !X
                    aftery = !Y
                    afterp = !P     
                    
                    <span class="comments">; Draw the background color and set the variables you will need later.</span>
                    PS_Background, background
                    psnodraw = 1
                    tempNoErase = 1
                    
                    <span class="comments">; Restore the original system variables so that it is as if you didn't</span>
                    <span class="comments">; draw the invisible plot.</span>
                    !X = bangx
                    !Y = bangy
                    !P = bangp
                
                ENDIF
                
            ENDIF ELSE tempNoErase = noerase
        ENDIF ELSE tempNoErase = noerase
     ENDIF ELSE tempNoErase = noerase
     
    <span class="comments">; Storing these system variable is *required* to make !P.MULTI work correctly</span>
    <span class="comments">; when doing filled contours. Do not delete!</span>
    bangx = !X
    bangy = !Y
    bangp = !P
    
    <span class="comments">; If you are not overploting, draw the contour plot now. Only the axes are</span>
    <span class="comments">; drawn here, no data. There is a special case of filling with lines instead</span>
    <span class="comments">; of colors, which is indicated by the "normalFill" keyword being set to 0.</span>
    normalFill = 1
    IF Keyword_Set(overplot) EQ 0 THEN BEGIN

        IF N_Elements(c_orientation) NE 0 THEN BEGIN
          Contour, contourData, xgrid, ygrid, COLOR=axiscolor, CHARSIZE=charsize, $
              BACKGROUND=background, LEVELS=levels, XSTYLE=xstyle, YSTYLE=ystyle, $
              POSITION=position, _STRICT_EXTRA=extra, T3D=t3d, C_COLORS=con_colors,  $
              XTHICK=xthick, YTHICK=ythick, FONT=font, C_CHARSIZE=c_charsize, $
              XTICKLEN=xticklen, YTICKLEN=yticklen, XTICKV=xtickv, XTICKS=xticks, $
              YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip, $
              TITLE=title, XTITLE=xtitle, YTITLE=ytitle, $
              C_ORIENTATION=c_orientation, C_SPACING=c_spacing
           normalFill = 0
        ENDIF ELSE BEGIN
          Contour, contourData, xgrid, ygrid, COLOR=axiscolor, CHARSIZE=charsize, $
              BACKGROUND=background, LEVELS=levels, XSTYLE=xstyle, YSTYLE=ystyle, $
              POSITION=position, _STRICT_EXTRA=extra, T3D=t3d, /NODATA, NOERASE=tempNoErase, $
              XTHICK=xthick, YTHICK=ythick, FONT=font, C_CHARSIZE=c_charsize, $
              XTICKLEN=xticklen, YTICKLEN=yticklen, XTICKV=xtickv, XTICKS=xticks, $
              YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip, $
              TITLE=title, XTITLE=xtitle, YTITLE=ytitle
           
        ENDELSE            
    ENDIF
    
    <span class="comments">; This is where we actually draw the data. Check to see if we have a map object and need to</span>
    <span class="comments">; convert the X and Y grid parameters from longitude/latitude to projected meter space</span>
    <span class="comments">; before we do the drawing.</span>
    IF (Keyword_Set(overplot) && (N_Elements(map_object) NE 0)) THEN BEGIN
    
        <span class="comments">; Do we have a valid map object?</span>
        IF ~Obj_Isa(map_object, 'cgMap') THEN Message, 'The map object is not valid or not the correct type.'
        
        <span class="comments">; Are the X and Y grids the same size? If so, it makes things easy.</span>
        IF (N_Elements(xgrid) EQ N_Elements(ygrid)) THEN BEGIN
           dims = Size(xgrid, /DIMENSIONS)
           n_dims = Size(xgrid, /N_DIMENSIONS)
           IF n_dims EQ 2 THEN BEGIN
              xgrid = Reform(xgrid, dims[0]*dims[1])
              ygrid = Reform(ygrid, dims[0]*dims[1])
           ENDIF
           xy = map_object -> Forward(xgrid, ygrid)
           xgrid = xy[0,*]
           ygrid = xy[1,*]
           IF n_dims EQ 2 THEN BEGIN
              xgrid = Reform(xgrid, dims[0], dims[1])
              ygrid = Reform(ygrid, dims[0], dims[1])
           ENDIF
        ENDIF ELSE BEGIN
           xsize = N_Elements(xgrid)
           ysize = N_Elements(ygrid)
           xgrid = Reform(Rebin(xgrid, xsize, ysize), xsize*ysize)
           ygrid = Reform(Rebin(Reform(ygrid, 1, ysize), xsize, ysize), xsize*ysize)
           xy = map_object -> Forward(xgrid, ygrid)
           xgrid = Reform(xy[0,*], xsize, ysize)
           ygrid = Reform(xy[1,*], xsize, ysize)
        ENDELSE
        
    ENDIF

    <span class="comments">; The actual levels are returned in the OLEVELS keyword.</span>
    olevels = levels
    
    <span class="comments">; Draw the data on the axes.</span>

    IF normalFill THEN BEGIN
        Contour, contourData, xgrid, ygrid, FILL=fill, CELL_FILL=cell_fill, COLOR=color, $
           LEVELS=levels, C_Labels=c_labels, C_COLORS=con_colors, XTHICK=xthick, YTHICK=ythick, $
           POSITION=position, XSTYLE=xstyle, YSTYLE=ystyle, _STRICT_EXTRA=extra, T3D=t3d, CHARSIZE=charsize, $
           FONT=font, /OVERPLOT, C_CHARSIZE=c_charsize, XTICKLEN=xticklen, YTICKLEN=yticklen, $
           XTICKV=xtickv, XTICKS=xticks, YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip, $
           C_ANNOTATION=c_annotation, C_ORIENTATION=c_orientation, C_SPACING=c_spacing, $
           NOERASE=(N_Elements(c_orientation) NE 0) ? 1 : 0
    ENDIF
        
    <span class="comments">; If this is a filled contour plot, and the OUTLINE keyword is set, then draw the contour</span>
    <span class="comments">; outlines over the top of the data. </span>
    IF (fill || cell_fill) && outline THEN BEGIN
        Contour, contourData, xgrid, ygrid, COLOR=cgColor(outcolor), $
           LEVELS=levels, C_Labels=c_labels, XTHICK=xthick, YTHICK=ythick, $
           _STRICT_EXTRA=extra, T3D=t3d, CHARSIZE=charsize, C_ORIENTATION=c_orientation, $
           FONT=font, /OVERPLOT, C_CHARSIZE=c_charsize, XTICKLEN=xticklen, YTICKLEN=yticklen, $
           XTICKV=xtickv, XTICKS=xticks, YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip
    ENDIF

        
    <span class="comments">; If this is the first plot in PS, then we have to make it appear that we have</span>
    <span class="comments">; drawn a plot, even though we haven't.</span>
    IF N_Elements(psnodraw) EQ 1 THEN BEGIN
        !X = afterX
        !Y = afterY
        !P = afterP
    ENDIF
        
    <span class="comments">; If we filled the contour plot, we need to repair the axes. But, in multiple plot we</span>
    <span class="comments">; have already advanced to the next position. We need to restore the position, do our</span>
    <span class="comments">; repair work, and then advance to the next position again.</span>
    IF (~Keyword_Set(overplot)) && (Keyword_Set(fill) || Keyword_Set(cell_fill)) THEN BEGIN 
        IF Total(!P.Multi) NE 0 THEN BEGIN
           fillx = !X
           filly = !Y
           fillp = !P
           !X = bangx
           !Y = bangy
           !P = bangP
        ENDIF
        Contour, contourData, xgrid, ygrid, COLOR=axiscolor, CHARSIZE=charsize, $
            BACKGROUND=background, LEVELS=levels, XSTYLE=xstyle, YSTYLE=ystyle, $
            POSITION=position, _STRICT_EXTRA=extra, T3D=t3d, /NODATA, C_ORIENTATION=c_orientation, $
            XTHICK=xthick, YTHICK=ythick, FONT=font, C_CHARSIZE=c_charsize, $
            XTICKLEN=xticklen, YTICKLEN=yticklen, XTICKV=xtickv, XTICKS=xticks, $
            YTICKV=ytickv, YTICKS=yticks, ZVALUE=zvalue, NOCLIP=noclip, /NOERASE
        IF Total(!P.Multi) NE 0 THEN BEGIN
           !X = fillx
           !Y = filly
           !P = fillp
        ENDIF
     ENDIF
    
    <span class="comments">; Restore the decomposed color state if you can.</span>
    SetDecomposedState, currentState
    
    <span class="comments">; Restore the color table. Can't do this for the Z-buffer or</span>
    <span class="comments">; the snap shot will be incorrect.</span>
    IF (!D.Name NE 'Z') AND (!D.Name NE 'NULL') THEN BEGIN
        TVLCT, rr, gg, bb
        <span class="comments">; If you loaded a color palette, restore the before color vectors.</span>
        IF N_Elements(p_red) NE 0 THEN TVLCT, p_red, p_grn, p_blu
    ENDIF
     
    <span class="comments">; Clean up if you are using a layout.</span>
    IF N_Elements(layout) NE 0 THEN !P.Multi = thisMulti

    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width
              
         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
END
    
</code>
    </div>
  </body>
</html>