<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgsurf.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgsurf.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgSurf</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of cgSurf is to create a wrapper for the traditional IDL graphics</span>
<span class="comments">;   commands, Surface and Shade_Surf. The primary purpose of this is to create surface </span>
<span class="comments">;   commands that work and look identically both on the display and in PostScript files.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2010, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">;   The purpose of cgSurf is to create a wrapper for the traditional IDL graphics</span>
<span class="comments">;   commands, Surface and Shade_Surf. The primary purpose of this is to create surface </span>
<span class="comments">;   commands that work and look identically both on the display and in PostScript files.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    data: in, required, type=any</span>
<span class="comments">;         A two-dimensional array of data to be displayed.</span>
<span class="comments">;    x: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the X coordinates of the</span>
<span class="comments">;         surface grid.</span>
<span class="comments">;    y: in, optional, type=any</span>
<span class="comments">;         A vector or two-dimensional array specifying the Y coordinates of the</span>
<span class="comments">;         surface grid.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to an cgWindow. Setting this keyword</span>
<span class="comments">;        automatically sets the WINDOW keyword, but the command does not erase the</span>
<span class="comments">;        graphics window as it would normally.</span>
<span class="comments">;     axiscolor: in, optional, type=string/integer, default='opposite'</span>
<span class="comments">;        If this keyword is a string, the name of the axis color.</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     axescolor: in, hidden, type=string/integer</span>
<span class="comments">;        Provisions for bad spellers.</span>
<span class="comments">;     background: in, optional, type=string/integer, default='background'</span>
<span class="comments">;        If this keyword is a string, the name of the background color. </span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     bottom: in, optional, type=string/integer, default='black'</span>
<span class="comments">;        If this keyword is a string, the name of the bottom color. By default, same as COLOR.</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     charsize: in, optional, type=float, default=cgDefCharSize*1.25</span>
<span class="comments">;        The character size for axes annotations. Uses cgDefCharSize()*1.25 to select default</span>
<span class="comments">;        character size, unless !P.Charsize is set, in which case !P.Charsize*1.25 is always used.</span>
<span class="comments">;     color: in, optional, type=string/integer, default='blu6'</span>
<span class="comments">;        If this keyword is a string, the name of the data color. By default, "BLU6".</span>
<span class="comments">;        Otherwise, the keyword is assumed to be a color index into the current color table.</span>
<span class="comments">;     elevation_shading: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to put elevation shading into effect for the surface.</span>
<span class="comments">;     font: in, optional, type=integer, default=-1</span>
<span class="comments">;        The type of font desired. If undefined, and the current graphics device is PostScript,</span>
<span class="comments">;        the FONT keyword will be set to 1, indicating true-type fonts. The FONT keyword must</span>
<span class="comments">;        be set to -1 (Hershey fonts) or 1 (true-type fonts) for surface annotations to be</span>
<span class="comments">;        rotated correctly in PostScript output.</span>
<span class="comments">;     layout: in, optional, type=intarr(3)</span>
<span class="comments">;         This keyword specifies a grid with a graphics window and determines where the</span>
<span class="comments">;         graphic should appear. The syntax of LAYOUT is three numbers: [ncolumns, nrows, location].</span>
<span class="comments">;         The grid is determined by the number of columns (ncolumns) by the number of </span>
<span class="comments">;         rows (nrows). The location of the graphic is determined by the third number. The</span>
<span class="comments">;         grid numbering starts in the upper left (1) and goes sequentually by column and then</span>
<span class="comments">;         by row.</span>
<span class="comments">;     noerase: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to prevent the window from erasing the contents before displaying</span>
<span class="comments">;        the surface plot.</span>
<span class="comments">;     outfilename: in, optional, type=string</span>
<span class="comments">;        If the `Output` keyword is set, the user will be asked to supply an output</span>
<span class="comments">;        filename, unless this keyword is set to a non-null string. In that case, the</span>
<span class="comments">;        value of this keyword will be used as the filename and there will be no dialog</span>
<span class="comments">;        presented to the user.</span>
<span class="comments">;     output: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to the type of output desired. Possible values are these::</span>
<span class="comments">;            </span>
<span class="comments">;            'PS'   - PostScript file</span>
<span class="comments">;            'EPS'  - Encapsulated PostScript file</span>
<span class="comments">;            'PDF'  - PDF file</span>
<span class="comments">;            'BMP'  - BMP raster file</span>
<span class="comments">;            'GIF'  - GIF raster file</span>
<span class="comments">;            'JPEG' - JPEG raster file</span>
<span class="comments">;            'PNG'  - PNG raster file</span>
<span class="comments">;            'TIFF' - TIFF raster file</span>
<span class="comments">;            </span>
<span class="comments">;        Or, you can simply set this keyword to the name of the output file, and the type of</span>
<span class="comments">;        file desired will be determined by the file extension. If you use this option, the</span>
<span class="comments">;        user will not be prompted to supply the name of the output file.</span>
<span class="comments">;            </span>
<span class="comments">;        All raster file output is created through PostScript intermediate files (the</span>
<span class="comments">;        PostScript files will be deleted), so ImageMagick and Ghostview MUST be installed </span>
<span class="comments">;        to produce anything other than PostScript output. (See cgPS2PDF and PS_END for </span>
<span class="comments">;        details.) And also note that you should NOT use this keyword when doing multiple </span>
<span class="comments">;        plots. The keyword is to be used as a convenient way to get PostScript or raster </span>
<span class="comments">;        output for a single graphics command. Output parameters can be set with cgWindow_SetDefs.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;         Set this keyword to a 3 x N or N x 3 byte array containing the RGB color vectors </span>
<span class="comments">;         to be loaded before the surface is displayed. Such vectors can be obtained, for </span>
<span class="comments">;         example, from cgLoadCT with the RGB_TABLE keyword:</span>
<span class="comments">;               </span>
<span class="comments">;             cgLoadCT, 33, RGB_TABLE=palette</span>
<span class="comments">;             cgSurf, cgDemoData(2), PALETTE=palette, /Elevation</span>
<span class="comments">;                    </span>
<span class="comments">;     rotx: in, optional, type=float, default=30</span>
<span class="comments">;        The rotation about the X axis.</span>
<span class="comments">;     rotz: in, optional, type=float, default=30</span>
<span class="comments">;        The rotation about the Z axis.</span>
<span class="comments">;     shaded: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to display a shaded surface. To display shaded surfaces</span>
<span class="comments">;        in a device-independent way, the shading values are confined to indices 0 to 253 with</span>
<span class="comments">;        SET_SHADING, and the background color is placed in color index 254. The color table vectors</span>
<span class="comments">;        are reduced to 254 elements when this happens. This all happens behind the stage, </span>
<span class="comments">;        and the original color table is restore upon exit. Because I can't tell how many values</span>
<span class="comments">;        SET_SHADING is using on entering the program, I just set it back to its default 256 values</span>
<span class="comments">;        on exiting the program.</span>
<span class="comments">;     shades: in, optional, type=byte</span>
<span class="comments">;        Set this keyword to a byte scaled 2D array of the same size as data to shade the surface</span>
<span class="comments">;        with these color indices.</span>
<span class="comments">;     skirt: in, optional, type=any</span>
<span class="comments">;        Set this keyword to a Z value where a skirt will be drawn for the surface.</span>
<span class="comments">;     title: in, optional, type=string</span>
<span class="comments">;        The title of the plot. It will be written "flat to the screen", rather than rotated.</span>
<span class="comments">;     traditional: in, optional, type=boolean, default=0</span>
<span class="comments">;         If this keyword is set, the traditional color scheme of a black background for</span>
<span class="comments">;         graphics windows on the display is used and PostScript files always use a white background.</span>
<span class="comments">;     tlocation: in, optional, type=float</span>
<span class="comments">;         A one or two element array in normalized coordinates that gives the location of the</span>
<span class="comments">;         plot title. The plot is centered on this location. If one element, the X location is taken</span>
<span class="comments">;         as 0.5 and the element is used as the Y location. Othersize, use [x,y]. Default is [0.5,0.9].</span>
<span class="comments">;     tsize: in, optional, type=float</span>
<span class="comments">;        The character size for the title. Normally, the title character size is 1.1 times</span>
<span class="comments">;        the character size of the surface annotation.</span>
<span class="comments">;     tspace: in, optional, type=float</span>
<span class="comments">;        The title Y spacing. This should be a number, between 0 and 1 that is the fraction </span>
<span class="comments">;        of the distance between !Y.Window[1] and !Y.Window[0] to locate the title above </span>
<span class="comments">;        !Y.Window[1]. When Total(!P.MULTI) EQ 0, the default is 0.005, and it is 0.0025 otherwise.</span>
<span class="comments">;        Now depreciated in favor of `TLocation`.</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in the current cgWindow or to</span>
<span class="comments">;        create a new cgWindow, if one doesn't currenly exist, for displaying this command.</span>
<span class="comments">;        To create a new cgWindow if one currenly exists, use the `cgWindow` command</span>
<span class="comments">;     xstyle: in, hidden</span>
<span class="comments">;        The normal XSTYLE keyword.</span>
<span class="comments">;     xtitle: in, optional, type=string</span>
<span class="comments">;        The X title of the plot.</span>
<span class="comments">;     ystyle: in, hidden</span>
<span class="comments">;        The normal YSTYLE keyword.</span>
<span class="comments">;     ytitle: in, optional, type=string</span>
<span class="comments">;        The Y title of the plot.</span>
<span class="comments">;     zstyle: in, hidden</span>
<span class="comments">;        The normal ZSTYLE keyword.</span>
<span class="comments">;     ztitle: in, optional, type=string</span>
<span class="comments">;        The Z title of the plot.</span>
<span class="comments">;     _ref_extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the `IDL Surface command &lt;http://www.exelisvis.com/docs/SURFACE_Procedure.html>` </span>
<span class="comments">;        is allowed in the program.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Use as you would use the IDL SURFACE of SHADE_SURF command::</span>
<span class="comments">;       data = Dist(200)</span>
<span class="comments">;       LoadCT, 33</span>
<span class="comments">;       cgSurf, data</span>
<span class="comments">;       cgSurf, data, Shades=BytScl(data)</span>
<span class="comments">;       cgSurf, data, /Shaded</span>
<span class="comments">;       cgSurf, data, /Shaded, Shades=BytScl(data) </span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 13 November 2010. DWF.</span>
<span class="comments">;        Now setting decomposition state by calling SetDecomposedState. 16 November 2010. DWF.</span>
<span class="comments">;        Added TSIZE and TSPACE keywords to treak title size and placement, </span>
<span class="comments">;           as necessary. 17 November 2010. DWF.</span>
<span class="comments">;        Background keyword now applies in PostScript file as well. 17 November 2010. DWF.</span>
<span class="comments">;        Many changes after BACKGROUND changes to get !P.MULTI working again! 18 November 2010. DWF.</span>
<span class="comments">;        Changes so that color variables don't change type. 23 Nov 2010. DWF.</span>
<span class="comments">;        Added ELEVATION_SHADING keyword. 26 Nov 2010. DWF.</span>
<span class="comments">;        I had keyword conflicts with the AX and AZ rotation keywords. Now perform rotation with</span>
<span class="comments">;           ROTX and ROTZ keywords. 7 Dec 2010. DWF.</span>
<span class="comments">;        Added WINDOW keyword to allow graphic to be displayed in a resizable graphics window. 8 Dec 2010. DWF</span>
<span class="comments">;        Changed the Title size to 1.1 times the character size of the plot. 14 Dec 2010. DWF.</span>
<span class="comments">;        Modifications to allow cgSurf to be drop-in replacement for old Surface commands in </span>
<span class="comments">;            indexed color mode. 24 Dec 2010. DWF.</span>
<span class="comments">;        Previous changes introduced problems with OVERPLOT that have now been fixed. 28 Dec 2010. DWF.</span>
<span class="comments">;        Set NOERASE keyword from !P.NoErase system variable when appropriate. 28 Dec 2010. DWF.</span>
<span class="comments">;        Additional problems with NOERASE discovered and solved. 29 Dec 2010. DWF.</span>
<span class="comments">;        Change to DECOMPOSED color was using incorrect color tables. 29 Dec 2010. DWF.</span>
<span class="comments">;        In some cases, I was turning BYTE values to strings without converting to </span>
<span class="comments">;            INTEGERS first. 30 Dec 2010. DWF.</span>
<span class="comments">;        Moved setting to decomposed color before color selection process to avoid PostScript</span>
<span class="comments">;             background problems when passed 24-bit color integers. 12 Jan 2011. DWF. </span>
<span class="comments">;        Fixed a problem in which I assumed the background color was a string. 18 Jan 2011. DWF.  </span>
<span class="comments">;        Added ADDCMD keyword. 26 Jan 2011. DWF.</span>
<span class="comments">;        Added LAYOUT keyword. 28 Jan 2011. DWF.</span>
<span class="comments">;        Added PALETTE keyword. 3 Feb 2011. DWF.</span>
<span class="comments">;        Color table vectors must be obtained AFTER loading the color palette. 6 March 2011. DWF.</span>
<span class="comments">;        Modified error handler to restore the entry decomposition state if there is an error. 17 March 2011. DWF</span>
<span class="comments">;        Modified the color decomposition state to properly handle shaded surfaces in PostScript. 20 July 2011. DWF.</span>
<span class="comments">;        Updated the BACKGROUND color selection from lessons learned in 27 Oct 2011 cgContour </span>
<span class="comments">;             corrections. 27 Oct 2011. DWF.</span>
<span class="comments">;        Added the ability to send the output directly to a file via the OUTPUT keyword. 9 Dec 2011, DWF.</span>
<span class="comments">;        PostScript, PDF, and Imagemagick parameters can now be tailored with cgWindow_SetDefs. 14 Dec 2001. DWF.</span>
<span class="comments">;        Now allowing the user to draw in the "background" color, if the COLOR or AXISCOLOR is "BACKGROUND". 19 March 2012. DWF.</span>
<span class="comments">;        Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;        Lost the XTitle and YTitle keywords when doing shaded surfaces. 15 December 2012. DWF.</span>
<span class="comments">;        Still had some color issues with shaded surfaces having to be done in indexed color to sort out.</span>
<span class="comments">;            This appears to work now both on the display and in PostScript. 25 Jan 2013. DWF.</span>
<span class="comments">;        Added the TLOCATION keyword and depreciated the TSPACE keyword. 27 May 2013. DWF.</span>
<span class="comments">;        Fixed a problem with shaded surfaces that set the top color to the background color. 12 June 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2010-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgSurf, data, x, y, $
    ADDCMD=addcmd, $
    AXISCOLOR=saxiscolor, $
    AXESCOLOR=saxescolor, $
    BACKGROUND=sbackground, $
    BOTTOM=sbottom, $
    CHARSIZE=charsize, $
    COLOR=scolor, $
    ELEVATION_SHADING=elevation_shading, $
    FONT=font, $
    LAYOUT=layout, $
    NOERASE=noerase, $
    OUTFILENAME=outfilename, $
    OUTPUT=output, $
    PALETTE=palette, $
    ROTX=rotx, $
    ROTZ=rotz, $
    SHADED=shaded, $
    SHADES=shades, $
    SKIRT=skirt, $
    TITLE=title, $
    TRADITIONAL=traditional, $
    TLOCATION=tlocation, $
    TSIZE=tsize, $
    TSPACE=tspace, $
    WINDOW=window, $
    XSTYLE=xstyle, $
    XTITLE=xtitle, $
    YSTYLE=ystyle, $
    YTITLE=ytitle, $
    ZSTYLE=zstyle, $
    ZTITLE=ztitle, $
    _Ref_Extra=extra
    
    Compile_Opt idl2

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(thisMulti) NE 0 THEN !P.Multi = thisMulti
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        RETURN
    ENDIF
    
    <span class="comments">; Did user pass parameters?</span>
    IF N_Elements(data) EQ 0 THEN BEGIN
        Print, 'USE SYNTAX: cgSurf, data, x, y, [SHADED=1]'
        RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
    IF Keyword_Set(addcmd) THEN window = 1
    IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; If you are using a layout, you can't ever erase.</span>
        IF N_Elements(layout) NE 0 THEN noerase = 1
        
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        
        <span class="comments">; If adding a command, have to do this differently.</span>
        IF Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgSurf', data, x, y, $
                AXISCOLOR=saxiscolor, $
                AXESCOLOR=saxescolor, $
                BACKGROUND=sbackground, $
                BOTTOM=sbottom, $
                CHARSIZE=charsize, $
                COLOR=scolor, $
                ELEVATION_SHADING=elevation_shading, $
                FONT=font, $
                LAYOUT=layout, $
                NOERASE=noerase, $
                PALETTE=palette, $
                ROTX=rotx, $
                ROTZ=rotz, $
                SHADED=shaded, $
                SHADES=shades, $
                SKIRT=skirt, $
                TITLE=title, $
                TRADITIONAL=traditional, $
                TLOCATION=tlocation, $
                TSIZE=tsize, $
                TSPACE=tspace, $
                XSTYLE=xstyle, $
                XTITLE=xtitle, $
                YSTYLE=ystyle, $
                YTITLE=ytitle, $
                ZSTYLE=zstyle, $
                ZTITLE=ztitle, $
                ADDCMD=1, $
                _Extra=extra
                
            RETURN
        ENDIF
        
        <span class="comments">; Otherwise, we are just replacing the commands in a new or existing window.</span>
        cgWindow, 'cgSurf', data, x, y, $
            AXISCOLOR=saxiscolor, $
            AXESCOLOR=saxescolor, $
            BACKGROUND=sbackground, $
            BOTTOM=sbottom, $
            CHARSIZE=charsize, $
            COLOR=scolor, $
            ELEVATION_SHADING=elevation_shading, $
            FONT=font, $
            LAYOUT=layout, $
            NOERASE=noerase, $
            PALETTE=palette, $
            ROTX=rotx, $
            ROTZ=rotz, $
            SHADED=shaded, $
            SHADES=shades, $
            SKIRT=skirt, $
            TITLE=title, $
            TRADITIONAL=traditional, $
            TLOCATION=tlocation, $
            TSIZE=tsize, $
            TSPACE=tspace, $
            XSTYLE=xstyle, $
            XTITLE=xtitle, $
            YSTYLE=ystyle, $
            YTITLE=ytitle, $
            ZSTYLE=zstyle, $
            ZTITLE=ztitle, $
            REPLACECMD=replaceCmd, $
            _Extra=extra
            
         RETURN
    ENDIF
    
    <span class="comments">; Are we doing some kind of output?</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; If the output string has a dot character, then this must be a</span>
       <span class="comments">; filename, and we will determine the type of file from the filename extension.</span>
       IF StrPos(output, '.') NE -1 THEN BEGIN
             root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
             IF theDir EQ "" THEN CD, CURRENT=theDir
             outfilename = output
             outputSelection = StrUpCase(ext)
       ENDIF
    
       IF N_Elements(outputSelection) EQ 0 THEN outputSelection = StrUpCase(output)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE
              
       <span class="comments">; Do you need a filename?</span>
       IF ( (N_Elements(outfilename) EQ 0) || (outfilename EQ "") ) THEN BEGIN 
            filename = 'cgplot' + ext
            outfilename = cgPickfile(FILE=filename, TITLE='Select Output File Name...', $
                FILTER=ext, /WRITE)
            IF outfilename EQ "" THEN RETURN
       ENDIF
       
       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    
    ENDIF
   
    <span class="comments">; Going to draw in decomposed color, if possible to avoid dirtying the color table.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState

    <span class="comments">; If current state is "indexed color" and colors are represented as long integers then "fix" them.</span>
    IF (currentState EQ 0) THEN BEGIN
      IF Size(sbackground, /TNAME) EQ 'LONG' THEN sbackground = Fix(sbackground)
      IF Size(scolor, /TNAME) EQ 'LONG' THEN scolor = Fix(scolor)
    ENDIF
    
    <span class="comments">; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be</span>
    <span class="comments">; done BEFORE checking the LAYOUT properties.</span>
    IF !P.NoErase NE 0 THEN noerase = !P.NoErase ELSE noerase = Keyword_Set(noerase)

    <span class="comments">; Set up the layout, if necessary.</span>
    IF N_Elements(layout) NE 0 THEN BEGIN
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       IF layout[2] EQ 1 THEN BEGIN
            noerase = 1
            !P.Multi[0] = 0
       ENDIF ELSE BEGIN
            !P.Multi[0] = totalPlots - layout[2] + 1
       ENDELSE
    ENDIF

    <span class="comments">; Check parameters.</span>
    IF N_Elements(title) EQ 0 THEN title = "" ELSE title = cgCheckForSymbols(title)
    IF N_Elements(xtitle) EQ 0 THEN xtitle = "" ELSE xtitle = cgCheckForSymbols(xtitle)
    IF N_Elements(ytitle) EQ 0 THEN ytitle = "" ELSE ytitle = cgCheckForSymbols(ytitle)
    IF N_Elements(ztitle) EQ 0 THEN ztitle = "" ELSE ztitle = cgCheckForSymbols(ztitle)
    ndims = Size(data, /N_DIMENSIONS)
    IF ndims NE 2 THEN Message, 'Data must be 2D.'
    s = Size(data, /DIMENSIONS)
    IF N_Elements(x) EQ 0 THEN x = Findgen(s[0])
    IF N_Elements(y) EQ 0 THEN y = Findgen(s[1])
    noerase = Keyword_Set(noerase)
    
    <span class="comments">; Load a color palette, if you have one.</span>
    IF N_Elements(palette) NE 0 THEN BEGIN
        IF Size(palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
        dims = Size(palette, /DIMENSIONS)
        threeIndex = Where(dims EQ 3)
        IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
        IF threeIndex[0] EQ 0 THEN palette = Transpose(palette)
        TVLCT, palette
    ENDIF
    
    <span class="comments">; Get the current color table vectors.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; Check the color keywords.</span>
    background = cgDefaultColor(sbackground, /BACKGROUND, TRADITIONAL=traditional)
    IF (N_Elements(saxisColor) EQ 0) && (N_Elements(saxesColor) NE 0) THEN saxisColor = saxesColor
    axisColor = cgDefaultColor(saxisColor, TRADITIONAL=traditional)
    color = cgDefaultColor(sColor, DEFAULT='BLU6', TRADITIONAL=traditional)
    bottom = cgDefaultColor(sbottom, DEFAULT=color, TRADITIONAL=traditionale)
    
    <span class="comments">; If color is the same as background, do something. Since this precludes drawing the the</span>
    <span class="comments">; background color (perhaps you want to "erase" something), I offer an exception. If the</span>
    <span class="comments">; COLOR is "Background", I am going to assume you know what you are doing!</span>
    IF ColorsAreIdentical(background, color) THEN BEGIN
        IF ((!D.Flags AND 256) NE 0) THEN BEGIN
           IF (!P.Multi[0] EQ 0) && (~Keyword_Set(overplot) && ~noerase) THEN cgErase, background
        ENDIF
        IF (Size(color, /TNAME) EQ 'STRING') THEN BEGIN
            IF (StrUpCase(color) NE 'BACKGROUND') THEN color = 'OPPOSITE'
        ENDIF ELSE color = 'OPPOSITE'
    ENDIF
    IF ColorsAreIdentical(background, axiscolor) THEN BEGIN
        IF ((!D.Flags AND 256) NE 0) THEN BEGIN
           IF (!P.Multi[0] EQ 0) && (~Keyword_Set(overplot) && ~noerase) THEN cgErase, background
        ENDIF
        IF (Size(axiscolor, /TNAME) EQ 'STRING') THEN BEGIN
           IF (StrUpCase(axiscolor) NE 'BACKGROUND') THEN axiscolor = 'OPPOSITE'
        ENDIF ELSE axiscolor = 'OPPOSITE'
    ENDIF

    elevation_shading = Keyword_Set(elevation_shading)
    
    <span class="comments">; Character size has to be determined *after* the layout has been decided.</span>
    IF N_Elements(font) EQ 0 THEN IF (!D.Name EQ 'PS') THEN font = 1 ELSE font = !P.font
    IF N_Elements(charsize) EQ 0 THEN charsize = cgDefCharSize(FONT=font) * 1.25
    
    <span class="comments">; Other properties.</span>
    IF N_Elements(rotx) EQ 0 THEN rotx = 30
    IF N_Elements(rotz) EQ 0 THEN rotz = 30
    IF N_Elements(xstyle) EQ 0 THEN xstyle = 0
    IF N_Elements(ystyle) EQ 0 THEN ystyle = 0
    IF N_Elements(zstyle) EQ 0 THEN zstyle = 0
            
    <span class="comments">; Load the drawing colors. If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay

    IF Size(axiscolor, /TNAME) EQ 'STRING' THEN BEGIN
        axiscolor = cgColor(axiscolor)
    ENDIF ELSE BEGIN
         IF currentState EQ 0 THEN axiscolor = cgColor24(rr[axiscolor], gg[axiscolor], bb[axiscolor])
    ENDELSE
    IF Size(bottom, /TNAME) EQ 'STRING' THEN BEGIN
        bottom = cgColor(bottom)
    ENDIF ELSE BEGIN
         IF currentState EQ 0 THEN bottom = cgColor24(rr[bottom], gg[bottom], bb[bottom])
    ENDELSE
    IF Size(color, /TNAME) EQ 'STRING' THEN BEGIN
        color = cgColor(color)
    ENDIF ELSE BEGIN
         IF currentState EQ 0 THEN color = cgColor24(rr[color], gg[color], bb[color])
    ENDELSE
    IF Size(background, /TNAME) EQ 'STRING' THEN BEGIN
        originalbg = background
        background = cgColor(background)
        shadebackground = cgColor(originalbg, DECOMPOSED=0, 254)
    ENDIF ELSE BEGIN
         <span class="comments">; Different values based on current state of the device. Indexed color mode here.</span>
         IF currentState EQ 0 THEN BEGIN
            originalbg = [rr[background], gg[background], bb[background]]
            background = cgColor24(rr[background], gg[background], bb[background])
         ENDIF
         <span class="comments">; Decomposed color mode here. Not sure how this should be handled. Just</span>
         <span class="comments">; do white. If it is not right, then use strings for color values!</span>
         IF currentState EQ 1 THEN BEGIN
            orginalbg = 'white'
            shadebackground = cgColor('white', DECOMPOSED=0, 254)
         ENDIF
    ENDELSE
    
    <span class="comments">; Get the color table with loaded drawing colors.</span>
    TVLCT, rl, gl, bl, /GET
    
    <span class="comments">; Are you doing elevation shading?</span>
    IF elevation_shading THEN BEGIN
        IF N_Elements(shades) EQ 0 THEN shades = BytScl(data, /NAN)
    ENDIF
    
    <span class="comments">; Do you need a PostScript background color? Lot's of problems here!</span>
    <span class="comments">; Basically, I MUST draw a plot to advance !P.MULTI. But, drawing a</span>
    <span class="comments">; plot of any sort erases the background color. So, I have to draw a </span>
    <span class="comments">; plot, store the new system variables, then draw my background, etc.</span>
    <span class="comments">; I have tried LOTS of options. This is the only one that worked.</span>
    IF !D.Name EQ 'PS' THEN BEGIN
       IF ~noerase THEN BEGIN
       
           <span class="comments">; I only have to do this, if this is the first plot.</span>
           IF !P.MULTI[0] EQ 0 THEN BEGIN
           
                <span class="comments">; Save the current system variables. Will need to restore later.</span>
                bangx = !X
                bangy = !Y
                bangz = !Z
                bangp = !P
                
                <span class="comments">; Make sure axis are turned off. I don't really want to draw anything,</span>
                <span class="comments">; just advance !P.MULTI or "erase" the display for the next plot.</span>
                IF BitGet(xstyle, 2) NE 1 THEN xxstyle = xstyle + 4 ELSE xxstyle = xstyle
                IF BitGet(ystyle, 2) NE 1 THEN yystyle = ystyle + 4 ELSE yystyle = ystyle
                IF BitGet(zstyle, 2) NE 1 THEN zzstyle = zstyle + 4 ELSE zzstyle = zstyle
                
                <span class="comments">; Draw the plot that doesn't draw anything.</span>
                Surface, data, x, y, XSTYLE=xxstyle, YSTYLE=yystyle, ZSTYLE=zzstyle, $
                    CHARSIZE=charsize, SKIRT=skirt, _STRICT_EXTRA=extra, $
                    AX=rotx, AZ=rotz  
                
                <span class="comments">; Save the "after plot" system variables. Will use later. </span>
                afterx = !X
                aftery = !Y
                afterz = !Z
                afterp = !P     
                
                <span class="comments">; Draw the background color and set the variables you will need later.</span>
                PS_Background, background
                psnodraw = 1
                tempNoErase = 1
                
                <span class="comments">; Restore the original system variables so that it is as if you didn't</span>
                <span class="comments">; draw the invisible plot.</span>
                !X = bangx
                !Y = bangy
                !Z = bangz
                !P = bangp
                
            ENDIF ELSE tempNoErase = noerase
        ENDIF ELSE tempNoErase = noerase
     ENDIF ELSE tempNoErase = noerase

    bangx = !X
    bangy = !Y
    bangz = !Z
    bangp = !P

    <span class="comments">; Draw the surface axes, but no data.</span>
    Surface, data, x, y, COLOR=axiscolor, BACKGROUND=background, BOTTOM=bottom, $
        /NODATA, XSTYLE=xstyle, YSTYLE=ystyle, ZSTYLE=zstyle, $
        FONT=font, CHARSIZE=charsize, NOERASE=tempNoErase, _STRICT_EXTRA=extra, $
        AX=rotx, AZ=rotz, XTITLE=xtitle, YTITLE=ytitle, ZTITLE=ztitle
        
    <span class="comments">; Storing these system variable is *required* to make !P.MULTI work correct.</span>
    <span class="comments">; Do not delete!</span>
    newx = !X
    newy = !y
    newz = !Z
    newP = !P
    !X = bangx
    !Y = bangy
    !Z = bangz
    !P = bangp
    
    <span class="comments">; Turn the axes off to draw the surface itself. Start by making sure bit 4 in</span>
    <span class="comments">; the [XYZ]Style bits are turned on.</span>
    IF BitGet(xstyle, 2) NE 1 THEN xxstyle = xstyle + 4 ELSE xxstyle = xstyle
    IF BitGet(ystyle, 2) NE 1 THEN yystyle = ystyle + 4 ELSE yystyle = ystyle
    IF BitGet(zstyle, 2) NE 1 THEN zzstyle = zstyle + 4 ELSE zzstyle = zstyle
         
    <span class="comments">; Make absolutely sure the colors are fresh.</span>
    IF N_Elements(palette) NE 0 THEN TVLCT, palette ELSE TVLCT, rr, gg, bb
    
    <span class="comments">; Draw either a wire mesh or shaded surface. Care has to be taken if</span>
    <span class="comments">; the SHADES keyword is used, because this also has to be done in indexed</span>
    <span class="comments">; color mode.</span>
    IF Keyword_Set(shaded) THEN BEGIN
    
        <span class="comments">; We have to get the background color out of the surface color</span>
        <span class="comments">; range to do this in a device independent way.</span>
        Set_Shading, VALUES=[1,253]
        
<span class="comments">;        ; Depending upon the original background color, load the color</span>
<span class="comments">;        ; in color table index 254.</span>
<span class="comments">;        IF Size(originalbg, /TNAME) EQ 'STRING' $</span>
<span class="comments">;            THEN orignalbg = cgColor(originalBg, 254) $</span>
<span class="comments">;            ELSE TVLCT, Reform(origialbg), 254</span>
            
        <span class="comments">; Restrict the current color table vectors to the range 1-254.</span>
        LoadCT, 0
        IF N_Elements(palette) NE 0 THEN BEGIN
            TVLCT, Congrid(palette[*,0],253), Congrid(palette[*,1],253), Congrid(palette[*,2],253), 1
        ENDIF ELSE BEGIN
            TVLCT, Congrid(rr,253), Congrid(gg,253), Congrid(bb,253), 1
        ENDELSE
        
        <span class="comments">; If shades is defined, then we have to make sure the values there</span>
        <span class="comments">; are in the range 1-254.</span>
        IF N_Elements(shades) NE 0 THEN BEGIN
            IF Max(shades,/NAN) GT 253 $
                THEN checkShades = BytScl(shades, TOP=252) + 1B $
                ELSE checkShades = shades
        ENDIF
        
         <span class="comments">; All shaded surfaces have to be done in indexed color mode.</span>
        SetDecomposedState, 0
        
        <span class="comments">; Shaded surface plot. Should be no axes here at all.</span>
         Shade_Surf, data, x, y, /NOERASE, SHADES=checkShades, $
            XSTYLE=xxstyle, YSTYLE=yystyle, ZSTYLE=zzstyle, _STRICT_EXTRA=extra, $
            BACKGROUND=shadebackground, AX=rotx, AZ=rotz, CHARSIZE=charsize, $
            XTITLE=xtitle, YTITLE=ytitle, ZTITLE=ztitle<span class="comments">;;;;;, COLOR=color, BOTTOM=bottom  </span>
            
        SetDecomposedState, 1
            
        <span class="comments">; Have to repair the axes. Do this in decomposed color mode, if possible.</span>
        TVLCT, rl, gl, bl <span class="comments">; Color table after colors are loaded.</span>
        Surface, data, x, y, COLOR=axiscolor, BACKGROUND=background, BOTTOM=bottom, $
            /NODATA, /NOERASE, XSTYLE=xstyle, YSTYLE=ystyle, ZSTYLE=zstyle, $
            FONT=font, CHARSIZE=charsize, SKIRT=skirt, _STRICT_EXTRA=extra, AX=rotx, AZ=rotz, $
            XTitle=xtitle, YTitle=ytitle
            
            
        <span class="comments">; Shading parameters are "sticky", but I can't tell what they</span>
        <span class="comments">; were when I came into the program. Here I just set them back</span>
        <span class="comments">; to their default values.</span>
        Set_Shading, VALUES=[0,255]
                    
    ENDIF ELSE BEGIN
    
        
        <span class="comments">; We can draw the surface in decomposed color mode, unless the SHADES</span>
        <span class="comments">; keyword is being used. Then we have to use indexed color mode.         </span>
        IF N_Elements(shades) NE 0 THEN BEGIN
            SetDecomposedState, 0
            TVLCT, rl, gl, bl <span class="comments">; Color table after colors are loaded.</span>
            Surface, data, x, y, NOERASE=1, SHADES=shades, $
                XSTYLE=xxstyle, YSTYLE=yystyle, ZSTYLE=zzstyle, $
                FONT=font, CHARSIZE=charsize, _STRICT_EXTRA=extra, AX=rotx, AZ=rotz , $
                XTITLE=xtitle, YTITLE=ytitle, ZTITLE=ztitle    
             SetDecomposedState, 1    
        ENDIF ELSE BEGIN
            TVLCT, rl, gl, bl <span class="comments">; Color table after colors are loaded.</span>
            Surface, data, x, y, NOERASE=1, COLOR=color, BOTTOM=bottom, $
                BACKGROUND=background, SKIRT=skirt, $
                XSTYLE=xxstyle, YSTYLE=yystyle, ZSTYLE=zzstyle, $
                FONT=font, CHARSIZE=charsize, _STRICT_EXTRA=extra, AX=rotx, AZ=rotz , $
                XTITLE=xtitle, YTITLE=ytitle, ZTITLE=ztitle
        ENDELSE
        
    ENDELSE
    
    <span class="comments">; If this is the first plot in PS, then we have to make it appear that we have</span>
    <span class="comments">; drawn a plot, even though we haven't.</span>
    IF N_Elements(psnodraw) EQ 1 THEN BEGIN
        newx = afterX
        newy = afterY
        newz = afterZ
        newp = afterP
    ENDIF

    <span class="comments">; Restore the decomposed color state to the input state.</span>
    SetDecomposedState, currentState

    <span class="comments">; Restore the color table. Can't do this for the Z-buffer or</span>
    <span class="comments">; the snap shot will be incorrect.</span>
    IF (!D.Name NE 'Z') THEN TVLCT, rr, gg, bb
    
    <span class="comments">; Update the system variables.</span>
    !X = newx 
    !Y = newy 
    !Z = newz 
    !P = newP
    
    <span class="comments">; Draw the title, if you have one.</span>
    T3D, /RESET
    IF N_Elements(title) NE 0 THEN BEGIN
        SetDecomposedState, 1, Current=currentState
        IF N_Elements(tsize) EQ 0 THEN BEGIN
            IF (!P.Charsize EQ 0) AND (N_Elements(charsize) EQ 0) THEN BEGIN
                titleSize = 1.10
            ENDIF ELSE BEGIN
                IF (!P.Charsize NE 0) THEN titleSize = !P.Charsize * 1.10
                IF (N_Elements(charsize) NE 0) THEN titleSize = charsize * 1.10
            ENDELSE
        ENDIF ELSE titleSize = tsize
        IF (N_Elements(tlocation) EQ 0) && (N_Elements(tspace) NE 0) THEN BEGIN
            xloc = (!X.Window[1] - !X.Window[0]) / 2.0 + !X.Window[0]
            distance = !Y.Window[1] - !Y.Window[0]
            tspace = (Total(!P.Multi) EQ 0) ? 0.0025 : 0.00125
            yloc = !Y.Window[1] + (distance * tspace)
            XYOutS, xloc, yloc, /NORMAL, ALIGNMENT=0.5, CHARSIZE=titleSize, $
                title, FONT=font, COLOR=axiscolor
        ENDIF ELSE BEGIN
            IF N_Elements(tlocation) EQ 0 THEN tlocation = [0.5, 0.9]
            IF N_Elements(tlocation) EQ 1 THEN titleLocation = [0.5, tlocation] ELSE titleLocation = tlocation
            XYOutS, titleLocation[0],  titleLocation[1], /NORMAL, ALIGNMENT=0.5, CHARSIZE=titleSize, $
                title, FONT=font, COLOR=axiscolor
        ENDELSE
        SetDecomposedState, currentState
    ENDIF
    

    <span class="comments">; Clean up if you are using a layout.</span>
    IF N_Elements(layout) NE 0 THEN !P.Multi = thisMulti

    <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
    IF (N_Elements(output) NE 0) && (output NE "") THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width

         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
    ENDIF
    
END
    
</code>
    </div>
  </body>
</html>