<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:02 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgconlevels.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgconlevels.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgConLevels</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This program is designed to create "nicely formatted" contour levels for use in</span>
<span class="comments">;   contour plots. The idea is to be able to produce evenly spaced contour intervals</span>
<span class="comments">;   with the contour levels rounded off to the preferred degree of accuracy. The program</span>
<span class="comments">;   will make a "guess" as to how to do this, but users can also take control of the</span>
<span class="comments">;   process if the results are not pleasing enough.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This program is designed to create "nicely formatted" contour levels for use in</span>
<span class="comments">; contour plots. The idea is to be able to produce evenly spaced contour intervals</span>
<span class="comments">; with the contour levels rounded off to the preferred degree of accuracy. The program</span>
<span class="comments">; will make a "guess" as to how to do this, but users can also take control of the</span>
<span class="comments">; process if the results are not pleasing enough.</span>
<span class="comments">; </span>
<span class="comments">; There is no claim that this program always produces the best results. It is more</span>
<span class="comments">; of a tool that can produce decent result in many situations.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Utilities</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     A vector of contour levels of the requested number. Each level is</span>
<span class="comments">;     rounded to a predefined or specified degree of accuracy.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;     data: in, required </span>
<span class="comments">;         The data for which contour levels are desired.</span>
<span class="comments">;          </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     factor: in, optional, type=float</span>
<span class="comments">;         The program makes a "guess" at how to best round the levels in the data</span>
<span class="comments">;         presented to it. This guess is not always what the user wants. This keyword</span>
<span class="comments">;         allows the user to "fine tune" the guess, so that it behaves better. See the</span>
<span class="comments">;         examples for details on how this keyword can be used. There is some danger,</span>
<span class="comments">;         when using the factor keyword that the results will be terrible. Don't dismay!</span>
<span class="comments">;         Just try something else.</span>
<span class="comments">;     maxvalue: in, optional</span>
<span class="comments">;         Normally, the levels are calculated using the minimum and maximum values </span>
<span class="comments">;         of the input data. The maximum value used in the calculation can be replaced</span>
<span class="comments">;         with this value, if you wish. If both the `MinValue` and MaxValue keywords</span>
<span class="comments">;         are used, you do not need to pass the data parameter.</span>
<span class="comments">;     minmax: out, optional</span>
<span class="comments">;         The actual minimum and maximum values used to calculate the levels.</span>
<span class="comments">;     minvalue: in, optional</span>
<span class="comments">;         Normally, the levels are calculated using the minimum and maximum values </span>
<span class="comments">;         of the input data. The minimum value used in the calculation can be replaced</span>
<span class="comments">;         with this value, if you wish.</span>
<span class="comments">;     nlevels: in, optional, type=integer, default=10</span>
<span class="comments">;         The number of contour levels desired.</span>
<span class="comments">;     silent: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want the program to remain "silent" in the face of </span>
<span class="comments">;         errors. If this keyword is set, the user should rely on the `Success` keyword</span>
<span class="comments">;         to determine whether the program completed its work.</span>
<span class="comments">;     step: out, optional</span>
<span class="comments">;         The step size actually used in the program to calculate the levels.</span>
<span class="comments">;     success: out, optional, type=boolen</span>
<span class="comments">;         Upon return, will contain a 1 if the program executed succesfully and</span>
<span class="comments">;         a 0 otherwise.</span>
<span class="comments">;          </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Here is the normal way a contour plot might be created::</span>
<span class="comments">;</span>
<span class="comments">;        cgDisplay, WID=0</span>
<span class="comments">;        data = cgScaleVector(cgDemoData(2), 0.1, 4534.5)</span>
<span class="comments">;        cgLoadCT, 33, NColors=10, Bottom=1</span>
<span class="comments">;        cgContour, data, NLevels=10, /Fill, /Outline, $</span>
<span class="comments">;           Position=[0.1, 0.1, 0.9, 0.75], C_Colors=Indgen(10)+1</span>
<span class="comments">;        cgColorbar, NColors=9, Bottom=1, /Discrete, /Fit, $</span>
<span class="comments">;           Range=[Min(data), Max(data)], OOB_High=10, OOB_Low='white'</span>
<span class="comments">;           </span>
<span class="comments">;    Here is how the same plot might be created with cgConLevels</span>
<span class="comments">;    to produce contour levels at 500 step intervals::</span>
<span class="comments">;    </span>
<span class="comments">;        cgDisplay, WID=1</span>
<span class="comments">;        data = cgScaleVector(cgDemoData(2), 0.1, 4534.5)</span>
<span class="comments">;        cgLoadCT, 33, NColors=10, Bottom=1</span>
<span class="comments">;        levels = cgConLevels(data, Factor=100, MINVALUE=0)</span>
<span class="comments">;        cgContour, data, Levels=levels, /Fill, /Outline, $</span>
<span class="comments">;           Position=[0.1, 0.1, 0.9, 0.75], C_Colors=Indgen(10)+1</span>
<span class="comments">;        cgColorbar, NColors=9, Bottom=1, /Discrete, /Fit, $</span>
<span class="comments">;           Range=[Min(levels), Max(levels)], OOB_High=10, OOB_Low='white'</span>
<span class="comments">;           </span>
<span class="comments">;    In this example, the data is scaled so that it is a bit more perverse.</span>
<span class="comments">;    The levels have been chosen so they round in the third decimal place::</span>
<span class="comments">;    </span>
<span class="comments">;        cgDisplay, WID=2</span>
<span class="comments">;        data = cgScaleVector(cgDemoData(2), 0.153, 0.986)</span>
<span class="comments">;        cgLoadCT, 33, NColors=10, Bottom=1</span>
<span class="comments">;        levels = cgConLevels(data)</span>
<span class="comments">;        cgContour, data, Levels=levels, /Fill, /Outline, $</span>
<span class="comments">;           Position=[0.1, 0.1, 0.9, 0.75], C_Colors=Indgen(10)+1</span>
<span class="comments">;        cgColorbar, NColors=9, Bottom=1, /Discrete, /Fit, $</span>
<span class="comments">;           Range=[Min(levels), Max(levels)], OOB_High=10, OOB_Low='white'</span>
<span class="comments">;    </span>
<span class="comments">;    It might be better to have the data rounded in the second data place, to</span>
<span class="comments">;    the nearest 0.05 value. This can be done with the `Factor` keyword::</span>
<span class="comments">;     </span>
<span class="comments">;        cgDisplay, WID=3</span>
<span class="comments">;        data = cgScaleVector(cgDemoData(2), 0.153, 0.986)</span>
<span class="comments">;        cgLoadCT, 33, NColors=10, Bottom=1</span>
<span class="comments">;        levels = cgConLevels(data, Factor=0.05)</span>
<span class="comments">;        cgContour, data, Levels=levels, /Fill, /Outline, $</span>
<span class="comments">;           Position=[0.1, 0.1, 0.9, 0.75], C_Colors=Indgen(10)+1</span>
<span class="comments">;        cgColorbar, NColors=9, Bottom=1, /Discrete, /Fit, $</span>
<span class="comments">;           Range=[Min(levels), Max(levels)], OOB_High=10, OOB_Low='white'</span>
<span class="comments">;           </span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 8 December 2011. David W. Fanning</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
FUNCTION cgConLevels, data, $
    FACTOR=factor, $
    MAXVALUE=maxvalue, $
    MINMAX=minmax, $
    MINVALUE=minvalue, $
    NLEVELS=nlevels, $
    SILENT=silent, $
    STEP=step, $
    SUCCESS=success

    Compile_Opt idl2
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        IF ~Keyword_Set(silent) THEN void = Error_Message()
        success = 0
        RETURN, -1
    ENDIF

    <span class="comments">; Assume success.</span>
    success = 1
    
    <span class="comments">; Data is required, unless both MINVALUE and MAXVALUE are used.</span>
    IF N_Elements(data) EQ 0 THEN BEGIN
        IF ~( (N_Elements(maxvalue)NE 0) && (N_Elements(minvalue) NE 0) ) THEN $ 
           Message, 'Data must be passed to calculate contour levels.'
    ENDIF
    
    <span class="comments">; Set default number of levels to 10.</span>
    SetDefaultValue, nlevels, 10
    
    <span class="comments">; Find the step.</span>
    IF N_Elements(data) NE 0 THEN mindata = Min(data, /NAN, MAX=maxdata)
    IF N_Elements(minvalue) NE 0 THEN mindata = minvalue
    IF N_Elements(maxvalue) NE 0 THEN maxdata = maxvalue 
    step  = (maxdata - mindata) / nlevels

    <span class="comments">; We are going to work with abolute values. Save the signs for the end.</span>
    minSign = (mindata LT 0) ? -1 : 1
    maxSign = (maxdata LT 0) ? -1 : 1
    minabs = Abs(mindata)
    maxabs = Abs(maxdata)
    
    <span class="comments">; If you have a factor supplied by the user, then use it. Otherwise, try to figure</span>
    <span class="comments">; out which factor you might use.</span>
    IF N_Elements(factor) EQ 0 THEN BEGIN
        CASE 1 OF
            step GE 10000: BEGIN
               minabs = (minsign GT 0) ? Floor(minabs / 1000) * 1000. : Ceil(minabs / 1000) * 1000.
               maxabs = (maxsign GT 0) ? Ceil(maxabs / 1000) * 1000.  : Floor(maxabs / 1000) * 1000.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step / 1000) * 1000
               END
            (step GE 1000) && (step LT 10000): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs / 100) * 100. : Ceil(minabs / 100) * 100.
               maxabs = (maxsign GT 0) ? Ceil(maxabs / 100) * 100. : Floor(maxabs / 100) * 100.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step / 100) * 100.
               END
            (step GE 100) && (step LT 1000): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs / 10) * 10. : Ceil(minabs / 10) * 10.
               maxabs = (maxsign GT 0) ? Ceil(maxabs / 10) * 10. : Floor(maxabs / 10) * 10.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step / 10) * 10.
               END
            (step GE 10) && (step LT 100): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs) : Ceil(minabs)
               maxabs = (maxsign GT 0) ? Ceil(maxabs)  : Floor(maxabs)
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Float(Round(step))
               END
            (step GE 1) && (step LT 10): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs * 10) / 10. : Ceil(minabs * 10) / 10.
               maxabs = (maxsign GT 0) ? Ceil(maxabs * 10) / 10.  : Floor(maxabs * 10) / 10.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step * 10) / 10.
               END
            (step GE 0.1) && (step LT 1): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs * 100) / 100. : Ceil(minabs * 100) / 100.
               maxabs = (maxsign GT 0) ? Ceil(maxabs * 100) / 100.  : Floor(maxabs * 100) / 100.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step * 100) / 100.
               END
            (step GE 0.01) && (step LT 0.1): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs * 1000) / 1000. : Ceil(minabs * 1000) / 1000.
               maxabs = (maxsign GT 0) ? Ceil(maxabs * 1000) / 1000.  : Floor(maxabs * 1000) / 1000.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step * 1000) / 1000.
               END
            (step GE 0.001) && (step LT 0.01): BEGIN
               minabs = (minsign GT 0) ? Floor(minabs * 10000) / 10000. : Ceil(minabs * 10000) / 100000.
               maxabs = (maxsign GT 0) ? Ceil(maxabs * 10000) / 10000.  : Floor(maxabs * 10000) / 100000.
               mindata = (minsign GT 0) ? minabs : minabs * (-1)
               maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
               step  = (maxdata - mindata) / nlevels
               step = Round(step * 10000) / 10000.
               END
             ELSE:    
        ENDCASE
    ENDIF ELSE BEGIN
        minabs = (minsign GT 0) ? Floor(minabs / factor) * Float(factor)  : Ceil(minabs / factor) * Float(factor)
        maxabs = (maxsign GT 0) ? Ceil(maxabs / factor)  * Float(factor) : Floor(maxabs / factor) * Float(factor)
        mindata = (minsign GT 0) ? minabs : minabs * (-1)
        maxdata = (maxsign GT 0) ? maxabs : maxabs * (-1)
        step  = (maxdata - mindata) / nlevels
        step = Round(step / factor) * Float(factor)
    ENDELSE
    
    <span class="comments">; Calculate the levels so they can be returned.</span>
    levels = Indgen(nlevels) * step + mindata

    <span class="comments">; Set up the output variable, minmax, with the actual min and max values used for the levels.</span>
    minmax = [mindata, maxdata]
    
    RETURN, levels
END
</code>
    </div>
  </body>
</html>