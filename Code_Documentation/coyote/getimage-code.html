<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:56 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>getimage.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="getimage.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       GETIMAGE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       The purpose of this function is to allow the user to open either</span>
<span class="comments">;       unformmated or XDR binary image files of up to eight dimensions.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Widgets, File I/O.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       image = GETIMAGE(filename)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       filename: The name of the file to open for reading.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       CANCEL: An output variable that can be set to a named variable.</span>
<span class="comments">;       The value of the return variable will be 1 if the user clicked</span>
<span class="comments">;       the "Cancel" button or if there was a problem reading the file.</span>
<span class="comments">;</span>
<span class="comments">;       DATATYPE: The "type" of data you wish to read out of the file.</span>
<span class="comments">;       The data type corresponds to the Size(image, /TYPE) value. Here</span>
<span class="comments">;       are the types supported:</span>
<span class="comments">;</span>
<span class="comments">;       BYTE                   1 (default)</span>
<span class="comments">;       INTEGER                2</span>
<span class="comments">;       LONG INTEGER           3</span>
<span class="comments">;       FLOAT                  4</span>
<span class="comments">;       DOUBLE                 5</span>
<span class="comments">;       UNSIGNED INTEGER      12</span>
<span class="comments">;       UNSIGNED LONG INTEGER 13</span>
<span class="comments">;       64-bit LONG           14</span>
<span class="comments">;       64-bit UNSIGNED LONG  15</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;       DIMENSIONS: A vector of image dimensions. The default value is [256, 256].</span>
<span class="comments">;</span>
<span class="comments">;       DIRECTORY: The name of the directory the file is located in. By</span>
<span class="comments">;       default the program looks in the "coyote" directory under the</span>
<span class="comments">;       main IDL directory, if one exists. Otherwise, it defaults to the</span>
<span class="comments">;       current directory.</span>
<span class="comments">;</span>
<span class="comments">;       ENDIAN: Set this keyword to an integer that indicates the byte</span>
<span class="comments">;       ordering of the data file. If you don't know what byte order means,</span>
<span class="comments">;       or you don't know anything about the byte order of the data, or</span>
<span class="comments">;       if you are sure the data was created on the same type of machine</span>
<span class="comments">;       you are now running IDL on, then just accept the default of 0 or</span>
<span class="comments">;       "native" ordering. If you are wrong, you will soon know it and you</span>
<span class="comments">;       can set the keyword to another value on your next try. :-)</span>
<span class="comments">;</span>
<span class="comments">;       If you know the machine was created on a big endian machine (such</span>
<span class="comments">;       as a Sun or HP workstation), set this value to 1 (Big Endian). If e</span>
<span class="comments">;       you are sur the image data was create on a little endian machine (such</span>
<span class="comments">;       as a Windows PC or laptop running LINUX), set the value to 2 (Little Endian).</span>
<span class="comments">;</span>
<span class="comments">;       HEADER: The size of any header information in the file in BYTES.</span>
<span class="comments">;       Default is 0.</span>
<span class="comments">;</span>
<span class="comments">;       HEADDATA: An optional output keyword that will contain the header</span>
<span class="comments">;       information read from the file.</span>
<span class="comments">;</span>
<span class="comments">;       PARENT: The group leader for this widget program. The PARENT is</span>
<span class="comments">;       required if GETIMAGE is called from another widget program in order</span>
<span class="comments">;       to make this program a MODAL widget program.</span>
<span class="comments">;</span>
<span class="comments">;       XDR: Set this keyword if the binary file is of XDR type. The default</span>
<span class="comments">;       type is "Unformatted".</span>
<span class="comments">;</span>
<span class="comments">;       XOFFSET: This is the X offset of the program on the display. The</span>
<span class="comments">;       program will be placed approximately in the middle of the display</span>
<span class="comments">;       by default.</span>
<span class="comments">;</span>
<span class="comments">;       YOFFSET: This is the Y offset of the program on the display. The</span>
<span class="comments">;       program will be placed approximately in the middle of the display</span>
<span class="comments">;       by default.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;       None.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;</span>
<span class="comments">;       A "CANCEL" operation is indicated by a 0 return value.</span>
<span class="comments">;       Any error in reading the file results in a 0 return value.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;</span>
<span class="comments">;      Requires the following Coyote Library files:</span>
<span class="comments">;</span>
<span class="comments">;      CENTER_TLB</span>
<span class="comments">;      ERROR_MESSAGE</span>
<span class="comments">;      FSC_FIELD</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       To load the image "galaxy.dat" in the $IDL/examples/data</span>
<span class="comments">;       directory, type:</span>
<span class="comments">;</span>
<span class="comments">;       image = GETIMAGE('galaxy.dat', DIRECTORY=!DIR + '/examples/data', $</span>
<span class="comments">;          DIMENSIONS=[256,256], Cancel=cancelled, Parent=event.top)</span>
<span class="comments">;       IF NOT cancelled THEN TV, image</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by: David Fanning, 3 February 96.</span>
<span class="comments">;       Fixed bug that prevented reading INTEGER data. 19 Dec 96.</span>
<span class="comments">;       Modifed program for IDL 5 MODAL operation. 19 Oct 97.</span>
<span class="comments">;       Added CANCEL keyword. 27 Oct 97. DWF.</span>
<span class="comments">;       Fixed CANCLE keyword spelling. Sigh... 29 JUN 98. DWF.</span>
<span class="comments">;       Added COYOTE_FIELD, improved appearance. 19 NOV 99. DWF.</span>
<span class="comments">;       Updated with latest version of COYOTE_FIELD. 18 FEB 2000. DWF.</span>
<span class="comments">;       Added CATCH keyword so the program will break when I want</span>
<span class="comments">;       it to. :-) 18 MAR 2000. DWF.</span>
<span class="comments">;       Added GROUP_LEADER keyword, which is synonymous with PARENT. 31 MAR 2000. DWF.</span>
<span class="comments">;       Updated obsolete PICKFILE call to DIALOG_PICKFILE. 17 JAN 2001. DWF.</span>
<span class="comments">;       Extensive update for IDL Programming Techniques, 3rd Edition. 1 November 2006. DWF.</span>
<span class="comments">;          XSIZE, YSIZE, CATCH, and FRAMES keyword made obsolete.</span>
<span class="comments">;          HEADDATA, ENDIAN, DATATYPE, DIMENSIONS keywords added.</span>
<span class="comments">;          Now dependent on FSC_FIELD, ERROR_MESSAGE, and CENTER_TLB from Coyote Library.</span>
<span class="comments">;       Added ability to parse fully qualified file names passed from Dialog_Pickfile. 30 Oct 2010. DWF.</span>
<span class="comments">;       IF a file name is not passed into the program, it asks the user to select one now. 10 Jan 2011. DWF.</span>
<span class="comments">;       Problem with SWAP_ENDIAN keywords fixed. 7 March 2011. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
PRO GETIMAGE_NULL_EVENTS, event

   <span class="comments">; The purpose of this event handler is to do nothing</span>
   <span class="comments">; and ignore all events that come to it.</span>

END <span class="comments">;-------------------------------------------------------------------------</span>



PRO GETIMAGE_DIMS_EVENTS, event

   <span class="comments">; The purpose of this event handler is to make the proper dimension widgets</span>
   <span class="comments">; sensitive or insensitive.</span>
   Widget_Control, event.top, Get_UValue=info
   num = event.index + 1
   FOR j=0,num-1 DO Widget_Control, info.d[j], Sensitive=1
   FOR j=num, 7 DO Widget_Control, info.d[j], Sensitive=0, Set_Value=0

END <span class="comments">;-------------------------------------------------------------------------</span>



PRO GETIMAGE_XDR_EVENTS, event

   <span class="comments">; The purpose of this event handler is to make the byte order widget</span>
   <span class="comments">; sensitive or insensitive depending on file format.</span>
   Widget_Control, event.top, Get_UValue=info

   IF event.index THEN Widget_Control, info.byteorderID, Sensitive=0 ELSE $
      Widget_Control, info.byteorderID, Sensitive=1

END <span class="comments">;-------------------------------------------------------------------------</span>



FUNCTION GETIMAGE_FIND_COYOTE

   <span class="comments">; The purpose of this function is to find the "coyote"</span>
   <span class="comments">; training directory and return its path. If no</span>
   <span class="comments">; directory is found, the function returns a null string.</span>
   ON_ERROR, 1

   <span class="comments">; Check this directory first.</span>
   CD, Current=thisDir
   IF STRPOS(STRUPCASE(thisDir), 'COYOTE') GT 0 THEN RETURN, thisDir

   <span class="comments">; Look in !Path directories.</span>
   pathDir = EXPAND_PATH(!Path, /Array)
   s = SIZE(pathDir)
   IF s[1] LT 1 THEN RETURN, ''
   FOR j=0,s[1]-1 DO BEGIN
      check = STRPOS(STRUPCASE(pathDir[j]), 'COYOTE')
      IF check GT 0 THEN RETURN, pathDir[j]
   ENDFOR
   RETURN, ''

END <span class="comments">;-------------------------------------------------------------------------</span>



PRO GETIMAGE_EVENT, event

   <span class="comments">; The only events that can come here are button events.</span>

   <span class="comments">; Get the info structure out of the user value of the top-level base.</span>
   Widget_Control, event.top, Get_UValue=info

   <span class="comments">; There may be errors we can't anticipate. Catch them here, alert the</span>
   <span class="comments">; user as to what the error was, and exit the event handler without</span>
   <span class="comments">; doing any damage.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      ok = Error_Message()
      formdata = {cancel:1}
      *info.ptrToFormData =formdata
      RETURN
   ENDIF

   <span class="comments">; Which button caused this event?</span>
   Widget_Control, event.id, Get_Value=buttonValue

   CASE buttonValue OF

      'Pick Filename': BEGIN

         <span class="comments">; Start in the directory listed in the directory text widget.</span>
         <span class="comments">; Convert the text value to a scalar.</span>
         Widget_Control, info.dirnameID, Get_Value=startDirectory
         startDirectory = startDirectory[0]

         <span class="comments">; If this directory doesn't exist, use the current directory.</span>
         test = File_Search(startDirectory, Count=foundfile)
         IF foundfile NE 1 THEN CD, Current=startDirectory

         <span class="comments">; Use PICKFILE to pick a name.</span>
         pick = Dialog_Pickfile(Path=startDirectory, /NoConfirm, $
            Get_Path=path, Filter='*.*')

         <span class="comments">; Set the directory text widget with the name of the directory.</span>
         <span class="comments">; Make sure the user didn't cancel out of PICKFILE.</span>
         IF pick NE '' THEN BEGIN

            <span class="comments">; Find the lengths of the PICK and the PATH.</span>
            pathLen = StrLen(path)
            picklen = StrLen(pick)

           <span class="comments">; Shorten the PATH to take off last file separator.</span>
            path = StrMid(path, 0, pathLen-1)

            <span class="comments">; Put the PATH in the directory location.</span>
            Widget_Control, info.dirnameID, Set_Value=path

            <span class="comments">; Set the filename text widget with the name of the file.</span>
            filename = StrMid(pick, pathlen, picklen-pathlen)
            Widget_Control, info.filenameID, Set_Value=filename

         ENDIF

         END <span class="comments">; of the Pick Filename button case</span>

       'Cancel': BEGIN

         <span class="comments">; Have to exit here gracefully. Set the "CANCEL" flag.</span>
         formdata = {cancel:1}
         *info.ptrToFormData =formdata

         <span class="comments">; Out of here!</span>
         Widget_Control, event.top, /Destroy
         END <span class="comments">; of the Cancel button case</span>

       'Accept': BEGIN  <span class="comments">; Gather the form information.</span>

          <span class="comments">; Put the directory and filename together to make a path.</span>
          Widget_Control, info.dirnameID, Get_Value=directory
          Widget_Control, info.filenameID, Get_Value=file

          filename = Filepath(Root_Dir=directory[0],file[0])

          <span class="comments">; Get the size and header info. Remember these are Pointers to Integers!</span>
          Widget_Control, info.headerID, Get_Value=header
          header = Long(header[0])

          <span class="comments">; Get the number of dimensions.</span>
          num = Widget_Info(info.dimsID, /Droplist_Select) + 1

          <span class="comments">; Get a vector of dimensions. If any of these numbers is 0, you</span>
          <span class="comments">; have a problem.</span>
          dimensions = IntArr(num)
          FOR j=0,num-1 DO BEGIN
            Widget_Control, info.d[j], Get_Value=theDimension
            IF theDimension EQ 0 THEN Message, 'Dimension ' + StrTrim(j+1,2) + ' cannot be zero.'
            dimensions[j] = theDimension
          ENDFOR

          <span class="comments">; Get the data type from the droplist widget.</span>
          listIndex = Widget_Info(info.datatypesID, /Droplist_Select)
          type = info.datatypes(listIndex)

          <span class="comments">; What kind of endness do we have?</span>
          endian = Widget_Info(info.byteorderID, /Droplist_Select)

          <span class="comments">; Get the format index from the formatlist widget.</span>
          xdr = Widget_Info(info.formatlistID, /Droplist_Select)

          <span class="comments">; If we want XDR, then the endian order is always "native".</span>
          IF xdr THEN endian = 0

          <span class="comments">; Create the formdata structure from the information you collected.</span>
          formdata = {header:header, dimensions:dimensions, endian:endian, $
             filename:filename, type:type, xdr:xdr, cancel:0}

          <span class="comments">; Store the formdata in the pointer location.</span>
          *info.ptrToFormData = formdata

         <span class="comments">; Out of here!</span>
         Widget_Control, event.top, /Destroy
         END <span class="comments">; of the Accept button case</span>

   ENDCASE

END <span class="comments">; of GETIMAGE_EVENT event handler ***************************************</span>



FUNCTION GETIMAGE, filename, Directory=directory, DataType=datatype, Dimensions=dimensions, $
   Header=header, HeadData=headdata, Parent=parent, XDR=xdr, XOffSet=xoffset, $
   YOffSet=yoffset, Cancel=canceled, Group_Leader=group_leader, Endian=endian, $
   XSIZE=xsize, YSIZE=ysize, FRAMES=frames, Catch=catchit  <span class="comments">; Obsolete keywords on this line</span>

   <span class="comments">; This is a function to specify the size, data type, and header information</span>
   <span class="comments">; about an image that you would like to read. It reads the data and returns</span>
   <span class="comments">; it as the result of the function. If an error occurs or the user CANCELS,</span>
   <span class="comments">; the function returns a 0.</span>
   On_Error, 2

   <span class="comments">; Catch errors unless explicitly told not to.</span>
   IF N_Elements(catchit) EQ 0 THEN catchit = 1  <span class="comments">; Now obsolete. Doing nothing with value.</span>

   <span class="comments">; Respond to either PARENT or GROUP_LEADER keywords.</span>
   IF N_Elements(parent) NE 0 THEN group_leader = parent

   <span class="comments">; Check for parameters and keywords.</span>
   IF N_Elements(filename) EQ 0 THEN BEGIN
        filename=Dialog_Pickfile()
        IF filename EQ "" THEN RETURN, ""
   ENDIF
   
   <span class="comments">; Does the file name have a directory? Is so, use it.</span>
   fileDir = File_Dirname(filename)
   IF StrLen(fileDir) GT 1 THEN BEGIN
       filename = File_Basename(filename)
       directory = fileDir
   ENDIF ELSE BEGIN
       IF fileDir EQ "." THEN BEGIN
          CD, CURRENT=directory
          filename = File_Basename(filename)
       ENDIF
   ENDELSE

   <span class="comments">; If DIRECTORY keyword is not used, use the IDL example/data directory.</span>
   IF N_Elements(directory) EQ 0 THEN BEGIN
       directory = File_DirName(Filepath(Subdirectory=['examples', 'data'], 'nonesense.dat'))
   ENDIF 
   startDirectory = directory
   
   <span class="comments">; Check for size and header keywords. These probably come in as</span>
   <span class="comments">; numbers and you need strings to put them into text widgets.</span>
   IF N_Elements(endian) EQ 0 THEN endian = 0 ELSE endian = 0 > endian &lt<span class="comments">; 2</span>
   IF N_Elements(datatype) EQ 0 THEN datatype = 1
   IF N_Elements(dimensions) EQ 0 THEN dimensions = [256, 256]
   IF N_Elements(header) EQ 0 THEN header='0' ELSE header=StrTrim(header,2)

   <span class="comments">; Create a modal top-level base if group leader is present.</span>
   IF N_Elements(group_leader) EQ 0 THEN $
      tlb = Widget_Base(Column=1, Title='Read Image Data', /Base_Align_Center) ELSE $
      tlb = Widget_Base(Column=1, Title='Read Image Data', Modal=1, $
         Group_Leader=group_leader, /Base_Align_Center)

   frameBase = Widget_Base(tlb, Frame=1, Column=1)

   <span class="comments">; Create the directory widgets.</span>
   dirnamebase = Widget_Base(frameBase, Row=1)
      dirnamelabel = Widget_Label(dirnamebase, Value='Directory:')
      dirnameID = Widget_Text(dirnamebase, Value=startDirectory, /Editable, $
         Event_Pro='GETIMAGE_NULL_EVENTS', XSize=Fix(2.0*StrLen(startDirectory) > 50))

   <span class="comments">; Create the filename widgets.</span>
   filenamebase = Widget_Base(frameBase, Row=1)
      filenamelabel = Widget_Label(filenamebase, Value='Filename:')
      filenameID = Widget_Text(filenamebase, Value=filename, /Editable, $
         Event_Pro='GETIMAGE_NULL_EVENTS', XSize=2*StrLen(filename) > 20)

   <span class="comments">; Create a button to allow user to pick a filename.</span>
   pickbutton = Widget_Button(filenamebase, Value='Pick Filename')

   <span class="comments">; Create a droplist widget to select file data types.</span>
   database = Widget_Base(frameBase, Row=1)
      datatypes = ['Byte', 'Integer (16-bit)', 'Long Integer (32-bit)', 'Float', 'Double', 'Unsigned Integer', 'Unsigned Long', '64-bit Long', '64-bit Unsigned Long']
      types = [1, 2, 3, 4, 5, 12, 13, 14, 15]
      theIndex = Where(types EQ datatype, count)
      datatypesID = Widget_Droplist(database, Value=datatypes, UValue=types, $
         Title='Data Type: ', Event_Pro='GETIMAGE_NULL_EVENTS')
      IF count EQ 0 THEN theIndex = 0
      Widget_Control, datatypesID, Set_Droplist_Select=theIndex

   <span class="comments">; Create a droplist widget to select file formats.</span>
   formatlistID = Widget_Droplist(database, Value=['Unformatted', 'XDR format'], $
      Title='File Format: ', Event_Pro='GETIMAGE_XDR_EVENTS')


   row4 = Widget_Base(frameBase, Row=1)
   dimsID = Widget_Droplist(row4, Title='Image Dimensions: ', Value=StrTrim(Indgen(7)+1, 2), $
      Event_PRO = 'GETIMAGE_DIMS_EVENTS')
   Widget_Control, dimsID, Set_Droplist_Select=1

   byteorderID = Widget_Droplist(row4, Title='Image Byte Order: ', $
      Value=['Native', 'Big Endian', 'Little Endian'], Event_PRO = 'GETIMAGE_NULL_EVENTS')
   Widget_Control, byteorderID, Set_Droplist_Select=endian

   label = Widget_Label(row4, Value=' Header Size: ')
   combovalues = ['0','32','64','128', '256', '512','1024']
   IF header GT 0 THEN combovalues = [StrTrim(header,2), combovalues]
   headerID = Widget_Combobox(row4, Value=combovalues, $
      /Editable, Event_PRO = 'GETIMAGE_NULL_EVENTS')


   <span class="comments">; Create widgets to gather the required file sizes.</span>

   sizebase = Widget_Base(frameBase, Row=2)

   d = IntArr(8)
   d[0] = FSC_Field(sizebase, Title='1st Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[1] = FSC_Field(sizebase, Title='2nd Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[2] = FSC_Field(sizebase, Title='3rd Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[3] = FSC_Field(sizebase, Title='4th Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[4] = FSC_Field(sizebase, Title='5th Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[5] = FSC_Field(sizebase, Title='6th Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[6] = FSC_Field(sizebase, Title='7th Dim:', Value=0, /Integer, XSize=6, /Positive)
   d[7] = FSC_Field(sizebase, Title='8th Dim:', Value=0, /Integer, XSize=6, /Positive)

   num = 1 > Size(dimensions, /N_Elements) &lt<span class="comments">; 8</span>
   FOR j=0,num-1 DO Widget_Control, d[j], Set_Value=dimensions[j]
   FOR j=num, 7 DO Widget_Control, d[j], Sensitive=0

   <span class="comments">; Create cancel and accept buttons.</span>
   cancelbase = Widget_Base(tlb, Row=1)
      cancel = Widget_Button(cancelbase, Value='Cancel')
      accept = Widget_Button(cancelbase, Value='Accept')

   <span class="comments">; Recalculate the length of the filenameID widget.</span>
   g1 = Widget_Info(dirnamebase, /Geometry)
   g2 = Widget_Info(filenamelabel, /Geometry)
   g3 = Widget_Info(pickbutton, /Geometry)
   target = g1.scr_xsize - (g2.scr_xsize + g3.scr_xsize) - 10
   Widget_Control, filenameID, Scr_XSize=target

   <span class="comments">; Center the program on the display.</span>
   cgCenterTLB, tlb

   <span class="comments">; Realize the program.</span>
   Widget_Control, tlb, /Realize

   <span class="comments">; Create a pointer to store the information collected from the form.</span>
   <span class="comments">; The initial data stored here is set to CANCEL, so nothing needs to</span>
   <span class="comments">; be done if the user kills the widget with the mouse.</span>
   ptrToFormData = Ptr_New({cancel:1})

   <span class="comments">; Set the correct file format in the format droplist widget.</span>
   Widget_Control, formatlistID, Set_Droplist_Select=Keyword_Set(xdr)

   <span class="comments">; Set the text insertion point at the end of the filename text widget.</span>
   tip = [StrLen(filename),0]
   Widget_Control, filenameID, Input_Focus=1
   Widget_Control, filenameID, Set_Text_Select=tip

   <span class="comments">; Create an info structure with program information.</span>
   info = { filenameID:filenameID, $        <span class="comments">; The name of the file.</span>
            d:d, $                          <span class="comments">; The dimension widgets IDs.</span>
            dimsID:dimsID, $                <span class="comments">; The number of dimensions widget ID.</span>
            byteorderID:byteorderID, $      <span class="comments">; The byte order widget ID.</span>
            dirnameID:dirnameID, $          <span class="comments">; The ID of the widget with the directory name.</span>
            headerID:headerID, $            <span class="comments">; The ID of the widget with the image HEADER size.</span>
            datatypesID:datatypesID, $      <span class="comments">; The ID of the image data TYPE droplist ID.</span>
            formatlistID:formatlistID, $    <span class="comments">; The ID of the image FORMAT droplist ID.</span>
            datatypes:types, $              <span class="comments">; The possible data types.</span>
            ptrToFormData:ptrToFormData}    <span class="comments">; A pointer to store the form information.</span>

  <span class="comments">; Store the info structure in the user value of the top-level base.</span>
   Widget_Control, tlb, Set_UValue=info

   <span class="comments">; The form will be a MODAL or BLOCKING widget, depending upon the</span>
   <span class="comments">; presence of the PARENT. We block or are MODAL here until the widget</span>
   <span class="comments">; is destroyed.</span>
   XManager, 'getimage', tlb, Event_Handler='GETIMAGE_EVENT'

   <span class="comments">; When the widget is destroyed, the block is released, and we</span>
   <span class="comments">; return here. Get the form data that was collected by the form</span>
   <span class="comments">; and stored in the pointer location.</span>
   formdata = *ptrToFormData

   <span class="comments">; If there is nothing here. Free the pointer and return.</span>
   IF N_Elements(formdata) EQ 0 THEN BEGIN
      Ptr_Free, ptrToFormData
      canceled = 1
      RETURN, 0
   ENDIF

   <span class="comments">; Did the user cancel out of the form? If so, return a 0.</span>
   IF formdata.cancel EQ 1 THEN BEGIN
      Ptr_Free, ptrToFormData
      canceled = 1
      RETURN, 0
   ENDIF

   <span class="comments">; Make the proper sized image array.</span>
   image = Make_Array(Dimension=formdata.dimensions, Type=formdata.type)

   <span class="comments">; We can have all kinds of trouble reading data. Let's catch all</span>
   <span class="comments">; input and output errors and alert user without crashing the program!</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN

      <span class="comments">; If we can't read the file for some reason, let the user know</span>
      <span class="comments">; why, free the pointer and its information, check the logical</span>
      <span class="comments">; unit number back in if it is checked out, and return a 0.</span>
      ok = Error_Message()
      Ptr_Free, ptrToFormData
      canceled = 1
      IF N_Elements(lun) NE 0 THEN Free_Lun, lun
      RETURN, 0
   ENDIF

   <span class="comments">; Set the canceled flag.</span>
   canceled = formdata.cancel

   <span class="comments">; Read the data file.</span>
   IF formdata.header GT 0 THEN headdata = BytArr(formdata.header)
   Get_Lun, lun
   CASE formdata.endian OF
      0: OpenR, lun, formdata.filename, XDR=formdata.xdr
      1: OpenR, lun, formdata.filename, XDR=formdata.xdr, /Swap_If_Little_Endian
      2: OpenR, lun, formdata.filename, XDR=formdata.xdr, /Swap_If_Big_Endian
   ENDCASE
   IF formdata.header GT 0 THEN ReadU, lun, headdata
   ReadU, lun, image
   Free_Lun, lun

   <span class="comments">; Free the pointer.</span>
   Ptr_Free, ptrToFormData

   RETURN, image

END <span class="comments">; of GETIMAGE program ***************************************************</span>
</code>
    </div>
  </body>
</html>