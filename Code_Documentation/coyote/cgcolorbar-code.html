<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:01 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgcolorbar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgcolorbar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgColorbar</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of this routine is to add a color bar to the current graphics window.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of this routine is to add a color bar to the current graphics window.</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgcolorbar2.png</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgcolorbar4.png</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgcolorbar1.png</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgcolorbar5.png</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;    annotatecolor: in, optional, type=string, default="opposite"</span>
<span class="comments">;       The name of the "annotation color" to use. The names are those for</span>
<span class="comments">;       cgCOLOR. If this keyword is used, the annotation color is loaded after</span>
<span class="comments">;       the color bar is displayed. This keyword is provided to maintain backward </span>
<span class="comments">;       compatibility, but also to solve the potential problem of an extra line showing up</span>
<span class="comments">;       in the color bar when the COLOR keyword is used in indexed color mode. In other words,</span>
<span class="comments">;       use ANNOTATECOLOR in place of COLOR for complete color model independent results.</span>
<span class="comments">;    bottom: in, optional, type=integer, default=0</span>
<span class="comments">;       The lowest color index of the colors to be loaded in the color bar.</span>
<span class="comments">;    brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;         This keyword is used only if the `CTIndex` keyword is used to select a color table number.</span>
<span class="comments">;         Setting this keyword allows Brewer color tables to be used.</span>
<span class="comments">;    charpercent: in, optional, type=float, default=0.85                 </span>
<span class="comments">;       A value from 0.0 go 1.0 that is multiplied by the CHARSIZE to produce</span>
<span class="comments">;       the character size for the color bar. This value is only used if CHARSIZE is </span>
<span class="comments">;       undefined. This keyword is primarily useful for using color bars in resizeable </span>
<span class="comments">;       graphics windows (cgWindow).</span>
<span class="comments">;    charsize: in, optional, type=float</span>
<span class="comments">;       The character size of the color bar annotations. Default is cgDefCharsize()*charPercent.</span>
<span class="comments">;    clamp: in, optional, type=float</span>
<span class="comments">;        A two-element array in data units. The color bar is clamped to these</span>
<span class="comments">;        two values. This is mostly of interest if you are "window-leveling"</span>
<span class="comments">;        an image. The clamp is set to the "window" of the color bar.</span>
<span class="comments">;        Normally, when you are doing this, you would like the colors outside</span>
<span class="comments">;        the "window" to be set to a neutral color. Use the NEUTRALINDEX keyword</span>
<span class="comments">;        to set the netural color index in the color bar. (See the Examples section</span>
<span class="comments">;        for more information.)</span>
<span class="comments">;    color: in, optional, type=string</span>
<span class="comments">;        The name of the color to use for color bar annotations. Ignored unless passed </span>
<span class="comments">;        the name of a cgColor color. The default value is to use the ANNOTATECOLOR.</span>
<span class="comments">;    ctindex: in, optional, type=integer</span>
<span class="comments">;         The index number of a color table. The `Brewer` and `Reverse` keywords will be checked</span>
<span class="comments">;         to see how to load the color table into the `Palette` keyword. This keyword will take</span>
<span class="comments">;         precidence over any colors that are loaded with the `Palette` keyword. </span>
<span class="comments">;    discrete: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to configure certain properties of the color bar to make</span>
<span class="comments">;         discrete color blocks for the color bar. This works best if you are using</span>
<span class="comments">;         a handful of colors in the color bar (e.g, 8-16).</span>
<span class="comments">;    divisions: in, optional, type=integer, default=0</span>
<span class="comments">;         The number of divisions to divide the bar into. There will be (divisions + 1) annotations. </span>
<span class="comments">;         When set to 0 (the default), the IDL Plot command detemines the number of divisions used.</span>
<span class="comments">;    fit: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, the colorbar "fits" itself to the normalized</span>
<span class="comments">;       coordinates of the last graphics command executed. In other words, for</span>
<span class="comments">;       a horizontal color bar, postition[[0,2]] = !X.Window, and for a vertical</span>
<span class="comments">;       color bar, position[[1,3]] = !Y.Window. Other positions are adjusted</span>
<span class="comments">;       to put the colorbar "reasonably" close to the plot. The fit many not always</span>
<span class="comments">;       be accurate. If you are fitting to an image, be sure to set the SAVE keyword</span>
<span class="comments">;       on cgImage to establish a data coordinate system.</span>
<span class="comments">;    font: in, optional, type=integer, default=!P.Font</span>
<span class="comments">;       Sets the font of the annotation. Hershey: -1, Hardware:0, True-Type: 1.</span>
<span class="comments">;    format: in, optional, type=string, default=""</span>
<span class="comments">;       The format of the color bar annotations. The dfault is to let the IDL Plot command </span>
<span class="comments">;       determine how the color bar labels are formatted.</span>
<span class="comments">;    invertcolors: in, optional, type=boolean, default=0</span>
<span class="comments">;       Setting this keyword inverts the colors in the color bar.</span>
<span class="comments">;    maxrange: in, optional</span>
<span class="comments">;       The maximum data value for the color bar annotation. Default is NCOLORS.</span>
<span class="comments">;    minrange: in, optional, type=float, default=0.0</span>
<span class="comments">;       The minimum data value for the bar annotation. </span>
<span class="comments">;    minor: in, optional, type=integer, default=2</span>
<span class="comments">;       The number of minor tick divisions. </span>
<span class="comments">;    ncolors: in, optional, type=integer, default=256</span>
<span class="comments">;       This is the number of colors in the color bar.</span>
<span class="comments">;    neutralindex: in, optional, type=integer   </span>
<span class="comments">;       This is the color index to use for color bar values outside the</span>
<span class="comments">;       clamping range when clamping the color bar with the CLAMP keyword.</span>
<span class="comments">;       If this keyword is absent, the highest color table value is used</span>
<span class="comments">;       for low range values and the lowest color table value is used</span>
<span class="comments">;       for high range values, in order to provide contrast with the</span>
<span class="comments">;       clamped region. (See the Examples section for more information.)</span>
<span class="comments">;    nodisplay: in, optional</span>
<span class="comments">;       This keyword is obsolete and is no longer used.</span>
<span class="comments">;    oob_factor: in, optional, type=float, default=1.0</span>
<span class="comments">;       The default is to make the length of the out-of-bounds triangle the</span>
<span class="comments">;       same distance as the height (or width, in the case of a vertical</span>
<span class="comments">;       color bar) of the color bar. If you would prefer a shorted triangle length, </span>
<span class="comments">;       set this keyword to a value less than zero (e.g., 0.5). If you prefer a </span>
<span class="comments">;       longer length, set this keyword to a value greater than zero. The "standard"</span>
<span class="comments">;       length will be multiplied by this value.</span>
<span class="comments">;    oob_high: in, optional, type=string</span>
<span class="comments">;       The name of an out-of-bounds high color. This color will be represented</span>
<span class="comments">;       by a triangle on the right or top of the color bar. If the color is</span>
<span class="comments">;       a string byte value (e.g., "215"), then this color in the current color</span>
<span class="comments">;       table is used. The color can also be a three-element color triple </span>
<span class="comments">;       (e.g., [240, 200, 65]). Note, you can CANNOT use a long integer as</span>
<span class="comments">;       a color table index number with this keyword. If you want to use a </span>
<span class="comments">;       color table index number, be sure the number is a short integer, byte</span>
<span class="comments">;       value, or a string (e.g, OOB_HIGH=200S, OOB_HIGH=200B, or OOB_HIGH='200').</span>
<span class="comments">;    oob_low: in, optional, type=string</span>
<span class="comments">;       The name of an out-of-bounds low color. This color will be represented</span>
<span class="comments">;       by a triangle on the left or bottom of the color bar. If the color is</span>
<span class="comments">;       a string byte value (e.g., "215"), then this color in the current color</span>
<span class="comments">;       table is used. The color can also be a three-element color triple </span>
<span class="comments">;       (e.g., [240, 200, 65]). Note, you can CANNOT use a long integer as</span>
<span class="comments">;       a color table index number with this keyword. If you want to use a </span>
<span class="comments">;       color table index number, be sure the number is a short integer, byte</span>
<span class="comments">;       value, or a string (e.g, OOB_HIGH=200S, OOB_HIGH=200B, or OOB_HIGH='200').</span>
<span class="comments">;    palette: in, optional, type=byte</span>
<span class="comments">;       A color palette containing the RGB color vectors to use for the color</span>
<span class="comments">;       bar. The program will sample NCOLORS from the color palette. </span>
<span class="comments">;    position: in, optional, type=float          </span>
<span class="comments">;       A four-element array of normalized coordinates in the same</span>
<span class="comments">;       form as the POSITION keyword on a plot. Default is[0.88, 0.10, 0.95, 0.90] </span>
<span class="comments">;       for a vertical bar and [0.10, 0.88, 0.90, 0.95] for a horizontal bar.</span>
<span class="comments">;       See the FIT keyword, also.</span>
<span class="comments">;    range: in, optional, type=float</span>
<span class="comments">;       A two-element vector of the form [min, max]. Provides an alternative </span>
<span class="comments">;       and faster way way of setting the MINRANGE and MAXRANGE keywords.</span>
<span class="comments">;    reverse: in, optional, type=boolean, default=0</span>
<span class="comments">;       An alternative keyword name (one I can actually remember!) for the INVERTCOLORS keyword.</span>
<span class="comments">;       It reverses the colors in the color bar.</span>
<span class="comments">;    right: in, optional, type=boolean, default=0   </span>
<span class="comments">;       This puts the labels on the right-hand side of a vertical color bar. It applies </span>
<span class="comments">;       only to vertical color bars.</span>
<span class="comments">;    tickinterval: in, optional, type=float</span>
<span class="comments">;       Set this keyword to the interval spacing of major tick marks. Use this keyword in</span>
<span class="comments">;       place of XTickInterval or YTickInterval keywords.</span>
<span class="comments">;    ticklen: in, optional, type=float, default=0.25</span>
<span class="comments">;       Set this keyword to the major tick length desired. Default is 0.25. Setting this </span>
<span class="comments">;       keyword to a value greater than or equal to 0.5 will result in major tick marks </span>
<span class="comments">;       extending the width of the color bar. Note that setting this keyword to 0.3 or</span>
<span class="comments">;       greater will result in minor tick mark lengths being set to 0.01, which is almost </span>
<span class="comments">;       too small to be seen. All direct graphics tick marks act in this (strange!) way.</span>
<span class="comments">;    ticknames: in, optional, type=string                 </span>
<span class="comments">;       A string array of names or values for the color bar tick marks. There should be</span>
<span class="comments">;       `divisions` + 1 tick names in the array.</span>
<span class="comments">;    title: in, optional, type=string, default=""</span>
<span class="comments">;       This is title for the color bar. The default is to have no title.</span>
<span class="comments">;    tcharsize: in, optional, type=float</span>
<span class="comments">;       The title size. By default, the same as `Charsize`. Note that this keyword is</span>
<span class="comments">;       ignored for vertical color bars unless the title location (`TLocation`) is on</span>
<span class="comments">;       the opposite side of the color bar from the color bar labels. This is a consequence</span>
<span class="comments">;       of being upable to determine the length of color bar labels programmatically in this</span>
<span class="comments">;       orientation.</span>
<span class="comments">;    textthick: in, optional, type=float, default=1.0</span>
<span class="comments">;        Sets the thickness of the textual annotations on the color bar.</span>
<span class="comments">;    tlocation: in, optional, type=string</span>
<span class="comments">;       The title location, which allows the user to set the title location independently </span>
<span class="comments">;       of the colorbar labels. May be "TOP" or "BOTTOM" for horizontal color bars, and</span>
<span class="comments">;       "LEFT" or "RIGHT" for vertical color bars.</span>
<span class="comments">;    top: in, optional, type=boolean, default=0</span>
<span class="comments">;       This puts the labels on top of the bar rather than under it. The keyword only </span>
<span class="comments">;       applies if a horizontal color bar is rendered.</span>
<span class="comments">;    vertical: in, optional, type=boolean, default=0</span>
<span class="comments">;       Setting this keyword give a vertical color bar. The default is a horizontal color bar.</span>
<span class="comments">;    window: in, optional, type=boolean, default=0               </span>
<span class="comments">;       Set this keyword to display the plot in a resizeable graphics window (cgWindow).</span>
<span class="comments">;    xlog: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to use logarithmic scaling for the colorbar data range.</span>
<span class="comments">;    xtickinterval: in, optional, type=float</span>
<span class="comments">;       This keyword is trapped, but unused. Please use the`TickInterval` keyword instead.</span>
<span class="comments">;    xticklayout: in, optional, type=integer, default=0</span>
<span class="comments">;       See the Plot graphics kewyords for an example. Used here only to track this keyword.</span>
<span class="comments">;    xtitle: in, optional, type=string</span>
<span class="comments">;        This keyword is ignored. Use the `Title` keyword to set a title for the color bar.</span>
<span class="comments">;    ylog: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to use logarithmic scaling for the colorbar data range.</span>
<span class="comments">;    ytickinterval: in, optional, type=float</span>
<span class="comments">;       This keyword is trapped, but unused. Please use the`TickInterval` keyword instead.</span>
<span class="comments">;    yticklayout: in, optional, type=integer, default=0</span>
<span class="comments">;       See the Plot graphics kewyords for an example. Used here only to track this keyword.</span>
<span class="comments">;    ytitle: in, optional, type=string</span>
<span class="comments">;        This keyword is ignored. Use the `Title` keyword to set a title for the color bar.</span>
<span class="comments">;    _ref_extra: in, optional</span>
<span class="comments">;         Any keyword appropriate for the PLOT and AXIS commands is also accepted by keyword</span>
<span class="comments">;         inheritance.</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    To display a horizontal color bar above a contour plot, type::</span>
<span class="comments">;</span>
<span class="comments">;       cgLOADCT, 5, NCOLORS=100</span>
<span class="comments">;       cgCONTOUR, DIST(31,41), POSITION=[0.15, 0.15, 0.95, 0.75], $</span>
<span class="comments">;          C_COLORS=INDGEN(25)*4, NLEVELS=25</span>
<span class="comments">;       cgCOLORBAR, NCOLORS=100, POSITION=[0.15, 0.85, 0.95, 0.90]</span>
<span class="comments">;       </span>
<span class="comments">;    Example using the `Clamp` and `NeutralIndex` keywords::</span>
<span class="comments">;       </span>
<span class="comments">;       cgLOADCT, 33, NCOLORS=254</span>
<span class="comments">;       TVLCT, cgCOLOR('gray', /TRIPLE), 255</span>
<span class="comments">;       cgCOLORBAR, NCOLORS=254, NEUTRALINDEX=255, RANGE=[0,1500], $</span>
<span class="comments">;           DIVISIONS=8, CLAMP=[400, 800]</span>
<span class="comments">;           </span>
<span class="comments">;    Additional examples can be found in the article `Adding a Color Bar &lt;http://www.idlcoyote.com/color_tips/colorbar.html>`.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;       Written by: David W. Fanning, 4 February 2011, as a direct descendant of cgColorbar.</span>
<span class="comments">;       Program developement stopped on cgColorbar as of this date, and this program has</span>
<span class="comments">;       become a part of the Coyote Graphics System.</span>
<span class="comments">;       Added FIT keyword. 28 Feb 2011. DWF</span>
<span class="comments">;       Made default character size cgDefCharsize*0.85. 28 Feb 2011. DWF.</span>
<span class="comments">;       Modified error handler to restore the entry decomposition state if there is an error. 17 March 2011. DWF</span>
<span class="comments">;       Added CHARPERCENT keyword 18 March 2011. DWF.</span>
<span class="comments">;       Added XTITLE and YTITLE keywords, which do nothing except prevent these keywords</span>
<span class="comments">;          from being used inadvertently. 27 May 2011. DWF.</span>
<span class="comments">;       Fixed a problem with assigning the color with the ANNOTATECOLOR keyword in the</span>
<span class="comments">;          Z-graphics buffer. 30 Aug 2011. DWF.</span>
<span class="comments">;       Changed the default DIVISIONS to 0 and the default FORMAT to "". 2 Sept 2011. DWF.</span>
<span class="comments">;       Added code that will force MINRANGE and MAXRANGE values to be scalars. 5 Sept 2011. DWF.</span>
<span class="comments">;       Problem with division by zero when FORMAT is not default value. Now, if format</span>
<span class="comments">;          is the default value, then default is DIVISIONS=0, else DIVISIONS=6.</span>
<span class="comments">;       Documented the TICKLEN keyword and set the default tick length to 0.25. 3 Oct 2011. DWF.</span>
<span class="comments">;       Added the OOB_FACTOR, OOB_HIGH and OOB_LOW keywords. 5 Dec 2011. DWF.</span>
<span class="comments">;       Added DISCRETE keyword. 7 Dec 2011. DWF.</span>
<span class="comments">;       Changed the way the top axis was drawn, and had a problem with EXTRA keywords. Fixed. 20 Dec 2011. DWF.</span>
<span class="comments">;       Modified to use cgDefaultColor for default color selection. 24 Dec 2011. DWF.</span>
<span class="comments">;       Fixed a problem with color palettes by defining NCOLORS according to the number of colors</span>
<span class="comments">;          in the palette. 19 March 2012. DWF.</span>
<span class="comments">;       Set the maximum number of divisions at 59 to recognize the IDL plot limit for tick marks. 19 March 2012. DWF.</span>
<span class="comments">;       Modifications to the FIT algorithm to make sure the color bar is completely inside</span>
<span class="comments">;           the graphics window. Also fixed mis-spelled variable name. 20 March 2012. DWF.</span>
<span class="comments">;       Added TickInterval, XTickInterval and YTickInterval keywords to accommodate interval </span>
<span class="comments">;           spacing of major tick marks. 21 July 2012. DWF.</span>
<span class="comments">;       Added the ability to use escape characters in plot titles to specify cgSymbol symbols. 27 July 2012. DWF.</span>
<span class="comments">;       Added TLOCATION and TCHARSIZE keywords. 20 September 2012. DWF.</span>
<span class="comments">;       Implemented a fix that will allow the user to specify a tick formatting function name </span>
<span class="comments">;          with the FORMAT keyword. 21 September 2012. DWF.</span>
<span class="comments">;       Fixed a problem in which setting the RANGE keyword gave different results, depending upon whether</span>
<span class="comments">;          a FORMAT keyword was used or not. This change will affect the default color bar labeling</span>
<span class="comments">;          *if* the user specifies a range. If you prefer the old labeling behavior, simiply set</span>
<span class="comments">;          the `Divisions` keyword to 0. 16 Oct 2012. DWF.</span>
<span class="comments">;       Added CTINDEX, and BREWER keywords to make loading a color table palette easier. 20 October 2012. DWF.</span>
<span class="comments">;       Fixed a strange interaction between TickInterval and the Format keywords. 5 Nov 2012. DWF.</span>
<span class="comments">;       Changes to support a tick formatting function when a log axis is used. 7 February 2013. DWF.</span>
<span class="comments">;       Added XTICKLAYOUT and YTICKLAYOUT keywords. 8 February 2013. DWF.</span>
<span class="comments">;       Somehow the default AnnotateColor had gotten changed from "opposite". Restored. 18 Feb 2013. DWF.</span>
<span class="comments">;       Greatly simplified the code and turned over the responsibility of doing tick formatting and setting</span>
<span class="comments">;          the number of divisions, etc. to the PLOT command. I do this with some trepidation, because it</span>
<span class="comments">;          is a big change, but I think it will lead to better results in the long run and won't affect</span>
<span class="comments">;          current IDL programs much, if at all. 27 Feb 2013. DWF.</span>
<span class="comments">;       Added TEXTTHICK keyword to change the thickness of the textual annotations. 28 Feb 2013. DWF.</span>
<span class="comments">;       Added more error handling for bad POSITION values. 26 July 2013. DWF.</span>
<span class="comments">;       Modified the code so that the original input POSITION values are not changed by the</span>
<span class="comments">;           program code. 8 August 2013. DWF.</span>
<span class="comments">;       </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2008-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgColorbar, $
    ADDCMD=addcmd, $
    ANNOTATECOLOR=annotatecolor, $
    BOTTOM=bottom, $
    BREWER=brewer, $
    CHARPERCENT=charpercent, $
    CHARSIZE=charsize, $
    CLAMP=clamp, $
    COLOR=color, $
    CTINDEX=ctindex, $
    DISCRETE=discrete, $
    DIVISIONS=divisions, $
    FIT=fit, $
    FONT=font, $
    FORMAT=format, $
    INVERTCOLORS=invertcolors, $
    MAXRANGE=maxrange, $
    MINOR=minor, $
    MINRANGE=minrange, $
    NCOLORS=ncolors, $
    NEUTRALINDEX=neutralIndex, $
    NODISPLAY=nodisplay, $
    OOB_FACTOR=oob_factor, $
    OOB_HIGH=oob_high, $
    OOB_LOW=oob_low, $
    PALETTE=palette, $
    POSITION=origpos, $
    RANGE=range, $
    REVERSE=reverse, $
    RIGHT=right, $
    TCHARSIZE=tcharsize, $
    TEXTTHICK=textthick, $
    TLOCATION=tlocation, $
    TICKINTERVAL=tickinterval, $
    TICKLEN=ticklen, $
    TICKNAMES=ticknames, $
    TITLE=title, $
    TOP=top, $
    VERTICAL=vertical, $
    XLOG=xlog, $
    XTICKINTERVAL=xtickinterval, $
    XTICKLAYOUT=xticklayout, $
    XTITLE=xtitle, $ <span class="comments">; Ignored.</span>
    YLOG=ylog, $
    YTICKINTERVAL=ytickinterval, $
    YTICKLAYOUT=yticklayout, $
    YTITLE=ytitle, $ <span class="comments">; Ignored</span>
    WINDOW=window, $
    _REF_EXTRA=extra

    Compile_Opt idl2

    <span class="comments">; Catch the error.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
        RETURN
    ENDIF

    <span class="comments">; Should this be added to a resizeable graphics window?</span>
    IF (Keyword_Set(window) OR Keyword_Set(addcmd)) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        IF Keyword_Set(addcmd) THEN window = 0
        void = cgQuery(COUNT=wincnt)
        IF wincnt EQ 0 THEN cgWindow
        cgWindow, 'cgColorbar', $
            ANNOTATECOLOR=annotatecolor, $
            BOTTOM=bottom, $
            BREWER=brewer, $
            CHARPERCENT=charpercent, $
            CHARSIZE=charsize, $
            CLAMP=clamp, $
            COLOR=color, $
            CTINDEX=ctindex, $
            DISCRETE=discrete, $
            DIVISIONS=divisions, $
            FIT=fit, $
            FONT=font, $
            FORMAT=format, $
            INVERTCOLORS=invertcolors, $
            MAXRANGE=maxrange, $
            MINOR=minor, $
            MINRANGE=minrange, $
            NCOLORS=ncolors, $
            NEUTRALINDEX=neutralIndex, $
            NODISPLAY=nodisplay, $
            OOB_FACTOR=oob_factor, $
            OOB_HIGH=oob_high, $
            OOB_LOW=oob_low, $
            PALETTE=palette, $
            POSITION=origpos, $
            RANGE=range, $
            REVERSE=reverse, $
            RIGHT=right, $
            TCHARSIZE=tcharsize, $
            TEXTTHICK=textthick, $
            TLOCATION=tlocation, $
            TICKINTERVAL=tickinterval, $
            XTICKLAYOUT=xticklayout, $
            TICKLEN=ticklen, $
            TICKNAMES=ticknames, $
            TITLE=title, $
            TOP=top, $
            VERTICAL=vertical, $
            XLOG=xlog, $
            XTICKINTERVAL=xtickinterval, $
            XTITLE=xtitle, $ <span class="comments">; Ignored.</span>
            YLOG=ylog, $
            YTICKINTERVAL=ytickinterval, $
            YTICKLAYOUT=yticklayout, $
            YTITLE=ytitle, $
            REPLACECMD=Keyword_Set(window), $
            ADDCMD=Keyword_Set(addcmd), $
             _EXTRA=extra

            
         RETURN
    ENDIF
    
    <span class="comments">; Do you have an original position vector? If so, copy it here to avoid</span>
    <span class="comments">; changing the original input position in the code below.</span>
    IF (N_Elements(origpos) NE 0) THEN position = origpos

    <span class="comments">; Get the current color table vectors. </span>
    TVLCT, r, g, b, /GET
    
    <span class="comments">; Default values.</span>
    IF (N_Elements(charPercent) EQ 0) $
        THEN charPercent = 0.85 $
        ELSE charPercent = 0.0 > charPercent &lt<span class="comments">; 1.0</span>
        
    <span class="comments">; Did you specify a color table index?</span>
    IF N_Elements(ctindex) NE 0 THEN BEGIN
        cgLoadCT, ctindex, Brewer=brewer, RGB_TABLE=palette
    ENDIF

    <span class="comments">; If you have a palette, load the colors now. Otherwise whatever colors</span>
    <span class="comments">; are in the current color table will be used.</span>
    IF N_Elements(palette) NE 0 THEN BEGIN
        IF Size(palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
        dims = Size(palette, /DIMENSIONS)
        threeIndex = Where(dims EQ 3)
        IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
        IF threeIndex[0] EQ 0 THEN BEGIN
            palette = Transpose(palette)
            npalColors = dims[1]
        ENDIF ELSE npalColors = dims[0]
        IF N_Elements(ncolors) EQ 0 THEN ncolors = npalColors
        TVLCT, palette
        TVLCT, rr, gg, bb, /Get
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; Save the current plot state.</span>
    bang_p = !P
    bang_x = !X
    bang_Y = !Y
    bang_Z = !Z
    bang_Map = !Map

    <span class="comments">; Are scalable pixels available on the device?</span>
    IF (!D.Flags AND 1) NE 0 THEN scalablePixels = 1 ELSE scalablePixels = 0

    <span class="comments">; Which release of IDL is this?</span>
    thisRelease = Float(!Version.Release)

    <span class="comments">; Check and define keywords.</span>
    SetDefaultValue, ncolors, 256
    SetDefaultValue, divisions, 0 <span class="comments">; Let the PLOT command decide.</span>
    SetDefaultValue, bottom, 0B
    SetDefaultValue, charsize, cgDefCharsize() * charPercent
    SetDefaultValue, tcharsize, charsize
    SetDefaultValue, textthick, 1.0
    SetDefaultValue, format, "" <span class="comments">; Let the PLOT command decide.</span>
    IF N_Elements(nodisplay) EQ 0 THEN nodisplay = 1
    minrange = (N_ELEMENTS(minrange) EQ 0) ? 0. : Float(minrange[0])
    maxrange = (N_ELEMENTS(maxrange) EQ 0) ? Float(ncolors) : Float(maxrange[0])
    SetDefaultValue, ticklen, 0.25
    SetDefaultValue, minor, 2
    IF N_ELEMENTS(range) NE 0 THEN BEGIN
       minrange = Float(range[0])
       maxrange = Float(range[1])
    ENDIF
    SetDefaultValue, font, !P.Font
    SetDefaultValue, title, ""
    IF N_Elements(title) NE "" THEN title = cgCheckForSymbols(title)
    SetDefaultValue, oob_factor, 1.0
    xlog = Keyword_Set(xlog)
    ylog = Keyword_Set(ylog)
    
    <span class="comments">; Deal with tick intervals, if you have them.</span>
    IF Keyword_Set(vertical) THEN BEGIN
       IF (N_Elements(tlocation) EQ 0) THEN tlocation = Keyword_Set(right) ? 'RIGHT' : 'LEFT'
       IF (N_Elements(yTickInterval) NE 0) && (ylog EQ 0) THEN BEGIN
           IF N_Elements(tickInterval) EQ 0 THEN tickInterval = yTickInterval
       ENDIF
    ENDIF ELSE BEGIN
       IF (N_Elements(tlocation) EQ 0) THEN tlocation = Keyword_Set(top) ? 'TOP' : 'BOTTOM'
       IF (N_Elements(xTickInterval) NE 0) && (xlog EQ 0) THEN BEGIN
           IF N_Elements(tickInterval) EQ 0 THEN tickInterval = xTickInterval    
       ENDIF
    ENDELSE
    
    <span class="comments">; A plot command limitation restricts the number of divisions to 59.</span>
    divisions = divisions &lt<span class="comments">; 59 </span>
    
    <span class="comments">; If needed create a window first, so the drawing</span>
    <span class="comments">; colors are correct for the window you want to draw into.</span>
    IF ((!D.Flags AND 256) NE 0) && (!D.Window LT 0) THEN cgDisplay
    
    <span class="comments">; If the user asked for discrete colors, set some keywords appropriately.</span>
    <span class="comments">; This really should not be used for more than 16 or colors, but I don't</span>
    <span class="comments">; want to limit it for the user. The maximum value is 59.</span>
    IF Keyword_Set(discrete) THEN BEGIN
       divisions = ncolors &lt<span class="comments">; 59</span>
       ticklen = 1.0
       minor = 0
    ENDIF

    <span class="comments">; You can't have a format set *and* use ticknames.</span>
    IF N_ELEMENTS(ticknames) NE 0 THEN format = ""
    
    <span class="comments">; Determine the position of the color bar in the window.</span>
    IF KEYWORD_SET(vertical) THEN BEGIN
       bar = REPLICATE(1B,20) # BINDGEN(ncolors)
       IF Keyword_Set(invertcolors) THEN bar = Reverse(bar, 2)
       IF N_ELEMENTS(position) EQ 0 THEN BEGIN
          IF Keyword_Set(right) THEN BEGIN
             position = [0.83, 0.125, 0.90, 0.9]
          ENDIF ELSE BEGIN
             position = [0.88, 0.125, 0.95, 0.9]
          ENDELSE
       ENDIF ELSE BEGIN
          IF position[2]-position[0] GT position[3]-position[1] THEN BEGIN
             position = [position[1], position[0], position[3], position[2]]
          ENDIF
       ENDELSE
       IF Keyword_Set(fit) THEN BEGIN
            position[[1,3]] = !Y.Window
            distance = position[2] - position[0]
            IF Keyword_Set(right) THEN BEGIN
                position[0] = !X.Window[1] + ((4*!D.X_CH_SIZE*charsize) / !D.X_Size)
            ENDIF ELSE BEGIN
                position[0] = !X.Window[1] + ((10*!D.X_CH_SIZE*charsize) / !D.X_Size)
            ENDELSE
            position[2] = position[0] + distance
            IF position[2] GT 1.0 THEN BEGIN
              diff = position[2]-1.0
              position[2] = 1.0 - 0.015
              IF (position[2] - position[0]) LT 0.015 THEN position[0] = (position[2] &lt<span class="comments">; position[0])-0.015</span>
            ENDIF
       ENDIF
    ENDIF ELSE BEGIN
       bar = BINDGEN(ncolors) # REPLICATE(1B, 20)
       IF Keyword_Set(invertcolors) THEN bar = Reverse(bar, 1)
       IF N_ELEMENTS(position) EQ 0 THEN BEGIN
          IF Keyword_Set(top) THEN BEGIN
             position = [0.125, 0.82, 0.925, 0.90]
          ENDIF ELSE BEGIN
             position = [0.125, 0.88, 0.925, 0.95]
          ENDELSE
       ENDIF ELSE BEGIN
          IF position[3]-position[1] GT position[2]-position[0] THEN BEGIN
             position = [position[1], position[0], position[3], position[2]]
          ENDIF
       ENDELSE
       IF Keyword_Set(fit) THEN BEGIN
            position[[0,2]] = !X.Window
            distance = (position[3] - position[1])
            position[1] = !Y.Window[1] + ((4*!D.Y_CH_SIZE*charsize) / !D.Y_Size)
            position[3] = position[1] + distance
            IF position[3] GT 1.0 THEN BEGIN
              diff = position[3]-1.0
              position[3] = 1.0 - 0.015
              IF (position[3] - position[1]) LT 0.015 THEN position[1] = (position[3] &lt<span class="comments">; position[1])-0.015</span>
            ENDIF
       ENDIF
     ENDELSE
     
     <span class="comments">; Adjust the positions if you have OOB colors.</span>
     IF (N_Elements(oob_high) NE 0) || (N_Elements(oob_low) NE 0) THEN BEGIN
         IF Keyword_Set(vertical) THEN BEGIN
            length = (position[2]-position[0]) * oob_factor
            IF (N_Elements(oob_high) NE 0) THEN position[3] = position[3] - length
            IF (N_Elements(oob_low) NE 0) THEN position[1] = position[1] + length
         ENDIF ELSE BEGIN
            length = (position[3]-position[1]) * oob_factor
            IF (N_Elements(oob_high) NE 0) THEN position[2] = position[2] - length
            IF (N_Elements(oob_low) NE 0) THEN position[0] = position[0] + length
         ENDELSE
     ENDIF

     <span class="comments">; Scale the color bar.</span>
     IF N_Elements(clamp) NE 0 THEN BEGIN
        IF N_Elements(clamp) NE 2 THEN Message, 'The CLAMP keyword must be a two-element array.'
        byterange = BytScl(clamp, minrange, maxrange)
        tempbar = BytScl(bar, TOP=(ncolors-1) &lt<span class="comments">; (255-bottom)) + bottom   </span>
        bar = BytScl(bar, TOP=(ncolors-1) &lt<span class="comments">; (255-bottom), MIN=byterange[0], MAX=byterange[1]) + bottom </span>
        IF N_Elements(neutralIndex) EQ 0 THEN BEGIN
            neutralBottom = (ncolors-1) &lt<span class="comments">; (255-bottom)</span>
            neutralTop = bottom
        ENDIF ELSE BEGIN
            neutralBottom = neutralIndex
            neutralTop = neutralIndex
        ENDELSE
        i = Where(tempbar LT byterange[0], count)
        IF count GT 0 THEN bar[i] = neutralBottom
        i = Where(tempbar GT byterange[1], count)
        IF count GT 0 THEN bar[i] = neutralTop
     ENDIF ELSE BEGIN
        bar = BytScl(bar, TOP=(ncolors-1) &lt<span class="comments">; (255-bottom)) + bottom</span>
     ENDELSE

     IF Keyword_Set(reverse) THEN BEGIN
       IF Keyword_Set(vertical) THEN bar = Reverse(bar,2) ELSE bar = Reverse(bar,1)
     ENDIF

    <span class="comments">; Get starting locations in NORMAL coordinates.</span>
    xstart = position[0]
    ystart = position[1]

    <span class="comments">; Get the size of the bar in NORMAL coordinates.</span>
    xsize = (position[2] - position[0])
    ysize = (position[3] - position[1])

       
    <span class="comments">; Let's do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, CURRENTSTATE=currentState
       
    <span class="comments">; Display the color bar in the window. Sizing is</span>
    <span class="comments">; different for PostScript and regular display.</span>
    IF scalablePixels THEN BEGIN

       <span class="comments">; Display the color bar.</span>
       SetDecomposedState, 0
       TV, bar, xstart, ystart, XSIZE=xsize, YSIZE=ysize, /Normal
       SetDecomposedState, 1 

    ENDIF ELSE BEGIN

       bar = CONGRID(bar, CEIL(xsize*!D.X_VSize), CEIL(ysize*!D.Y_VSize))

       <span class="comments">; Display the color bar.</span>
       SetDecomposedState, 0
       TV, bar, xstart, ystart, /Normal
       SetDecomposedState, 1

    ENDELSE
   
    <span class="comments">; Get the current colortable.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; You can't specify both DIVISIONS and a tick interval, so fix that here.</span>
    IF N_Elements(tickInterval) NE 0 THEN divisions = 0
        
    <span class="comments">; Annotate the color bar.</span>
    annotateColor = cgDefaultColor(annotateColor, DEFAULT='opposite')
    
    <span class="comments">; If color is undefined, use the annotate color.</span>
    color = cgDefaultColor(color, DEFAULT=annotateColor)
    
    IF Size(annotateColor, /TNAME) EQ 'STRING' THEN annotateColor = cgColor(annotateColor)
    IF Size(color, /TNAME) EQ 'STRING' THEN color = cgColor(color)
    
    <span class="comments">; If the POSITION is screwed up, the user can get a weird error message from AXIS about a</span>
    <span class="comments">; "data coordinate system not established". Check the position here to make sure it is right.</span>
    IF position[0] GE position[2] THEN Message, 'The X POSITION coordinates cannot be reconciled.'
    IF position[1] GE position[3] THEN Message, 'The Y POSITION coordinates cannot be reconciled.'
    IF (position[0] LT 0) || (position[2] GT 1) THEN Message, 'The X POSITION cooordinates must be in the range 0 to 1.'
    IF (position[1] LT 0) || (position[3] GT 1) THEN Message, 'The Y POSITION cooordinates must be in the range 0 to 1.'
    
    IF KEYWORD_SET(vertical) THEN BEGIN

       IF KEYWORD_SET(right) THEN BEGIN

          IF StrUpCase(tlocation) EQ 'LEFT' THEN BEGIN
              PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=1, $
                 YTICKS=divisions, XSTYLE=1, YSTYLE=9, XTITLE="", YTITLE="", $
                 POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
                 XTICKFORMAT='(A1)', YTICKFORMAT='(A1)', YMINOR=minor, _STRICT_EXTRA=extra, $
                 YTICKNAME=ticknames, FONT=font, YLOG=ylog, YTICKINTERVAL=tickinterval, $
                 YTICKLAYOUT=yticklayout, XTICKLAYOUT=xticklayout, CHARTHICK=textthick
    
              AXIS, YAXIS=1, YRANGE=[minrange, maxrange], YTICKFORMAT=format, YTICKS=divisions, $
                 YTICKLEN=ticklen, YSTYLE=1, COLOR=color, CHARSIZE=charsize, XTITLE="", $
                 FONT=font, YTITLE="", _STRICT_EXTRA=extra, YMINOR=minor, YTICKNAME=ticknames, $
                 YLOG=ylog, YTICKINTERVAL=tickinterval, YTICK_GET=ticks, YTICKLAYOUT=yticklayout
                 
              truecharsize = Float(!D.X_CH_SIZE * tcharsize) / !D.X_SIZE
              yloc = (position[3] - position[1]) / 2.0 + position[1]
              xloc = position[0] - (1.5 * truecharsize)
              XYOUTS, xloc, yloc, title, /NORMAL, COLOR=color, CHARTHICK=textthick, $
                ALIGNMENT=0.5, FONT=font, CHARSIZE=tcharsize, ORIENTATION=-270
          ENDIF ELSE BEGIN
              PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=1, $
                 YTICKS=divisions, XSTYLE=1, YSTYLE=9, XTITLE="", YTITLE="", $
                 POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
                 XTICKFORMAT='(A1)', YTICKFORMAT='(A1)', YMINOR=minor, _STRICT_EXTRA=extra, $
                 YTICKNAME=ticknames, FONT=font, YLOG=ylog, YTICKINTERVAL=tickinterval, $
                 YTICKLAYOUT=yticklayout, XTICKLAYOUT=xticklayout, CHARTHICK=textthick
    
              AXIS, YAXIS=1, YRANGE=[minrange, maxrange], YTICKFORMAT=format, YTICKS=divisions, $
                 YTICKLEN=ticklen, YSTYLE=1, COLOR=color, CHARSIZE=charsize, XTITLE="", $
                 FONT=font, YTITLE=title, _STRICT_EXTRA=extra, YMINOR=minor, YTICKNAME=ticknames, $
                 YLOG=ylog, YTICKINTERVAL=tickinterval, YTICK_GET=ticks, YTICKLAYOUT=yticklayout
          ENDELSE

       ENDIF ELSE BEGIN

          IF StrUpCase(tlocation) EQ 'RIGHT' THEN BEGIN
              PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=1,  $
                 YTICKS=divisions, YSTYLE=9, XSTYLE=1, YTITLE="", CHARTHICK=textthick, $
                 POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
                 XTICKFORMAT='(A1)', YTICKFORMAT=format, YMinor=minor, _STRICT_EXTRA=extra, $
                 YTICKNAME=ticknames, YLOG=ylog, YTICKLEN=ticklen, FONT=font, XTITLE="", $
                 YTICKINTERVAL=tickinterval, YTICKLAYOUT=yticklayout, XTICKLAYOUT=xticklayout
    
              AXIS, YAXIS=1, YRANGE=[minrange, maxrange], YTICKFORMAT='(A1)', YTICKS=divisions, $
                 YTICKLEN=0.001, YSTYLE=1, COLOR=color, CHARSIZE=charsize, XTITLE="", $
                 FONT=font, YTITLE="", _STRICT_EXTRA=extra, YMINOR=minor, YTICKNAME="", YLOG=ylog, $
                 YTICKINTERVAL=tickinterval, YTICKLAYOUT=yticklayout
                 
              truecharsize = Float(!D.X_CH_SIZE * tcharsize) / !D.X_SIZE
              yloc = (position[3] - position[1]) / 2.0 + position[1]
              xloc = position[2] + (2.0 * truecharsize)
              XYOUTS, xloc, yloc, title, /NORMAL, COLOR=color, CHARTHICK=textthick, $
                ALIGNMENT=0.5, FONT=font, CHARSIZE=tcharsize, ORIENTATION=-270
          ENDIF ELSE BEGIN
              PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=1,  $
                 YTICKS=divisions, YSTYLE=9, XSTYLE=1, YTITLE=title, CHARTHICK=textthick, $$
                 POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
                 XTICKFORMAT='(A1)', YTICKFORMAT=format, YMinor=minor, _STRICT_EXTRA=extra, $
                 YTICKNAME=ticknames, YLOG=ylog, YTICKLEN=ticklen, FONT=font, XTITLE="", $
                 YTICKINTERVAL=tickinterval, YTICKLAYOUT=yticklayout, XTICKLAYOUT=xticklayout
    
              AXIS, YAXIS=1, YRANGE=[minrange, maxrange], YTICKFORMAT='(A1)', YTICKS=divisions, $
                 YTICKLEN=0.001, YSTYLE=1, COLOR=color, CHARSIZE=charsize, XTITLE="", $
                 FONT=font, YTITLE="", _STRICT_EXTRA=extra, YMINOR=minor, YTICKNAME="", YLOG=ylog, $
                 YTICKINTERVAL=tickinterval, YTICKLAYOUT=yticklayout
          ENDELSE

       ENDELSE

    ENDIF ELSE BEGIN

       IF KEYWORD_SET(top) THEN BEGIN

          PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=divisions, $
             YTICKS=1, XSTYLE=9, YSTYLE=1, CHARTHICK=textthick, $
             POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
             YTICKFORMAT='(A1)', XTICKFORMAT='(A1)', XTICKLEN=0.01, $
             XRANGE=[minrange, maxrange], FONT=font, XMINOR=minor, _STRICT_EXTRA=extra, $
             XTICKNAME=ticknames, XLOG=xlog, XTITLE="", YTITLE="", XTICKINTERVAL=tickInterval, $
             XTICKLAYOUT=xticklayout, YTICKLAYOUT=yticklayout

          AXIS, XTICKS=divisions, XSTYLE=1, COLOR=color, CHARSIZE=charsize, $
             XTICKFORMAT=format, XTICKLEN=ticklen, XRANGE=[minrange, maxrange], XAXIS=1, $
             FONT=font, XTITLE="", _STRICT_EXTRA=extra, XMINOR=minor, $
             XTICKNAME=ticknames, XLOG=xlog, YTITLE="", XTICKINTERVAL=tickInterval, $
             XTICKLAYOUT=xticklayout
             
          IF title NE "" THEN BEGIN
             xloc = (position[2] - position[0]) / 2.0 + position[0]
             CASE StrUpCase(tlocation) OF
                'TOP': BEGIN
                     truecharsize = Float(!D.Y_CH_SIZE * charsize) / !D.Y_SIZE
                     yloc = position[3] + (2.25 * truecharsize)
                     END
                'BOTTOM': BEGIN
                      truecharsize = Float(!D.Y_CH_SIZE * tcharsize) / !D.Y_SIZE
                      yloc = position[1] - (1.5 * truecharsize)
                      END
                'RIGHT': Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
                'LEFT': Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
                ELSE: Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
             ENDCASE
             XYOUTS, xloc, yloc, title, /NORMAL, COLOR=color, CHARTHICK=textthick, $
                ALIGNMENT=0.5, FONT=font, CHARSIZE=tcharsize
          ENDIF

       ENDIF ELSE BEGIN

          PLOT, [minrange,maxrange], [minrange,maxrange], /NODATA, XTICKS=divisions, $
             YTICKS=1, XSTYLE=9, YSTYLE=1, TITLE="", CHARTHICK=textthick, $
             POSITION=position, COLOR=color, CHARSIZE=charsize, /NOERASE, $
             YTICKFORMAT='(A1)', XTICKFORMAT=format, XTICKLEN=ticklen, $
             XRANGE=[minrange, maxrange], FONT=font, XMinor=minor, _STRICT_EXTRA=extra, $
             XTICKNAME=ticknames, XLOG=xlog, XTITLE="", YTITLE="", $
             XTICKINTERVAL=tickInterval, XTICKLAYOUT=xticklayout, YTICKLAYOUT=yticklayout

          AXIS, XTICKS=divisions, XSTYLE=1, COLOR=color, CHARSIZE=charsize, $
             XTICKFORMAT='(A1)', XTICKLEN=0.001, XRANGE=[minrange, maxrange], XAXIS=1, $
             FONT=font, XTITLE="", XCHARSIZE=charsize, XMINOR=minor, $
             XTICKNAME="", XLOG=xlog, YTITLE="", XTICKINTERVAL=tickInterval, XTICKLAYOUT=xticklayout

          IF title NE "" THEN BEGIN
             xloc = (position[2] - position[0]) / 2.0 + position[0]
             CASE StrUpCase(tlocation) OF
                'TOP': BEGIN
                     truecharsize = Float(!D.Y_CH_SIZE * charsize) / !D.Y_SIZE
                     yloc = position[3] + (0.75 * truecharsize)
                     END
                'BOTTOM': BEGIN
                      truecharsize = Float(!D.Y_CH_SIZE * charsize) / !D.Y_SIZE
                      yloc = position[1] - (2.00 * truecharsize) - $
                           (Float(!D.Y_CH_SIZE * tcharsize) / !D.Y_SIZE)
                      END
                'RIGHT': Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
                'LEFT': Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
               ELSE: Message, 'Illegal specification for title position: ' + StrUpCase(tlocation)
             ENDCASE
             XYOUTS, xloc, yloc, title, /NORMAL, COLOR=color, CHARTHICK=textthick, $
                ALIGNMENT=0.5, FONT=font, CHARSIZE=tcharsize
          ENDIF

        ENDELSE

    ENDELSE

    <span class="comments">; If you have OOB colors, draw them now.</span>
    IF (N_Elements(oob_high) NE 0) || (N_Elements(oob_low) NE 0) THEN BEGIN
         p = position
         IF Keyword_Set(vertical) THEN BEGIN
            IF (N_Elements(oob_high) NE 0) THEN BEGIN
               phalf = (p[2]-p[0])/2.0 + p[0]
               pdist = (p[2]-p[0]) * oob_factor
               PolyFill, [p[0], phalf, p[2], p[0]], $
                         [p[3], pdist+p[3], p[3], p[3]], /Normal, Color=cgColor(oob_high)
               PlotS, [p[0], phalf, p[2], p[0]], $
                      [p[3], pdist+p[3], p[3], p[3]], /Normal, Color=color
            ENDIF
            IF (N_Elements(oob_low) NE 0) THEN BEGIN
               phalf = (p[2]-p[0])/2.0 + p[0]
               pdist = (p[2]-p[0]) * oob_factor
               PolyFill, [p[0], phalf, p[2], p[0]], $
                         [p[1], p[1]-pdist, p[1], p[1]], /Normal, Color=cgColor(oob_low)
               PlotS, [p[0], phalf, p[2], p[0]], $
                      [p[1], p[1]-pdist, p[1], p[1]], /Normal, Color=color            
            END
         ENDIF ELSE BEGIN
            IF (N_Elements(oob_high) NE 0) THEN BEGIN
               phalf = (p[3]-p[1])/2.0 + p[1]
               pdist = (p[3]-p[1]) * oob_factor
               PolyFill, [p[2], p[2]+pdist, p[2], p[2]], $
                         [p[1], phalf, p[3], p[1]], /Normal, Color=cgColor(oob_high)
               PlotS, [p[2], p[2]+pdist, p[2], p[2]], $
                      [p[1], +phalf, p[3], p[1]], /Normal, Color=color            
            ENDIF
            IF (N_Elements(oob_low) NE 0) THEN BEGIN
               phalf = (p[3]-p[1])/2.0 + p[1]
               pdist = (p[3]-p[1]) * oob_factor
               PolyFill, [p[0], p[0]-pdist, p[0], p[0]], $
                         [p[1], phalf, p[3], p[1]], /Normal, Color=cgColor(oob_low)
               PlotS, [p[0], p[0]-pdist, p[0], p[0]], $
                      [p[1], +phalf, p[3], p[1]], /Normal, Color=color            
            END
         ENDELSE
    ENDIF

    <span class="comments">; Restore the color state.</span>
    SetDecomposedState, currentState

    <span class="comments">; Restore the previous plot and map system variables.</span>
    !P = bang_p
    !X = bang_x
    !Y = bang_y
    !Z = bang_z
    !Map = bang_map
    
    <span class="comments">; Set the current colors back.</span>
    IF !D.Name NE 'Z' THEN TVLCT, r, g, b
END
</code>
    </div>
  </body>
</html>