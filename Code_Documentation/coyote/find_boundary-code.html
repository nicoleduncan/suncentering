<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:42 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>find_boundary.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="find_boundary.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FIND_BOUNDARY</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;       This program finds the boundary points about a region of interest (ROI)</span>
<span class="comments">;       represented by pixel indices. It uses a "chain-code" algorithm for finding</span>
<span class="comments">;       the boundary pixels.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;</span>
<span class="comments">;       Graphics, math.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       boundaryPts = Find_Boundary(indices, XSize=xsize, YSize=ysize)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       indices - A 1D vector of pixel indices that describe the ROI. For example,</span>
<span class="comments">;            the indices may be returned as a result of the WHERE function.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       boundaryPts - A 2-by-n points array of the X and Y points that describe the</span>
<span class="comments">;            boundary. The points are scaled if the SCALE keyword is used.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       SCALE - A one-element or two-element array of the pixel scale factors, [xscale, yscale],</span>
<span class="comments">;            used to calculate the perimeter length or area of the ROI. The SCALE keyword is</span>
<span class="comments">;            NOT applied to the boundary points. By default, SCALE=[1,1].</span>
<span class="comments">;</span>
<span class="comments">;       XSIZE - The X size of the window or array from which the ROI indices are taken.</span>
<span class="comments">;            Set to !D.X_Size by default.</span>
<span class="comments">;</span>
<span class="comments">;       YSIZE - The Y size of the window or array from which the ROI indices are taken.</span>
<span class="comments">;            Set to !D.Y_Size by default.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       AREA - A named variable that contains the pixel area represented by the input pixel indices,</span>
<span class="comments">;            scaled by the SCALE factors.</span>
<span class="comments">;</span>
<span class="comments">;       CENTER - A named variable that contains a two-element array containing the center point or</span>
<span class="comments">;            centroid of the ROI. The centroid is the position in the ROI that the ROI would</span>
<span class="comments">;            balance on if all the index pixels were equally weighted. The output is a two-element</span>
<span class="comments">;            floating-point array in device coordinate system, unless the SCALE keyword is used,</span>
<span class="comments">;            in which case the values will be in the scaled coordinate system.</span>
<span class="comments">;</span>
<span class="comments">;       PERIM_AREA - A named variable that contains the (scaled) area represented by the perimeter</span>
<span class="comments">;            points, as indicated by John Russ in _The Image Processing Handbook, 2nd Edition_ on</span>
<span class="comments">;            page 490. This is the same "perimeter" that is returned by IDLanROI in its</span>
<span class="comments">;            ComputeGeometry method, for example. In general, the perimeter area will be</span>
<span class="comments">;            smaller than the pixel area.</span>
<span class="comments">;</span>
<span class="comments">;       PERIMETER - A named variable that will contain the perimeter length of the boundary</span>
<span class="comments">;            upon returning from the function, scaled by the SCALE factors.</span>
<span class="comments">;</span>
<span class="comments">;  EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       LoadCT, 0, /Silent</span>
<span class="comments">;       image = BytArr(400, 300)+125</span>
<span class="comments">;       image[125:175, 180:245] = 255B</span>
<span class="comments">;       indices = Where(image EQ 255)</span>
<span class="comments">;       Window, XSize=400, YSize=300</span>
<span class="comments">;       TV, image</span>
<span class="comments">;       PLOTS, Find_Boundary(indices, XSize=400, YSize=300, Perimeter=length), $</span>
<span class="comments">;           /Device, Color=cgColor('red')</span>
<span class="comments">;       Print, length</span>
<span class="comments">;           230.0</span>
<span class="comments">;</span>
<span class="comments">; DEPENDENCIES:</span>
<span class="comments">;</span>
<span class="comments">;       Requires ERROR_MESSAGE from the Coyote Library.</span>
<span class="comments">;</span>
<span class="comments">;           http://www.idlcoyote.com/programs/error_message.pro</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;       Written by David W. Fanning, April 2002. Based on an algorithm written by Guy</span>
<span class="comments">;       Blanchard and provided by Richard Adams.</span>
<span class="comments">;       Fixed a problem with distinction between solitary points and</span>
<span class="comments">;          isolated points (a single point connected on a diagonal to</span>
<span class="comments">;          the rest of the mask) in which the program can't get back to</span>
<span class="comments">;          the starting pixel. 2 Nov 2002. DWF</span>
<span class="comments">;       Added the ability to return the perimeter length with PERIMETER and</span>
<span class="comments">;           SCALE keywords. 2 Nov 2002. DWF.</span>
<span class="comments">;       Added AREA keyword to return area enclosed by boundary. 2 Nov 2002. DWF.</span>
<span class="comments">;       Fixed a problem with POLYFILLV under-reporting the area by removing</span>
<span class="comments">;           POLYFILLV and using a pixel counting method. 10 Dec 2002. DWF.</span>
<span class="comments">;       Added the PERIM_AREA and CENTER keywords. 15 December 2002. DWF.</span>
<span class="comments">;       Replaced the ERROR_MESSAGE routine with the latest version. 15 December 2002. DWF.</span>
<span class="comments">;       Fixed a problem in which XSIZE and YSIZE have to be specified as integers to work. 6 March 2006. DWF.</span>
<span class="comments">;       Fixed a small problem with very small ROIs that caused the program to crash. 1 October 2008. DWF.</span>
<span class="comments">;       Modified the algorithm that determines the number of boundary points for small ROIs. 28 Sept 2010. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
FUNCTION Find_Boundary_Outline, mask, darray, boundaryPts, ptIndex, $
   xsize, ysize, from_direction

On_Error, 2

FOR j=1,7 DO BEGIN

   to_direction = (from_direction + j) MOD 8
   newPt = boundaryPts[*,ptIndex-1] + darray[*,to_direction]

      <span class="comments">; If this is the edge, assume it is a background point.</span>

   IF (newpt[0] LT 0 OR newpt[0] GE xsize OR newpt[1] LT 0 OR $
       newpt[1] GE ysize) THEN CONTINUE
   IF mask[newPt[0], newPt[1]] NE 0 THEN BEGIN
      boundaryPts[*,ptIndex] = newPt

     <span class="comments">; Return the "from" direction.</span>

      RETURN, (to_direction + 4) MOD 8
   ENDIF

ENDFOR

   <span class="comments">; If we get this far, this is either a solitary point or an isolated point.</span>

IF TOTAL(mask GT 0) GT 1 THEN BEGIN <span class="comments">; Isolated point.</span>
   newPt = boundaryPts[*,ptIndex-1] + darray[*,from_direction]
   boundaryPts[*,ptIndex] = newPt
   RETURN, (from_direction + 4) MOD 8
ENDIF ELSE BEGIN <span class="comments">; Solitary point.</span>
   boundaryPts[*,ptIndex] = boundaryPts[*,ptIndex-1]
   RETURN, -1
ENDELSE
END <span class="comments">; ------------------------------------------------------------------------------------------</span>



FUNCTION Find_Boundary, indices, $
   AREA=area, $
   CENTER=center, $
   PERIM_AREA=perim_area, $
   PERIMETER=perimeter, $
   SCALE=scale, $
   XSIZE=xsize, $
   YSIZE=ysize


Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, /Cancel
   ok = Error_Message()
   RETURN, -1
ENDIF


IF N_Elements(indices) EQ 0 THEN Message, 'Indices of boundary region are required. Returning...'
IF N_Elements(scale) EQ 0 THEN BEGIN
   diagonal = SQRT(2.0D)
ENDIF ELSE BEGIN
   scale = Double(scale)
   diagonal = SQRT(scale[0]^2 + scale[1]^2)
ENDELSE
IF N_Elements(xsize) EQ 0 THEN xsize = !D.X_Size ELSE xsize = Long(xsize)
IF N_Elements(ysize) EQ 0 THEN ysize = !D.Y_Size ELSE ysize = Long(ysize)
IF Arg_Present(perimeter) THEN perimeter = 0.0

   <span class="comments">; Create a mask with boundary region inside.</span>

indices = indices[Uniq(indices)]
mask = BytArr(xsize, ysize)
mask[indices] = 255B

   <span class="comments">; Set up a direction array.</span>

darray = [[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1]]

   <span class="comments">; Find a starting point. The pixel to the left of</span>
   <span class="comments">; this point is background</span>

i = Where(mask GT 0)
firstPt = [i[0] MOD xsize, i[0] / xsize]
from_direction = 4

   <span class="comments">; Set up output points array. For narrow ROIs, we need to construct</span>
   <span class="comments">; a different sort of algoritm for the number of boundary points.</span>
IF (xsize LT 4) OR (ysize LT 4) THEN BEGIN
    boundaryPts = LonArr(2, (2*Max([xsize,ysize]) + 2*Min([xsize,ysize])))
ENDIF ELSE BEGIN
    boundaryPts = LonArr(2, (Long(xsize) * ysize / 4L) + 1)
ENDELSE
boundaryPts[0] = firstPt
ptIndex = 0L

   <span class="comments">;   We shall not cease from exploration</span>
   <span class="comments">;   And the end of all our exploring</span>
   <span class="comments">;   Will be to arrive where we started</span>
   <span class="comments">;   And know the place for the first time</span>
   <span class="comments">;</span>
   <span class="comments">;                     T.S. Eliot</span>
REPEAT BEGIN
   ptIndex = ptIndex + 1L
   from_direction = Find_Boundary_Outline(mask, darray, $
      boundaryPts, ptIndex, xsize, ysize, from_direction)

   IF N_Elements(perimeter) NE 0 THEN BEGIN
      IF N_Elements(scale) EQ 0 THEN BEGIN
         CASE from_direction OF
            0: perimeter = perimeter + 1.0D
            1: perimeter = perimeter + diagonal
            2: perimeter = perimeter + 1.0D
            3: perimeter = perimeter + diagonal
            4: perimeter = perimeter + 1.0D
            5: perimeter = perimeter + diagonal
            6: perimeter = perimeter + 1.0D
            7: perimeter = perimeter + diagonal
            ELSE: perimeter = 4
         ENDCASE
       ENDIF ELSE BEGIN
         CASE from_direction OF
            0: perimeter = perimeter + scale[0]
            1: perimeter = perimeter + diagonal
            2: perimeter = perimeter + scale[1]
            3: perimeter = perimeter + diagonal
            4: perimeter = perimeter + scale[0]
            5: perimeter = perimeter + diagonal
            6: perimeter = perimeter + scale[1]
            7: perimeter = perimeter + diagonal
            ELSE: perimeter = (2*scale[0]) + (2*scale[1])
         ENDCASE
      ENDELSE
   ENDIF
ENDREP UNTIL (boundaryPts[0,ptIndex] EQ firstPt[0] AND $
            boundaryPts[1,ptIndex] EQ firstPt[1])

boundaryPts = boundaryPts[*,0:ptIndex-1]

   <span class="comments">; Calculate area.</span>

IF N_Elements(scale) EQ 0 THEN BEGIN

   area = N_Elements(i)

      <span class="comments">; Calculate area from the perimeter.</span>
      <span class="comments">; The first point must be the same as the last point. Method</span>
      <span class="comments">; of Russ, p.490, _Image Processing Handbook, 2nd Edition_.</span>

   bx = Double(Reform(boundaryPts[0,*]))
   by = Double(Reform(boundaryPts[1,*]))
   bx = [bx, bx[0]]
   by = [by, by[0]]
   n = N_Elements(bx)
   perim_area = Total( (bx[1:n-1] + bx[0:n-2]) * (by[1:n-1] - by[0:n-2]) ) / 2.


ENDIF ELSE BEGIN

   area = N_Elements(i) * scale[0] * scale[1]

      <span class="comments">; Calculate area from the perimeter.</span>
      <span class="comments">; The first point must be the same as the last point. Method</span>
      <span class="comments">; of Russ, p.490, _Image Processing Handbook, 2nd Edition_.</span>

   bx = Double(Reform(boundaryPts[0,*])) * scale[0]
   by = Double(Reform(boundaryPts[1,*])) * scale[1]
   bx = [bx, bx[0]]
   by = [by, by[0]]
   n = N_Elements(bx)
   perim_area = Total( (bx[1:n-1] + bx[0:n-2]) * (by[1:n-1] - by[0:n-2]) ) / 2.

   boundaryPts = Double(Temporary(boundaryPts))
   boundaryPts[0,*] = boundaryPts[0,*] * scale[0]
   boundaryPts[1,*] = boundaryPts[1,*] * scale[1]
ENDELSE

   <span class="comments">; Calculate the centroid</span>

mask = mask GT 0
totalMass = Total(mask)
xcm = Total( Total(mask, 2) * Indgen(xsize) ) / totalMass
ycm = Total( Total(mask, 1) * Indgen(ysize) ) / totalMass
center = [xcm, ycm]

RETURN, boundaryPts
END <span class="comments">; ------------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>