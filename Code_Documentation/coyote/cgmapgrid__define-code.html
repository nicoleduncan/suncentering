<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:21 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgmapgrid__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgmapgrid__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgMapGrid</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This object is a wrapper for the cgMap_Grid routine in IDL. It provides a simple </span>
<span class="comments">;   way to allow map grids on images which use a cgMAP object to set up the map </span>
<span class="comments">;   projection space. A map coordinate space must be in effect at the time the </span>
<span class="comments">;   Draw method of this object is used. </span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This object is a wrapper for the cgMap_Grid routine in IDL. It provides a simple </span>
<span class="comments">;   way to allow map grids on images which use a cgMAP object to set up the map </span>
<span class="comments">;   projection space. A map coordinate space must be in effect at the time the </span>
<span class="comments">;   Draw method of this object is used. </span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Map Projections</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;   FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;      David W. Fanning </span>
<span class="comments">;      1645 Sheely Drive</span>
<span class="comments">;      Fort Collins, CO 80526 USA</span>
<span class="comments">;      Phone: 970-221-0438</span>
<span class="comments">;      E-mail: david@idlcoyote.com</span>
<span class="comments">;      Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by David W. Fanning, 7 November 2011.</span>
<span class="comments">;        Modified AutoDrawGrid method to update, better-working method in cgMap_Grid. 28 Dec 2011. DWF.</span>
<span class="comments">;                </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;---------------------------------------------------------------------------</span>

<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   The initialization method for the object.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    mapCoord: in, required, type=object</span>
<span class="comments">;       A map coordinate object that will set up a map coordinate data space.</span>
<span class="comments">;       Required to convert lat/lon values to projected meter space. A cgMap object.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object is added to the resizeable graphics</span>
<span class="comments">;        window, cgWindow. The DRAW method of the object is called in cgWindow.</span>
<span class="comments">;     autodrawgrid: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the grid latitude and longitude values</span>
<span class="comments">;        are automatically calculated from the mapCoord object ranges and drawn</span>
<span class="comments">;        appropriately. Most keywords are ignored when auto drawing the grid.</span>
<span class="comments">;     bcolor: optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the color to draw box axes with.</span>
<span class="comments">;     box_axes: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw a box-style axes around the map.</span>
<span class="comments">;     charsize: in, optional, type=float, default=1.0</span>
<span class="comments">;        Set this keyword to the size of characters used for the labels.</span>
<span class="comments">;     clip_text: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to a zero value to turn off clipping of text labels. </span>
<span class="comments">;        By default, text labels are clipped. This keyword is ignored if the </span>
<span class="comments">;        BOX_AXES keyword is set. </span>
<span class="comments">;     color: in, optional, type=string, default="opposite"</span>
<span class="comments">;        The name of the color to draw the grid lines in. </span>
<span class="comments">;     fill_horizon: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to fill the current map horizon.</span>
<span class="comments">;     format: in, optional, type=string</span>
<span class="comments">;        Set this keyword to a string format for formatting the grid </span>
<span class="comments">;        labels (e.g., '(F0.2)')</span>
<span class="comments">;     fuzzy: in, optional, type=float, default=0.0</span>
<span class="comments">;        This keyword applies only if the MAP_STRUCTURE keyword is used. Set the</span>
<span class="comments">;        keyword to a value that is a percentage of the current data range.</span>
<span class="comments">;        This percentage of the range is added to or subtracted from the</span>
<span class="comments">;        values used to determine if the label is "inside" the boundary.</span>
<span class="comments">;        It allows you to be a little less exact when selecting inside </span>
<span class="comments">;        points. There are occasional aesthetic reasons for allowing fuzzy</span>
<span class="comments">;        boundaries. A reasonable value for fuzziness might be 0.0125.</span>
<span class="comments">;     horizon: in, optional, type=boolean, default=0 </span>
<span class="comments">;        Set this keyword to draw the current map horizon.</span>
<span class="comments">;     increment: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the spacing between the graticle points.</span>
<span class="comments">;     label: in, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to an integer, n, that labels every n parallels and meridians.</span>
<span class="comments">;        For example, LABEL=3 will label every 3rd line. Default is 1.</span>
<span class="comments">;     latalign: in, optional, type=float, default=0.5                </span>
<span class="comments">;        This keyword controls the alignment of the text baseline for latitude </span>
<span class="comments">;        labels. A value of 0.0 left justifies the label, 1.0 right justifies </span>
<span class="comments">;        it, and 0.5 centers it. This keyword is ignored if the BOX_AXES keyword is set.</span>
<span class="comments">;     latdel: in, optional, type=float                 </span>
<span class="comments">;        Set this keyword equal to the spacing (in degrees) between parallels of </span>
<span class="comments">;        latitude in the grid. If this keyword is not set, a default value of 5 is used.</span>
<span class="comments">;     latlab: in, optional, type=float                  </span>
<span class="comments">;        The longitude at which to place latitude labels. The default is the center </span>
<span class="comments">;        longitude on the map. This keyword is ignored if the BOX_AXES keyword is set.</span>
<span class="comments">;     latnames: in, optional, type=varies                  </span>
<span class="comments">;        Set this keyword equal to an array specifying the names to be used for the </span>
<span class="comments">;        latitude labels. By default, this array is automatically generated in units </span>
<span class="comments">;        of degrees. The LATNAMES array can be either type string or any single numeric </span>
<span class="comments">;        type, but should not be of mixed type.When LATNAMES is specified, the LATS </span>
<span class="comments">;        keyword must also be specified.</span>
<span class="comments">;     lats: in, optional, type=float </span>
<span class="comments">;        Set this keyword equal to a one or more element vector of latitudes for which </span>
<span class="comments">;        lines will be drawn (and optionally labeled). If LATS is omitted, appropriate </span>
<span class="comments">;        latitudes will be generated based on the value of the (optional) LATDEL keyword. </span>
<span class="comments">;        If LATS is set to a single value, that latitude and a series of automatically </span>
<span class="comments">;        generated latitudes will be drawn (and optionally labeled).</span>
<span class="comments">;     lcolor: in, optional, type=string</span>
<span class="comments">;        Set this to the name of the label color to use in labeling grid lines.</span>
<span class="comments">;        By default, the same as COLOR, or if BOX_AXIS is set, then same as BCOLOR.</span>
<span class="comments">;     linestyle: in, optional, type=integer, default=1 </span>
<span class="comments">;        Set this keyword to the type of linestyle desired. See Graphics Keywords in</span>
<span class="comments">;        the on-line help for additional information.</span>
<span class="comments">;     lonalign: in, optional, type=float, default=0.5</span>
<span class="comments">;        This keyword controls the alignment of the text baseline for longitude </span>
<span class="comments">;        labels. A value of 0.0 left justifies the label, 1.0 right justifies </span>
<span class="comments">;        it, and 0.5 centers it. This keyword is ignored if the BOX_AXES keyword is set.</span>
<span class="comments">;     londel: in, optional, type=integer, default=10              </span>
<span class="comments">;        Set this keyword equal to the spacing (in degrees) between parallels of </span>
<span class="comments">;        longitude in the grid. If this keyword is not set, a default value of 10 is used.</span>
<span class="comments">;     lonlab: in, optional, type=float                  </span>
<span class="comments">;       The latitude at which to place longitude labels. The default is the center </span>
<span class="comments">;       latitude on the map. This keyword is ignored if the BOX_AXES keyword is set.</span>
<span class="comments">;     lonnames: in, optional, type=varies                  </span>
<span class="comments">;        Set this keyword equal to an array specifying the names to be used for the </span>
<span class="comments">;        longitude labels. By default, this array is automatically generated in units </span>
<span class="comments">;        of degrees. The LONNAMES array can be either type string or any single numeric </span>
<span class="comments">;        type, but should not be of mixed type.When LONNAMES is specified, the LONS </span>
<span class="comments">;        keyword must also be specified.</span>
<span class="comments">;     lons: in, optional, type=float                  </span>
<span class="comments">;        Set this keyword equal to a one or more element vector of longitudes for which </span>
<span class="comments">;        lines will be drawn (and optionally labeled). If LONS is omitted, appropriate </span>
<span class="comments">;        longitudes will be generated based on the value of the (optional) LONDEL keyword. </span>
<span class="comments">;        If LONS is set to a single value, that longitudes and a series of automatically </span>
<span class="comments">;        generated longitudes will be drawn (and optionally labeled).</span>
<span class="comments">;     thick: in, optional, type=integer, default=1</span>
<span class="comments">;        Set this keyword to the thickness of the line used to draw the grid.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
FUNCTION cgMapGrid::INIT, mapCoord, $
    ADDCMD=addcmd, $
    AUTODRAWGRID=autodrawgrid, $
    BCOLOR=bcolor, $
    BOX_AXES=box_axes, $
    CLIP_TEXT=clip_text, $
    CHARSIZE=charsize, $
    COLOR=color, $
    FILL_HORIZON=fill_horizon, $
    FORMAT=format, $
    FUZZY=fuzzy, $
    LINESTYLE=linestyle, $
    HORIZON=horizon, $
    INCREMENT=increment, $
    LABEL=label, $
    LATALIGN=latalign, $
    LATDEL=latdel, $
    LATLAB=latlab, $
    LATNAMES=latnames, $
    LATS=lats, $
    LCOLOR=lcolor, $
    LONALIGN=lonalign, $
    LONDEL=londel, $
    LONLAB=lonlab, $
    LONNAMES=lonnames, $
    LONS=lons, $
    THICK=thick, $
    _EXTRA=extra
    
    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN, 0
    ENDIF
    
    <span class="comments">; Initialize superclass object,</span>
     ok = self -> cgContainer::INIT(_EXTRA=extra) 
     IF ~ok THEN RETURN, 0

    <span class="comments">; Default values.</span>
    self._cg_autodrawgrid = Keyword_Set(autodrawgrid)
    self._cg_box_axes = Keyword_Set(box_axes)
    IF N_Elements(format) NE 0 THEN self._cg_format = format
    self._cg_fill_horizon = Keyword_Set(fill_horizon)
    self._cg_horizon = Keyword_Set(horizon)
    SetDefaultValue, clip_text, 1
    IF N_Elements(charsize) EQ 0 THEN $
        <span class="comments">;charsize = (StrUpCase(!Version.OS_Family) EQ 'WINDOWS') ? 0.75 : 1.0</span>
        charsize = cgDefCharsize() * 0.75
    SetDefaultValue, bcolor, 'opposite'
    SetDefaultValue, color, 'opposite'
    IF N_Elements(lcolor) EQ 0 THEN lcolor = Keyword_Set(box_axes) ? bcolor : color
    SetDefaultValue, fuzzy, 0.0
    SetDefaultValue, label, 1
    SetDefaultValue, linestyle, 1
    SetDefaultValue, latalign, 0.5
    SetDefaultValue, latdel, 5.0
    SetDefaultValue, lonalign, 0.5
    SetDefaultValue, londel, 10.0
    SetDefaultValue, thick, 1.0
    self._cg_bcolor = bcolor
    self._cg_clip_text = clip_text
    self._cg_charsize = charsize
    self._cg_color = color
    self._cg_label = label
    self._cg_latalign = latalign
    self._cg_lcolor = lcolor
    self._cg_lonalign = lonalign
    self._cg_linestyle = linestyle
    self._cg_thick = thick
    
    <span class="comments">; Initialize all program pointers.</span>
    IF N_Elements(increment) EQ 0 $
        THEN self._cg_increment = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_increment = Ptr_New(increment)
    IF N_Elements(latdel) EQ 0 $
        THEN self._cg_latdel = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_latdel = Ptr_New(latdel)
    IF N_Elements(londel) EQ 0 $
        THEN self._cg_londel = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_londel = Ptr_New(londel)
    IF N_Elements(latlab) EQ 0 $
        THEN self._cg_latlab = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_latlab = Ptr_New(latlab)
    IF N_Elements(lonlab) EQ 0 $
        THEN self._cg_lonlab = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_lonlab = Ptr_New(lonlab)
    IF N_Elements(latnames) EQ 0 $
        THEN self._cg_latnames = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_latnames = Ptr_New(latnames)
    IF N_Elements(lonnames) EQ 0 $
        THEN self._cg_lonnames = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_lonnames = Ptr_New(lonnames)
    IF N_Elements(lats) EQ 0 $
        THEN self._cg_lats = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_lats = Ptr_New(lats)
    IF N_Elements(lons) EQ 0 $
        THEN self._cg_lons = Ptr_New(/ALLOCATE_HEAP) $
        ELSE self._cg_lons = Ptr_New(lons)
    
    <span class="comments">; Make sure you have a valid mapCoord object.</span>
    IF Obj_Valid(mapCoord) $
       THEN self._cg_map_object = mapCoord $
       ELSE Message, 'A valid map object is required to create a cgMapGrid object.'
       
   <span class="comments">; Need to add this command to a resizeable cgWindow?</span>
   IF Keyword_Set(addcmd) THEN self -> AddCmd
   
    RETURN, 1
    
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Adds the object as a command (the DRAW method is called) in a cgWindow </span>
<span class="comments">;   resizeable graphics window. </span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::AddCmd

   cgWindow, "Draw", self, /Method, /AddCmd 
   
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Calculates suitable latitude and longitude lines that run through the</span>
<span class="comments">;   map range and suggests a default position for labeling such lines.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     success: out, optional, type=boolean</span>
<span class="comments">;        Will be set to 1 on return, if the operation was successful. Otherwise,</span>
<span class="comments">;        this value is set to 0.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::AutoDrawGrid, SUCCESS=success

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        seccess = 0
        RETURN
    ENDIF
    
    <span class="comments">; Assume success.</span>
    success = 1
    
    <span class="comments">; The longitudes might be calculated from the results of the latitude calculation.</span>
    <span class="comments">; If they are, this flag will be set to 1.</span>
    lonsdone = 0
    latsdone = 0
    
    <span class="comments">; Get the ranges of the map coordinate object.</span>
    IF ~Obj_Valid(self._cg_map_object) THEN Message, 'A valid map object is required.'
    self._cg_map_object -> GetProperty, XRANGE=xrange, YRANGE=yrange

    <span class="comments">; Sample XY grid at 625 locations throughout the grid (25x25).</span>
    xstep = (xrange[1] - xrange[0]) / 24.0
    ystep = (yrange[1] - yrange[0]) / 24.0
    xvec = (Findgen(25) * xstep) + xrange[0]
    yvec = (Findgen(25) * ystep) + yrange[0]
    xarr = Rebin(xvec, 25, 25)
    yarr = Rebin(Reform(Reverse(yvec), 1, 25), 25, 25)
    
    <span class="comments">; Find the latitude/longitude of these locations. Find the min, max,</span>
    <span class="comments">; and lat/lon at the center of the grid.</span>
    ll = Map_Proj_Inverse(xarr, yarr, MAP_STRUCTURE=self._cg_map_object->GetMapStruct())
    latlon = Reform(ll, 2, 25, 25)
    latlon = Transpose(latlon, [1,2,0])
    latitudes = latlon[*,*,1]
    longitudes = latlon[*,*,0]

    <span class="comments">; Convert the longitudes to 0 to 360. Otherwise, I have</span>
    <span class="comments">; problems near the date line.</span>
<span class="comments">;    longitudes = (longitudes + 360.0) MOD 360.0</span>
    
    lon_min = Min(longitudes, MAX=lon_max, /NAN)
    lat_min = Min(latitudes, MAX=lat_max, /NAN)
    center_lat = latitudes[12,12]
    center_lon = longitudes[12,12]
    
    <span class="comments">; We are going to try to have seven lines running through the grid space.</span>
    <span class="comments">; We will have special rules if the center latitude is at the pole.</span>
    latrange = Abs(lat_max - lat_min)
    IF latrange GT 90.0 THEN BEGIN
        lats = -90.0 > (Findgen(13) * 15 - 90.0) &lt<span class="comments">; 90.0</span>
        latsdone = 1
    ENDIF
    latstep =  latrange / 6.0
    
    lonrange = Abs(lon_max - lon_min)
    IF lonrange GT 180.0 THEN BEGIN
        lons = -180.0 > (Findgen(13) * 30 - 180.0) &lt<span class="comments">; 180.0</span>
        lonsdone = 1
    ENDIF
    lonstep =  (lonrange)/ 6.0
    
    <span class="comments">; Make sure we don't have a center latitude at either pole. If we</span>
    <span class="comments">; do, then lons are calulated differently.</span>
    IF (center_lat GT (90.-0.05)) && (center_lat LT (90.0 + 0.05)) THEN BEGIN
       lats = cgScaleVector(Findgen(5), 0 > lat_min &lt<span class="comments">; 80) </span>
       latsdone = 1 
       IF lonstep GT 40 THEN BEGIN
          lons = Findgen(11) * 36
          lonsDone = 1
       ENDIF      
    ENDIF ELSE BEGIN
       IF (center_lat LT (-90.+0.05)) && (center_lat GT (-90.0 - 0.05)) THEN BEGIN
           lats = cgScaleVector(Findgen(5), -80, 0 &lt<span class="comments">; lat_max)  </span>
           latsdone = 1    
           IF lonstep GT 40 THEN BEGIN
              lons = Findgen(11) * 36
              lonsDone = 1
           ENDIF 
       ENDIF    
    ENDELSE
    
    
    IF latsdone EQ 0 THEN BEGIN
       CASE 1 OF
       
           (latstep GE 30): BEGIN
                latstep = 30
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 10) && (latstep LT 60): BEGIN
                latstep = Ceil(latstep/10.) * 10.0
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 1) && (latstep LT 10): BEGIN
                latstep = Ceil(latstep)
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 0.1) && (latstep LT 1): BEGIN
                latstep = Ceil(latstep*10.0)/ 10.
                center_lat = Round(center_lat*10.0) / 10.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep GT 0.01) && (latstep LT 0.1): BEGIN
                latstep = Ceil(latstep*100.0)/ 100.
                center_lat = Round(center_lat*100.0) / 100.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           (latstep LT 0.01) : BEGIN
                latstep = Ceil(latstep*1000.0)/ 1000.
                center_lat = Round(center_lat*1000.0) / 1000.0
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
           ELSE: BEGIN
                latstep = 30
                center_lat = Round(center_lat)
                lats = -90.0 > [(Indgen(4)+1)*(-latstep) + center_lat, center_lat,  $
                             (Indgen(4)+1)*( latstep) + center_lat] &lt<span class="comments">; 90.0</span>
                END
       ENDCASE
    ENDIF
    
    IF lonsDone EQ 0 THEN BEGIN
       CASE 1 OF
       
           (lonstep GE 60): BEGIN
                lonstep = 60
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(3)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(3)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 10) && (lonstep LT 60): BEGIN
                lonstep = Ceil(lonstep/10.) * 10.0
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 1) && (lonstep LT 10): BEGIN
                lonstep = Ceil(lonstep)
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 0.1) && (lonstep LT 1): BEGIN
                lonstep = Ceil(lonstep*10.0)/ 10.
                center_lon = Round(center_lon*10.0) / 10.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep GT 0.01) && (lonstep LT 0.1): BEGIN
                lonstep = Ceil(lonstep*100.0)/ 100.
                center_lon = Round(center_lon*100.0) / 100.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           (lonstep LT 0.01) : BEGIN
                lonstep = Ceil(lonstep*1000.0)/ 1000.
                center_lon = Round(center_lon*1000.0) / 1000.0
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
           ELSE: BEGIN
                lonstep = 30
                center_lon = Round(center_lon)
                lons = -180.0 > [(Indgen(4)+1)*(-lonstep) + center_lon, center_lon,  $
                             (Indgen(4)+1)*( lonstep) + center_lon] &lt<span class="comments">; 360.0</span>
                END
       ENDCASE
     ENDIF
        
    <span class="comments">; The values might need to be sorted.</span>
    lats = lats[Sort(lats)]
    lons = lons[Sort(lons)]
    
    <span class="comments">; Labels should be near the center.</span>
    index = Value_Locate(lons, center_lon)
    latlab = (lons[index] - lons[index-1]) / 2.0 + lons[index-1]
    index = Value_Locate(lats, center_lat)
    lonlab = (lats[index] - lats[index-1]) / 2.0 + lats[index-1]
    
    <span class="comments">; Set up the latitude and longitude names.</span>
    IF Total(lats-Long(lats)) EQ 0 THEN format='(I0)' ELSE format='(F0.2)'
    latnames = String(lats, FORMAT=format)
    IF Total(lons-Long(lons)) EQ 0 THEN format='(I0)' ELSE format='(F0.2)'
    lonnames = String(lons, FORMAT=format)

    <span class="comments">; Set the properties of the object.</span>
    self -> SetProperty, LATLAB=latlab, LATS=lats, LATNAMES=latnames, $
                         LONLAB=lonlab, LONS=lons, LONNAMES=lonnames
                             
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   Draws the map grid by calling cgMap_Grid.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::Draw

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
        
    <span class="comments">; This can cause all kinds of error messages from MAP_PROJ_FORWARD. Turn them all off.</span>
    except = !Except
    !Except = 0
    
    <span class="comments">; If you are auto drawing grids, set up the lats and lons.</span>
    IF self._cg_autodrawgrid THEN BEGIN
        self -> AutoDrawGrid, SUCCESS=success
        void = Check_Math()
        !Except = except
        IF ~success THEN RETURN
    ENDIF
    
    <span class="comments">; Draw the map grid.</span>
    cgMap_Grid, $
       BCOLOR=self._cg_bcolor, BOX_AXES=self._cg_box_axes, $
       CLIP_TEXT=1, $
       CHARSIZE=self._cg_charsize, $
       COLOR=self._cg_color, $
       FILL_HORIZON=self._cg_fill_horizon, $
       FORMAT=self._cg_format, $
       FUZZY=self._cg_fuzzy, $
       HORIZON=self._cg_horizon, $
       INCREMENT=*self._cg_increment, $
       LABEL=self._cg_label, $
       LATALIGN=self._cg_latalign, $
       LATDEL=*self._cg_latdel, $
       LATLAB=*self._cg_latlab, $
       LATNAMES=*self._cg_latnames, $
       LATS=*self._cg_lats, $
       LCOLOR=self._cg_lcolor, $
       LINESTYLE=self._cg_linestyle, $
       LONALIGN=self._cg_lonalign, $
       LONDEL=*self._cg_londel, $
       LONLAB=*self._cg_lonlab, $
       LONNAMES=*self._cg_lonnames, $
       LONS=*self._cg_lons, $
       MAP_STRUCTURE=self._cg_map_object, $ <span class="comments">; The map object itself.</span>
       THICK=self._cg_thick

    <span class="comments">; Turn messages back on.</span>
    void = Check_Math()
    !Except = except
    
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method allows the user to get various properties of the object. In general,</span>
<span class="comments">;   the same keywords that are used for the INIT method can be used here.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::GetProperty, $
    AUTODRAWGRID=autodrawgrid, $
    BOX_AXES=box_axes, $
    CLIP_TEXT=clip_text, $
    CHARSIZE=charsize, $
    COLOR=color, $
    FILL_HORIZON=fill_horizon, $
    FIXED_cgMapGrid=fixed_map_grid, $
    FORMAT=format, $
    LCOLOR=lcolor, $
    LINESTYLE=linestyle, $
    THICK=thick, $
    HORIZON=horizon, $
    INCREMENT=increment, $
    LABEL=label, $
    LATALIGN=latalign, $
    LATDEL=latdel, $
    LATLAB=latlab, $
    LATNAMES=latnames, $
    LATS=lats, $
    LONALIGN=lonalign, $
    LONDEL=londel, $
    LONLAB=lonlab, $
    LONNAMES=lonnames, $
    LONS=lons, $
    MAP_OBJECT=map_object, $
    MAP_STRUCTURE=map_structure, $
    _REF_EXTRA=extra

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
    
    autodrawgrid = self._cg_autodrawgrid
    box_axes = self._cg_box_axes
    clip_text = self._cg_clip_text
    charsize = self._cg_charsize
    color = self._cg_color
    fill_horizon = self._cg_fill_horizon
    format = self._cg_format
    latalign = self._cg_latalign
    lcolor = self._cg_lcolor
    lonalign = self._cg_lonalign
    linestyle = self._cg_linestyle
    thick = self._cg_thick
    horizon = self._cg_horizon
    increment = self._cg_increment
    IF Ptr_Valid(self._cg_label) THEN label = self._cg_label
    IF N_Elements(*self._cg_latdel) NE 0 THEN latdel = *self._cg_latdel
    IF N_Elements(*self._cg_latlab) NE 0 THEN latlab = *self._cg_latlab
    IF N_Elements(*self._cg_latnames) NE 0 THEN latnames = *self._cg_latnames
    IF N_Elements(*self._cg_lats) NE 0 THEN lats = *self._cg_lats
    IF N_Elements(*self._cg_londel) NE 0 THEN londel = *self._cg_londel
    IF N_Elements(*self._cg_lonlab) NE 0 THEN lonlab = *self._cg_lonlab
    IF N_Elements(*self._cg_lonnames) NE 0 THEN lonnames = *self._cg_lonnames
    IF N_Elements(*self._cg_lons) NE 0 THEN lons = *self._cg_lons
    map_object = self._cg_map_object
    IF Arg_Present(map_structure) THEN map_structure = self._cg_map_object -> GetMapStruct()
    
    IF N_Elements(extra) NE 0 THEN self -> cgContainer::GetProperty, _EXTRA=extra
    
END 

    
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This method allows the user to set various properties of the object. In general,</span>
<span class="comments">;   the same keywords that are used for the INIT method can be used here.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::SetProperty, $
    AUTODRAWGRID=autodrawgrid, $
    BOX_AXES=box_axes, $
    CLIP_TEXT=clip_text, $
    CHARSIZE=charsize, $
    COLOR=color, $
    DRAW=draw, $
    FILL_HORIZON=fill_horizon, $
    FIXED_cgMapGrid=fixed_map_grid, $
    FORMAT=format, $
    LINESTYLE=linestyle, $
    HORIZON=horizon, $
    INCREMENT=increment, $
    LABEL=label, $
    LATALIGN=latalign, $
    LATDEL=latdel, $
    LATLAB=latlab, $
    LATNAMES=latnames, $
    LATS=lats, $
    LCOLOR=lcolor, $
    LONALIGN=lonalign, $
    LONDEL=londel, $
    LONLAB=lonlab, $
    LONNAMES=lonnames, $
    LONS=lons, $
    THICK=thick, $
    _EXTRA=extra

    <span class="comments">; Error handling</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN
    ENDIF
    
    IF N_Elements(autodrawgrid) NE 0 THEN self._cg_autodrawgrid = Keyword_Set(autodrawgrid)
    IF N_Elements(box_axes) NE 0 THEN self._cg_box_axes = Keyword_Set(box_axes)
    IF N_Elements(clip_text) NE 0 THEN self._cg_clip_text = clip_text
    IF N_Elements(charsize) NE 0 THEN self._cg_charsize = charsize
    IF N_Elements(color) NE 0 THEN self._cg_color = color
    IF N_Elements(fill_horizon) NE 0 THEN self._cg_fill_horizon = Keyword_Set(fill_horizon)
    IF N_Elements(format) NE 0 THEN self._cg_format = format
    IF N_Elements(linestyle) NE 0 THEN self._cg_linestyle = linestyle
    IF N_Elements(horizon) NE 0 THEN self._cg_horizon = Keyword_Set(horizon)
    IF N_Elements(increment) NE 0 THEN *self._cg_increment = increment
    IF N_Elements(label) NE 0 THEN self._cg_label = label
    IF N_Elements(latalign) NE 0 THEN self._cg_latalign = latalign
    IF N_Elements(latdel) NE 0 THEN *self._cg_latdel = latdel
    IF N_Elements(latlab) NE 0 THEN *self._cg_latlab = latlab
    IF N_Elements(latnames) NE 0 THEN *self._cg_latnames = latnames
    IF N_Elements(lats) NE 0 THEN *self._cg_lats = lats
    IF N_Elements(lcolor) NE 0 THEN self._cg_lcolor = lcolor
    IF N_Elements(lonalign) NE 0 THEN self._cg_lonalign = lonalign
    IF N_Elements(londel) NE 0 THEN *self._cg_londel = londel
    IF N_Elements(lonlab) NE 0 THEN *self._cg_lonlab = lonlab
    IF N_Elements(lonnames) NE 0 THEN *self._cg_lonnames = lonnames
    IF N_Elements(lons) NE 0 THEN *self._cg_lons = lons
    IF N_Elements(thick) NE 0 THEN self._cg_thick = thick

    IF N_Elements(extra) NE 0 THEN self -> cgContainer::SetProperty, _EXTRA=extra
    
    <span class="comments">; Need a draw?</span>
    IF Keyword_Set(draw) THEN self -> Draw

END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the clean-up routine for the object.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid::CLEANUP

    <span class="comments">; Destroy object pointers.</span>
    Ptr_Free, self._cg_increment
    Ptr_Free, self._cg_latdel
    Ptr_Free, self._cg_latlab
    Ptr_Free, self._cg_latnames
    Ptr_Free, self._cg_lats
    Ptr_Free, self._cg_londel
    Ptr_Free, self._cg_lonlab
    Ptr_Free, self._cg_lonnames
    Ptr_Free, self._cg_lons
    
    <span class="comments">; Call the superclass cleanup or memory leaks will occur.</span>
    self -> cgContainer::CLEANUP
END 


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This is the class definition module. Structures used to manipulate</span>
<span class="comments">;   map projection and map datum information are also created here.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    class: out, optional, type=structure</span>
<span class="comments">;       Occasionally, it is useful to have an object class definition as</span>
<span class="comments">;       a structure variable. Using this output keyword will allow that.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMapGrid__DEFINE, class

    class = { cgMapGrid, $
              _cg_autodrawgrid: 0B, $
              _cg_bcolor: "", $
              _cg_box_axes: 0B, $              
              _cg_clip_text: 0B, $
              _cg_charsize: 0.0, $
              _cg_color: "", $
              _cg_fill_horizon: 0B, $
              _cg_format: "", $
              _cg_fuzzy: 0.0, $
              _cg_linestyle: 0, $
              _cg_thick: 0, $
              _cg_horizon: 0B, $
              _cg_increment: Ptr_New(), $
              _cg_label: 0, $
              _cg_latalign: 0.0, $
              _cg_latdel: Ptr_New(), $
              _cg_latlab: Ptr_New(), $
              _cg_latnames: Ptr_New(), $
              _cg_lats: Ptr_New(), $
              _cg_lcolor: "", $
              _cg_lonalign: 0.0, $
              _cg_londel: Ptr_New(), $
              _cg_lonlab: Ptr_New(), $
              _cg_lonnames: Ptr_New(), $
              _cg_lons: Ptr_New(), $
              _cg_map_object: Obj_New(), $
              INHERITS cgContainer $
            }

END 
</code>
    </div>
  </body>
</html>