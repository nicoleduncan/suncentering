<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:30 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgstretch.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgstretch.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgStretch</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The program implements an interactive way to stretch an image histogram and provide</span>
<span class="comments">;   contrast for 2D image arrays.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2012, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The program implements an interactive way to stretch an image histogram and provide</span>
<span class="comments">; contrast for 2D image arrays. This is commonly known as "contrast stretching."</span>
<span class="comments">; The program supports the following stretches::</span>
<span class="comments">;       LINEAR         Linear stretch between end points.</span>
<span class="comments">;       CLIP           Linear, except a 2% of pixels are clipped at either end of histogram.</span>
<span class="comments">;       GAMMA          An exponential function.</span>
<span class="comments">;       LOG            An S-shaped log function.</span>
<span class="comments">;       ASINH          An inverse hyperbolic sine function (strong log function).</span>
<span class="comments">;       SQUARE ROOT    The square-root of the image pixels is stretched linearly.</span>
<span class="comments">;       EQUALIZATION   Image histogram is equalized before stretching.</span>
<span class="comments">;       ADAPTIVE EQUALIZATION Image histogram is equalized with Adapt_Hist_Equal before stretching.</span>
<span class="comments">;       GAUSSIAN       A gaussian normal distribution function is applied to the stretch.</span>
<span class="comments">;       STDDEV         The image is stretched by multiples of its standard deviation from its mean value.</span>
<span class="comments">;</span>
<span class="comments">; .. image:: cgstretch.png</span>
<span class="comments">; </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Image Processing, Widgets</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;   If you have a 2D image in the variable "image", you can run this program like this::</span>
<span class="comments">;</span>
<span class="comments">;       IDL> image = cgDemoData(7)</span>
<span class="comments">;       IDL> cgStretch, image</span>
<span class="comments">;       IDL> cgStretch, image, TYPE='GAMMA'</span>
<span class="comments">;       IDL> cgStretch, image, TYPE='LOG', EXPONENT=5.5</span>
<span class="comments">;       IDL> cgStretch, image, TYPE='ASINH', BETA=0.1</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: davidf@dfanning.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.dfanning.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by David W. Fanning, April 1996, as XStretch.</span>
<span class="comments">;        XStretch retired and the program was renamed cgStretch, 21 October 2012.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 1996-2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This procedure validates a threshold value to make sure it doesn't</span>
<span class="comments">; get out of range.</span>
<span class="comments">; </span>
<span class="comments">; : Returns:</span>
<span class="comments">;     A validated threshold value in the appropriate range.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;     threshold: in, required</span>
<span class="comments">;        The input threshold to check and validate.</span>
<span class="comments">;     info: in, required</span>
<span class="comments">;        The program's information structure.</span>
<span class="comments">;-</span>
FUNCTION cgSTRETCH_VALIDATE_THRESHOLD, threshold, info

   <span class="comments">; Catch any errors.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, Cancel=1
      void = Error_Message(/Traceback)
      RETURN, threshold
   ENDIF

   <span class="comments">; Make sure threshold is inside of the plot.</span>
   threshold = info.xmin > threshold &lt<span class="comments">; info.xmax</span>

   <span class="comments">; Make sure threshold doesn't exceed range of data type.</span>
   CASE info.dataType OF
        'BYTE': threshold = 0B > threshold &lt<span class="comments">; 255B</span>
        'INT': threshold = (-2L^15+1) > threshold &lt<span class="comments">; (2L^15-1)</span>
        'UINT': threshold = 0 > threshold &lt<span class="comments">; (2L^16-1)</span>
        'LONG': threshold = (-2L^31+1) > threshold &lt<span class="comments">; (2L^31-1)</span>
        'ULONG': threshold = 0 > threshold &lt<span class="comments">; (2L^32-1)</span>
        'LONG64': threshold = (-2LL^64+1) > threshold &lt<span class="comments">; (2LL^64-1)</span>
        'ULONG64': threshold = 0 > threshold &lt<span class="comments">; (2LL^64-1)</span>
        ELSE:
   ENDCASE

   <span class="comments">; Make sure threshold has the same type as the image, unless SQUARE ROOT stretch.</span>
   IF info.type NE 'SQUARE ROOT' THEN $
      threshold = Convert_to_Type(threshold, Size(*info.image, /Type))
   IF Size(threshold, /TNAME) EQ 'BYTE' THEN threshold = Fix(threshold)

   RETURN, threshold
END <span class="comments">;--------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; The function stretches the image according to the current stretch parameters.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     The stretched image is returned.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     info: in, required</span>
<span class="comments">;        The information structure for the program.</span>
<span class="comments">;-</span>
FUNCTION cgSTRETCH_SCALEIMAGE, info

<span class="comments">; Scales the image data appropriately, depending on scale type.</span>

   <span class="comments">; Catch any errors.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, Cancel=1
      void = Error_Message(/Traceback)
      RETURN, *info.image
   ENDIF

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   <span class="comments">; Turn floating underflow warnings off.</span>
   thisExcept = !Except
   !Except = 0


   CASE info.type OF

      'LINEAR': BEGIN
         scaledImage = BytScl(*info.image, Max=info.maxThresh, Min=info.minThresh, /NAN)
         IF info.negative THEN RETURN, 255B - scaledImage ELSE RETURN, scaledImage
         END

      'LINEAR 2%': BEGIN
      
         scaledImage = BytScl(*info.image, Max=info.maxThresh, Min=info.minThresh, /NAN)
         IF info.negative THEN RETURN, 255B - scaledImage ELSE RETURN, scaledImage
         END

      'ADAPTIVE EQUALIZATION': BEGIN
         scaledImage = BytScl(Adapt_Hist_Equal(*info.image), Max=info.maxThresh, Min=info.minThresh, /NAN)
         IF info.negative THEN RETURN, 255B - scaledImage ELSE RETURN, scaledImage
         END

      'EQUALIZATION': BEGIN
         scaledImage = BytScl(Hist_Equal(*info.image), Max=info.maxThresh, Min=info.minThresh, /NAN)
         IF info.negative THEN RETURN, 255B - scaledImage ELSE RETURN, scaledImage
         END

      'GAMMA': BEGIN
         scaledImage = GmaScl(*info.image, Max=info.maxThresh, Min=info.minThresh, $
                   Gamma=info.gamma, Negative=info.negative)
         RETURN, scaledImage
         END

      'GAUSSIAN': BEGIN
         scaledImage = GaussScl(*info.image, Max=info.maxThresh, Min=info.minThresh, $
                   Sigma=info.sigma, Negative=info.negative)
         RETURN, scaledImage
         END

      'SQUARE ROOT': BEGIN
         scaledImage = BytScl(SQRT(*info.image), Max=info.maxThresh, Min=info.minThresh, /NAN)
         IF info.negative THEN RETURN, 255B - scaledImage ELSE RETURN, scaledImage
         RETURN, scaledImage
         END

      'LOG': BEGIN
         scaledImage =  LogScl(*info.image, Max=info.maxThresh, Min=info.minThresh, $
                   Mean=info.mean, Exponent=info.exponent, Negative=info.negative)
         RETURN, scaledImage
         END

      'ASINH' :BEGIN
         scaledImage = ASinhScl(*info.image, Max=info.maxThresh, Min=info.minThresh, $
                  BETA=info.beta, Negative=info.negative)
         RETURN, scaledImage
         END

      'STDDEV': BEGIN
          scaledImage = BytScl(cgImgScl(*info.image, Stretch=10, Multiplier=info.multiplier, $
             Exclude=*info.exclude), Max=info.maxThresh, Min=info.minThresh, /NAN)
         RETURN, scaledImage
         END
   ENDCASE

   <span class="comments">; Turn warning back on.</span>
   void = Check_Math()
   !Except = thisExcept

END <span class="comments">;--------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; The call-back routine responds appropriately when the image window</span>
<span class="comments">; is destroyed by the user.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     imagewindowid: in, required</span>
<span class="comments">;        The identifier of the image draw widget.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_IMAGEWINDOWKILLED, imageWindowID

<span class="comments">; Turn the Save As, Print, and Image Colors buttons off.</span>

   Widget_Control, imageWindowID, Get_UValue=buttonIDs
   IF Widget_Info(buttonIDs[0], /Valid_ID) THEN BEGIN
      Widget_Control, buttonIDs[0], Sensitive=0
      Widget_Control, buttonIDs[1], Sensitive=0
      Widget_Control, buttonIDs[2], Sensitive=0
   ENDIF

END <span class="comments">;--------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; The event handler saves the stretched image to the main program level,</span>
<span class="comments">; where it can be manipulated further.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_SAVETOMAIN, event

<span class="comments">; Handle events from the SAVE to MAIN LEVEL buttons.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy   
   info.event_handler = 'cgSTRETCH_SAVETOMAIN'

   Widget_Control, event.id, Get_UValue=buttonValue
   CASE buttonValue OF

      'IMAGE': BEGIN

            varname = TextBox(Title='Provide Main-Level Variable Name...', Group_Leader=event.top, $
               Label='Image Variable Name: ', Cancel=cancelled, XSize=200, Value='stretched_image')

            <span class="comments">; The ROUTINE_NAMES function is not documented in IDL,</span>
            <span class="comments">; so it may not always work. This capability has been</span>
            <span class="comments">; tested in IDL versions 5.3 through 5.6 and found to work.</span>
            <span class="comments">; People with IDL 6.1 and higher should use SCOPE_VARFETCH to</span>
            <span class="comments">; set main-level variables. I use the older, undocumented version</span>
            <span class="comments">; to stay compatible with more users.</span>

            IF NOT cancelled THEN BEGIN
               displayImage = cgStretch_ScaleImage(info)
               dummy = Routine_Names(varname, displayImage, Store=1)
            ENDIF
            END

      'HISTOGRAM': BEGIN

            varname = TextBox(Title='Provide Main-Level Variable Name...', Group_Leader=event.top, $
               Label='Histogram Variable Name: ', Cancel=cancelled, XSize=200, Value='stretched_histogram')

            <span class="comments">; The ROUTINE_NAMES function is not documented in IDL,</span>
            <span class="comments">; so it may not always work. This capability has been</span>
            <span class="comments">; tested in IDL versions 5.3 through 5.6 and found to work.</span>
            <span class="comments">; People with IDL 6.1 and higher should use SCOPE_VARFETCH to</span>
            <span class="comments">; set main-level variables. I use the older, undocumented version</span>
            <span class="comments">; to stay compatible with more users.</span>

            IF NOT cancelled THEN BEGIN

               <span class="comments">; Calculate binsize.</span>
               displayImage = cgStretch_ScaleImage(info)
               maxval = Max(displayImage, MIN=minval)
               range = maxval - minval
               IF Size(displayImage, /TName) EQ 'BYTE' THEN binsize = 1.0 ELSE binsize = range / 256.

               <span class="comments">; Normalized pixel density.</span>
               histdata = Histogram(/NAN, displayImage, Binsize=binsize)

               dummy = Routine_Names(varname, histdata, Store=1)
            ENDIF
            END

      'PARAMETERS': BEGIN

            varname = TextBox(Title='Provide Main-Level Variable Name...', Group_Leader=event.top, $
               Label='Parameter Structure Name: ', Cancel=cancelled, XSize=200, Value='stretched_params')

            <span class="comments">; The ROUTINE_NAMES function is not documented in IDL,</span>
            <span class="comments">; so it may not always work. This capability has been</span>
            <span class="comments">; tested in IDL versions 5.3 through 5.6 and found to work.</span>
            <span class="comments">; People with IDL 6.1 and higher should use SCOPE_VARFETCH to</span>
            <span class="comments">; set main-level variables. I use the older, undocumented version</span>
            <span class="comments">; to stay compatible with more users.</span>

            IF NOT cancelled THEN BEGIN

               struct = { minThresh: info.minThresh, $
                          maxThresh: info.maxThresh, $
                          gamma: info.gamma, $
                          beta: info.beta, $
                          mean: info.mean, $
                          exponent: info.exponent, $
                          multiplier: info.multiplier, $
                          type: info.type }

               dummy = Routine_Names(varname, struct, Store=1)
            ENDIF
            END

         'EVERYTHING': BEGIN

            varname = TextBox(Title='Provide Main-Level Variable Name...', Group_Leader=event.top, $
               Label='Stretched Structure Name: ', Cancel=cancelled, XSize=200, Value='stretched_struct')

            <span class="comments">; The ROUTINE_NAMES function is not documented in IDL,</span>
            <span class="comments">; so it may not always work. This capability has been</span>
            <span class="comments">; tested in IDL versions 5.3 through 5.6 and found to work.</span>
            <span class="comments">; People with IDL 6.1 and higher should use SCOPE_VARFETCH to</span>
            <span class="comments">; set main-level variables. I use the older, undocumented version</span>
            <span class="comments">; to stay compatible with more users.</span>

            IF NOT cancelled THEN BEGIN

               displayImage = cgStretch_ScaleImage(info)

               <span class="comments">; Calculate binsize.</span>
               maxval = Max(displayImage, MIN=minval)
               range = maxval - minval
               IF Size(displayImage, /TName) EQ 'BYTE' THEN binsize = 1.0 ELSE binsize = range / 256.

               <span class="comments">; Normalized pixel density.</span>
               histdata = Histogram(/NAN, displayImage, Binsize=binsize)

               struct = { minThresh: info.minThresh, $
                          maxThresh: info.maxThresh, $
                          gamma: info.gamma, $
                          beta: info.beta, $
                          mean: info.mean, $
                          exponent: info.exponent, $
                          type: info.type, $
                          image: displayImage, $
                          multiplier: info.multiplier, $
                          histogram: histdata }

               dummy = Routine_Names(varname, struct, Store=1)
            ENDIF
            END
ENDCASE

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;--------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This procedure draws the minimum and maximum threshold lines on the histogram</span>
<span class="comments">; plot.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     minthresh: in, required</span>
<span class="comments">;        The minimum threshold value.</span>
<span class="comments">;     maxthresh: in, required</span>
<span class="comments">;        The maximum threshold value.</span>
<span class="comments">;     info: in, required, type=struct</span>
<span class="comments">;        The information structure for the program.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_DRAWLINES, minThresh, maxThresh, info

<span class="comments">; Procedure to draw threshold lines and asinh function on histogram plot.</span>

   <span class="comments">; Catch any errors.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, Cancel=1
      void = Error_Message(/Traceback)
      RETURN
   ENDIF

   <span class="comments">; Make sure you have the latest values of the parameters</span>
   CASE info.type OF

      'GAMMA': BEGIN
         theValue = Widget_Info(info.gamma_comboID, /Combobox_GetText)
         info.gamma = Double(theValue)
      END

      'GAUSSIAN': BEGIN
         IF N_Elements(info.sigmaObj -> Get_Value()) NE 0 THEN $
            info.sigma = info.sigmaObj -> Get_Value() ELSE info.sigma = 1.0
         info.sigmaObj -> Set_Value, info.sigma
      END

      'LOG': BEGIN
         IF N_Elements(info.param1Obj -> Get_Value()) NE 0 THEN $
            info.mean = info.param1Obj -> Get_Value() ELSE info.mean = 0.5
         info.param1Obj -> Set_Value, info.mean
         IF N_Elements(info.param2Obj -> Get_Value()) NE 0 THEN $
            info.exponent = info.param2Obj -> Get_Value() ELSE info.exponent = 4.0
         info.param2Obj -> Set_Value, info.exponent
      END

      'ASINH': BEGIN
         theValue = Widget_Info(info.asinh_comboID, /Combobox_GetText)
         info.beta = Double(theValue)
      END

      'STDDEV': BEGIN
         IF N_Elements(info.multiplierObj -> Get_Value()) NE 0 THEN $
            info.multiplier = info.multiplierObj -> Get_Value() ELSE info.multiplier = 1.0
         info.multiplierObj -> Set_Value, info.multiplier
      END
      ELSE:

   ENDCASE

   <span class="comments">; Make histogram window active..</span>
   IF (!D.Flags AND 256) NE 0 THEN WSet, info.histo_wid

   <span class="comments">; Draw threshold lines.</span>
   !P = info.pbang
   !X = info.xbang
   !Y = info.ybang
   PlotS, [minThresh, minThresh], [!Y.CRange(0), !Y.CRange(1)], $
      Color=cgColor(info.colors[2]), Thick=3
   PlotS, [maxThresh, maxThresh], [!Y.CRange(0), !Y.CRange(1)], $
      Color=cgColor(info.colors[3]), Thick=3

   <span class="comments">; Label the lines.</span>
   cmax = Convert_Coord(maxThresh, 0, /Data, /To_Normal)
   cmin = Convert_Coord(minThresh, 0, /Data, /To_Normal)
   minThresh = cgStretch_Validate_Threshold(minThresh, info)
   maxThresh = cgStretch_Validate_Threshold(maxThresh, info)
   IF info.type EQ 'SQUARE ROOT' THEN BEGIN
      minThresh = Float(minThresh)
      maxThresh = Float(maxThresh)
   ENDIF
   XYOuts, cmin[0], 0.90, /Normal, cgNumber_Formatter(minThresh, Decimals=3), $
      Color=cgColor(info.colors[2]), Alignment=1.0, Font=0
   XYOuts, cmax[0], 0.90, /Normal, cgNumber_Formatter(maxThresh, Decimals=3), $
      Color=cgColor(info.colors[3]), Alignment=0.0, Font=0

   CASE info.type OF

      'LINEAR': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'LINEAR 2%': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'ADAPTIVE EQUALIZATION': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'EQUALIZATION': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'LOG': BEGIN
            line = LogScl(Findgen(101), Mean=info.mean, Exponent=info.exponent)
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'GAMMA': BEGIN
            <span class="comments">; Draw the gamma function.</span>
            line = cgScaleVector(Findgen(101), 0.0, 1.0)
            line = Double(line)^info.gamma
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'GAUSSIAN': BEGIN
            <span class="comments">; Draw the gaussian function.</span>
            line = cgScaleVector(Findgen(101), -!PI, !PI)
            line = (1/(2*!PI*info.sigma^2))*EXP(-(line^2/(2*info.sigma^2)))
            line = cgScaleVector(line, 0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'SQUARE ROOT': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'ASINH': BEGIN
            <span class="comments">; Draw the asinh function.</span>
            line = ASinhScl(Findgen(101), BETA=info.beta)
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
             x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

      'STDDEV': BEGIN
            line = BytScl(Findgen(101))
            line = cgScaleVector(line, 0.0, !Y.CRange[1])
            x = cgScaleVector(Findgen(101), minThresh, maxThresh)
            OPlot, x, line, Color=cgColor(info.colors[4]), LineStyle=2, Thick=2
         END

   ENDCASE
END <span class="comments">;--------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This procedure will notify interested parties (who have signed up with</span>
<span class="comments">; the NotifyObj or NotifyPro keywords) about program events.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     info: in, required</span>
<span class="comments">;        The info structure of the program.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_NOTIFYOTHERS, info

<span class="comments">; This is the procedure that notifies others of an image change.</span>

   <span class="comments">; Catch any error in the histogram display routine.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, Cancel=1
      void = Error_Message()
      RETURN
   ENDIF

    stretchedImage = cgStretch_ScaleImage(info)

    <span class="comments">; The structure parameter.</span>
    struct = { image: stretchedImage, $       <span class="comments">; The stretched image.</span>
               r: info.r, $                   <span class="comments">; The R color vector associated with the image</span>
               g: info.g, $                   <span class="comments">; The G color vector associated with the image</span>
               b: info.b, $                   <span class="comments">; The B color vector associated with the image</span>
               event_handler:  info.event_handler, $ <span class="comments">; Where did the event come from?</span>
               type: info.type, $             <span class="comments">; The TYPE of stretch applied to the image.</span>
               minThresh: info.minThresh, $   <span class="comments">; The minimum threshold value.</span>
               maxThresh: info.maxThresh, $   <span class="comments">; The maximum threshold value.</span>
               beta: info.beta, $             <span class="comments">; The current BETA value.</span>
               gamma: info.gamma, $           <span class="comments">; The current GAMMA value.</span>
               mean: info.mean, $             <span class="comments">; The current MEAN value.</span>
               exponent: info.exponent, $     <span class="comments">; The current EXPONENT value.</span>
               multiplier: info.multiplier, $ <span class="comments">; The current MULTIPLIER value.</span>
               sigma: info.sigma }            <span class="comments">; The current SIGMA value.</span>
               
   <span class="comments">; Is there a user value?</span>
   IF N_Elements(*info.uvalue) NE 0 THEN BEGIN
       struct = Create_Struct(struct, "uvalue", *info.uvalue)
   ENDIF

   <span class="comments">; Notify a procedure.</span>
   IF info.notify_pro NE "" THEN Call_Procedure, info.notify_pro, struct

   <span class="comments">; Notify an object.</span>
   IF Obj_Valid(info.notify_obj.object) THEN $
      Call_Method, info.notify_obj.method, info.notify_obj.object, struct

END <span class="comments">;--------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This procedure draws the histogram plot for the image.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     info: in, required</span>
<span class="comments">;        The information structure for the program.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;      maxvalue: in, optional</span>
<span class="comments">;          The maximum value that the histogram plot will display.</span>
<span class="comments">;      wid: in, optional</span>
<span class="comments">;          The window index number of the window the histogram plot should be drawn in.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_HISTOPLOT, info, $
   MAXVALUE=maxvalue, $
   WID=wid

<span class="comments">; This is a utility program to draw a histogram plot in a</span>
<span class="comments">; display window.</span>

   <span class="comments">; Catch any error in the histogram display routine.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
       Catch, Cancel=1
       void = Error_Message()
       RETURN
   ENDIF

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   <span class="comments">; Proper number formatting.</span>
   format = '(F0.2)'
   IF N_Elements(maxvalue) THEN maxvalue = info.maxvalue
   IF maxvalue LT 0.1 THEN  format = '(F0.3)'
   IF maxvalue LT 0.05 THEN format = '(F0.4)'
   
   <span class="comments">; What kind of data are we working with?</span>
   dataType = Size(*info.image, /TYPE)

   <span class="comments">; Normalized pixel density.</span>
   CASE info.type OF
   
      'ADAPTIVE EQUALIZATION': BEGIN
         goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
         IF nanCount GT 0 THEN BEGIN
             binsize = (3.5 * StdDev(ADAPT_HIST_EQUAL(*info.image), /NAN))/N_Elements((*info.image)[goodIndices])^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             IF binsize LT 1 THEN binsize = 1
             histdata = Histogram(/NAN, ADAPT_HIST_EQUAL((*info.image)[goodIndices]), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(count)         
         ENDIF ELSE BEGIN
             binsize = (3.5 * StdDev(ADAPT_HIST_EQUAL(*info.image), /NAN))/N_Elements(*info.image)^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             IF binsize LT 1 THEN binsize = 1
             histdata = Histogram(/NAN, ADAPT_HIST_EQUAL(*info.image), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(N_Elements(*info.image))
         ENDELSE
         imageTitle = 'Adapted Equalization Image Value'
         END
   

      'EQUALIZATION': BEGIN
         goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
         IF nanCount GT 0 THEN BEGIN
             binsize = (3.5 * StdDev(HIST_EQUAL(*info.image), /NAN))/N_Elements((*info.image)[goodIndices])^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             IF binsize LT 1 THEN binsize = 1
             histdata = Histogram(/NAN, Hist_Equal((*info.image)[goodIndices]), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(count)         
         ENDIF ELSE BEGIN
             binsize = (3.5 * StdDev(HIST_EQUAL(*info.image), /NAN))/N_Elements(*info.image)^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             IF binsize LT 1 THEN binsize = 1
             histdata = Histogram(/NAN, Hist_Equal(*info.image), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(N_Elements(*info.image))
         ENDELSE
         imageTitle = 'Equalized Image Value'
         END
      'SQUARE ROOT': BEGIN
         goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
         IF nanCount GT 0 THEN BEGIN
             binsize = (3.5 * StdDev(SQRT(*info.image), /NAN))/N_Elements((*info.image)[goodIndices])^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, SQRT((*info.image)[goodIndices]), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(count)
         ENDIF ELSE BEGIN
             binsize = (3.5 * StdDev(SQRT(*info.image), /NAN))/N_Elements(*info.image)^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, SQRT(*info.image), Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(N_Elements(*info.image))
         ENDELSE
         imageTitle = 'Square Root of Image Value'
         END

      'STDDEV': BEGIN
         IF N_Elements(*info.exclude) NE 0 THEN BEGIN
              badIndices = Where(*info.image EQ *info.exclude, badCount)
              IF badCount GT 0 THEN BEGIN
                 *info.image = Float(*info.image)
                 (*info.image)[badIndices] = !Values.F_NAN
                 goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
              ENDIF
         ENDIF ELSE goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
         IF nanCount GT 0 THEN BEGIN
             binsize = (3.5 * StdDev(*info.image, /NAN))/N_Elements((*info.image)[goodIndices])^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, (*info.image)[goodIndices], Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(count)
         ENDIF ELSE BEGIN
             binsize = (3.5 * StdDev(*info.image, /NAN))/N_Elements(*info.image)^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, *info.image, Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(N_Elements(*info.image))
         ENDELSE
         imageTitle = 'Image Value'
          END
      ELSE: BEGIN
         goodIndices = Where(Finite(*info.image), NCOMPLEMENT=nanCount, count)
         IF nanCount GT 0 THEN BEGIN
             binsize = (3.5 * StdDev(*info.image, /NAN))/N_Elements((*info.image)[goodIndices])^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, (*info.image)[goodIndices], Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(count)
         ENDIF ELSE BEGIN
             binsize = (3.5 * StdDev(*info.image, /NAN))/N_Elements(*info.image)^(1./3)
             IF (dataType LE 3) OR (dataType GE 12) THEN binsize = Round(binsize) > 1
             binsize = Convert_To_Type(binsize, dataType)
             histdata = Histogram(/NAN, *info.image, Binsize=binsize, $
                OMIN=omin, OMAX=omax)/Float(N_Elements(*info.image))
         ENDELSE
         imageTitle = 'Image Value'
         END
   ENDCASE

   <span class="comments">; Save the current window index.</span>
   cWinID = !D.Window

   <span class="comments">; Calculate the range of the plot output.</span>
   ymin = 0
   ymax = Max(histData) * 1.05
   xmin = Double(omin) - binsize
   xmax = Double(omax) + (binsize * 2)
   
   <span class="comments">; Plot the histogram of the display image.</span>
   IF N_Elements(wid) NE 0 THEN WSet, wid
   Plot, [0,0], [1,1], $             
          Background=cgColor(info.colors[0]), $
          Color=cgColor(info.colors[1]), $       <span class="comments">; The color of the axes.</span>
          NoData=1, $                              <span class="comments">; Draw the axes only. No data.</span>
          XRange=[xmin, xmax], $                   <span class="comments">; The X data range.          </span>
          XStyle=9, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
          YMinor=1, $                              <span class="comments">; No minor tick mark on X axis.</span>
          YRange=[ymin, ymax &lt<span class="comments">; maxValue], $        ; The Y data range.</span>
          YStyle=1, $                              <span class="comments">; Exact axis scaling. No autoscaled axes.</span>
          YTitle='Relative Frequency', $           <span class="comments">; Y Title</span>
          XTicklen=-0.025, $
          Max_Value=maxValue, $
          YTickformat=format, $
          Position=[0.15, 0.20, 0.85, 0.85], $
          _Extra=extra                      <span class="comments">; Pass any extra PLOT keywords.</span>
             
    Axis, !X.CRange[0], !Y.CRange[1], XAXIS=1, XTickformat='(A1)', XMINOR=1, COLOR=cgColor(info.colors[1])
       
    step = (!X.CRange[1] - !X.CRange[0]) / (binsize + 1)
    start = !X.CRange[0] + binsize
    endpt = start + binsize
    FOR j=0,N_Elements(histdata)-1 DO BEGIN
        x = [start, start, endpt, endpt, start]
        y = [0, histdata[j], histdata[j], 0, 0]
        PolyFill, x, y, COLOR=cgColor('rose'), NOCLIP=0
        PlotS, x, y, COLOR=cgColor(info.colors[5]), NOCLIP=0
        start = start + binsize
        endpt = start + binsize
    ENDFOR
   
   <span class="comments">; Store the plotting system variables for later recall.</span>
   info.pbang = !P
   info.xbang = !X
   info.ybang = !Y
   info.ymin = !Y.CRange[0]
   info.ymax = !Y.CRange[1]
   info.xmin = !X.CRange[0]
   info.xmax = !X.CRange[1]

   <span class="comments">; Validate the threshold.</span>
   info.maxThresh = cgStretch_Validate_Threshold(info.maxThresh, info)
   info.minThresh = cgStretch_Validate_Threshold(info.minThresh, info)
   info.minThreshObj -> Set_Value,$
      cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(info.minThresh, info), Decimals=3), /FloatValue
   info.maxThreshObj -> Set_Value,$
      cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(info.maxThresh, info), Decimals=3), /FloatValue

   <span class="comments">; Restore previous graphics window.</span>
   IF cWinID GT 0 THEN IF (!D.Flags AND 256) NE 0 THEN WSet, cWinID

END <span class="comments">;--------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This event handler sets up the stretch parameters for the different stretches.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_PARAMETERS, event

<span class="comments">; Handle events from the log parameter widgets.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_PARAMETERS'

   <span class="comments">; Make sure you have the latest values for alpha and beta.</span>
   CASE info.type OF

      'LOG': BEGIN
         IF N_Elements(info.param1Obj -> Get_Value()) NE 0 THEN $
            info.mean = info.param1Obj -> Get_Value() ELSE info.mean = 0.5
            info.mean = 0.0 > info.mean &lt<span class="comments">; 1.0</span>
         info.param1Obj -> Set_Value, info.mean
         IF N_Elements(info.param2Obj -> Get_Value()) NE 0 THEN $
            info.exponent = info.param2Obj -> Get_Value() ELSE info.exponent = 4.0
         info.param2Obj -> Set_Value, info.exponent
      END

      'ASINH': BEGIN
         theText = Widget_Info(info.asinh_comboID, /Combobox_GetText)
         info.beta = Float(theText)
      END

      'GAMMA': BEGIN
         theText = Widget_Info(info.gamma_comboID, /Combobox_GetText)
         info.gamma = Float(theText)
      END

      'GAUSSIAN': BEGIN
         IF N_Elements(info.sigmaObj -> Get_Value()) NE 0 THEN $
            info.sigma = info.sigmaObj -> Get_Value() ELSE info.sigma = 1.0
         info.sigmaObj -> Set_Value, info.sigma
      END

      'STDDEV': BEGIN
         IF N_Elements(info.multiplierObj -> Get_Value()) NE 0 THEN $
            info.multiplier = info.multiplierObj -> Get_Value() ELSE info.multiplier = 1.0
         info.multiplierObj -> Set_Value, info.multiplier
         mean = Mean(*info.image, /NAN)
         stddev = StdDev(*info.image, /NAN)
         info.minThresh = (mean - (stddev * info.multiplier)) > Min(*info.image, /NAN)
         info.maxThresh = (mean + (stddev * info.multiplier)) &lt<span class="comments">; Max(*info.image, /NaN)</span>
         
      END
      ELSE:

   ENDCASE

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
      WSet, info.windex
      WShow, info.windex
      TVLCT, info.r, info.g, info.b
      cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   <span class="comments">; Copy histogram from pixmap.</span>
   WSet, info.histo_wid
   Device, Copy=[0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.pixmap]

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   Widget_Control, event.top, Set_UValue=info, /No_Copy


END <span class="comments">;--------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This event handler will reverse the image in the Y direction.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_FLIPIMAGE, event

<span class="comments">; Handle events from the "Flip Image" button.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_FLIPIMAGE'
   
   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   <span class="comments">; Switch the value of the button.</span>
   *info.image = Reverse(*info.image, 2)

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
      WSet, info.windex
      WShow, info.windex
      TVLCT, info.r, info.g, info.b
      cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;--------------------------------------------------------------------------------</span>




<span class="comments">;+</span>
<span class="comments">; This event handler saves the Gamma pull-down menu events.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_GAMMA, event

<span class="comments">; Handler events from the GAMMA pull-down menu.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_GAMMA'
   Widget_Control, event.id, Get_UValue=gamma
   info.gamma = gamma
   Widget_Control, info.cgammaID, Set_Button=0
   info.cgammaID = event.id
   Widget_Control, event.id, Set_Button=1

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
      WSet, info.windex
      WShow, info.windex
      TVLCT, info.r, info.g, info.b
      cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   <span class="comments">; Copy histogram from pixmap.</span>
   WSet, info.histo_wid
   Device, Copy=[0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.pixmap]

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;--------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This event handler reverses the image to a negative image.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_NEGATIVE, event

<span class="comments">; Handle events from the "Positive Image/Negative Image" button.</span>

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_NEGATIVE'

   <span class="comments">; Switch the value of the button.</span>
   Widget_Control, event.id, Get_Value=buttonValue
   CASE buttonValue OF
      'Negative Image': Widget_Control, event.id, Set_Value='Positive Image'
      'Positive Image': Widget_Control, event.id, Set_Value='Negative Image'
   ENDCASE
   info.negative = 1-info.negative

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
      WSet, info.windex
      WShow, info.windex
      TVLCT, info.r, info.g, info.b
      cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;--------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This event handler allows new images to be opened and displayed.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_OPENIMAGE, event

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.ID, Get_Value=buttonValue
   needcolors = 0

   CASE buttonValue OF
      'Raw Binary Image File...': BEGIN

         newImage = GetImage(Group_Leader=event.top, Cancel=cancelled, Catch=0)
         IF cancelled THEN RETURN
         END

      'Formatted Image File...': BEGIN

         newImage = ImageSelect(Cancel=cancelled, Palette=palette, Group_Leader=event.top)
         IF cancelled THEN RETURN
         END

   ENDCASE

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_OPENIMAGE'

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.image_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   dims = Image_Dimensions(newimage, XSize=xsize, YSize=ysize, TrueIndex=true)
   IF N_Elements(dims) LT 2 OR N_Elements(dims) GT 3 THEN Message, 'Must pass a 2D or 24-bit image'
   IF true NE -1 THEN BEGIN
      CASE true OF
         0: newimage = Transpose(newimage, [1, 2, 0])
         1: newimage = Transpose(newimage, [0, 2, 1])
         ELSE:
      ENDCASE
   ENDIF

   IF N_Elements(palette) NE 0 THEN BEGIN
      info.r = palette[*,0]
      info.g = palette[*,1]
      info.b = palette[*,2]
   ENDIF

   <span class="comments">; Restore the color table vectors.</span>
   TVLCT, info.r, info.g, info.b

   *info.image = newImage

   <span class="comments">; Start with linear stretch on both ends.</span>
   info.maxVal = Max(Double(newImage), Min=minVal)
   info.maxThresh =  Float(info.maxVal)
   info.minVal = minVal
   info.minThresh = Float(info.minVal)
   info.dataType = Size(newImage, /TNAME)

   <span class="comments">; Calculate a value to tell you if you are "close" to a threshold line.</span>
   info.close = 0.05 * (info.maxval-info.minval)

   cWinID = !D.Window
   WSet, info.histo_wid
   cgStretch_Histoplot, info, WID=info.histo_wid, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Store the plotting system variables for later recall.</span>
   info.pbang = !P
   info.xbang = !X
   info.ybang = !Y
   info.ymin = !Y.CRange[0]
   info.ymax = !Y.CRange[1]
   info.xmin = !X.CRange[0]
   info.xmax = !X.CRange[1]

   <span class="comments">; Validitate the threshold values. Have to do this AFTER setting xmin/xmax.</span>
   info.minThresh = cgSTRETCH_VALIDATE_THRESHOLD(info.minThresh, info)
   info.maxThresh = cgSTRETCH_VALIDATE_THRESHOLD(info.maxThresh, info)
   info.minThreshObj -> Set_Value, cgNumber_Formatter(info.minThresh, Decimals=3), /FloatValue
   info.maxThreshObj -> Set_Value, cgNumber_Formatter(info.maxThresh, Decimals=3), /FloatValue


   <span class="comments">; Put the same plot in the pixmap.</span>
   WSet, info.pixmap
   Device, Copy=[0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.histo_wid]

   <span class="comments">; Update the image display by appling the threshold parameters.</span>
   <span class="comments">; Be sure the image draw widget is still around. Make it if it isn't.</span>
   displayImage = cgStretch_ScaleImage(info)

   IF NOT info.no_window THEN BEGIN
      IF Widget_Info(info.image_draw, /Valid_ID) THEN BEGIN
         WSet, info.windex
         TVLCT, info.r, info.g, info.b
         imageSize = Size(*info.image)
         xsize = imageSize(1)
         ysize = imageSize(2)
         aspect = Float(xsize)/ysize
         IF xsize GT 512 OR ysize GT 512 THEN BEGIN
            IF xsize NE ysize THEN BEGIN
               aspect = Float(ysize) / xsize
               IF aspect LT 1 THEN BEGIN
                  xsize = 512
                  ysize = (512 * aspect) &lt<span class="comments">; 512</span>
               ENDIF ELSE BEGIN
                  ysize = 512
                  xsize = (512 / aspect) &lt<span class="comments">; 512</span>
               ENDELSE
            ENDIF ELSE BEGIN
               ysize = 512
               xsize = 512
            ENDELSE
         ENDIF
         Widget_Control, info.image_draw, Draw_XSize=xsize, Draw_YSize=ysize

      ENDIF ELSE BEGIN

         imageSize = Size(*info.image)
         xsize = imageSize(1)
         ysize = imageSize(2)
         aspect = Float(xsize)/ysize
         IF xsize GT 512 OR ysize GT 512 THEN BEGIN
            IF xsize NE ysize THEN BEGIN
               aspect = Float(ysize) / xsize
               IF aspect LT 1 THEN BEGIN
                  xsize = 512
                  ysize = (512 * aspect) &lt<span class="comments">; 512</span>
               ENDIF ELSE BEGIN
                  ysize = 512
                  xsize = (512 / aspect) &lt<span class="comments">; 512</span>
               ENDELSE
            ENDIF ELSE BEGIN
               ysize = 512
               xsize = 512
            ENDELSE
         ENDIF
         Widget_Control, event.top, TLB_Get_Offset=offsets, TLB_Get_Size=sizes
         xoff = offsets[0] + sizes[0] + 20
         yoff = offsets[1]
         image_tlb = Widget_Base(Row=1, Group=event.top, Title='cgStretch Image', $
            XOffSet=xoff, YOffSet=yoff, TLB_Size_Events=1, XPad=0, YPad=0)
         image_draw = Widget_Draw(image_tlb, XSize=xsize, YSize=ysize)
         Widget_Control, image_tlb, /Realize, Set_UValue=event.top
         Widget_Control, image_draw, Get_Value=windex
         info.image_draw = image_draw
         info.windex = windex

         XManager, 'cgstretch_image', image_tlb, Event_Handler='cgStretch_Image_Resize', /No_Block
         Widget_Control, info.saveas, Sensitive=1
         Widget_Control, info.printit, Sensitive=1
         Widget_Control, info.colorsID, Sensitive=1
      ENDELSE
   ENDIF

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
     WSet, info.windex
     WShow, info.windex
     TVLCT, info.r, info.g, info.b
     cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   IF cWinID GT 0 THEN WSet, cWinID
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;--------------------------------------------------------------------------------</span>




<span class="comments">;+</span>
<span class="comments">; This event handler saves the stretched image in various raster and PostScript formats.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_SAVEAS, event

   <span class="comments">; Errors caused by incorrect IDL versions or missing Coyote files.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(thisDevice) NE 0 THEN Set_Plot, thisDevice
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Save as various file types.</span>

   Widget_Control, event.top, Get_UValue=info, /No_Copy
  info.event_handler = 'cgSTRETCH_SAVEAS'
   Widget_Control, event.id, Get_UValue=saveAsType

   <span class="comments">; Set the current graphics window.</span>

   cWinID = !D.Window
   WSet, info.windex
   TVLCT, info.r, info.g, info.b

   <span class="comments">; What kind of file do you want?</span>

   filename = 'cgstretch'
   CASE saveAsType OF

      'JPEG': dummy = cgSnapshot(Filename=filename, /JPEG)
      'PNG': dummy = cgSnapshot(Filename=filename, /PNG)
      'TIFF': dummy = cgSnapshot(Filename=filename, /TIFF)
      'GIF': dummy = cgSnapshot(Filename=filename, /GIF)
      'PICT': dummy = cgSnapshot(Filename=filename, /PICT)
      'BMP': dummy = cgSnapshot(Filename=filename, /BMP)
      'PS': BEGIN

            WSet, info.windex
            keys = PSWindow()
            configureIt = PSConfig(Group_Leader=event.top, Cancel=cancelled, $
               Color=1, Filename='cgstretch.ps', _Extra=keys)
            IF NOT cancelled THEN BEGIN
                  thisDevice = !D.Name
                  Set_Plot, 'PS', /Copy
                  Device, _Extra=configureIt
                  displayImage = cgStretch_ScaleImage(info)
                  cgImage, displayImage, /NoInterp
                  Device, /Close_File
                  Set_Plot, thisDevice
            ENDIF

            ENDCASE
   ENDCASE

   IF cWinID GT 0 THEN WSet, cWinID

   <span class="comments">; Put the info structure back.</span>

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;-------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This event handler saves the histogram in various raster and PostScript formats.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_SAVEHISTOAS, event

   <span class="comments">; Errors caused by incorrect IDL versions or missing Coyote files.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(thisDevice) NE 0 THEN Set_Plot, thisDevice
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Save as various file types.</span>

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_SAVEHISTOAS'
   Widget_Control, event.id, Get_UValue=saveAsType

   <span class="comments">; Set the current graphics window.</span>

   cWinID = !D.Window
   WSet, info.histo_wid
   TVLCT, info.r, info.g, info.b

   <span class="comments">; What kind of file do you want?</span>

   filename = 'cgstretch_histogram'
   CASE saveAsType OF

      'JPEG': dummy = cgSnapshot(Filename=filename, /JPEG)
      'PNG': dummy = cgSnapshot(Filename=filename, /PNG)
      'TIFF': dummy = cgSnapshot(Filename=filename, /TIFF)
      'GIF': dummy = cgSnapshot(Filename=filename, /GIF)
      'PICT': dummy = cgSnapshot(Filename=filename, /PICT)
      'BMP': dummy = cgSnapshot(Filename=filename, /BMP)
      'PS': BEGIN

            keys = PSWindow()
            configureIt = PSConfig(Group_Leader=event.top, Cancel=cancelled, $
               Color=1, Filename='cgstretch_histrogram.ps', _Extra=keys)
            IF NOT cancelled THEN BEGIN
                  thisDevice = !D.Name
                  thisFont=!P.Font
                  !P.Font = 0
                  Set_Plot, 'PS', /Copy
                  Device, _Extra=configureIt
                  cgStretch_Histoplot, info, MaxValue=info.maxValue, _Extra=*info.extra
                  cgStretch_DrawLines, info.minThresh, info.maxThresh, info
                  Device, /Close_File
                  !P.Font = thisFont
                  Set_Plot, thisDevice
            ENDIF

            ENDCASE



   ENDCASE

   IF cWinID GT 0 THEN WSet, cWinID

   <span class="comments">; Put the info structure back.</span>

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;-------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This event handler sends the threshold values for the stretch.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_SETTHRESHOLD, event

   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Get the min and max thresholds. Make sure they</span>
   <span class="comments">; don't overlap each other.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_SETTHRESHOLD'

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   minThresh = info.minThreshObj -> Get_Value()
   info.minThresh = cgSTRETCH_VALIDATE_THRESHOLD(minThresh &lt<span class="comments">; (info.maxThresh - (info.range/200.)), info)</span>
   maxThresh = info.maxThreshObj -> Get_Value()
   info.maxThresh = cgSTRETCH_VALIDATE_THRESHOLD((info.minThresh + (info.range/200.)) > maxThresh, info)
   info.minThreshObj -> Set_Value, cgNumber_Formatter(info.minThresh, Decimals=3), /FloatValue
   info.maxThreshObj -> Set_Value, cgNumber_Formatter(info.maxThresh, Decimals=3), /FloatValue

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT info.no_window THEN BEGIN
      WSet, info.windex
      WShow, info.windex
      TVLCT, info.r, info.g, info.b
      cgImage, displayImage, /NoInterp
   ENDIF
   cgStretch_NotifyOthers, info

   <span class="comments">; Copy histogram from pixmap.</span>
   WSet, info.histo_wid
   Device, Copy=[0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.pixmap]

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">;-------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This event handler sends the output to a printer.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_PRINT, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Printing and printer setup handled here.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_PRINT'

   <span class="comments">; Configure printer and print if user OKs.</span>
   result = Dialog_PrinterSetup()
   IF result EQ 1 THEN BEGIN

      <span class="comments">; Are you printing the image or the histogram?</span>
      Widget_Control, event.id, Get_Value=TARGET

      <span class="comments">; I want the output on the page to have the same aspect ratio</span>
      <span class="comments">; as I see in the display window.</span>
      cWinID = !D.Window
      IF TARGET EQ 'IMAGE' THEN BEGIN
         WSet, info.windex
         TVLCT, info.r, info.g, info.b
      ENDIF ELSE BEGIN
         WSet, info.histo_wid

         <span class="comments">; Have to set up drawing colors *before* we go into the PRINTER device.</span>
         FOR j=0,N_Elements(info.colors)-1 DO color = cgColor(info.colors[j])
      ENDELSE
      configurePrinter = PSWindow(/Printer)

      <span class="comments">; Print the image.</span>
      thisDevice = !D.Name
      Set_Plot, 'PRINTER', /Copy
      Device, _Extra=configurePrinter
      Widget_Control, Hourglass=1
      IF TARGET EQ 'IMAGE' THEN BEGIN
         displayImage = cgStretch_ScaleImage(info)
         cgImage, displayImage, /NoInterp
      ENDIF ELSE BEGIN
            cgStretch_Histoplot, info, MaxValue=info.maxValue, _Extra=*info.extra
            cgStretch_DrawLines, info.minThresh, info.maxThresh, info
      ENDELSE
      Widget_Control, Hourglass=0
      Device, /Close_Document
      Set_Plot, thisDevice
      IF cWinID GT 0 THEN WSet, cWinID
   ENDIF

   <span class="comments">; Put the info structure back.</span>
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;-------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This event handler ONLY responds to button down events from the</span>
<span class="comments">; draw widget. If it gets a DOWN event, it does two things: (1) finds</span>
<span class="comments">; out which threshold line is to be moved, and (2) changes the</span>
<span class="comments">; event handler for the draw widget to cgSTRETCH_MOVELINE.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_PROCESS_EVENTS, event


   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL' ]
   thisEvent = possibleEventTypes[event.type]
   IF thisEvent NE 'DOWN' THEN RETURN

      <span class="comments">; Must be DOWN event to get here, so get info structure.</span>
      Widget_Control, event.top, Get_UValue=info, /No_Copy
      info.event_handler = 'cgSTRETCH_PROCESS_EVENTS'

      <span class="comments">; Make sure you have the correct plotting environment.</span>
      current_bangp = !P
      current_bangx = !X
      current_bangy = !Y

      !P = info.pbang
      !X = info.xbang
      !Y = info.ybang

      <span class="comments">; Convert the device coordinates to data coordinates.</span>
      <span class="comments">; Have to have scaling factors for conversion.</span>
      cWinID = !D.Window
      Wset, info.histo_wid
      TVLCT, info.r, info.g, info.b
      coords = Convert_Coord(event.x, event.y, 0, /Device, /To_Data)

      <span class="comments">; Is this event close to a line? If not, ignore it.</span>
      <span class="comments">; Click has to be inside the graph in the y direction.</span>
      IF coords[1] LT info.ymin OR coords[1] GT info.ymax THEN BEGIN
         Widget_Control, event.top, Set_UValue=info, /No_Copy

         <span class="comments">; Put the info structure back into its storage location.; Set things back.</span>
         !P = current_bangp
         !X = current_bangx
         !Y = current_bangy
         IF cWinID GT 0 THEN WSet, cWinID
         RETURN
      ENDIF

      <span class="comments">; How close to either line are you?</span>
       closemin = Abs(info.minthresh - coords[0])
       closemax = Abs(info.maxthresh - coords[0])
       IF closemin LE closemax THEN info.lineby = 'MIN' ELSE info.lineby = 'MAX'

       <span class="comments">; If you are not close to a line, goodbye!</span>
       CASE info.lineby OF
          'MIN': BEGIN
                 IF closemin GT info.close THEN BEGIN
                     Widget_Control, event.top, Set_UValue=info, /No_Copy

                     <span class="comments">; Put the info structure back into its storage location.; Set things back.</span>
                     !P = current_bangp
                     !X = current_bangx
                     !Y = current_bangy
                     IF cWinID GT 0 THEN WSet, cWinID
                     RETURN
                 ENDIF
                 END

          'MAX': BEGIN
                 IF closemax GT info.close THEN BEGIN
                     Widget_Control, event.top, Set_UValue=info, /No_Copy

                     <span class="comments">; Put the info structure back into its storage location.; Set things back.</span>
                     !P = current_bangp
                     !X = current_bangx
                     !Y = current_bangy
                     IF cWinID GT 0 THEN WSet, cWinID
                     RETURN
                 ENDIF
                 END
       ENDCASE

    <span class="comments">; Change the event handler for the draw widget and turn MOTION</span>
    <span class="comments">; events ON.</span>
    Widget_Control, event.id, Event_Pro='cgSTRETCH_MOVELINE', Draw_Motion_Events=1

   <span class="comments">; Put the info structure back into its storage location.; Set things back.</span>
   !P = current_bangp
   !X = current_bangx
   !Y = current_bangy
   IF cWinID GT 0 THEN WSet, cWinID

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; of cgSTRETCH_PROCESS_EVENTS *********************************************</span>



<span class="comments">;+</span>
<span class="comments">; This event handler continuously draws and erases a threshold line</span>
<span class="comments">; until it receives an UP event from the draw widget. Then it turns</span>
<span class="comments">; draw widget motion events OFF and changes the event handler for the</span>
<span class="comments">; draw widget back to cgSTRETCH_PROCESS_EVENTS.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_MOVELINE, event


   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF
   
   <span class="comments">; Get the info structure out of the top-level base.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy
   
   info.event_handler = 'cgSTRETCH_MOVELINE'

   <span class="comments">; Learn the type of the image data for later testing.</span>
   imageType = Size(*info.image, /TYPE)

   <span class="comments">; Make sure you have the correct plotting environment.</span>
   IF Size(*info.image, /Type) LE 3 THEN format = '(I0)' ELSE format='(F0)'
   current_bangp = !P
   current_bangx = !X
   current_bangy = !Y

   !P = info.pbang
   !X = info.xbang
   !Y = info.ybang

   cWinID = !D.Window

   <span class="comments">; Load image colors.</span>
   TVLCT, info.r, info.g, info.b

   <span class="comments">; What type of an event is this?</span>
   possibleEventTypes = [ 'DOWN', 'UP', 'MOTION', 'SCROLL' ]
   thisEvent = possibleEventTypes[event.type]

   IF thisEvent EQ 'UP' THEN BEGIN

      <span class="comments">; If this is an UP event, set the draw widget's event handler back</span>
      <span class="comments">; to cgSTRETCH_PROCESS_EVENTS, turn MOTION events OFF, and apply the</span>
      <span class="comments">; new threshold parameters to the image.</span>

      <span class="comments">; Erase the last theshold line drawn.</span>
      cWinID = !D.Window
      WSet, info.histo_wid
      TVLCT, info.r, info.g, info.b
      Device, Copy = [0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.pixmap]

      <span class="comments">; Turn motion events off and redirect the events to cgSTRETCH_PROCESS_EVENTS.</span>
       Widget_Control, event.id, Draw_Motion_Events=0, $
          Event_Pro='cgStretch_Process_Events'

      <span class="comments">; Convert the event device coordinates to data coordinates.</span>
      coord = Convert_Coord(event.x, event.y, /Device, /To_Data)
      coord = cgStretch_Validate_Threshold(coord, info)

      <span class="comments">; Make sure the coordinate is between the other line and</span>
      <span class="comments">; still inside the plot.</span>
      range = info.xmax - info.xmin
      closest = range * 0.005
      CASE info.lineby OF
         'MIN': BEGIN
                coord[0] = coord[0] > info.xmin
                coord[0] = coord[0] &lt<span class="comments">; (info.maxThresh - closest)</span>
                END
         'MAX': BEGIN
                coord[0] = coord[0] > (info.minThresh + closest)
                coord[0] = coord[0] &lt<span class="comments">; info.xmax</span>
                END
      ENDCASE
      
      <span class="comments">; You can get into trouble is this value goes beyond certain bounds and</span>
      <span class="comments">; is of different type from the data.</span>
      IF (imageType EQ 1)  THEN coord[0] = 0 > coord[0] &lt<span class="comments">; 255</span>
      IF (imageType EQ 2)  THEN coord[0] = Round(coord[0]) 
      IF (imageType EQ 3)  THEN coord[0] = Round(coord[0]) 
      IF (imageType GE 12) THEN coord[0] = Round(coord[0]) 

      <span class="comments">; Draw both of the threshold lines again.</span>
      CASE info.lineby OF
         'MIN': BEGIN
             cgStretch_DrawLines, coord[0], info.maxThresh, info
            info.minThresh = coord[0]
            info.minThreshObj -> Set_Value, $
               cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(info.minThresh, info), Decimals=3), /FloatValue
            END
         'MAX': BEGIN
            cgStretch_DrawLines, info.minThresh, coord[0], info
            info.maxThresh = coord[0]
            info.maxThreshObj -> Set_Value, $
               cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(info.maxThresh, info), Decimals=3), /FloatValue
            END
      ENDCASE

   <span class="comments">; Update the image display by appling the threshold parameters.</span>
   <span class="comments">; Be sure the image draw widget is still around. Make it if it isn't.</span>
   displayImage = cgStretch_ScaleImage(info)
   cgStretch_NotifyOthers, info

   IF NOT info.no_window THEN BEGIN
   IF Widget_Info(info.image_draw, /Valid_ID) THEN BEGIN
         WSet, info.windex
         WShow, info.windex
         TVLCT, info.r, info.g, info.b
         cgImage, displayImage, /NoInterp
      ENDIF ELSE BEGIN

         imageSize = Size(*info.image)
         xsize = imageSize(1)
         ysize = imageSize(2)
         aspect = Float(xsize)/ysize
         IF xsize GT 512 OR ysize GT 512 THEN BEGIN
            IF xsize NE ysize THEN BEGIN
               aspect = Float(ysize) / xsize
               IF aspect LT 1 THEN BEGIN
                  xsize = 512
                  ysize = (512 * aspect) &lt<span class="comments">; 512</span>
               ENDIF ELSE BEGIN
                  ysize = 512
                  xsize = (512 / aspect) &lt<span class="comments">; 512</span>
               ENDELSE
            ENDIF
         ENDIF
         Widget_Control, event.top, TLB_Get_Offset=offsets, TLB_Get_Size=sizes
         xoff = offsets[0] + sizes[0] + 20
         yoff = offsets[1]
         image_tlb = Widget_Base(Row=1, Group=event.top, Title='cgStretch Image', $
            XOffSet=xoff, YOffSet=yoff, TLB_Size_Events=1, XPad=0, YPad=0)
         image_draw = Widget_Draw(image_tlb, XSize=xsize, YSize=ysize)
         Widget_Control, image_tlb, /Realize, Set_UValue=event.top
         Widget_Control, image_draw, Get_Value=windex
         info.image_draw = image_draw
         info.windex = windex
         cgImage, displayImage, /NoInterp

         XManager, 'cgstretch_image', image_tlb, Event_Handler='cgStretch_Image_Resize', /No_Block
         Widget_Control, info.saveas, Sensitive=1
         Widget_Control, info.printit, Sensitive=1
         Widget_Control, info.colorsID, Sensitive=1
      ENDELSE
   ENDIF

      <span class="comments">; Update the pixmap with histogram with no threshold lines.</span>
      cgStretch_Histoplot, info, WID=info.pixmap, $
         MaxValue=info.maxValue, _Extra=*info.extra

      <span class="comments">; Put the info structure back into its storage location and then,</span>
      <span class="comments">; out of here!</span>
      Widget_Control, event.top, Set_UValue=info, /No_Copy
       IF cWinID GT 0 THEN WSet, cWinID
      RETURN
   ENDIF <span class="comments">; thisEvent = UP</span>


   <span class="comments">; Most of the action in this event handler occurs here while we are waiting</span>
   <span class="comments">; for an UP event to occur. As long as we don't get it, keep erasing the</span>
   <span class="comments">; old threshold line and drawing a new one.</span>

   <span class="comments">; Get current window and scaling parameters in order.</span>
   WSet, info.histo_wid
   TVLCT, info.r, info.g, info.b
   !P = info.pbang
   !X = info.xbang
   !Y = info.ybang
   coord = Convert_Coord(event.x, event.y, /Device, /To_Data)
   coord[0] = cgStretch_Validate_Threshold(coord[0], info)

   <span class="comments">; Draw the "other" line on the pixmap (so you don't have to draw</span>
   <span class="comments">; it all the time).</span>
   WSet, info.pixmap
   CASE info.lineby OF
      'MIN': BEGIN
         cmax = Convert_Coord(info.maxThresh, 0, /Data, /To_Normal)
         PlotS, [info.maxthresh, info.maxthresh],[info.ymin, info.ymax],  $
            Color=cgColor(info.colors[3]), Thick=2
         XYOuts, cmax[0], 0.90, /Normal, cgNumber_Formatter(cgStretch_Validate_Threshold(info.maxThresh, info), Decimals=3), $
            Color=cgColor(info.colors[3]), Alignment=0.0, Font=0
         END
      'MAX': BEGIN
         cmin = Convert_Coord(info.minThresh, 0, /Data, /To_Normal)
         PlotS, [info.minthresh, info.minthresh],[info.ymin, info.ymax],  $
            Color=cgColor(info.colors[2]), Thick=2
         XYOuts, cmin[0], 0.90, /Normal, cgNumber_Formatter(cgStretch_Validate_Threshold(info.minThresh, info), Decimals=3), $
            Color=cgColor(info.colors[2]), Alignment=1.0, Font=0
         END
   ENDCASE

   <span class="comments">; Erase the old threshold line.</span>
   WSet, info.histo_wid
   TVLCT, info.r, info.g, info.b
   Device, Copy = [0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.pixmap]

   <span class="comments">; You can get into trouble is this value goes beyond certain bounds and</span>
   <span class="comments">; is of different type from the data.</span>
   IF (imageType EQ 1)  THEN coord[0] = 0 > coord[0] &lt<span class="comments">; 255</span>
   IF (imageType EQ 2)  THEN coord[0] = Round(coord[0]) 
   IF (imageType EQ 3)  THEN coord[0] = Round(coord[0]) 
   IF (imageType GE 12) THEN coord[0] = Round(coord[0]) 

   <span class="comments">; Draw the new line at the new coordinate. Make sure the coordinate</span>
   <span class="comments">; is inside the plot and doesn't go over the other line.</span>
   CASE info.lineby OF
      'MIN': BEGIN
             coord[0] = coord[0] > (info.xmin)
             coord[0] = coord[0] &lt<span class="comments">; (info.maxThresh)</span>
             info.minThreshObj -> Set_Value, cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(coord[0], info), Decimals=3), /FloatValue
             END
      'MAX': BEGIN
             coord[0] = coord[0] > (info.minThresh)
             coord[0] = coord[0] &lt<span class="comments">; (info.xmax )</span>
             info.maxThreshObj -> Set_Value, cgNumber_Formatter(cgSTRETCH_VALIDATE_THRESHOLD(coord[0], info), Decimals=3), /FloatValue
             END
   ENDCASE

   cmax = Convert_Coord(info.maxThresh, 0, /Data, /To_Normal)
   cmin = Convert_Coord(info.minThresh, 0, /Data, /To_Normal)

   theCoord = cgStretch_Validate_Threshold(coord[0], info)
   CASE info.lineby OF
      'MIN': BEGIN
         PlotS, [coord[0], coord[0]],[info.ymin, info.ymax], Color=cgColor(info.colors[2]), Thick=2
         XYOuts, Float(event.x)/!D.X_Size, 0.90, /Normal, cgNumber_Formatter(thecoord, Decimals=3), $
            Color=cgColor(info.colors[2]), Alignment=1.0, Font=0
         END
      'MAX': BEGIN
         PlotS, [coord[0], coord[0]],[info.ymin, info.ymax], Color=cgColor(info.colors[3]), Thick=2
         XYOuts, Float(event.x)/!D.X_Size, 0.90, /Normal, cgNumber_Formatter(thecoord, Decimals=3), $
            Color=cgColor(info.colors[3]), Alignment=0.0, Font=0
         END
   ENDCASE

   <span class="comments">; Set things back.</span>
   !P = current_bangp
   !X = current_bangx
   !Y = current_bangy

   IF cWinID GT 0 THEN WSet, cWinID

   <span class="comments">; Put the info structure back into its storage location.</span>
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; of cgSTRETCH_MOVELINE **************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler restores the original stretch parameters.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_RESTORE, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Get the info structure out of the top-level base.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_RESTORE'
   
   <span class="comments">; Get the current mapped base.</span>
   currentMappedBase = info.currentMappedBase
   IF Widget_Info(currentMappedBase, /VALID_ID) THEN Widget_Control, info.currentMappedBase, Map=0
   
   <span class="comments">; Get the originalSetup pointer</span>
   originalSetup = info.originalSetup
   
   info = *info.originalSetup
   info = Create_Struct(info, 'OriginalSetup', originalSetup)
   
    <span class="comments">; Validitate the threshold values. Have to do this AFTER setting xmin/xmax.</span>
   info.minThresh = cgSTRETCH_VALIDATE_THRESHOLD(info.minThresh, info)
   info.maxThresh = cgSTRETCH_VALIDATE_THRESHOLD(info.maxThresh, info)
   info.minThreshObj -> Set_Value, cgNumber_Formatter(info.minThresh, Decimals=3), /FloatValue
   info.maxThreshObj -> Set_Value, cgNumber_Formatter(info.maxThresh, Decimals=3), /FloatValue
   
   <span class="comments">; Determine scaling type.</span>
   type = info.type
   possibleTypes = ['LINEAR', 'GAMMA', 'LOG', 'ASINH', 'LINEAR 2%', 'SQUARE ROOT', 'EQUALIZATION', 'GAUSSIAN', 'STDDEV']
   IF N_Elements(type) EQ 0 THEN type = 'LINEAR'
   IF Size(type, /TName) EQ 'STRING' THEN BEGIN
      type = StrUpCase(type)
      index = WHERE(possibleTypes EQ type, count)
      IF count EQ 0 THEN Message, 'Cannot find specified stretch type: ' + type
   ENDIF ELSE BEGIN
      type = 0 > Fix(type) &lt<span class="comments">; 8</span>
      type = possibleTypes[type]
   ENDELSE
   
   <span class="comments">; Realize the proper controls.</span>
   CASE type OF
      'LOG': BEGIN
         Widget_Control, info.logBaseID, Map=1
         info.currentMappedBase = info.logBaseID
         info.param1Obj -> Set_Value, info.mean
         info.param2Obj -> Set_Value, info.exponent
         END
      'GAMMA': BEGIN
         Widget_Control, info.gammaBaseID, Map=1
         info.currentMappedBase = info.gammaBaseID
         Widget_Control, info.gamma_comboID, Set_Value=StrTrim(info.gamma,2)
         END
      'ASINH': BEGIN
         Widget_Control, info.asinhBaseID, Map=1
         info.currentMappedBase = info.asinhBaseID
         Widget_Control, info.asinh_comboID, Set_Value=StrTrim(info.beta,2)
         END
      'GAUSSIAN': BEGIN
         Widget_Control, info.gaussBaseID, Map=1
         info.currentMappedBase = info.gaussBaseID
         info.sigmaObj -> Set_Value, info.sigma
         END
      'STDDEV': BEGIN
         Widget_Control, info.stddevBaseID, Map=1
         info.currentMappedBase = info.stddevBaseID
         info.multiplierObj -> Set_Value, info.multipler
         END
      ELSE: info.currentMappedBase = -1L
   ENDCASE
   
   types = StrUpCase(['Linear', 'Linear 2%', 'Gamma', 'Log', 'Square Root', 'Asinh', 'Equalization', 'Gaussian', 'StdDev'])
   index = Where(types EQ type) <span class="comments">; Necessary for backward compatibility and for my ordering in pull-down.</span>
   info.scaleID -> SetIndex, index[0] > 0
   

   <span class="comments">; Draw histogram.</span>
   cgStretch_Histoplot, info, WID=info.histo_wid, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Draw histogram in pixmap</span>
   cgStretch_Histoplot, info, WID=info.pixmap, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT Keyword_Set(info.no_window) THEN BEGIN
      WSet, info.windex
      TVLCT, info.r, info.g, info.b
      WShow, info.windex
      cgImage, displayImage, /NoInterp, _Extra=*info.extra
   ENDIF
   
   <span class="comments">; Notify others.</span>
   cgStretch_NotifyOthers, info
   
   <span class="comments">; Put the info structure back.</span>
   Widget_Control, event.top, Set_UValue=info, /No_Copy
END


<span class="comments">;+</span>
<span class="comments">; The event handler handles events from the Stretch Type buttons.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_STRETCHTYPE, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   <span class="comments">; Get the info structure out of the top-level base.</span>
   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_STRETCHTYPE'

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   <span class="comments">; What is the new type?</span>
   selection = event.self -> GetSelection()

   <span class="comments">; Always start min and max thresholds fresh when moving from one stretch to another.</span>
   IF info.type NE selection THEN BEGIN
      CASE StrUpCase(selection) OF
         'SQUARE ROOT': info.minThresh = MIN(SQRT(*info.image), MAX=maxthresh)
         'EQUALIZATION': info.minThresh = MIN(HIST_EQUAL(*info.image), MAX=maxthresh)
         'STDDEV': BEGIN
                   mean = Mean(*info.image, /NAN)
                   stddev = StdDev(*info.image, /NAN)
                   info.minThresh = mean - (stddev * info.multiplier)
                   maxThresh = mean + (stddev * info.multiplier)
             END
         'LINEAR 2%': BEGIN
            <span class="comments">; Calculate binsize.</span>
            maxr = Max(Double(*info.image), MIN=minr, /NAN)
            range = maxr - minr
            CASE Size(*info.image, /TName) OF
                'BYTE': binsize = 1
                'INT': binsize = 1 > Round(range / 300.)
                'LONG': binsize = 1 > Round(range / 300.)
                'UINT': binsize = 1 > Round(range / 300.)
                'ULONG': binsize = 1 > Round(range / 300.)
                'LONG64': binsize = 1 > Round(range / 300.)
                'ULONG64': binsize = 1 > Round(range / 300.)
                ELSE: binsize = range / 300.
            ENDCASE
            h = Histogram(/NAN, *info.image, BINSIZE=binsize, OMIN=omin, OMAX=omax)
            n = N_Elements(*info.image)
            cumTotal = Total(h, /CUMULATIVE)
            minIndex = Value_Locate(cumTotal, n * 0.02)
            IF minIndex EQ -1 THEN minIndex = 0
            WHILE cumTotal[minIndex] EQ cumTotal[minIndex + 1] DO BEGIN
                 minIndex = minIndex + 1
            ENDWHILE
            info.minThresh = minIndex * binsize + omin

            maxIndex  = Value_Locate(cumTotal, n * 0.98)
            WHILE cumTotal[maxIndex] EQ cumTotal[maxIndex - 1] DO BEGIN
                maxIndex = maxIndex - 1
            ENDWHILE
            maxThresh = maxIndex * binsize + omin
            
          END
         ELSE: info.minThresh = MIN(*info.image, MAX=maxthresh)
      ENDCASE
      info.maxThresh = maxthresh
   ENDIF

   <span class="comments">; Store the selection type.</span>
   info.type = StrUpCase(selection)

   CASE info.type OF

      'LINEAR': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         END

      'LINEAR 2%': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         END

      'ADAPTIVE EQUALIZATION': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         END

      'EQUALIZATION': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         END

      'SQUARE ROOT': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         END

      'GAMMA': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         Widget_Control, info.gammaBaseID, Map=1
         info.currentMappedBase = info.gammaBaseID
         END

      'GAUSSIAN': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         Widget_Control, info.gaussBaseID, Map=1
         info.currentMappedBase = info.gaussBaseID
         END

      'LOG': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
           Widget_Control, info.currentMappedBase, Map=0
         Widget_Control, info.logBaseID, Map=1
         info.currentMappedBase = info.logBaseID
         END

      'ASINH': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
            Widget_Control, info.currentMappedBase, Map=0
         Widget_Control, info.asinhBaseID, Map=1
         info.currentMappedBase = info.asinhBaseID
         END

      'STDDEV': BEGIN
         IF Widget_Info(info.currentMappedBase, /Valid_ID) THEN $
            Widget_Control, info.currentMappedBase, Map=0
         Widget_Control, info.stddevBaseID, Map=1
         info.currentMappedBase = info.stddevBaseID
         END

   ENDCASE

   <span class="comments">; Draw histogram.</span>
   cgStretch_Histoplot, info, WID=info.histo_wid, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Draw histogram in pixmap</span>
   cgStretch_Histoplot, info, WID=info.pixmap, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   <span class="comments">; Display the image after thresholding.</span>
   displayImage = cgStretch_ScaleImage(info)
   IF NOT Keyword_Set(info.no_window) THEN BEGIN
      WSet, info.windex
      TVLCT, info.r, info.g, info.b
      WShow, info.windex
      cgImage, displayImage, /NoInterp, _Extra=*info.extra
   ENDIF

   <span class="comments">; Notify others of image change.</span>
   cgStretch_NotifyOthers, info

   <span class="comments">; Put the info structure back into the top-level base.</span>
   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;-------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; The event handler that deals with the QUIT button.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_QUIT, event
   Widget_Control, event.top, /Destroy
END <span class="comments">; of cgSTRETCH_QUIT ******************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler that deals setting image colors</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_COLORS, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_COLORS'
   cWinID = !D.Window

   thisEvent = Tag_Names(event, /Structure_Name)
   CASE thisEvent OF

      'WIDGET_BUTTON': BEGIN
          TVLCT, info.r, info.g, info.b
          XColors, Group=event.top, NotifyID=[event.id, event.top], BREWER=info.brewer
          END
      'XCOLORS_LOAD': BEGIN
          Device, Get_Visual_Depth=thisDepth
          IF thisDepth GT 8 THEN BEGIN
             displayImage = cgStretch_ScaleImage(info)
             IF info.no_window EQ 0 THEN BEGIN
                info.r = event.r
                info.g = event.g
                info.b = event.b
                TVLCT, info.r, info.g, info.b
                WShow, info.windex
                WSet, info.windex
                cgImage, displayImage, /NoInterp
             ENDIF
             cgStretch_NotifyOthers, info

          ENDIF
          END
   ENDCASE
   IF cWinID GT 0 THEN WSet, cWinID

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; of cgSTRETCH_COLORS ****************************************************</span>


<span class="comments">;+</span>
<span class="comments">; The event handler that deals with the setting of the Max Value widget.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_MAXVALUE, event

    <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_MAXVALUE'
   cWinID = !D.Window

   <span class="comments">; Get the new max value.</span>
   Widget_Control, info.pixelDensityID, SET_BUTTON=0
   Widget_Control, event.id, Get_UValue=maxValue, SET_BUTTON=1
   info.maxValue = maxValue
   info.pixelDensityID = event.id

   <span class="comments">; Update the histogram plot.</span>
   cgStretch_Histoplot, info, WID=info.histo_wid, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Draw threshold lines on the histogram plot.</span>
   cgStretch_DrawLines, info.minthresh, info.maxthresh, info

   <span class="comments">; Update the pixmap with histogram with no threshold lines.</span>
   cgStretch_Histoplot, info, WID=info.pixmap, $
      MaxValue=info.maxValue, _Extra=*info.extra

   IF cWinID GT 0 THEN WSet, cWinID

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">;-------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; The event handler that deals with resizing the image window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_IMAGE_RESIZE, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   cWinID = !D.Window
   Widget_Control, event.top, Get_UValue=histoTLB
   Widget_Control, histoTLB, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_IMAGE_RESIZE'

   <span class="comments">; Hourglass cursor.</span>
   IF Widget_Info(info.histo_draw, /VALID_ID) THEN Widget_Control, /HOURGLASS

   <span class="comments">; I would like to maintain the window aspect ratio the same as the</span>
   <span class="comments">; image aspect ratio.</span>
   dims = Size(*info.image, /Dimensions)
   xsize = dims[0]
   ysize = dims[1]
   maxWindowSize = Max([event.x, event.y])
   IF xsize NE ysize THEN BEGIN
      aspect = Float(ysize) / xsize
      IF aspect LT 1 THEN BEGIN
         xsize = maxWindowSize
         ysize = (maxWindowSize * aspect) &lt<span class="comments">; maxWindowSize</span>
      ENDIF ELSE BEGIN
         ysize = maxWindowSize
         xsize = (maxWindowSize / aspect) &lt<span class="comments">; maxWindowSize</span>
      ENDELSE
   ENDIF ELSE BEGIN
      ysize = maxWindowSize
      xsize = maxWindowSize
   ENDELSE


   Widget_Control, info.image_draw, Draw_XSize=xsize, Draw_YSize=ysize
   WSet, info.windex
   displayImage = cgStretch_ScaleImage(info)
   TVLCT, info.r, info.g, info.b
   cgImage, displayImage, /NoInterp
   cgStretch_NotifyOthers, info

   Widget_Control, histoTLB, Set_UValue=info, /No_Copy
   IF cWinID GT 0 THEN WSet, cWinID

END <span class="comments">; of cgSTRETCH_IMAGE_RESIZE **********************************************</span>


<span class="comments">;+</span>
<span class="comments">; The event handler that deals with resizing the histogram window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_HISTOGRAM_RESIZE, event

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      IF N_Elements(info) NE 0 THEN Widget_Control, event.top, Set_UValue=info, /No_Copy
      RETURN
   ENDIF

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   info.event_handler = 'cgSTRETCH_HISTOGRAM_RESIZE'
   cWinID = !D.Window

   Widget_Control, info.histo_draw, Draw_XSize=event.x > info.min_xsize, Draw_YSize=(event.y - info.pbase_ysize) > 150

   <span class="comments">; Draw the plot.</span>
   cgStretch_Histoplot, info, WID=info.histo_wid, $
      MaxValue=info.maxValue, _Extra=*info.extra

   <span class="comments">; Put the same plot in the pixmap.</span>
   WDelete, info.pixmap
   Window, /Free, XSize=event.x > info.min_xsize, YSize=(event.y - info.pbase_ysize) > 150, /Pixmap
   info.pixmap = !D.Window
   info.pix_xsize = event.x > info.min_xsize
   info.pix_ysize = (event.y - info.pbase_ysize) > 150
   Device, Copy=[0, 0, info.pix_xsize, info.pix_ysize, 0, 0, info.histo_wid]

   <span class="comments">; Save the scaling factors for calculating data coordinates.</span>
   info.pbang = !P
   info.xbang = !X
   info.ybang = !Y
   info.ymin = !Y.CRange[0]
   info.ymax = !Y.CRange[1]
   info.xmin = !X.CRange[0]
   info.xmax = !X.CRange[1]

   <span class="comments">; Draw threshold lines on the histogram plot.</span>
   cgStretch_DrawLines, info.minThresh, info.maxThresh, info

   IF cWinID GT 0 THEN WSet, cWinID

   Widget_Control, event.top, Set_UValue=info, /No_Copy

END <span class="comments">; of cgSTRETCH_COLORS ****************************************************</span>


<span class="comments">;+</span>
<span class="comments">; The widget clean-up routine.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     tlb: in, required</span>
<span class="comments">;        The identifier of the widget that died.</span>
<span class="comments">;-</span>
PRO cgSTRETCH_CLEANUP, tlb

   Widget_Control, tlb, Get_UValue=info
   IF N_Elements(info) NE 0 THEN BEGIN
      IF info.newPointer THEN Ptr_Free, info.image
      Ptr_Free, info.uvalue
      Ptr_Free, info.originalSetup
      Ptr_Free, info.extra
      Ptr_Free, info.exclude
      WDelete, info.pixmap
   ENDIF

END <span class="comments">;---------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; The widget definition module for this interative contrast stretching program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    theimage: in, required</span>
<span class="comments">;       The image data to be stretched. It must be 2D array or a pointer to a 2D array.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    beta: in, optional, type=float, default=3.0</span>
<span class="comments">;        The beta factor in a Hyperpolic Sine stretch.</span>
<span class="comments">;    block: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish the program to be a blocking widget.</span>
<span class="comments">;    brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you wish to use the Brewer color tables.</span>
<span class="comments">;    colors: in, optional, type=string</span>
<span class="comments">;         A five element string array, listing the colors for drawing the</span>
<span class="comments">;         histogram plot. If a particular color is represented as a null string, then the</span>
<span class="comments">;         default for that color is used. The colors are used as follows::</span>
<span class="comments">;             colors[0] : Background color. Default: "white".</span>
<span class="comments">;             colors[1] : Axis color. Default: "black".</span>
<span class="comments">;             colors[2] : Min threshold color. Default: "firebrick".</span>
<span class="comments">;             colors[3] : Max threshold  color. Default: "steel blue".</span>
<span class="comments">;             colors[4] : ASinh color. Default: "grn6".</span>
<span class="comments">;             colors[5] : Histogram color. Default: "charcoal".</span>
<span class="comments">;    colortable: in, optional, type=integer, default=0</span>
<span class="comments">;         The color table to display the image in. By default, gray-scale colors.</span>
<span class="comments">;    exclude: in, optional, type=numeric</span>
<span class="comments">;         The value to exclude in a standard deviation stretch.</span>
<span class="comments">;    exponent: in, optional, type=float, default=4.0</span>
<span class="comments">;         The logarithm exponent in a logarithmic stretch.</span>
<span class="comments">;    filename: in, optional, type=string</span>
<span class="comments">;         If no image is supplied as a positional parameter, this keyword can be</span>
<span class="comments">;         used to specify the name of an image file to read with ImageSelect.</span>
<span class="comments">;    gamma: in, optional, type=float, default=1.5</span>
<span class="comments">;         The gamma factor in a gamma stretch.</span>
<span class="comments">;    group_leader: in, optional, type=integer</span>
<span class="comments">;         The identifier of the widget group leader is this program is called from within</span>
<span class="comments">;         a widget program.</span>
<span class="comments">;    max_value: in, optional, type=varies</span>
<span class="comments">;         Use this keyword to assign a maximun value for the normalized Histogram Plot.</span>
<span class="comments">;         Images with lots of pixels of one color (e.g. black) skew the histogram. This </span>
<span class="comments">;         helps make a better looking plot. Set by default to the maximum value of the </span>
<span class="comments">;         histogram data.</span>
<span class="comments">;    maxthresh: in, optional</span>
<span class="comments">;         The initial maximum threshold value for the stretch.</span>
<span class="comments">;    mean: in, optional, type=float, default=0.5</span>
<span class="comments">;         The mean factor in a logarithmic stretch.</span>
<span class="comments">;    minthresh: in, optional</span>
<span class="comments">;         The initial minimun threshold value for the stretch.</span>
<span class="comments">;    multiplier: in, optional, type=float</span>
<span class="comments">;         The multiplication factor in a standard deviation stretch. The standard deviation</span>
<span class="comments">;         is multiplied by this factor to produce the thresholds for a linear stretch.</span>
<span class="comments">;    negative: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you want to display the image with a negative or reverse stretch.</span>
<span class="comments">;    no_window: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you do no want the program to display an image window. This would </span>
<span class="comments">;         be the case, for example, if you are displaying the image in your own window and your program</span>
<span class="comments">;         is being notified of images changes via the `NOTIFY_PRO` or `NOTIFY_OBJ` keywords.</span>
<span class="comments">;    notify_obj: in, optional, type=struct</span>
<span class="comments">;         Set this keyword to a structure containing the fields OBJECT and METHOD. When the image is changed, </span>
<span class="comments">;         the object identified in the OBJECT field will have the method identified in the METHOD</span>
<span class="comments">;         field called. The method should be written to accept one positional parameter. The parameter passed </span>
<span class="comments">;         to the method is a structure defined as below::</span>
<span class="comments">;           struct = { image: stretchedImage, $ ; The stretched image.</span>
<span class="comments">;               r: info.r, $                    ; The R color vector associated with the image</span>
<span class="comments">;               g: info.g, $                    ; The G color vector associated with the image</span>
<span class="comments">;               b: info.b, $                    ; The B color vector associated with the image</span>
<span class="comments">;               type: info.type, $              ; The TYPE of stretch applied to the image.</span>
<span class="comments">;               minThresh: info.minThresh, $    ; The minimum threshold value.</span>
<span class="comments">;               maxThresh: info.maxThresh, $    ; The maximum threshold value.</span>
<span class="comments">;               beta: info.beta, $              ; The current BETA value.</span>
<span class="comments">;               gamma: info.gamma, $            ; The current GAMMA value.</span>
<span class="comments">;               mean: info.mean, $              ; The current MEAN value.</span>
<span class="comments">;               exponent: info.exponent, $      ; The current EXPONENT value.</span>
<span class="comments">;               multiplier: info.multiplier, $  ; The current MULTIPLIER value.</span>
<span class="comments">;               sigma: info.sigma }             ; The current SIGMA value.</span>
<span class="comments">;    notify_pro: in, optional, type=string</span>
<span class="comments">;         Set this keyword to the name of a procedure that should be notified when the image is changed. </span>
<span class="comments">;         The procedure should be defined with one positional parameter. The parameter passed</span>
<span class="comments">;         to the procedure is a structure defined in the `Notify_Obj` keyword..</span>
<span class="comments">;    sigma: in, optional, type=float, default=1.0</span>
<span class="comments">;         The sigma scale factor in a Gaussian stretch.</span>
<span class="comments">;    title: in, optional, type=string</span>
<span class="comments">;         The title of the histogram window. By default: 'Drag Vertical Lines to STRETCH Image Contrast'.</span>
<span class="comments">;    type: in, optional, type=integer</span>
<span class="comments">;         The type of stretch to be applied. May be either a string (e.g, 'GAMMA') or a number from the table below::</span>
<span class="comments">;           Number   Type of Stretch</span>
<span class="comments">;</span>
<span class="comments">;             0         Linear         scaled = BytScl(image, MIN=minThresh, MAX=maxThresh)</span>
<span class="comments">;             1         Gamma          scaled = GmaScl(image, MIN=minThresh, MAX=maxThresh, Gamma=gamma)</span>
<span class="comments">;             2         Log            scaled = LogScl(image, MIN=minThresh, MAX=maxThresh, Mean=mean, Exponent=exponent)</span>
<span class="comments">;             3         Asinh          scaled = AsinhScl(image, MIN=minThresh, MAX=maxThresh, Beta=beta)</span>
<span class="comments">;             4         Linear 2%      A linear stretch, with 2 percent of pixels clipped at both the top and bottom</span>
<span class="comments">;             5         Square Root    A linear stretch of the square root histogram of the image values.</span>
<span class="comments">;             6         Equalization   A linear stretch of the histogram equalized image histogram.</span>
<span class="comments">;             7         Gaussian       A Gaussian normal function is applied to the image histogram.</span>
<span class="comments">;             8         StdDev         The image is stretched linearly based on its mean and a multiple of its standard deviation.</span>
<span class="comments">;    uvalue: in, optional</span>
<span class="comments">;         Any IDL variable can be stored in this keyword.</span>
<span class="comments">;    xpos: in, optional, type=integer, default=100</span>
<span class="comments">;         The X position of the histogram window in pixels from upper-left of display.</span>
<span class="comments">;    ypos: in, optional, type=integer, default=100</span>
<span class="comments">;         The Y position of the histogram window in pixels from upper-left of display.</span>
<span class="comments">;         </span>
<span class="comments">;-</span>
PRO cgSTRETCH, theImage, $
   Beta=beta, $
   Block=block, $
   Brewer=brewer, $
   Colors=colors, $
   Colortable=ctable, $
   Exclude=exclude, $
   Exponent=exponent, $
   Filename=filename, $
   Gamma=gamma, $
   Group_Leader=group, $
   MinThresh=minThresh, $
   MaxThresh=maxThresh, $
   Max_Value=maxvalue, $
   Multiplier=multiplier, $
   Mean=mean, $
   Negative=negative, $
   No_Window=no_window, $
   Notify_Obj=notify_obj, $
   Notify_Pro=notify_pro, $
   Sigma=sigma, $
   Title=title, $
   Type=type, $
   UValue=uvalue, $
   XPos=xpos, $
   YPos=ypos, $
   _EXTRA=extra

   <span class="comments">; Error Handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      ok = Error_Message(/Traceback)
      RETURN
   ENDIF

   <span class="comments">; Set up environment.</span>
   Compile_Opt idl2

   <span class="comments">; Initial values of some variables.</span>
   cWinID = !D.Window
   histXsize = 400
   histYsize = 220

   <span class="comments">; Did you specify a filename?</span>
   IF N_Elements(filename) NE 0 AND N_Elements(theImage) EQ 0 THEN BEGIN
      IF filename NE "" THEN BEGIN
         theImage = ImageSelect(Filename=filename, Cancel=cancelled, Palette=palette, /Silent)
         IF cancelled THEN RETURN
      ENDIF
   ENDIF

   <span class="comments">; Need an image?</span>
   IF N_Elements(theImage) EQ 0  THEN BEGIN
      file = Filepath(SubDir=['examples', 'data'], 'ctscan.dat')
      theImage = BytArr(256, 256)
      OpenR, lun, file, /GET_LUN
      ReadU, lun, theImage
      Free_LUN, lun
   ENDIF

   <span class="comments">; Is image a pointer? If not, make it one.</span>
   IF Size(theImage, /TName) NE 'POINTER' THEN BEGIN
      image = Ptr_New(theImage)
      newPointer = 1
      datatype = Size(theImage, /TNAME)
   ENDIF ELSE BEGIN
      image = theImage
      newPointer = 0
      datatype = Size(*theImage, /TNAME)
   ENDELSE
   
   <span class="comments">; All kinds of havoc if I work with BYTE data, so do conversion here.</span>
   IF datatype EQ 'BYTE' THEN *image = Temporary(Fix(*image))

   <span class="comments">; Check for underflow of values near 0. Yuck! Necessary with gnarly data.</span>
   curExcept = !Except
   !Except = 0
   i = Where(*image GT -1e-35 AND *image LT 1e-35, count)
   IF count GT 0 THEN (*image)[i] = 0.0
   void = Check_Math()
   !Except = curExcept

   dims = Image_Dimensions(*image, XSize=xsize, YSize=ysize, TrueIndex=true)
   IF N_Elements(dims) LT 2 OR N_Elements(dims) GT 3 THEN Message, 'Must pass a 2D or 24-bit image'
   IF true NE -1 THEN BEGIN
      CASE true OF
         0: *image = Transpose(*image, [1, 2, 0])
         1: *image = Transpose(*image, [0, 2, 1])
         ELSE:
      ENDCASE
   ENDIF

   <span class="comments">; Default values for keywords.</span>
  IF N_Elements(beta) EQ 0 THEN beta = 3 ELSE beta = beta > 0.0
  brewer = Keyword_Set(brewer)
  IF N_Elements(colors) EQ 0 THEN BEGIN
      colors = ['white', 'black', 'firebrick', 'steel blue', 'grn6', 'black']
   ENDIF ELSE BEGIN
      IF N_Elements(colors) NE 6 THEN Message, 'Incorrect number of colors in COLORS vector.'
      defcolors = ['white', 'black', 'firebrick', 'steel blue', 'grn6', 'black']
      i = Where(colors EQ "", count)
      IF count GT 0 THEN colors[i] = defcolors[i]
   ENDELSE
   IF N_Elements(ctable) EQ 0 THEN ctable = 0
   IF N_Elements(exponent) EQ 0 THEN exponent = 4.0
   IF N_Elements(extra) EQ 0 THEN extra = Ptr_New(/Allocate_Heap) ELSE extra = Ptr_New(extra)
   IF N_Elements(gamma) EQ 0 THEN gamma = 1.5
   IF N_Elements(maxvalue) EQ 0 THEN maxvalue = 0.70
   IF N_Elements(mean) EQ 0 THEN mean = 0.5
   mean = 0.0 > mean &lt<span class="comments">; 1.0</span>
   IF N_Elements(minThresh) EQ 0 THEN minThresh = Min(*image)
   IF N_Elements(maxThresh) EQ 0 THEN maxThresh = Max(*image)    
   IF N_Elements(multiplier) EQ 0 THEN multiplier = 2.0
   IF N_Elements(notify_pro) EQ 0 THEN notify_pro = ""
   IF N_Elements(negative) EQ 0 THEN negative = 0
   IF N_Elements(notify_obj) EQ 0 THEN notify_obj = {object:Obj_New(), method:""} ELSE BEGIN
      IF Size(notify_obj, /TNAME) NE 'STRUCT' THEN $
         Message, 'NOTIFY_OBJ keyword requires structure variable'
      names = Tag_Names(notify_obj)
      index = Where(names EQ "METHOD", count)
      IF count EQ 0 THEN Message, 'NOTIFY_OBJ structure requires METHOD field.'
      index = Where(names EQ "OBJECT", count)
      IF count EQ 0 THEN Message, 'NOTIFY_OBJ structure requires OBJECT field.'
      IF Obj_Valid(notify_obj.object) EQ 0 THEN Message, 'NOTIFY_OBJ object is invalid.'
   ENDELSE
   no_window = Keyword_Set(no_window)
   IF N_Elements(sigma) EQ 0 THEN sigma = 1.0 ELSE sigma = sigma > 0.1
   IF N_Elements(uvalue) EQ 0 THEN uvalueptr = Ptr_New(/Allocate_Heap) ELSE uvalueptr = Ptr_New(uvalue)
   IF N_Elements(xpos) EQ 0 THEN xpos = 100
   IF N_Elements(ypos) EQ 0 THEN ypos = 100
   IF N_Elements(title) EQ 0 THEN title = 'Drag Vertical Lines to STRETCH Image Contrast'

   <span class="comments">; Determine scaling type.</span>
   possibleTypes = ['LINEAR', 'GAMMA', 'LOG', 'ASINH', 'LINEAR 2%', 'SQUARE ROOT', $
        'EQUALIZATION', 'ADAPTIVE EQUALIZATION', 'GAUSSIAN', 'STDDEV']
   IF N_Elements(type) EQ 0 THEN type = 'LINEAR'
   IF Size(type, /TName) EQ 'STRING' THEN BEGIN
      type = StrUpCase(type)
      index = WHERE(possibleTypes EQ type, count)
      IF count EQ 0 THEN Message, 'Cannot find specified stretch type: ' + type
   ENDIF ELSE BEGIN
      type = 0 > Fix(type) &lt<span class="comments">; 9</span>
      type = possibleTypes[type]
   ENDELSE

   <span class="comments">; Check for availability of GIF files.</span>
   thisVersion = Float(!Version.Release)
   IF ((thisVersion LT 5.4) OR (thisVersion GE 6.2)) THEN haveGif = 1 ELSE haveGIF = 0

   <span class="comments">; Create the histogram widget.</span>
   histo_tlb = Widget_Base(Column=1, Title=title, XPad=0, YPad=0, $
      MBar=menubaseID, TLB_Size_Events=1, XOffset=xpos, YOffset=ypos, Base_Align_Center=1)

   <span class="comments">; Create draw widget. UNIX versions of IDL have a bug in which creating</span>
   <span class="comments">; a draw widget as the very first window in an IDL session causes both</span>
   <span class="comments">; !P.Background and !P.Color to be set to white. I know, it's odd. But</span>
   <span class="comments">; doing this little trick fixes the problem.</span>
   tempBackground = !P.Background
   tempColor = !P.Color
   retain = (StrUpCase(!Version.OS_Family) EQ 'UNIX') ? 2 : 1
   histo_draw = Widget_Draw(histo_tlb, XSize=histXsize, YSize=histYsize, $
        Button_Events=1, Event_Pro='cgStretch_Process_Events', RETAIN=retain)
   !P.Background = Temporary(tempBackground)
   !P.Color = Temporary(tempColor)
   controlID = Widget_Button(menubaseID, Value='Controls', Event_Pro='cgStretch_MaxValue')
   openit = Widget_Button(controlID, Value='Open', /MENU)
   dummy = Widget_Button(openit, Value='Formatted Image File...', Event_Pro='cgStretch_OpenImage')
   dummy = Widget_Button(openit, Value='Raw Binary Image File...', Event_Pro='cgStretch_OpenImage')
   mainsaveID = Widget_Button(controlID, Value='Save as Main IDL Variable', /Menu, Event_Pro='cgSTRETCH_SAVETOMAIN')
   dummy = Widget_Button(mainsaveID, Value='Stretched Image', UValue='IMAGE')
   dummy = Widget_Button(mainsaveID, Value='Stretched Histogram', UValue='HISTOGRAM')
   dummy = Widget_Button(mainsaveID, Value='Current Stretch Parameters (structure)', UValue='PARAMETERS')
   dummy = Widget_Button(mainsaveID, Value='All Stretch Information (structure)', UValue='EVERYTHING')
   saveAs = Widget_Button(controlID, Value='Save Image As', Event_Pro="cgStretch_SaveAs", /Menu)
   dummy = Widget_Button(saveAs, Value='BMP File', UValue='BMP')
   dummy = Widget_Button(saveAs, Value='JPEG File', UValue='JPEG')
   dummy = Widget_Button(saveAs, Value='PNG File', UValue='PNG')
   dummy = Widget_Button(saveAs, Value='PICT File', UValue='PICT')
   dummy = Widget_Button(saveAs, Value='TIFF File', UValue='TIFF')
   IF havegif THEN dummy = Widget_Button(saveAs, Value='GIF File', UValue='GIF')
   dummy = Widget_Button(saveAs, Value='PostScript File', UValue='PS')
   saveHistoAs = Widget_Button(controlID, Value='Save Histogram As', Event_Pro="cgStretch_SaveHistoAs", /Menu)
   dummy = Widget_Button(saveHistoAs, Value='BMP File', UValue='BMP')
   dummy = Widget_Button(saveHistoAs, Value='JPEG File', UValue='JPEG')
   dummy = Widget_Button(saveHistoAs, Value='PNG File', UValue='PNG')
   dummy = Widget_Button(saveHistoAs, Value='PICT File', UValue='PICT')
   dummy = Widget_Button(saveHistoAs, Value='TIFF File', UValue='TIFF')
   IF havegif THEN dummy = Widget_Button(saveHistoAs, Value='GIF File', UValue='GIF')
   dummy = Widget_Button(saveHistoAs, Value='PostScript File', UValue='PS')
   printit = Widget_Button(controlID, Value='Print...', Event_Pro='cgStretch_Print', /MENU)
   dummy = Widget_Button(printit, Value='Image', UValue='IMAGE')
   dummy = Widget_Button(printit, Value='Histogram', UValue='HISTOGRAM')

   maxID = Widget_Button(controlID, Value='Max Pixel Density', /Menu, /Separator)
   dummy = Widget_Button(maxID, Value='0.005', UValue=0.005, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.010', UValue=0.010, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.025', UValue=0.025, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.050', UValue=0.050, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.075', UValue=0.075, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.100', UValue=0.1, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.200', UValue=0.2, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.300', UValue=0.3, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.400', UValue=0.4, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.500', UValue=0.5, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.600', UValue=0.6, /CHECKED_MENU)
   pixelDensityID = Widget_Button(maxID, Value='0.700', UValue=0.7, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.800', UValue=0.8, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='0.900', UValue=0.9, /CHECKED_MENU)
   dummy = Widget_Button(maxID, Value='1.000', UValue=1.0, /CHECKED_MENU)
   Widget_Control, pixelDensityID, Set_Button=1
   colorsID = Widget_Button(controlID, Value='Image Colors...', $
      Event_Pro='cgStretch_Colors', /Separator)
   button = Widget_Button(controlID, Value='Negative Image', Dynamic_Resize=1, Event_Pro='cgStretch_Negative')
   button = Widget_Button(controlID, Value='Flip Image', Event_Pro='cgStretch_FlipImage')
   button = Widget_Button(controlID, Value='Restore Original Stretch', Event_Pro='cgStretch_Restore', /Separator)
   quitter = Widget_Button(controlID, Value='Quit', $
      Event_Pro='cgStretch_Quit', /Separator)

   <span class="comments">; Stretch TYPE buttons.</span>
   paramBaseID = Widget_Base(histo_tlb, XPAD=0, YPAD=0, Column=1, Base_Align_Left=1)
   rowID = Widget_Base(paramBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10)
   types = StrUpCase(['Linear', 'Linear 2%', 'Gamma', 'Log', 'Square Root', 'Asinh', $
        'Equalization', 'Adaptive Equalization', 'Gaussian'])
   index = Where(types EQ type) <span class="comments">; Necessary for backward compatibility and for my ordering in pull-down.</span>
   scaleID = FSC_Droplist(rowID, Title='Scaling: ', Spaces=1, $
      Value=['Linear', 'Linear 2%', 'Gamma', 'Log', 'Square Root', 'Asinh', $
        'Equalization', 'Adaptive Equalization','Gaussian', 'StdDev'], $
      Event_Pro='cgStretch_StretchType')
   scaleID -> SetIndex, index[0] > 0

   minthreshObj = FSC_InputField(rowID, Title='Min: ', Value=Float(minThresh), $
      /FloatValue, Event_Pro='cgStretch_SetThreshold', UValue='MINTHRESH', $
      XSize=10, /CR_Only)

   maxthreshObj = FSC_InputField(rowID, Title='Max: ', Value=Float(maxThresh) , $
      /FloatValue, Event_Pro='cgStretch_SetThreshold', UValue='MAXTHRESH', $
      XSize=10, /CR_Only)

   <span class="comments">; Create the control base widgets.</span>
   controlBaseID = Widget_Base(paramBaseID, XPAD=0, YPAD=0)

         <span class="comments">; LOG controls.</span>
         logBaseID = Widget_Base(controlBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10, Map=0)
         param1Obj = FSC_InputField(logBaseID, Title='Mean: ', Value=mean, /Positive, $
            /FoatValue, Event_Pro='cgStretch_Parameters', /CR_Only, XSize=10)
         param2Obj = FSC_InputField(logBaseID, Title='Exponent: ', Value=exponent, /Positive, $
            /FloatValue, Event_Pro='cgStretch_Parameters', /CR_Only, XSize=10)

         <span class="comments">; GAMMA controls.</span>
         gammaBaseID = Widget_Base(controlBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10, Map=0)
         label = Widget_Label(gammaBaseID, Value='Gamma: ', /Dynamic_Resize)
         gammas = ['0.040', '0.100', '0.200', '0.400', '0.667', '1.00', '1.500', '2.500', '5.000', '10.00', '25.00']
         gamma_comboID = Widget_Combobox(gammaBaseID, /Editable, Value=gammas, UVALUE='GAMMA', $
                   Event_Pro='cgStretch_Parameters')
         index = Where(gammas EQ gamma, count)
         IF count EQ 0 THEN BEGIN
            Widget_Control, gamma_comboID, Combobox_AddItem=StrTrim(gamma,2), ComboBox_Index=0
         ENDIF ELSE Widget_Control, gamma_comboID, Set_Combobox_Select=index[0]

         <span class="comments">; ASINH controls.</span>
         asinhBaseID = Widget_Base(controlBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10, Map=0)
         label = Widget_Label(asinhBaseID, Value='Beta: ', /Dynamic_Resize)
         betas = ['0.0', '0.1', '0.5', '1.0', '3.0', '5.0', '10.0', '50.0', '100.0']
         asinh_comboID = Widget_Combobox(asinhBaseID, /Editable, Value=betas, $
            UVALUE='ASINH', Event_Pro='cgStretch_Parameters')
         index = Where(betas EQ beta, count)
         IF count EQ 0 THEN BEGIN
            Widget_Control, asinh_comboID, Combobox_AddItem=cgNumber_Formatter(beta,Decimals=2), ComboBox_Index=0
         ENDIF ELSE Widget_Control, asinh_comboID, Set_Combobox_Select=index[0]

         <span class="comments">; GAUSSIAN controls.</span>
         gaussBaseID = Widget_Base(controlBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10, Map=0)
         sigmaObj = FSC_InputField(gaussBaseID, Title='Sigma: ', Value=sigma, /Positive, $
            /FoatValue, Event_Pro='cgStretch_Parameters', /CR_Only, XSize=10)

         <span class="comments">; STDDEV controls.</span>
         stddevBaseID = Widget_Base(controlBaseID, XPAD=0, YPAD=0, ROW=1, SPACE=10, Map=0)
         multiplierObj = FSC_InputField(stddevBaseID, Title='Multiplier: ', Value=multiplier, /Positive, $
            /FoatValue, Event_Pro='cgStretch_Parameters', /CR_Only, XSize=10)

   <span class="comments">; Realize the proper controls.</span>
   CASE type OF
      'LOG': BEGIN
         Widget_Control, logBaseID, Map=1
         currentMappedBase = logBaseID
         END
      'GAMMA': BEGIN
         Widget_Control, gammaBaseID, Map=1
         currentMappedBase = gammaBaseID
         END
      'ASINH': BEGIN
         Widget_Control, asinhBaseID, Map=1
         currentMappedBase = asinhBaseID
         END
      'GAUSSIAN': BEGIN
         Widget_Control, gaussBaseID, Map=1
         currentMappedBase = gaussBaseID
         END      
      'STDDEV': BEGIN
         Widget_Control, stddevBaseID, Map=1
         currentMappedBase = stddevBaseID
         END      
      ELSE: currentMappedBase = -1L
   ENDCASE
   Widget_Control, histo_tlb, /Realize

   <span class="comments">; Create a pixmap window for moving and erasing the histogram</span>
   <span class="comments">; threshold bars.</span>
   Window, XSize=histXsize, YSize=histYsize, /Free, /Pixmap
   pixmap = !D.Window

   <span class="comments">; Create an image window for displaying the image.</span>
   IF NOT Keyword_Set(no_window) THEN BEGIN

      Widget_Control, histo_tlb, TLB_Get_Offset=offsets, TLB_Get_Size=sizes
      xoff = offsets[0] + sizes[0] + 20
      yoff = offsets[1]
      aspect = Float(xsize)/ysize
      IF xsize GT 512 OR ysize GT 512 THEN BEGIN
         IF xsize NE ysize THEN BEGIN
            aspect = Float(ysize) / xsize
            IF aspect LT 1 THEN BEGIN
               xsize = 512
               ysize = (512 * aspect) &lt<span class="comments">; 512</span>
            ENDIF ELSE BEGIN
               ysize = 512
               xsize = (512 / aspect) &lt<span class="comments">; 512</span>
            ENDELSE
         ENDIF ELSE BEGIN
            ysize = 512
            xsize = 512
         ENDELSE
      ENDIF
      image_tlb = Widget_Base(Row=1, Group_Leader=histo_tlb, Title='cgStretch Image', $
         XOffSet=xoff, YOffSet=yoff, TLB_Size_Events=1, XPad=0, YPad=0)

      <span class="comments">; Create draw widget. UNIX versions of IDL have a bug in which creating</span>
      <span class="comments">; a draw widget as the very first window in an IDL session causes both</span>
      <span class="comments">; !P.Background and !P.Color to be set to white. I know, it's odd. But</span>
      <span class="comments">; doing this little trick fixes the problem.</span>
      tempBackground = !P.Background
      tempColor = !P.Color
      retain = (StrUpCase(!Version.OS_Family) EQ 'UNIX') ? 2 : 1
      image_draw = Widget_Draw(image_tlb, XSize=xsize, YSize=ysize, RETAIN=retain, $
         Kill_Notify='cgStretch_ImageWindowKilled', UValue=[saveAs, printit, colorsID])
      !P.Background = Temporary(tempBackground)
      !P.Color = Temporary(tempColor)

      Widget_Control, image_tlb, /Realize

      <span class="comments">; Get window index numbers for the draw widgets.</span>
      Widget_Control, image_draw, Get_Value=windex

     <span class="comments">; If this window closes, the whole application exits.</span>
     Widget_Control, histo_tlb, Group_Leader=image_tlb

   ENDIF ELSE BEGIN

      <span class="comments">; Must have values for info structure.</span>
      image_tlb = -1L
      image_draw = -1L
      windex = -1L

   ENDELSE

   <span class="comments">; Need identifier of histogram window.</span>
   Widget_Control, histo_draw, Get_Value=histo_wid

   <span class="comments">; Load the color table.</span>
   IF N_Elements(palette) EQ 0 THEN $
      cgLoadCT, 0 > ctable &lt<span class="comments">; 40, Brewer=brewer ELSE $</span>
      TVLCT, palette
   TVLCT, r, g, b, /Get

   <span class="comments">; Start with no stretch on both ends.</span>
   maxVal = Max(Double(*image)) > maxthresh
   minVal = Min(Double(*image)) &lt<span class="comments">; minthresh</span>
   range = maxVal - minVal

   <span class="comments">; Calculate a value to tell you if you are "close" to a threshold line.</span>
   close = 0.05 * (maxval-minval)

   <span class="comments">; How big is the parameter base.</span>
   geo = Widget_Info(paramBaseID, /Geometry)
   pbase_ysize = geo.scr_ysize + 2
   min_xsize = geo.scr_xsize
   IF N_Elements(exclude) NE 0 THEN exclude=Ptr_New(exclude) ELSE exclude=Ptr_New(/ALLOCATE_HEAP)

   <span class="comments">; Make an info structure with all info to run the program.</span>
   info = {image:image, $                   <span class="comments">; A pointer to the image data</span>
           minThresh:minThresh, $           <span class="comments">; The minimum threshold</span>
           maxThresh:maxThresh, $           <span class="comments">; The maximum threshold</span>
           maxValue:maxValue, $             <span class="comments">; The MAX_VALUE for the Histogram Plot.</span>
           colors: colors, $                <span class="comments">; The histogram plot drawing colors.</span>
           exclude: exclude, $              <span class="comments">; The value to exclude in a STDDEV stretch.</span>
           histo_wid:histo_wid, $           <span class="comments">; The histogram window index number</span>
           histo_draw:histo_draw, $         <span class="comments">; The histogram draw widget ID.</span>
           image_draw:image_draw, $         <span class="comments">; The image draw widget ID.</span>
           windex:windex, $                 <span class="comments">; The image window index</span>
           ymin:!Y.CRange[0], $                     <span class="comments">; The ymin in data coordinates</span>
           ymax:!Y.CRange[1], $                     <span class="comments">; The ymax in data coordinates</span>
           xmin:!X.CRange[0], $                     <span class="comments">; The xmin in data coordinates</span>
           xmax:!X.CRange[1], $                     <span class="comments">; The xmax in data coordinates</span>
           r:r, $                           <span class="comments">; The R color vector for the image</span>
           g:g, $                           <span class="comments">; The G color vector for the image</span>
           b:b, $                           <span class="comments">; The B color vector for the image</span>
           pbang:!P, $                   <span class="comments">; The !P system variable.</span>
           xbang:!X, $                   <span class="comments">; The !X system variable.</span>
           ybang:!Y, $                   <span class="comments">; The !Y system variable.</span>
           lineby:'MIN', $                  <span class="comments">; The line you are close to.</span>
           linex:minThresh, $               <span class="comments">; The x coordinate of line (data coords).</span>
           pixmap:pixmap, $                 <span class="comments">; The pixmap window index</span>
           minval:minval, $                 <span class="comments">; The minimum intensity value of the data</span>
           maxval:maxval, $                 <span class="comments">; The maximum intensity value of the data</span>
           multiplier:multiplier, $         <span class="comments">; The multiplier for a STDDEV stretch.</span>
           notify_pro:notify_pro, $         <span class="comments">; The name of a procedure to notify when the image is stretched.</span>
           notify_obj:notify_obj, $         <span class="comments">; The object reference and method to notify when image is stretched.</span>
           no_window:no_window, $           <span class="comments">; A flag that, if set, means no image window.</span>
           extra:extra, $                   <span class="comments">; The extra keywords for the Plot command.</span>
           pix_xsize:histXsize, $           <span class="comments">; The X size of the pixmap.</span>
           pix_ysize:histYsize, $           <span class="comments">; The Y size of the pixmap.</span>
           pixelDensityID:pixelDensityID, $ <span class="comments">; The ID of the current pixel density button.</span>
           newPointer:newPointer, $         <span class="comments">; A flag that indicates if we made a pointer or not.</span>
           saveAs:saveAs, $                 <span class="comments">; The SaveAs button widget identifier.</span>
           printIt:printIt, $               <span class="comments">; The Print button widget identifier.</span>
           gamma: gamma, $                  <span class="comments">; The gamma value.</span>
           beta: beta, $                    <span class="comments">; The "softenting parameter" for ASINH scaling.</span>
           logBaseID: logBaseID, $          <span class="comments">; The base widget ID of the LOG parameters.</span>
           gammaBaseID: gammaBaseID, $      <span class="comments">; The base widget ID of the GAMMA parameters.</span>
           asinhBaseID: asinhBaseID, $      <span class="comments">; The base widget ID of the ASINH parameters.</span>
           gaussBaseID: gaussBaseID, $      <span class="comments">; The base widget ID of the GAUSSIAN parameters.</span>
           stddevBaseID: stddevBaseID, $    <span class="comments">; The base widget ID of the STDEV parameters.</span>
           currentMappedBase: currentMappedBase, $ The current base mapped into the control base.
           exponent: exponent, $            <span class="comments">; The exponent value.</span>
           mean: mean, $                    <span class="comments">; The mean value.</span>
           param1Obj: param1Obj, $          <span class="comments">; The first parameter widget.</span>
           param2Obj: param2Obj, $          <span class="comments">; The second parameter widget.</span>
           gamma_comboID: gamma_comboID, $  <span class="comments">; The gamma control combobox widget ID.</span>
           asinh_comboID: asinh_comboID, $  <span class="comments">; The asinh control combobox widget ID.</span>
           pbase_ysize: pbase_ysize, $      <span class="comments">; The y size of the parameter base.</span>
           min_xsize: min_xsize, $          <span class="comments">; The minimum X size for the draw widget.</span>
           negative: negative, $            <span class="comments">; Want a negative image.</span>
           type: type, $                    <span class="comments">; The type of scaling requested.</span>
           datatype: datatype, $            <span class="comments">; The data type of the input image.</span>
           minthreshObj: minthreshObj, $    <span class="comments">; The minThresh object widget.</span>
           maxthreshObj: maxthreshObj, $    <span class="comments">; The maxThresh object widget.</span>
           sigmaObj: sigmaObj, $            <span class="comments">; The sigma object widget.</span>
           multiplierObj: multiplierObj, $  <span class="comments">; The multiplier object widget.</span>
           sigma: sigma, $                  <span class="comments">; The sigma value for Gaussian stretch.</span>
           event_handler: "", $             <span class="comments">; The name of the event handler processing the event</span>
           colorsID:colorsID, $             <span class="comments">; The Image Colors button widget identifier.</span>
           range: range, $                  <span class="comments">; The image data range.</span>
           scaleID:scaleID, $               <span class="comments">; The droplist that display scale type.</span>
           brewer:brewer, $                 <span class="comments">; A flag that indicates the Brewer color tables should be used.</span>
           uvalue:uvalueptr, $              <span class="comments">; A pointer to the user value (may be undefined variable).</span>
           close:close}                     <span class="comments">; A value to indicate closeness to line</span>

   <span class="comments">; Scale the image. Special processing for linear 2%.</span>
   CASE type OF 
      'LINEAR 2%': BEGIN
   
            <span class="comments">; Calculate binsize.</span>
            maxr = Max(Double(*info.image), MIN=minr, /NAN)
            range = maxr - minr
            CASE Size(*info.image, /TName) OF
                'BYTE': binsize = 1
                'INT': binsize = 1 > Round(range / 300.)
                'LONG': binsize = 1 > Round(range / 300.)
                'UINT': binsize = 1 > Round(range / 300.)
                'ULONG': binsize = 1 > Round(range / 300.)
                'LONG64': binsize = 1 > Round(range / 300.)
                'ULONG64': binsize = 1 > Round(range / 300.)
                ELSE: binsize = range / 300.
            ENDCASE
            h = Histogram(/NAN, *info.image, BINSIZE=binsize, OMIN=omin, OMAX=omax)
            n = N_Elements(*info.image)
            cumTotal = Total(h, /CUMULATIVE)
            minIndex = Value_Locate(cumTotal, n * 0.02)
            IF minIndex EQ -1 THEN minIndex = 0
            WHILE cumTotal[minIndex] EQ cumTotal[minIndex + 1] DO BEGIN
                 minIndex = minIndex + 1
            ENDWHILE
            info.minThresh = minIndex * binsize + omin

            maxIndex  = Value_Locate(cumTotal, n * 0.98)
            WHILE cumTotal[maxIndex] EQ cumTotal[maxIndex - 1] DO BEGIN
                maxIndex = maxIndex - 1
            ENDWHILE
            info.maxThresh = maxIndex * binsize + omin
   
            END
        
        'SQUARE ROOT': BEGIN
            min = Min(SQRT(*info.image), MAX=max)
            info.minThresh = min
            info.maxThresh = max
            END
            
        ELSE: 
        
   ENDCASE
   displayImage = cgStretch_ScaleImage(info)
   minThresh = info.minThresh
   maxThresh = info.maxThresh
   
   <span class="comments">; Draw the histogram. Keep this in FRONT of storing plotting system variables!</span>
   WSet, histo_wid
   cgStretch_Histoplot, info, WID=histo_wid, $
      MaxValue=maxValue, _Extra=*extra

   <span class="comments">; Put the same plot in the pixmap.</span>
   WSet, pixmap
   Device, Copy=[0, 0, histXsize, histYsize, 0, 0, histo_wid]

   <span class="comments">; Store the plotting system variables for later recall.</span>
   info.pbang = !P
   info.xbang = !X
   info.ybang = !Y
   info.ymin = !Y.CRange[0]
   info.ymax = !Y.CRange[1]
   info.xmin = !X.CRange[0]
   info.xmax = !X.CRange[1]

   <span class="comments">; Display the image.</span>
   IF NOT Keyword_Set(no_window) THEN BEGIN
      WSet, windex
      cgLoadCT, ctable, Brewer=brewer
      WShow, windex
      cgImage, displayImage, /NoInterp, _Extra=*extra
   ENDIF

   <span class="comments">; Set proper threshold values.</span>
   minThreshObj -> Set_Value, cgSTRETCH_VALIDATE_THRESHOLD(minThresh, info), /FloatValue
   maxThreshObj -> Set_Value, cgSTRETCH_VALIDATE_THRESHOLD(maxThresh, info), /FloatValue

   <span class="comments">; Draw threshold lines.</span>
   cgStretch_DrawLines, minThresh, maxThresh, info

   <span class="comments">; Notify others of image change.</span>
   info.event_handler = 'cgSTRETCH_STRETCHTYPE'
   cgStretch_NotifyOthers, info

   <span class="comments">; Save a pointer to the current set up, so you can restore it, if necessary.</span>
   originalSetup = Ptr_New(info)
   info = Create_Struct(info, 'originalSetup', originalSetup)

   <span class="comments">; Save the info structure and bring the histogram window forward with SHOW.</span>
   Widget_Control, histo_tlb, Set_UValue=info, /No_Copy, /Show
   IF cWinID GE 0 THEN WSet, cWinID
   

   IF NOT no_window THEN BEGIN
      Widget_Control, image_tlb, Set_UValue=histo_tlb
      XManager, 'cgstretch_image', image_tlb, Event_Handler='cgStretch_Image_Resize', $
         No_Block=1
   ENDIF
   XManager, 'cgstretch', histo_tlb, Group=group, No_Block=1-Keyword_Set(block), $
      Event_Handler='cgStretch_Histogram_Resize', Cleanup='cgStretch_Cleanup'

END
</code>
    </div>
  </body>
</html>