<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:15 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>xcolors.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="xcolors.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   XColors</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The purpose of this routine is to interactively change color tables</span>
<span class="comments">;   in a manner similar to XLOADCT. No common blocks are used so</span>
<span class="comments">;   multiple copies of XCOLORS can be on the display at the same</span>
<span class="comments">;   time (if each has a different TITLE). XCOLORS has the ability</span>
<span class="comments">;   to notify a widget event handler, an object method, or an IDL</span>
<span class="comments">;   procedure if and when a new color table has been loaded. Brewer</span>
<span class="comments">;   color tables can also be accessed from this program, if the file</span>
<span class="comments">;   fsc_brewer.tbl can be found somewhere in your IDL path.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 1997-2012, by Fanning Software Consulting, Inc. All rights reserved.      ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of this program is to interactively change color tables</span>
<span class="comments">; in a manner similar to XLoadCT. No common blocks are used so</span>
<span class="comments">; multiple copies of XColors can be on the display at the same</span>
<span class="comments">; time (if each has a different `Title`). XColors has the ability</span>
<span class="comments">; to notify a widget event handler, an object method, or an IDL</span>
<span class="comments">; procedure if and when a new color table has been loaded. Brewer</span>
<span class="comments">; color tables can also be accessed from this program, if the file</span>
<span class="comments">; fsc_brewer.tbl can be found somewhere in your IDL path.</span>
<span class="comments">;</span>
<span class="comments">; Events are sent to widgets if the `NotifyID` keyword is used. Object </span>
<span class="comments">; methods are called if the `NotifyObj` keyword is used. This program </span>
<span class="comments">; is a non-blocking widget unless the `Block` keyword is set.</span>
<span class="comments">; </span>
<span class="comments">; .. image:: xcolors.png</span>
<span class="comments">; </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    To load a color table into 100 colors, starting at color index</span>
<span class="comments">;     50 and send an event to the widget identified at info.drawID</span>
<span class="comments">;     in the widget heirarchy of the top-level base event.top, type::</span>
<span class="comments">;        XCOLORS, NCOLORS=100, BOTTOM=50, NOTIFYID=[info.drawID, event.top]</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Change History::</span>
<span class="comments">;       Written by David W. Fanning, 15 April 97. </span>
<span class="comments">;       Added OBJECT_DATA keyword so that I can get additional information</span>
<span class="comments">;           about the state of the color table tool into object methods. 21 October 2008. DWF.</span>
<span class="comments">;       Add REVERSE keyword and Reverse Color Table button. 12 April 2009. DWF.</span>
<span class="comments">;       In looking for a Brewer color table file, I replaced all FILE_WHICH </span>
<span class="comments">;           commands with FIND_RESOURCE_FILE commands. 28 April 2009. DWF.</span>
<span class="comments">;       Made sure all "NOTIFY" data structures have both a "REVERSED" and </span>
<span class="comments">;           "BREWER" field in them to indicate the status of the XCOLORS program. Also </span>
<span class="comments">;           inproved the documentation and made it more accurate. 20 Sept 2009. DWF.</span>
<span class="comments">;       Still a few problems getting the Brewer color tables completely integrated. </span>
<span class="comments">;           Fixed several bugs with updating color table names and type. 14 Oct 2009. DWF.</span>
<span class="comments">;       Modified the program to work correctly with a user-supplied color table file. 29 Sept 2010. DWF.</span>
<span class="comments">;       Fixed a problem I noticed when starting the program with reversed color tables. The </span>
<span class="comments">;            initial colors were incorrect on subsequent calls. Also made a modification so that </span>
<span class="comments">;            color index -1 as input is handled properly (ignored). 26 November 2010. DWF.</span>
<span class="comments">;       Added WINDOW and WINID keywords. 26 January 2011. DWF.</span>
<span class="comments">;       Changed several Get_Decomposed calls to the more generic SetDecomposedState. 15 Jan 2012. DWF.</span>
<span class="comments">;       </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 1997-2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; This routines is identical to the IDL Congrid command, except that it </span>
<span class="comments">; handles a problem with floating divides by zero properly.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    arr: in, required</span>
<span class="comments">;       The input array to be resized.</span>
<span class="comments">;    x: in, required</span>
<span class="comments">;       The X dimension of the output.</span>
<span class="comments">;    y: in, optional</span>
<span class="comments">;       The Y dimension of the output.</span>
<span class="comments">;    z: in, optional</span>
<span class="comments">;       The Z dimension of the output.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    cubic: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to perform cubic convolution interpolation rather than nearest neighbor</span>
<span class="comments">;       interpolation.</span>
<span class="comments">;    interp: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to do bilinear interpolation rather than nearest neighbor interpolation.</span>
<span class="comments">;    minus_one: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to prevent extrapolating one row or column beyond the bounds of the input.</span>
<span class="comments">;-</span>
Function XColors_Congrid, arr, x, y, z, CUBIC = cubic, INTERP=int, MINUS_ONE=m1

    ON_ERROR, 2      <span class="comments">;Return to caller if error</span>
    s = Size(arr)

    if ((s[0] eq 0) or (s[0] gt 3)) then $
      Message, 'Array must have 1, 2, or 3 dimensions.'

    <span class="comments">;;  Supply defaults = no interpolate, and no minus_one.</span>
    if (N_ELEMENTS(int) le 0) then int = 0 else int = KEYWORD_SET(int)
    if (N_ELEMENTS(m1) le 0) then m1 = 0 else m1 = KEYWORD_SET(m1)
    if (N_ELEMENTS(cubic) eq 0) then cubic = 0
    if (cubic ne 0) then int = 1 <span class="comments">;Cubic implies interpolate</span>


    case s[0] of
        1: begin                <span class="comments">; *** ONE DIMENSIONAL ARRAY</span>
            <span class="comments">; DWF modified: Check divide by zero.</span>
            srx = float(s[1] - m1)/((x-m1) > 1e-6) * findgen(x) <span class="comments">;subscripts</span>
            if (int) then $
              return, INTERPOLATE(arr, srx, CUBIC = cubic) else $
              return, arr[ROUND(srx)]
        endcase
        2: begin                <span class="comments">; *** TWO DIMENSIONAL ARRAY</span>
            if (int) then begin
                srx = float(s[1] - m1) / ((x-m1) > 1e-6) * findgen(x)
                sry = float(s[2] - m1) / ((y-m1) > 1e-6) * findgen(y)
                return, INTERPOLATE(arr, srx, sry, /GRID, CUBIC=cubic)
            endif else $
              return, POLY_2D(arr, $
                              [[0,0],[(s[1]-m1)/(float(x-m1) > 1e-6),0]], $ <span class="comments">;Use poly_2d</span>
                              [[0,(s[2]-m1)/(float(y-m1) > 1e-6)],[0,0]],int,x,y)

        endcase
        3: begin                <span class="comments">; *** THREE DIMENSIONAL ARRAY</span>
            srx = float(s[1] - m1) / ((x-m1) > 1e-6) * findgen(x)
            sry = float(s[2] - m1) / ((y-m1) > 1e-6) * findgen(y)
            srz = float(s[3] - m1) / ((z-m1) > 1e-6) * findgen(z)
            return, interpolate(arr, srx, sry, srz, /GRID)
        endcase
    endcase

    return, arr_r
END <span class="comments">; ***************************************************************</span>


<span class="comments">;+</span>
<span class="comments">; Define a structure for notifying an object method.</span>
<span class="comments">;-</span>
PRO XColors_NotifyObj__Define

   <span class="comments">; Structure definition module for object notification.</span>

struct = {  XColors_NotifyObj, $  <span class="comments">; The structure name.</span>
            object:Obj_New(),  $  <span class="comments">; The object to notify.</span>
            method:'' }           <span class="comments">; The name of the object method to call.</span>

END <span class="comments">; ***************************************************************</span>


<span class="comments">;+</span>
<span class="comments">; Set the new colors for the program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     info: in, required, type=structure</span>
<span class="comments">;         The information structure for the widget program, containing all the</span>
<span class="comments">;         information needed to run the program.</span>
<span class="comments">;-</span>
PRO XColors_Set, info

    TVLCT, r, g, b, /Get
    
       <span class="comments">; Is the color table reversed?</span>
       
    reverseSet = Widget_Info(info.reverseID, /BUTTON_SET)
    
       <span class="comments">; Make sure the current bottom index is less than the current top index.</span>
    
    IF info.currentbottom GE info.currenttop THEN BEGIN
       temp = info.currentbottom
       info.currentbottom = info.currenttop
       info.currenttop = temp
    ENDIF
    
    IF reverseSet THEN BEGIN
        r(info.bottom:info.currentbottom) = info.topcolor(0)
        g(info.bottom:info.currentbottom) = info.topcolor(1)
        b(info.bottom:info.currentbottom) = info.topcolor(2)
        r(info.currenttop:info.top) = info.bottomcolor(0)
        g(info.currenttop:info.top) = info.bottomcolor(1)
        b(info.currenttop:info.top) = info.bottomcolor(2)
    ENDIF ELSE BEGIN
        r(info.bottom:info.currentbottom) = info.bottomcolor(0)
        g(info.bottom:info.currentbottom) = info.bottomcolor(1)
        b(info.bottom:info.currentbottom) = info.bottomcolor(2)
        r(info.currenttop:info.top) = info.topcolor(0)
        g(info.currenttop:info.top) = info.topcolor(1)
        b(info.currenttop:info.top) = info.topcolor(2)
    ENDELSE
    
    red = info.r
    green = info.g
    blue = info.b
    number = ABS((info.currenttop-info.currentbottom) + 1)
    
    gamma = info.gamma
    index = Findgen(info.ncolors)
    distribution = index^gamma > 10e-6
    index = Round(distribution * (info.ncolors-1) / (Max(distribution) > 10e-6))
    
    IF info.currentbottom GE info.currenttop THEN BEGIN
       temp = info.currentbottom
       info.currentbottom = info.currenttop
       info.currenttop = temp
    ENDIF
    
    IF info.reversed EQ 0 THEN BEGIN
       IF reverseSet THEN BEGIN
           r(info.currentbottom:info.currenttop) = Reverse(XColors_Congrid(red(index), number, /Minus_One))
           g(info.currentbottom:info.currenttop) = Reverse(XColors_Congrid(green(index), number, /Minus_One))
           b(info.currentbottom:info.currenttop) = Reverse(XColors_Congrid(blue(index), number, /Minus_One))   
       ENDIF ELSE BEGIN
           r(info.currentbottom:info.currenttop) = XColors_Congrid(red(index), number, /Minus_One)
           g(info.currentbottom:info.currenttop) = XColors_Congrid(green(index), number, /Minus_One)
           b(info.currentbottom:info.currenttop) = XColors_Congrid(blue(index), number, /Minus_One)
       ENDELSE
    ENDIF ELSE BEGIN
       r(info.currentbottom:info.currenttop) = $
          Reverse(XColors_Congrid(red(index), number, /Minus_One))
       g(info.currentbottom:info.currenttop) = $
          Reverse(XColors_Congrid(green(index), number, /Minus_One))
       b(info.currentbottom:info.currenttop) = $
          Reverse(XColors_Congrid(blue(index), number, /Minus_One))
    ENDELSE
    
    TVLCT, r, g, b
    WSet, info.windowindex
    SetDecomposedState, 0, Current=theState
    TV, info.colorimage
    Device, Decomposed=theState
    WSet, info.thisWindow
    
    (*info.colorInfoPtr).R = r
    (*info.colorInfoPtr).G = g
    (*info.colorInfoPtr).B = b
    (*info.colorInfoPtr).name = info.ctname
    (*info.colorInfoPtr).index = info.index
    (*info.colorInfoPtr).type = info.colortabletype
    (*info.colorInfoPtr).reversed = reverseSet
    IF (*info.colorInfoPtr).type EQ 'BREWER' $
        THEN (*info.colorInfoPtr).brewer = 1 $
        ELSE (*info.colorInfoPtr).brewer = 0
    
       <span class="comments">; Don't bother with notification if this is just a color</span>
       <span class="comments">; protection event.</span>
    
    IF info.from EQ 'PROTECT' THEN RETURN
    
       <span class="comments">; Are there widgets to notify?</span>
    
    s = SIZE(info.notifyID)
    IF s(0) EQ 1 THEN count = 0 ELSE count = s(2)-1
    FOR j=0,count DO BEGIN
       colorEvent = { XCOLORS_LOAD, $            <span class="comments">;</span>
                      ID:info.notifyID(0,j), $   <span class="comments">;</span>
                      TOP:info.notifyID(1,j), $
                      HANDLER:0L, $
                      R:r, $
                      G:g, $
                      B:b, $
                      index:info.index, $
                      name:info.ctname, $
                      type:info.colortabletype, $
                      brewer:info.brewer, $
                      reversed:info.reversed }
       IF Widget_Info(info.notifyID(0,j), /Valid_ID) THEN $
          Widget_Control, info.notifyID(0,j), Send_Event=colorEvent
    ENDFOR
    
       <span class="comments">; Is there an object to notify?</span>
    
    nelements = SIZE(info.notifyobj, /N_Elements)
    FOR j=0,nelements-1 DO BEGIN
       IF Obj_Valid((info.notifyobj)[j].object) THEN BEGIN
          IF N_Elements(*info.xcolorsData) EQ 0 THEN BEGIN
             s = Size(*info.extra)
             IF s[s[0]+1] EQ 0 THEN BEGIN
                IF info.object_data $
                   THEN Call_Method, (info.notifyobj)[j].method, $
                         (info.notifyobj)[j].object, $
                         XCOLORS_DATA=*info.colorInfoPtr $
                   ELSE Call_Method, (info.notifyobj)[j].method, ($
                         info.notifyobj)[j].object
             ENDIF ELSE BEGIN
                IF info.object_data $
                   THEN Call_Method, (info.notifyobj)[j].method, $
                          (info.notifyobj)[j].object,_Strict_Extra=*info.extra, $
                          XCOLORS_DATA=*info.colorinfoptr $ 
                   ELSE Call_Method, (info.notifyobj)[j].method, $
                          (info.notifyobj)[j].object,_Strict_Extra=*info.extra
             ENDELSE
          ENDIF ELSE BEGIN
            s = Size(*info.extra)
            IF s[s[0]+1] EQ 0 THEN BEGIN
                IF info.object_data $
                   THEN Call_Method, (info.notifyobj)[j].method, $
                      (info.notifyobj)[j].object, DATA=*info.xcolorsData, $
                      XCOLORS_DATA=*info.colorinfoptr $ 
                   ELSE Call_Method, (info.notifyobj)[j].method, $
                      (info.notifyobj)[j].object, DATA=*info.xcolorsData
            ENDIF ELSE BEGIN
                IF info.object_data $
                   THEN Call_Method, (info.notifyobj)[j].method, $
                      (info.notifyobj)[j].object, DATA=*info.xcolorsData, $
                      _Strict_Extra=*info.extra, XCOLORS_DATA=*info.colorinfoptr  $
                   ELSE Call_Method, (info.notifyobj)[j].method, $
                      (info.notifyobj)[j].object, DATA=*info.xcolorsData, $
                      _Strict_Extra=*info.extra
            ENDELSE
          ENDELSE
       ENDIF
    ENDFOR
    
       <span class="comments">; Is there a procedure to notify?</span>
    
    IF info.notifyPro NE "" THEN BEGIN
       IF N_Elements(*info.xcolorsData) EQ 0 THEN BEGIN
          s = Size(*info.extra)
          IF s[s[0]+1] EQ 0 THEN BEGIN
             Call_Procedure, info.notifyPro
          ENDIF ELSE BEGIN
             Call_Procedure, info.notifyPro, _Strict_Extra=*info.extra
          ENDELSE
       ENDIF ELSE BEGIN
          s = Size(*info.extra)
          IF s[s[0]+1] EQ 0 THEN BEGIN
             Call_Procedure, info.notifyPro, DATA=*info.xcolorsData
          ENDIF ELSE BEGIN
             Call_Procedure, info.notifyPro, DATA=*info.xcolorsData, _Strict_Extra=*info.extra
          ENDELSE
       ENDELSE
    ENDIF

END <span class="comments">; ***************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the TOP slider. Modify the color table when</span>
<span class="comments">; the slider is moved.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_TOP_SLIDER, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
       <span class="comments">; Update the current top value of the slider.</span>
    
    currentTop = event.value
    Widget_Control, info.botSlider, Get_Value=currentBottom
    currentBottom = currentBottom + info.bottom
    currentTop = currentTop + info.bottom
    
       <span class="comments">; Error handling. Is currentBottom = currentTop?</span>
    
    IF currentBottom EQ currentTop THEN BEGIN
       currentBottom = (currentTop - 1) > 0
       thisValue = (currentBottom-info.bottom)
       IF thisValue LT 0 THEN BEGIN
          thisValue = 0
          currentBottom = info.bottom
       ENDIF
       Widget_Control, info.botSlider, Set_Value=thisValue
    ENDIF
    
       <span class="comments">; Error handling. Is currentBottom > currentTop?</span>
    
    IF currentBottom GT currentTop THEN BEGIN
    
       bottom = currentTop
       top = currentBottom
       bottomcolor = info.topColor
       topcolor = info.bottomColor
       reversed = 1
    
    ENDIF ELSE BEGIN
    
       bottom = currentBottom
       top = currentTop
       bottomcolor = info.bottomColor
       topcolor = info.topColor
       reversed = 0
    
    ENDELSE
    
       <span class="comments">; Create a pseudo structure.</span>
    
    pseudo = {currenttop:top, currentbottom:bottom, reversed:reversed, $
       bottomcolor:bottomcolor, topcolor:topcolor, gamma:info.gamma, index:info.index, $
       top:info.top, bottom:info.bottom, ncolors:info.ncolors, r:info.r, $
       g:info.g, b:info.b, notifyID:info.notifyID, colorimage:info.colorimage, $
       windowindex:info.windowindex, from:'TOP', notifyObj:info.notifyObj, extra:info.extra, $
       thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
       colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
       needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
       object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
    
       <span class="comments">; Update the colors.</span>
    
    XColors_Set, pseudo
    
    info.currentTop = currentTop
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the BOTTOM slider. Modify the color table when</span>
<span class="comments">; the slider is moved.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_BOTTOM_SLIDER, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
       <span class="comments">; Update the current bottom value of the slider.</span>
    
    currentBottom = event.value + info.bottom
    Widget_Control, info.topSlider, Get_Value=currentTop
    <span class="comments">;currentBottom = currentBottom + info.bottom</span>
    currentTop = currentTop + info.bottom
    
       <span class="comments">; Error handling. Is currentBottom = currentTop?</span>
    
    IF currentBottom EQ currentTop THEN BEGIN
       currentBottom = currentTop
       Widget_Control, info.botSlider, Set_Value=(currentBottom-info.bottom)
    ENDIF
    
       <span class="comments">; Error handling. Is currentBottom > currentTop?</span>
    
    IF currentBottom GT currentTop THEN BEGIN
    
       bottom = currentTop
       top = currentBottom
       bottomcolor = info.topColor
       topcolor = info.bottomColor
       reversed = 1
    
    ENDIF ELSE BEGIN
    
       bottom = currentBottom
       top = currentTop
       bottomcolor = info.bottomColor
       topcolor = info.topColor
       reversed = 0
    
    ENDELSE
    
       <span class="comments">; Create a pseudo structure.</span>
    
    pseudo = {currenttop:top, currentbottom:bottom, reversed:reversed, $
       bottomcolor:bottomcolor, topcolor:topcolor, gamma:info.gamma, index:info.index, $
       top:info.top, bottom:info.bottom, ncolors:info.ncolors, r:info.r, $
       g:info.g, b:info.b, notifyID:info.notifyID, colorimage:info.colorimage, $
       windowindex:info.windowindex, from:'BOTTOM', notifyObj:info.notifyObj, extra:info.extra, $
       thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
       colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
       needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
       object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
    
       <span class="comments">; Update the colors.</span>
    
    XColors_Set, pseudo
    
    info.currentBottom = currentBottom
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>




<span class="comments">;+</span>
<span class="comments">; The event handler for the GAMMA slider. Modify the color table when</span>
<span class="comments">; the slider is moved.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_GAMMA_SLIDER, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
       <span class="comments">; Get the gamma value from the slider.</span>
    
    Widget_Control, event.id, Get_Value=gamma
    gamma = 10^((gamma/50.0) - 1)
    
       <span class="comments">; Update the gamma label.</span>
    
    Widget_Control, info.gammaID, Set_Value=String(gamma, Format='(F6.3)')
    
       <span class="comments">; Make a pseudo structure.</span>
    
    IF info.currentBottom GT info.currentTop THEN $
       pseudo = {currenttop:info.currentbottom, currentbottom:info.currenttop, $
          reversed:1, bottomcolor:info.topcolor, topcolor:info.bottomcolor, $
          gamma:gamma, top:info.top, bottom:info.bottom, index:info.index, $
          ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
          notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
          windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
          thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
          colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
          needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
          object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer} $
    ELSE $
       pseudo = {currenttop:info.currenttop, currentbottom:info.currentbottom, $
          reversed:0, bottomcolor:info.bottomcolor, topcolor:info.topcolor, $
          gamma:gamma, top:info.top, bottom:info.bottom, index:info.index, $
          ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
          notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
          windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
          thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
          colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
          needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
          object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
    
       <span class="comments">; Load the colors.</span>
    
    XColors_Set, pseudo
    
    info.gamma = gamma
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the REVERSE button. Modify the color table when</span>
<span class="comments">; the button is selectd.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_REVERSE_BUTTON, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    <span class="comments">; To get the initial colors correct. We have to load the colors as if they</span>
    <span class="comments">; were not reversed.</span>
    IF info.index GE 0 THEN BEGIN  
    cgLoadCT, info.index, BREWER=info.brewer, RGB_TABLE=c
    info.r = c[*,0]
    info.g = c[*,1]
    info.b = c[*,2]
    ENDIF ELSE TVLCT, info.r, info.g, info.b
    
    <span class="comments">; Is the button set or not?</span>
    buttonSet = Widget_Info(event.id, /BUTTON_SET)
    
    <span class="comments">; Make a pseudo structure.</span>
    IF buttonSet THEN  BEGIN
        
        IF info.currentBottom GT info.currentTop THEN $
           pseudo = {currenttop:info.currentbottom, currentbottom:info.currenttop, $
              reversed:1, bottomcolor:info.topcolor, topcolor:info.bottomcolor, $
              gamma:info.gamma, top:info.top, bottom:info.bottom, index:info.index, $
              ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
              notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
              windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
              thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
              colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
              needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
              object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer} $
        ELSE $
           pseudo = {currenttop:info.currenttop, currentbottom:info.currentbottom, $
              reversed:1, bottomcolor:info.bottomcolor, topcolor:info.topcolor, $
              gamma:info.gamma, top:info.top, bottom:info.bottom, index:info.index, $
              ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
              notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
              windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
              thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
              colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
              needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
              object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
              
    ENDIF ELSE BEGIN
    
        IF info.currentBottom GT info.currentTop THEN $
           pseudo = {currenttop:info.currentbottom, currentbottom:info.currenttop, $
              reversed:0, bottomcolor:info.topcolor, topcolor:info.bottomcolor, $
              gamma:info.gamma, top:info.top, bottom:info.bottom, index:info.index, $
              ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
              notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
              windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
              thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
              colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
              needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
              object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer} $
        ELSE $
           pseudo = {currenttop:info.currenttop, currentbottom:info.currentbottom, $
              reversed:0, bottomcolor:info.bottomcolor, topcolor:info.topcolor, $
              gamma:info.gamma, top:info.top, bottom:info.bottom, index:info.index, $
              ncolors:info.ncolors, r:info.r, g:info.g, b:info.b, $
              notifyID:info.notifyID, colorimage:info.colorimage, extra:info.extra, $
              windowindex:info.windowindex, from:'SLIDER', notifyObj:info.notifyObj, $
              thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
              colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
              needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
              object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
              
    ENDELSE
    
       <span class="comments">; Load the colors.</span>
    
    XColors_Set, pseudo
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the color table selector. Modify the color table when</span>
<span class="comments">; the selector is clicked.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_COLORTABLE, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
    LoadCT, event.index, File=info.file, /Silent, $
       NColors=info.ncolors, Bottom=info.bottom
    
    TVLct, r, g, b, /Get
    info.r = r(info.bottom:info.top)
    info.g = g(info.bottom:info.top)
    info.b = b(info.bottom:info.top)
    info.topcolor = [r(info.top), g(info.top), b(info.top)]
    info.bottomcolor = [r(info.bottom), g(info.bottom), b(info.bottom)]
    
       <span class="comments">; Update the slider positions and values.</span>
    
    IF 1 - info.nosliders THEN BEGIN
       Widget_Control, info.botSlider, Set_Value=0
       Widget_Control, info.topSlider, Set_Value=info.ncolors-1
       Widget_Control, info.gammaSlider, Set_Value=50
       Widget_Control, info.gammaID, Set_Value=String(1.0, Format='(F6.3)')
    ENDIF
    info.currentBottom = info.bottom
    info.currentTop = info.top
    info.gamma = 1.0
    info.index = event.index
    info.ctname = (*info.colornames)[event.index]
    
       <span class="comments">; Create a pseudo structure.</span>
    
    pseudo = {currenttop:info.currenttop, currentbottom:info.currentbottom, $
       reversed:info.reversed, windowindex:info.windowindex, index:event.index, $
       bottomcolor:info.bottomcolor, topcolor:info.topcolor, gamma:info.gamma, $
       top:info.top, bottom:info.bottom, ncolors:info.ncolors, r:info.r, $
       g:info.g, b:info.b, notifyID:info.notifyID, colorimage:info.colorimage, $
       from:'LIST', notifyObj:info.notifyObj, thisWindow:info.thisWindow, $
       notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, extra:info.extra, $
       colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
       needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
       object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
    
       <span class="comments">; Update the colors.</span>
    
    XColors_Set, pseudo
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for updating the colors on a 24-bit display.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_PROTECT_COLORS, event

       <span class="comments">; Get the info structure from storage location.</span>
    
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
       <span class="comments">; Create a pseudo structure.</span>
    
    pseudo = {currenttop:info.currenttop, currentbottom:info.currentbottom, $
       reversed:info.reversed, $
       bottomcolor:info.bottomcolor, topcolor:info.topcolor, gamma:info.gamma, $
       top:info.top, bottom:info.bottom, ncolors:info.ncolors, r:info.r, index:info.index, $
       g:info.g, b:info.b, notifyID:info.notifyID, colorimage:info.colorimage, $
       windowindex:info.windowindex, from:'PROTECT', notifyObj:info.notifyObj, extra:info.extra, $
       thisWindow:info.thisWindow, notifyPro:info.notifyPro, xcolorsData:info.xcolorsData, $
       colorInfoPtr:info.colorInfoPtr, colornames:info.colornames, ctname:info.ctname, $
       needColorInfo:info.needColorInfo, colortabletype:info.colortabletype, $
       object_data:info.object_data, reverseID:info.reverseID, brewer:info.brewer}
    
       <span class="comments">; Update the colors.</span>
    
    XColors_Set, pseudo
    
       <span class="comments">; Put the info structure back in storage location.</span>
    
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the CANCEL button. Update to original color table.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_CANCEL, event
    Widget_Control, event.top, Get_UValue=info, /No_Copy
    
       <span class="comments">; Update the colors.</span>
    
    XColors_Set, info.cancelStruct
    Widget_Control, event.top, Set_UValue=info, /No_Copy
    Widget_Control, event.top, /Destroy
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the QUIT button. Destroy the widget.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_DISMISS, event
Widget_Control, event.top, /Destroy
END <span class="comments">; ************************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The event handler for the BREWER colors button. Switch between IDL</span>
<span class="comments">; and Brewer color tables.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required</span>
<span class="comments">;         The event structure passed from the Window Manager.</span>
<span class="comments">;-</span>
PRO XCOLORS_SWITCH_COLORS, event

   Widget_Control, event.top, Get_UValue=info, /No_Copy
   Widget_Control, event.id, GET_UVALUE=colortypes
   thisType = colortypes[event.index]
   parent = Widget_Info(event.id, /PARENT)
   oldList = info.tableList
   
   CASE thisType OF
   
   
        'IDL': BEGIN
           info.file = Filepath(SubDir=['resource','colors'], 'colors1.tbl')
           info.brewer = 0
           END
           
        'USER-DEFINED': BEGIN
           info.file = info.userfile
           info.brewer = 0
           END

        'BREWER': BEGIN
           info.file = Find_Resource_File('fsc_brewer.tbl')
           info.brewer = 1
           END
   ENDCASE
   
   <span class="comments">; Load the appropriate colors and the new color table names into</span>
   <span class="comments">; the list widget.</span>
    colorNames=''
    LoadCT, Get_Names=colorNames, File=info.file
    colorNamesIndex = StrArr(N_Elements(colorNames))
    FOR j=0,N_Elements(colorNames)-1 DO $
       colorNamesIndex[j] = StrTrim(j,2) + ' - ' + colorNames[j]
    info.tableList = Widget_List(info.tableListBase, Value=colorNamesIndex, YSize=12 + (12*Keyword_Set(nosliders)), Scr_XSize=256, $
       Event_Pro='XColors_ColorTable')
    Widget_Control, oldList, /Destroy
    
    <span class="comments">; Update the color table type and names in the info structure.</span>
    info.colorTableType = thisType
    *info.colornames = colorNames

    Widget_Control, event.top, Set_UValue=info, /No_Copy
END <span class="comments">; *****************************************************************</span>



<span class="comments">;+</span>
<span class="comments">; The cleanup routine for the widget program. Called when the widget</span>
<span class="comments">; dies.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     tlb: in, required</span>
<span class="comments">;         The widget identifier of the widget that just died.</span>
<span class="comments">;-</span>
PRO XCOLORS_CLEANUP, tlb
    Widget_Control, tlb, Get_UValue=info, /No_Copy
    IF N_Elements(info) NE 0 THEN BEGIN
       Ptr_Free, info.colornames
       Ptr_Free, info.xcolorsData
       Ptr_Free, info.extra
       IF info.needColorInfo EQ 0 THEN Ptr_Free, info.colorInfoPtr
    ENDIF
END <span class="comments">; ************************************************************************</span>

<span class="comments">;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="comments">; This is a procedure to load color tables into a restricted color range of the physical </span>
<span class="comments">; color table. It is a highly simplified, but much more powerful, version of XLoadCT.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     block: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the program will try to block the</span>
<span class="comments">;        IDL command line. Note that this is only possible if no other</span>
<span class="comments">;        widget program is currently blocking the IDL command line. It</span>
<span class="comments">;        is much more reliable to make XCOLORS a modal widget (see the MODAL</span>
<span class="comments">;        keyword), although this can generally only be done when XCOLORS</span>
<span class="comments">;        is called from another widget program.</span>
<span class="comments">;     brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you wish to use the Brewer Colors, as explained</span>
<span class="comments">;        in this reference: http://www.idlcoyote.com/color_tips/brewer.html. The</span>
<span class="comments">;        file, `fsc_brewer.tbl &lt;http://www.idlcoyote.com/programs/fsc_brewer.tbl>`</span>
<span class="comments">;        must be found somewhere in your IDL path for this option to be available. </span>
<span class="comments">;        Note that if this file is found, the Brewer colors are automatically added</span>
<span class="comments">;        to the program as an option. In this case, the BREWER keyword just makes sure</span>
<span class="comments">;        this is the initial user choice.</span>
<span class="comments">;     bottom: in, optional, type=integer, default=0</span>
<span class="comments">;        The lowest color index of the colors to be changed.</span>
<span class="comments">;     colorinfo: out, optional</span>
<span class="comments">;        This output keyword will return either a pointer to a color information structure </span>
<span class="comments">;        (if the program is called in a non-modal fashion) or a color information structure </span>
<span class="comments">;        (if the program is called in modal or blocking fashion). The color information</span>
<span class="comments">;         structure is an anonymous structure defined like this::</span>
<span class="comments">;</span>
<span class="comments">;             struct = { R: BytArr(!D.Table_Size), $ ; The current R color vector.</span>
<span class="comments">;                        G: BytArr(!D.Table_Size), $ ; The current G color vector.</span>
<span class="comments">;                        B: BytArr(!D.Table_Size), $ ; The current B color vector.</span>
<span class="comments">;                        NAME: "", $                 ; The name of the current color table.</span>
<span class="comments">;                        INDEX: 0, $                 ; The index number of the current color table.</span>
<span class="comments">;                        TYPE: "", $                 ; The type of color table (e.g, BREWER or IDL).</span>
<span class="comments">;                        BREWER: 0, $                ; Set to 1 if using BREWER color tables, else to 0.</span>
<span class="comments">;                        REVERSED: 0B }              ; Set to 1 if the color table is reversed.</span>
<span class="comments">;                        </span>
<span class="comments">;        If a pointer to the structure is obtained, you will be responsible</span>
<span class="comments">;        for freeing it to prevent memory leakage::</span>
<span class="comments">;</span>
<span class="comments">;             XColors, ColorInfo=colorInfoPtr</span>
<span class="comments">;             Print, "Color Table Name: ", (*colorInfoPtr).Name</span>
<span class="comments">;             Ptr_Free, colorInfoPtr</span>
<span class="comments">;</span>
<span class="comments">;        Note that that Name field will be "Unknown" and the Index field will</span>
<span class="comments">;        be -1 until a color table is actually selected by the user. You are</span>
<span class="comments">;        responsible for checking this value before you use it.</span>
<span class="comments">;</span>
<span class="comments">;        When called in modal or blocking fashion, you don't have to worry about freeing</span>
<span class="comments">;        the pointer, since no pointer is involved::</span>
<span class="comments">;</span>
<span class="comments">;             XColors, /Block, ColorInfo=colorInfoData</span>
<span class="comments">;             Help, colorInfoData, /Structure</span>
<span class="comments">;             Print, "Color Table Name: ", colorInfoData.Name</span>
<span class="comments">;     data: in, optional</span>
<span class="comments">;        This keyword can be set to any valid IDL variable. If</span>
<span class="comments">;        the variable is defined, the specified object method or notify</span>
<span class="comments">;        procedure will be passed this variable via a DATA keyword. This</span>
<span class="comments">;        keyword is defined primarily so that Notify Procedures are compatible</span>
<span class="comments">;        with the XLOADCT way of passing data. It is not strictly required,</span>
<span class="comments">;        since the _EXTRA keyword inheritance mechanism will allow passing</span>
<span class="comments">;        of *any* keyword parameter defined for the object or procedure that is</span>
<span class="comments">;        to be notified.</span>
<span class="comments">;     drag: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you want colors loaded as you drag</span>
<span class="comments">;        the sliders. Default is to update colors only when you release</span>
<span class="comments">;        the sliders. Use of this keyword is greatly discouraged.</span>
<span class="comments">;     file: in, optional, type=string, default="colors1.tbl"</span>
<span class="comments">;        A name of a color table file. The supplied colors1.tbl file is used by default.</span>
<span class="comments">;     group_leader: in, optional, type=long</span>
<span class="comments">;        The group leader identifier for this program. When the group</span>
<span class="comments">;          leader is destroyed, this program will be destroyed.</span>
<span class="comments">;     index: in, optional, type=integer</span>
<span class="comments">;        The index of the color table to start up. If provided, a color</span>
<span class="comments">;        table of this index number is loaded prior to display. Otherwise,</span>
<span class="comments">;        the current color table is used. Set this keyword if you wish</span>
<span class="comments">;        to have the index number of the event structure correct when</span>
<span class="comments">;        the user CANCELs out of the progam.</span>
<span class="comments">;     modal: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword (along with the GROUP_LEADER keyword) to</span>
<span class="comments">;        make the XCOLORS dialog a modal widget dialog. Note that NO</span>
<span class="comments">;        other events can occur until the XCOLORS program is destroyed</span>
<span class="comments">;        when in modal mode.</span>
<span class="comments">;     ncolors: in, optional, type=integer, default=256</span>
<span class="comments">;        Set this keyword to the number of colors to load when a color table</span>
<span class="comments">;        is selected.</span>
<span class="comments">;     nosliders: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the color stretch and color gamma</span>
<span class="comments">;        sliders are not displayed. This would be appropriate, for example,</span>
<span class="comments">;        for programs that just load pre-defined color tables.</span>
<span class="comments">;     notifyid: in, optional</span>
<span class="comments">;        A 2-column by n-row array that contains the IDs of widgets</span>
<span class="comments">;        that should be notified when XCOLORS loads a color table. The first</span>
<span class="comments">;        column of the array is the widgets that should be notified. The</span>
<span class="comments">;        second column contains IDs of widgets that are at the top of the</span>
<span class="comments">;        hierarchy in which the corresponding widgets in the first column</span>
<span class="comments">;        are located. (The purpose of the top widget IDs is to make it</span>
<span class="comments">;        possible for the widget in the first column to get the "info"</span>
<span class="comments">;        structure of the widget program.) An XCOLORS_LOAD event will be</span>
<span class="comments">;        sent to the widget identified in the first column. The event</span>
<span class="comments">;        structure is defined like this::</span>
<span class="comments">;</span>
<span class="comments">;           event = {XCOLORS_LOAD, ID:0L, TOP:0L, HANDLER:0L, $</span>
<span class="comments">;              R:BytArr(!D.TABLE_SIZE &lt; 256), G:BytArr(!D.TABLE_SIZE &lt; 256), $</span>
<span class="comments">;              B:BytArr(!D.TABLE_SIZE &lt; 256), INDEX:0, NAME:"", $</span>
<span class="comments">;              TYPE:"", BREWER:0, REVERSED:0}</span>
<span class="comments">;</span>
<span class="comments">;        The ID field will be filled out with NOTIFYID[0, n] and the TOP</span>
<span class="comments">;        field will be filled out with NOTIFYID[1, n]. The R, G, and B</span>
<span class="comments">;        fields will have the current color table vectors, obtained by</span>
<span class="comments">;        exectuing the command TVLCT, r, g, b, /Get. The INDEX field will</span>
<span class="comments">;        have the index number of the just-loaded color table. The name</span>
<span class="comments">;        field will have the name of the currently loaded color table.</span>
<span class="comments">;        The TYPE field with be "BREWER" if a Brewer color table was loaded,</span>
<span class="comments">;        or "IDL" otherwise. The BREWER field will be set to 1 if a Brewer </span>
<span class="comments">;        color table was loaded, or to 0 otherwise. The REVERSED field will</span>
<span class="comments">;        be set to 1 if the color table is reversed, or to 0 otherwise.</span>
<span class="comments">;</span>
<span class="comments">;        Note that XCOLORS can't initially tell *which* color table is</span>
<span class="comments">;        loaded, since it just uses whatever colors are available when it</span>
<span class="comments">;        is called. Thus, it stores a -1 in the INDEX field to indicate</span>
<span class="comments">;        this "default" value. Programs that rely on the INDEX field of</span>
<span class="comments">;        the event structure should normally do nothing if the value is</span>
<span class="comments">;        set to -1. This value is also set to -1 if the user hits the</span>
<span class="comments">;        CANCEL button. (Note the NAME field will initially be "Unknown").</span>
<span class="comments">;</span>
<span class="comments">;        Typically the XCOLORS button will be defined like this::</span>
<span class="comments">;</span>
<span class="comments">;             xcolorsID = Widget_Button(parentID, Value='Load New Color Table...', $</span>
<span class="comments">;                Event_Pro='Program_Change_Colors_Event')</span>
<span class="comments">;</span>
<span class="comments">;        The event handler will be written something like this::</span>
<span class="comments">;</span>
<span class="comments">;             PRO Program_Change_Colors_Event, event</span>
<span class="comments">;</span>
<span class="comments">;                ; Handles color table loading events. Allows colors be to changed.</span>
<span class="comments">;</span>
<span class="comments">;             Widget_Control, event.top, Get_UValue=info, /No_Copy</span>
<span class="comments">;             thisEvent = Tag_Names(event, /Structure_Name)</span>
<span class="comments">;             CASE thisEvent OF</span>
<span class="comments">;</span>
<span class="comments">;                'WIDGET_BUTTON': BEGIN</span>
<span class="comments">;</span>
<span class="comments">;                     ; Color table tool.</span>
<span class="comments">;</span>
<span class="comments">;                   XColors, NColors=info.ncolors, Bottom=info.bottom, $</span>
<span class="comments">;                      Group_Leader=event.top, NotifyID=[event.id, event.top]</span>
<span class="comments">;                   ENDCASE</span>
<span class="comments">;</span>
<span class="comments">;                'XCOLORS_LOAD': BEGIN</span>
<span class="comments">;</span>
<span class="comments">;                     ; Update the display for 24-bit displays.</span>
<span class="comments">;</span>
<span class="comments">;                   Device, Get_Visual_Depth=thisDepth</span>
<span class="comments">;                   IF thisDepth GT 8 THEN BEGIN</span>
<span class="comments">;                   WSet, info.wid</span>
<span class="comments">;</span>
<span class="comments">;                    ...Whatever display commands are required go here. For example...</span>
<span class="comments">;</span>
<span class="comments">;                    TV, info.image</span>
<span class="comments">;</span>
<span class="comments">;                 ENDIF</span>
<span class="comments">;                 ENDCASE</span>
<span class="comments">;</span>
<span class="comments">;              ENDCASE</span>
<span class="comments">;</span>
<span class="comments">;              Widget_Control, event.top, Set_UValue=info, /No_Copy</span>
<span class="comments">;              END</span>
<span class="comments">;              </span>
<span class="comments">;     notifyobj: in, optional, type=structure</span>
<span class="comments">;        A vector of structures (or a single structure), with each element of the vector </span>
<span class="comments">;        defined as follows::</span>
<span class="comments">;</span>
<span class="comments">;             struct = {XCOLORS_NOTIFYOBJ, object:Obj_New(), method:''}</span>
<span class="comments">;</span>
<span class="comments">;        where the Object field is an object reference, and the Method field</span>
<span class="comments">;        is the name of the object method that should be called when XCOLORS</span>
<span class="comments">;        loads its color tables::</span>
<span class="comments">;</span>
<span class="comments">;             ainfo = {XCOLORS_NOTIFYOBJ, a, 'Draw'}</span>
<span class="comments">;             binfo = {XCOLORS_NOTIFYOBJ, b, 'Display'}</span>
<span class="comments">;             XColors, NotifyObj=[ainfo, binfo]</span>
<span class="comments">;</span>
<span class="comments">;        Note that the XColors program must be compiled before these structures</span>
<span class="comments">;        are used. Alternatively, you can put this program, named</span>
<span class="comments">;        "xcolors_notifyobj__define.pro" (*three* underscore characters in this</span>
<span class="comments">;        name!) in your PATH::</span>
<span class="comments">;</span>
<span class="comments">;             PRO XCOLORS_NOTIFYOBJ__DEFINE</span>
<span class="comments">;              struct = {XCOLORS_NOTIFYOBJ, OBJECT:Obj_New(), METHOD:''}</span>
<span class="comments">;             END</span>
<span class="comments">;</span>
<span class="comments">;        Or, you can simply define this structure as it is shown here in your code.</span>
<span class="comments">;</span>
<span class="comments">;        "Extra" keywords added to the XCOLORS call are passed along to</span>
<span class="comments">;        the object method, which makes this an alternative way to get information</span>
<span class="comments">;        to your methods. If you expect such keywords, your methods should be defined</span>
<span class="comments">;        with an _Extra keyword.</span>
<span class="comments">;          </span>
<span class="comments">;        If you set the /OBJECT_DATA keyword, the same structure defined for the </span>
<span class="comments">;        COLORINFO keyword above will be passed to your object method via an </span>
<span class="comments">;        XCOLORS_DATA keyword that you will have to define for the method.</span>
<span class="comments">;        </span>
<span class="comments">;     notifypro: in, optional, type=string</span>
<span class="comments">;        The name of a procedure to notify or call when the color</span>
<span class="comments">;        tables are loaded. If the DATA keyword is also defined with a valid</span>
<span class="comments">;        IDL variable, it will be passed to this program via an DATA keyword. </span>
<span class="comments">;        But note that *any* keyword appropriate for the procedure can be used </span>
<span class="comments">;        in the call to XCOLORS. For example, here is a procedure that re-displays </span>
<span class="comments">;        an image in the current graphics window::</span>
<span class="comments">;</span>
<span class="comments">;             PRO REFRESH_IMAGE, Image=image, _Extra=extra, WID=wid</span>
<span class="comments">;             IF N_Elements(wid) NE 0 THEN WSet, wid</span>
<span class="comments">;             cgImage, image, _Extra=extra</span>
<span class="comments">;             END</span>
<span class="comments">;</span>
<span class="comments">;        This program can be invoked with this series of commands::</span>
<span class="comments">;</span>
<span class="comments">;             IDL> Window, /Free</span>
<span class="comments">;             IDL> cgImage, image, Position=[0.2, 0.2, 0.8, 0.8]</span>
<span class="comments">;             IDL> XColors, NotifyPro='Refresh_Image', Image=image, WID=!D.Window</span>
<span class="comments">;</span>
<span class="comments">;        Note that "extra" keywords added to the XCOLORS call are passed along to</span>
<span class="comments">;        your procedure, which makes this an alternative way to get information</span>
<span class="comments">;        to your procedure. If you expect such keywords, your procedure should</span>
<span class="comments">;        be defined with an _Extra keyword as illustrated above.</span>
<span class="comments">;     object_data: in, optional, type=boolean, default=0        </span>
<span class="comments">;        Set this keyword if you wish color information to be</span>
<span class="comments">;        supplied to your object notification method via an XCOLORS_DATA</span>
<span class="comments">;        keyword. This keyword is ignored unless the NOTIFYOBJ keyword is</span>
<span class="comments">;        also used. The color information is supplied as a structure and is</span>
<span class="comments">;        defined in the COLORINFO keyword definition above.</span>
<span class="comments">;     reverse: in, optional, type=boolean, default=0      </span>
<span class="comments">;        If this keyword is set, the color table is reversed and the</span>
<span class="comments">;        Reverse Color Table button is set on.</span>
<span class="comments">;     title: in, optional, type='string'</span>
<span class="comments">;        This is the window title. It is "Load Color Tables" by default. The program </span>
<span class="comments">;        is registered with the name 'XCOLORS:' plus the TITLE string. The "register </span>
<span class="comments">;        name" is checked before the widgets are defined. If a program with that name </span>
<span class="comments">;        has already been registered you cannot register another with that name. This </span>
<span class="comments">;        means that you can have several versions of XCOLORS open simultaneously as long </span>
<span class="comments">;        as each has a unique title or name. For example, like this::</span>
<span class="comments">;</span>
<span class="comments">;            IDL> XColors, NColors=100, Bottom=0, Title='First 100 Colors'</span>
<span class="comments">;            IDL> XColors, NColors=100, Bottom=100, Title='Second 100 Colors'</span>
<span class="comments">;     window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to send the colors to a Coyote Graphics cgWindow program.</span>
<span class="comments">;     winid: in, optional, type=integer   </span>
<span class="comments">;        The window index number of a Coyote Graphics cgWindow program to receive the color vectors.</span>
<span class="comments">;     xoffset: in, optional, type=integer</span>
<span class="comments">;        This is the X offset of the program on the display. The program will be placed </span>
<span class="comments">;        approximately in the middle of the display by default.</span>
<span class="comments">;     yoffset: in, optional, type=integer</span>
<span class="comments">;        This is the Y offset of the program on the display. The program will be placed </span>
<span class="comments">;        approximately in the middle of the display by default.</span>
<span class="comments">;     _extra: in, optional</span>
<span class="comments">;        The keyword inheritance mechanism will pick up and pass along to any method or procedure </span>
<span class="comments">;        to be notified any keywords that are defined for that procedure. Note that you should be </span>
<span class="comments">;        sure that keywords are spelled correctly. Any mis-spelled keyword will be ignored.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------------------</span>
PRO XCOLORS, $
    Block=block, $
    Brewer=brewer, $
    Bottom=bottom, $
    ColorInfo=colorinfoPtr, $
    Data=xColorsData, $
    Drag=drag, $
    File=file, $
    Group_Leader=group_leader, $
    Index=index, $
    Modal=modal, $
    NColors=ncolors, $
    NoSliders=nosliders, $
    NotifyID=notifyID, $
    NotifyObj=notifyObj, $
    NotifyPro=notifyPro, $
    Object_Data=object_data, $
    Reverse=reverse, $
    Title=title, $
    Window=window, $
    WinID=winID, $
    XOffset=xoffset, $
    YOffset=yoffset, $
    _EXTRA=extra


    On_Error, 1
    
       <span class="comments">; Current graphics window.</span>
    
    thisWindow = !D.Window
    
       <span class="comments">; Check keyword parameters. Define defaults.</span>
    
    IF N_Elements(title) EQ 0 THEN title = 'Load Color Tables'
    IF N_Elements(drag) EQ 0 THEN drag = 0
    
    IF N_Elements(file) EQ 0 THEN BEGIN
        file = Filepath(SubDir=['resource','colors'], 'colors1.tbl')
        userfile = ""
    ENDIF ELSE userfile = file
    
       <span class="comments">; Try to locate the brewer file. Check resource/colors directory, then look for it</span>
       <span class="comments">; in the IDL path if it is not found there.</span>
    
    brewerfile = Filepath(SubDir=['resource','colors'], 'fsc_brewer.tbl')
    IF File_Test(brewerfile, /READ) EQ 0 THEN brewerfile = Find_Resource_File('fsc_brewer.tbl')
    IF brewerfile EQ "" THEN BEGIN
        locatedBrewerFile = 0 
    ENDIF ELSE BEGIN
        locatedBrewerFile = 1
        IF Keyword_Set(brewer) THEN file = brewerfile
    ENDELSE
    IF locatedBrewerFile AND Keyword_Set(brewer) $
       THEN colortabletype = 'BREWER' $
       ELSE IF userfile NE "" THEN colortabletype = 'USER-DEFINED' ELSE colortabletype = 'IDL'
    object_data = Keyword_Set(object_data)
    IF N_Elements(notifyID) EQ 0 THEN notifyID = [-1L, -1L]
    IF StrUpCase(colortabletype) EQ 'BREWER' THEN brewer = 1 ELSE brewer = 0
    
    <span class="comments">; Is the window keyword set? If so, you will be sending this to</span>
    <span class="comments">; an FSC_Window to load the colors.</span>
    IF Keyword_Set(window) THEN BEGIN
      
          <span class="comments">; Does a window object exist somewhere?</span>
          DefSysV, '!FSC_WINDOW_LIST', EXISTS=exists
          IF exists THEN BEGIN
               theList = !FSC_WINDOW_LIST
               IF Obj_Valid(theList) THEN BEGIN
                    structs = theList -> Get_Item(/ALL, /DEREFERENCE)
                    IF Size(structs, /TNAME) EQ 'POINTER' THEN RETURN
                    IF N_Elements(winID) EQ 0 THEN BEGIN
                        winID = N_Elements(structs) - 1
                    ENDIF ELSE BEGIN
                        index = Where(structs.wid[*] EQ winID, count)
                        IF count GT 0 THEN winID = index[0] ELSE BEGIN
                            Message, 'Cannot find an FSC_Window with window index ' + StrTrim(winID, 2) + '.'
                        ENDELSE
                    ENDELSE
                    thisWindowStruct = structs[winID]
                    IF Obj_Valid(thisWindowStruct.windowObj) THEN BEGIN
                         thisStruct = {XCOLORS_NOTIFYOBJ, thisWindowStruct.windowObj, 'LoadColors'}
                         object_data = 1
                        IF N_Elements(notifyObj) EQ 0 THEN BEGIN
                           notifyObj = thisStruct
                        ENDIF ELSE BEGIN
                           notifyObj = [notifyObj, thisStruct]
                        ENDELSE
                    ENDIF 
               ENDIF 
           ENDIF 
    ENDIF
    
    IF N_Elements(notifyObj) EQ 0 THEN BEGIN
       notifyObj = {object:Obj_New(), method:'', wid:-1}
    ENDIF
    IF Size(notifyObj, /Type) NE 8 THEN BEGIN
       ok = Dialog_Message(['Arguments to the NotifyObj keyword must', $
          'be structures. Returning...'])
       RETURN
    END
    nelements = Size(notifyObj, /N_Elements)
    FOR j=0,nelements-1 DO BEGIN
       tags = Tag_Names(notifyObj[j])
       check = Where(tags EQ 'OBJECT', count1)
       check = Where(tags EQ 'METHOD', count2)
       IF (count1 + count2) NE 2 THEN BEGIN
          ok = Dialog_Message('NotifyObj keyword has incorrect fields. Returning...')
       RETURN
       ENDIF
    ENDFOR
    IF N_Elements(notifyPro) EQ 0 THEN notifyPro = ""
    IF N_Elements(xcolorsData) EQ 0 THEN xdata = Ptr_New(/Allocate_Heap) ELSE $
       xdata = Ptr_New(xcolorsData)
    IF N_Elements(extra) EQ 0 THEN extra = Ptr_New(/Allocate_Heap) ELSE $
       extra = Ptr_New(extra)
    IF Arg_Present(colorinfoPtr) THEN needcolorInfo = 1 ELSE needcolorInfo = 0
    noblock = 1 - Keyword_Set(block)
    block = Keyword_Set(block)
    
       <span class="comments">; Find the center of the display.</span>
    
    DEVICE, GET_SCREEN_SIZE=theScreenSize
    IF theScreenSize[0] GT 2000 THEN theScreenSize[0] = theScreenSize[0]/2
    xCenter = FIX(theScreenSize[0] / 2.0)
    yCenter = FIX(theScreenSize[1] / 2.0)
    
    IF N_ELEMENTS(xoffset) EQ 0 THEN xoffset = xCenter - 150
    IF N_ELEMENTS(yoffset) EQ 0 THEN yoffset = yCenter - 200
    
    registerName = 'XCOLORS:' + title
    
       <span class="comments">; Only one XCOLORS with this title.</span>
    
    IF XRegistered(registerName) GT 0 THEN BEGIN
       Ptr_Free, xdata
       Ptr_Free, extra
       IF N_Elements(colorInfoPtr) NE 0 THEN Ptr_Free, colorInfoPtr
       RETURN
    ENDIF
    
       <span class="comments">; Create the top-level base. No resizing.</span>
    
    IF Keyword_Set(modal) AND N_Elements(group_leader) NE 0 THEN BEGIN
       tlb = Widget_Base(Column=1, Title=title, TLB_Frame_Attr=1, $
          XOffSet=xoffset, YOffSet=yoffset, Base_Align_Center=1, $
          Modal=1, Group_Leader=group_leader)
       modal = 1
    
    ENDIF ELSE BEGIN
       tlb = Widget_Base(Column=1, Title=title, TLB_Frame_Attr=1, $
          XOffSet=xoffset, YOffSet=yoffset, Base_Align_Center=1, Space=5)
       modal = 0
       IF N_Elements(group_leader) EQ 0 THEN group_leader = -1L
    ENDELSE
    
       <span class="comments">; Create a draw widget to display the current colors.</span>
    
       draw = Widget_Draw(tlb, XSize=256, YSize=40, Retain=2)
    
    IF N_Elements(bottom) EQ 0 THEN bottom = 0
    IF N_Elements(ncolors) EQ 0 THEN ncolors = (256 &lt<span class="comments">; !D.Table_Size) - bottom</span>
    IF (ncolors + bottom) GT 256 THEN ncolors = 256 - bottom
    
       <span class="comments">; Load colors in INDEX if specified.</span>
    IF userfile NE "" THEN file = userfile
    IF N_Elements(index) GE 1 THEN BEGIN
       IF index GE 0 THEN BEGIN
            LoadCT, index, File=file, /Silent, NColors=ncolors, Bottom=bottom
       ENDIF ELSE index = -1
    ENDIF ELSE index = -1
    
    
       <span class="comments">; Create a pointer to the color information.</span>
    
    TVLCT, rr, gg, bb, /Get
    IF Keyword_Set(reverse) THEN BEGIN
       rr = Reverse(rr)
       gg = Reverse(gg)
       bb = Reverse(bb)
       TVLCT, rr, gg, bb
    ENDIF
    colorInfoPtr = Ptr_New({R:rr, G:gg, B:bb, Name:'Unknown', $
       Index:index, Type:colortabletype, Reversed:Keyword_Set(reverse), $
       Brewer:Keyword_Set(locatedBrewerFile)})
    
       <span class="comments">; Calculate top parameter.</span>
    
    top = ncolors + bottom - 1
    
       <span class="comments">; Create sliders to control stretchs and gamma correction.</span>
    
    IF 1 - Keyword_Set(nosliders) THEN BEGIN
       sliderbase = Widget_Base(tlb, Column=1, XPad=0, YPad=0, /Frame)
       botSlider = Widget_Slider(sliderbase, Value=0, Min=0, $
          Max=ncolors-1, XSize=256,Event_Pro='XColors_Bottom_Slider', $
          Title='Stretch Bottom', Drag=drag)
       topSlider = Widget_Slider(sliderbase, Value=ncolors-1, Min=0, $
          Max=ncolors-1, XSize=256, Event_Pro='XColors_Top_Slider', $
          Title='Stretch Top', Drag=drag)
       gammaID = Widget_Label(sliderbase, Value=String(1.0, Format='(F6.3)'))
       gammaSlider = Widget_Slider(sliderbase, Value=50.0, Min=0, Max=100, $
          Drag=drag, XSize=256, /Suppress_Value, Event_Pro='XColors_Gamma_Slider', $
          Title='Gamma Correction')
    ENDIF ELSE BEGIN
       botSlider = 0L
       topSlider = 0L
       gammaID = 0L
       gammaSlider = 0L
    ENDELSE
    
    <span class="comments">; A reverse button.</span>
    cbase = WIDGET_BASE(tlb, Row=1, BASE_ALIGN_CENTER=1, FRAME=1, SCR_XSIZE=256)
    reverseBase = WIDGET_BASE(cbase, Row=1, XPAD=0, YPAD=0, SPACE=0, /NONEXCLUSIVE)
    reverseStr = StrUpCase(!Version.OS_Family) EQ 'WINDOWS' ? 'Reverse Color Table' : 'Reverse Colors'
    reverseID = Widget_Button(reversebase, Value=reverseStr, EVENT_PRO='XColors_Reverse_Button')
    IF Keyword_Set(reverse) THEN Widget_Control, reverseID, SET_BUTTON=1
    
       <span class="comments">; A row for additional control.</span>
    IF locatedBrewerFile THEN BEGIN
        IF userfile NE "" THEN BEGIN
           colorvalues = [' User-Defined Colors ', ' Brewer Colors ']
           coloruvalue = ['USER-DEFINED', 'BREWER']
        ENDIF ELSE BEGIN
           colorvalues = [' IDL Colors ', ' Brewer Colors ']
           coloruvalue = ['IDL','BREWER']
        ENDELSE
        colorType = Widget_Droplist(cbase, Value=colorvalues, $
            /DYNAMIC_RESIZE, EVENT_PRO='XCOLORS_SWITCH_COLORS', UVALUE=coloruvalue) 
        IF Keyword_Set(Brewer) THEN Widget_Control, colorType, Set_Droplist_Select=1
    ENDIF 
        
       <span class="comments">; Get the colortable names for the list widget.</span>
    
    colorNames=''
    LoadCT, Get_Names=colorNames, File=file
    IF index NE -1 THEN ctname = colorNames[index] ELSE ctname = 'Unknown'
    colorNamesIndex = StrArr(N_Elements(colorNames))
    FOR j=0,N_Elements(colorNames)-1 DO $
       colorNamesIndex[j] = StrTrim(j,2) + ' - ' + colorNames[j]
    tableListBase = Widget_Base(tlb, XPad=0, YPad=0)
    tablelist = Widget_List(tableListBase, Value=colorNamesIndex, YSize=12 + (12*Keyword_Set(nosliders)), $
        Scr_XSize=256, Event_Pro='XColors_ColorTable')
    
       <span class="comments">; Dialog Buttons</span>
    dialogbase = WIDGET_BASE(tlb, Row=1, BASE_ALIGN_CENTER=1)
    cancel = Widget_Button(dialogbase, Value='Cancel', $
       Event_Pro='XColors_Cancel', UVALUE='CANCEL')
    dismiss = Widget_Button(dialogbase, Value='Accept', $
       Event_Pro='XColors_Dismiss', UVALUE='ACCEPT')
    
    Widget_Control, tlb, /Realize
    
       <span class="comments">; If you used INDEX, then position this color table near the top of the list.</span>
    IF index NE -1 THEN BEGIN
       Widget_Control, tablelist, Set_List_Top=(0 > (index-3))
       Widget_Control, tablelist, Set_List_Select=index
    ENDIF
    
       <span class="comments">; Get window index number of the draw widget.</span>
    
    Widget_Control, draw, Get_Value=windowIndex
    
       <span class="comments">; Put a picture of the color table in the window.</span>
    
    bar = BINDGEN(ncolors) # REPLICATE(1B, 10)
    bar = BYTSCL(bar, TOP=ncolors-1) + bottom
    bar = XColors_Congrid(bar, 256, 40, /INTERP)
    WSet, windowIndex
    SetDecomposedState, 0, Current=theState
    TV, bar
    Device, Decomposed=theState
    
       <span class="comments">; Get the colors that make up the current color table</span>
       <span class="comments">; in the range that this program deals with.</span>
    
    TVLCT, rr, gg, bb, /Get
    r = rr(bottom:top)
    g = gg(bottom:top)
    b = bb(bottom:top)
    
    topColor = [rr(top), gg(top), bb(top)]
    bottomColor = [rr(bottom), gg(bottom), bb(bottom)]
    colornames = Ptr_New(colornames)
    
       <span class="comments">; Create a cancel structure.</span>
    
    cancelstruct = {currenttop:top, currentbottom:bottom, $
       reversed:Keyword_Set(reverse), windowindex:windowindex, $
       bottomcolor:bottomcolor, topcolor:topcolor, gamma:1.0, $
       top:top, bottom:bottom, ncolors:ncolors, r:r, $
       g:g, b:b, notifyID:notifyID, index:index, $
       colorimage:bar, from:'CANCEL', notifyObj:notifyObj, extra:extra, $
       thisWindow:thisWindow, notifyPro:notifyPro, xcolorsData:xData, $
       colorInfoPtr:colorInfoPtr, colornames:colornames, ctname:ctname, $
       needColorInfo:needColorInfo, colortabletype:colortabletype, $
       object_data:object_data, reverseID:reverseID, brewer:Keyword_Set(locatedBrewerFile)}
    
    
       <span class="comments">; Create an info structure to hold information to run the program.</span>
    
    info = {  windowIndex:windowIndex, $         <span class="comments">; The WID of the draw widget.</span>
              botSlider:botSlider, $             <span class="comments">; The widget ID of the bottom slider.</span>
              currentBottom:bottom, $            <span class="comments">; The current bottom slider value.</span>
              currentTop:top, $                  <span class="comments">; The current top slider value.</span>
              topSlider:topSlider, $             <span class="comments">; The widget ID of the top slider.</span>
              gammaSlider:gammaSlider, $         <span class="comments">; The widget ID of the gamma slider.</span>
              gammaID:gammaID, $                 <span class="comments">; The widget ID of the gamma label</span>
              ncolors:ncolors, $                 <span class="comments">; The number of colors we are using.</span>
              gamma:1.0, $                       <span class="comments">; The current gamma value.</span>
              file:file, $                       <span class="comments">; The name of the user-supplied or default color table file.</span>
              userfile:userfile, $               <span class="comments">; The name, if any, of a user-supplied color table file.</span>
              bottom:bottom, $                   <span class="comments">; The bottom color index.</span>
              top:top, $                         <span class="comments">; The top color index.</span>
              topcolor:topColor, $               <span class="comments">; The top color in this color table.</span>
              bottomcolor:bottomColor, $         <span class="comments">; The bottom color in this color table.</span>
              reversed:Keyword_Set(reverse), $   <span class="comments">; A reverse color table flag.</span>
              reverseID:reverseID, $             <span class="comments">; The reverseID button.</span>
              nosliders:Keyword_set(nosliders), $<span class="comments">; A no slider flag.</span>
              notifyID:notifyID, $               <span class="comments">; Notification widget IDs.</span>
              notifyObj:notifyObj, $             <span class="comments">; An vector of structures containng info about objects to notify.</span>
              notifyPro:notifyPro, $             <span class="comments">; The name of a procedure to notify.</span>
              r:r, $                             <span class="comments">; The red color vector.</span>
              g:g, $                             <span class="comments">; The green color vector.</span>
              b:b, $                             <span class="comments">; The blue color vector.</span>
              extra:extra, $                     <span class="comments">; A pointer to extra keywords.</span>
              oindex:index, $                    <span class="comments">; The original color table number.</span>
              index:index, $                     <span class="comments">; The current color table number.</span>
              thisWindow:thisWindow, $           <span class="comments">; The current graphics window when this program is called.</span>
              xcolorsData:xdata, $               <span class="comments">; A pointer to the xcolorData variable passed into the program.</span>
              rstart:r, $                        <span class="comments">; The original red color vector.</span>
              gstart:g, $                        <span class="comments">; The original green color vector.</span>
              bstart:b, $                        <span class="comments">; The original blue color vector.</span>
              colorInfoPtr:colorInfoPtr, $       <span class="comments">; A pointer to the color information.</span>
              colornames:colornames, $           <span class="comments">; A pointer to the names of the color tables.</span>
              ctname:ctname, $                   <span class="comments">; The current color table name.</span>
              needColorInfo:needColorInfo, $     <span class="comments">; A flag that indicates color information is requested.</span>
              cancelStruct:cancelStruct, $       <span class="comments">; The cancel structure.</span>
              drag:drag, $                       <span class="comments">; Need additional information for switching to BREWER colors and visa versa.</span>
              modal:modal, $
              brewer:brewer, $                   <span class="comments">; Using a brewer color table file.</span>
              group_leader:group_leader, $
              block:block, $
              title:title, $
              tableListBase:tableListBase, $     <span class="comments">; The base holding the color table list.</span>
              tableList:tableList, $
              object_data:object_data, $         <span class="comments">; Flag to indicate data should be sent with object notification.</span>
              colortabletype:colortabletype, $   <span class="comments">; The type of color table, e.g, BREWER or IDL.</span>
              colorimage:bar }                   <span class="comments">; The color table image.</span>
    
       <span class="comments">; Turn color protection on.</span>
    
    IF !D.NAME NE 'MAC' THEN Widget_Control, draw, Draw_Expose_Events=1
    
       <span class="comments">; Store the info structure in the user value of the top-level base.</span>
    Widget_Control, tlb, Set_UValue=info, /No_Copy
    Widget_Control, tlb, /Managed
    WSet, thisWindow
    
    XManager, registerName, tlb, Group=(group_leader GE 0) ? group_leader : xx, No_Block=noblock, Cleanup="XColors_Cleanup"
       
       <span class="comments">; Return the colorInfo information as a structure if this program</span>
       <span class="comments">; was called as a modal widget.</span>
    IF (Keyword_Set(modal) AND N_Elements(group_leader) NE 0 AND needColorInfo) OR (noblock EQ 0 AND needColorInfo) THEN BEGIN
       colorStruct = *colorInfoPtr
       Ptr_Free, colorInfoPtr
       colorInfoPtr = colorStruct
    ENDIF

END
</code>
    </div>
  </body>
</html>