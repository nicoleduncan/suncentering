<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>loglevels.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="loglevels.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;        LOGLEVELS (function)</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;        Compute default values for logarithmic axis labeling</span>
<span class="comments">;        or contour levels. For a range from 1 to 100 these</span>
<span class="comments">;        would be 1., 2., 5., 10., 20., 50., 100.</span>
<span class="comments">;        If the range spans more than (usually) 3 decades, only</span>
<span class="comments">;        decadal values will be returned unless the /FINE keyword</span>
<span class="comments">;        is set.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;        Tools</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;        result = LOGLEVELS([range | MIN=min,MAX=max] [,/FINE], [COARSE=dec])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;        RANGE -> A 2-element vector with the minimum and maximum</span>
<span class="comments">;            value to be returned. Only levels _within_ this range</span>
<span class="comments">;            will be returned. If RANGE contains only one element,</span>
<span class="comments">;            this is interpreted as MAX and MIN will be assumed as</span>
<span class="comments">;            3 decades smaller. RANGE superseeds the MIN and MAX</span>
<span class="comments">;            keywords. Note that RANGE must be positive definite</span>
<span class="comments">;            but can be given in descending order in which case</span>
<span class="comments">;            the labels will be reversed.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;        MIN, MAX -> alternative way of specifying a RANGE. If only</span>
<span class="comments">;            one keyword is given, the other one is computed as</span>
<span class="comments">;            3 decades smaller/larger than the given parameter.</span>
<span class="comments">;            RANGE superseeds MIN and MAX.</span>
<span class="comments">;</span>
<span class="comments">;        /FINE -> always return finer levels (1,2,5,...)</span>
<span class="comments">;</span>
<span class="comments">;        COARSE -> the maximum number of decades for which LOGLEVELS</span>
<span class="comments">;            shall return fine labels. Default is 3. (non-integer</span>
<span class="comments">;            values are possible).</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;        A vector with "round" logarithmic values within the given</span>
<span class="comments">;        range. The original (or modified) RANGE will be returned</span>
<span class="comments">;        unchanged if RANGE does not span at least one label interval.</span>
<span class="comments">;        The result will always contain at least two elements.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SUBROUTINES:</span>
<span class="comments">;        none</span>
<span class="comments">;</span>
<span class="comments">; REQUIREMENTS:</span>
<span class="comments">;        none</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;        If COARSE is lt 0, the nearest decades will be returned</span>
<span class="comments">;        instead. The result will always have at least two elements.</span>
<span class="comments">;        If COARSE forces decades, the result values may be out-of-</span>
<span class="comments">;        range if RANGE spans less than a decade.</span>
<span class="comments">;</span>
<span class="comments">;        Caution with type conversion from FLOAT to DOUBLE !!</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;        range = [ min(data), max(data) ]</span>
<span class="comments">;        c_level = LOGLEVELS(range)</span>
<span class="comments">;        contour,...,c_level=c_level</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;        mgs, 17 Mar 1999: VERSION 1.00</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 1999, Martin Schultz, Harvard University</span>
<span class="comments">; This software is provided as is without any warranty</span>
<span class="comments">; whatsoever. It may be freely used, copied or distributed</span>
<span class="comments">; for non-commercial purposes. This copyright notice must be</span>
<span class="comments">; kept with any copy of this software. If this software shall</span>
<span class="comments">; be used commercially or sold as part of a larger package,</span>
<span class="comments">; please contact the author to arrange payment.</span>
<span class="comments">; Bugs and comments should be directed to mgs@io.harvard.edu</span>
<span class="comments">; with subject "IDL routine loglevels"</span>
<span class="comments">;-------------------------------------------------------------</span>


<a id="loglevels:source"></a>function loglevels,range,min=mind,max=maxd,  $
           coarse=coarse,fine=fine


    if (n_elements(COARSE) eq 0) then COARSE = 3

    <span class="comments">; Make sure to have a valid range which is positive definite</span>
    <span class="comments">; NOTE that range does not need to be sorted!</span>
    if (n_elements(mind) gt 0) then begin
       mind = mind[0]
       if (n_elements(maxd) eq 0) then maxd = mind*1000.
    endif
    if (n_elements(maxd) gt 0) then begin
       maxd = maxd[0]
       if (n_elements(mind) eq 0) then mind = maxd*0.001
    endif
    <span class="comments">; still not defined, i.e. neither mind nor maxd given</span>
    if (n_elements(mind) eq 0) then begin
       mind = 0.1
       maxd = 100.
    endif
    <span class="comments">; RANGE superseeds min and max</span>
    if (n_elements(range) eq 0) then range = [ mind,maxd ]
    <span class="comments">; one element for RANGE is interpreted as MAX</span>
    if (n_elements(range) eq 1) then range = [ range*0.001, range ]

    thisrange = double(range) > 1.D-100
    thisrange = thisrange(sort(thisrange))

    <span class="comments">; set lower range to 3 decades below upper range if it is zero</span>
    if (thisrange[0] lt 1.D-36) then thisrange[0] = thisrange[1]/1000.


    <span class="comments">; get log of ranges and decadal log</span>
    lrange = alog10(thisrange)
    if (lrange[0] lt 0.) then lrange[0] = lrange[0] - 1.0D-6
    if (lrange[1] lt 0.) then lrange[1] = lrange[1] - 1.0D-6
<span class="comments">;   if (lrange[1] gt 0.) then lrange[1] = lrange[1] + 1.0D-6</span>
    drange = fix(lrange)


    <span class="comments">; create label arrays to choose from</span>
    <span class="comments">; currently 1.D-15 to 5.D+16</span>
    <span class="comments">; ranges outside these limits always return only decades</span>

    <span class="comments">; set mode according to following rules:</span>
    <span class="comments">; - range outside limits -> return decades</span>
    <span class="comments">; - coarse exceeded -> return decades</span>
    <span class="comments">; - /fine set -> return 1,2,5,... for any number of decades</span>
    <span class="comments">; - [automatic] -> return decades if more than COARSE decades</span>
    <span class="comments">;                 otherwise 1,2,5,..</span>

    mode = 0   <span class="comments">; return decades</span>
    if (keyword_set(fine)) then mode = 1
    if ((lrange[1]-lrange[0]) le COARSE) then mode = 1
    if (thisrange[0] lt 1.D-15 OR thisrange[1] gt 5.D16) then mode = 0

    if (mode) then begin
       <span class="comments">; make overall array</span>
       labels = [ 1.D-15, 2.D-15, 5.D-15, 1.D-14, 2.D-14, 5.D-14, $
                  1.D-13, 2.D-13, 5.D-13, 1.D-12, 2.D-12, 5.D-12, $
                  1.D-11, 2.D-11, 5.D-11, 1.D-10, 2.D-10, 5.D-10, $
                  1.D-09, 2.D-09, 5.D-09, 1.D-08, 2.D-08, 5.D-08, $
                  1.D-07, 2.D-07, 5.D-07, 1.D-06, 2.D-06, 5.D-06, $
                  1.D-05, 2.D-05, 5.D-05, 1.D-04, 2.D-04, 5.D-04, $
                  1.D-03, 2.D-03, 5.D-03, 1.D-02, 2.D-02, 5.D-02, $
                  1.D-01, 2.D-01, 5.D-01, 1.D+00, 2.D+00, 5.D+00 ]
       labels = [ labels, $
                  1.D+01, 2.D+01, 5.D+01, 1.D+02, 2.D+02, 5.D+02, $
                  1.D+03, 2.D+03, 5.D+03, 1.D+04, 2.D+04, 5.D+04, $
                  1.D+05, 2.D+05, 5.D+05, 1.D+06, 2.D+06, 5.D+06, $
                  1.D+07, 2.D+07, 5.D+07, 1.D+08, 2.D+08, 5.D+08, $
                  1.D+09, 2.D+09, 5.D+09, 1.D+10, 2.D+10, 5.D+10, $
                  1.D+11, 2.D+11, 5.D+11, 1.D+12, 2.D+12, 5.D+12, $
                  1.D+13, 2.D+13, 5.D+13, 1.D+14, 2.D+14, 5.D+14, $
                  1.D+15, 2.D+15, 5.D+15, 1.D+16, 2.D+16, 5.D+16 ]

        llabels = alog10(labels)
        ind = where(llabels ge lrange[0] AND llabels le lrange[1])

        <span class="comments">; if range values are too close, return original range</span>
        if (ind[0] lt 0) then return,range

        <span class="comments">; return reversed labels if range[0] gt range[1]</span>
        if (range[0] gt range[1]) then $
           return,reverse(labels[min(ind):max(ind)]) $
        else $
           return,labels[min(ind):max(ind)]

    endif else begin

       if (lrange[1] lt 0.) then drange[1] = drange[1] - 1

       exponent = indgen(drange[1]-drange[0]+1)+drange[0]
       if (n_elements(exponent) eq 1) then $
          exponent = [ exponent, exponent+1 ]

       if (range[0] gt range[1]) then $
          return,reverse(10.D0^exponent)  $
       else $
          return,10.D0^exponent
    endelse

end
</code>
    </div>
  </body>
</html>