<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:58 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgcmdwindow__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgcmdwindow__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgCmdWindow</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Creates a "command" window for IDL traditional commands (Plot, Contour, </span>
<span class="comments">;   Surface, etc. or for Coyote Graphics routines, cgPlot, cgContour, cgSurf, etc.). </span>
<span class="comments">;   In addition, the window contents can be saved as PostScript files or as raster image </span>
<span class="comments">;   files. If ImageMagick is installed on your machine, the raster image files can be </span>
<span class="comments">;   created in very high quality from PostScript files. This program can be used in </span>
<span class="comments">;   place of a normal draw widget or as a stand-alone program.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;+</span>
<span class="comments">;  Creates a "command" window for IDL traditional commands (Plot, Contour, </span>
<span class="comments">;  Surface, etc. or for Coyote Graphics routines, cgPlot, cgContour, cgSurf, etc.). </span>
<span class="comments">;  In addition, the window contents can be saved as PostScript files or as raster image </span>
<span class="comments">;  files. If ImageMagick is installed on your machine, the raster image files can be </span>
<span class="comments">;  created in very high quality from PostScript files. This program can be used in </span>
<span class="comments">;  place of a normal draw widget or as a stand-alone program.</span>
<span class="comments">;</span>
<span class="comments">;  The program is designed to work with any IDL traditional graphics routine</span>
<span class="comments">;  that is a procedure and includes no more than four positional parameters.</span>
<span class="comments">;  Any number of keywords can be used to specify properties of the graphical</span>
<span class="comments">;  output. Any number of graphics commands can be "added" the the window.</span>
<span class="comments">;  Simply use the AddCommand method to add commands.</span>
<span class="comments">;  </span>
<span class="comments">;  If your program does not load its own color tables, the color tables in</span>
<span class="comments">;  effect when this program is initiated are used to display the graphics</span>
<span class="comments">;  commands.</span>
<span class="comments">;    </span>
<span class="comments">;  To create PostScript output from within the program, your graphics program</span>
<span class="comments">;  has to be written in such a way that it can work properly in the PostScript</span>
<span class="comments">;  device. This means there are no Window commands, WSet commands, and the like</span>
<span class="comments">;  that are not allowed in the PostScript device. Such commands are allowed in </span>
<span class="comments">;  programs, of course, if they are "protected". Usually such protection looks </span>
<span class="comments">;  like this::</span>
<span class="comments">;  </span>
<span class="comments">;     IF (!D.Flags AND 256) NE 0 THEN Window, ...</span>
<span class="comments">;     </span>
<span class="comments">;  The Coyote Graphics program `cgDisplay` is a good program for opening graphics </span>
<span class="comments">;  "windows", because such PostScript protection is built into the program. In a PostScript </span>
<span class="comments">;  device, cgDisplay produces a "window" with the same aspect ratio as the current</span>
<span class="comments">;  display graphics window, which is an aid in producing PostScript output that</span>
<span class="comments">;  looks like the same output in the display window.</span>
<span class="comments">;   </span>
<span class="comments">;  Much better looking raster files can be created from the graphics window contents,</span>
<span class="comments">;  if the raster files are created by converting PostScript files to the raster </span>
<span class="comments">;  file. If the ImageMagick "convert" command can be found on your machine, you</span>
<span class="comments">;  will have the option to create raster files using this method. I *highly*</span>
<span class="comments">;  recommend doing so, as fonts and other plot annotation will be of much higher</span>
<span class="comments">;  quality using this method.</span>
<span class="comments">;   </span>
<span class="comments">;  This program has been designed to work with other Coyote Graphics routines: `cgPlot`,</span>
<span class="comments">;  `cgContour`, `cgSurf`, and so on, although I expect it to work with any IDL</span>
<span class="comments">;  traditional graphics routine, if the routine is well written.</span>
<span class="comments">;        </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011, Fanning Software Consulting, Inc.</span>
<span class="comments">;     </span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Separated from old cgWindow program 22 Jan 2012, by David W. Fanning.</span>
<span class="comments">;        Fixed a typo in PackageCommand method that prevented extra keywords from</span>
<span class="comments">;           being collectd. 26 Jan 2012. DWF.</span>
<span class="comments">;        Fixed a problem with MULTI keyword. 31 Jan 2012. DWF.</span>
<span class="comments">;        Added a COPY method. 7 Feb 2012. DWF.</span>
<span class="comments">;        Fixed a problem with input filenames in the AutoRasterFile method. 22 Feb 2012. DWF.</span>
<span class="comments">;        Modified Draw_Widget creation routine to account for events that were added in </span>
<span class="comments">;           different versions of IDL. 23 Feb 2012. DWF.</span>
<span class="comments">;        Added ability to use IM_WIDTH keyword to set the width of raster file output</span>
<span class="comments">;           created with ImageMagick. 3 April 2012. DWF.</span>
<span class="comments">;        Forgot to specify the GROUP_LEADER when calling PS_START. Caused PSConfig to</span>
<span class="comments">;           run though its block when cgWindow was called from a blocking widget program.</span>
<span class="comments">;           5 June 2012. DWF.</span>
<span class="comments">;        Added the ability to save the file name and directory of the last output file, so</span>
<span class="comments">;            that subsequent file saves can use that last name and directory as a starting</span>
<span class="comments">;            default filename. 11 July 2012. DWF.</span>
<span class="comments">;        In decompling cgWindow from cgCmdWindow, I accidentally named the WASPECT keyword ASPECT. Restored</span>
<span class="comments">;             original name in this version. 13 July 2012. DWF.</span>
<span class="comments">;        I added a new method, ReplaceEscapeSequences, that can evaluate escape sequences in</span>
<span class="comments">;             string parameters and keywords to call the appropriate cgSymbol value at run-time.</span>
<span class="comments">;             This eliminates the need for alternate keywords. 27 July 2012. DWF.</span>
<span class="comments">;        Added WDestroyObjects keyword to destroy objects parameters, if needed. 11 November 2012. DWF.</span>
<span class="comments">;        Not adding IM_WIDTH parameter from cgWindow_GetDefs. 19 November 2012. DWF.</span>
<span class="comments">;        Modified ReplaceEscapeSequence method to use cgCheckForSymbols. 24 November 2012. DWF.</span>
<span class="comments">;        Modified to allow keywords to turn off messages from PS_START and PS_END with keywords. 27 November 2012. DWF.</span>
<span class="comments">;        The output filename was not specified correctly when making PDF file automatically. Fixed. 2 Dec 2012. DWF.</span>
<span class="comments">;        Renamed the MULTI keyword to WMULTI, as it was suppose to be. 11 Feb 2013. DWF.</span>
<span class="comments">;        Misspelled keyword in PackageCommand method. 21 February 2013. DWF.</span>
<span class="comments">;        Modified GUI so there is only one Raster Image File choice, depending on if ImageMagick is</span>
<span class="comments">;           installed. 21 May 2013. DWF.</span>
<span class="comments">;-</span>


<span class="comments">;+</span>
<span class="comments">; This method initializes the object that is at the heart of the Coyote Graphics system.</span>
<span class="comments">; It allows you to both configure the draw widget for events and to load a command into</span>
<span class="comments">; the command window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    parent: in, optional</span>
<span class="comments">;       The parent base widget for this draw widget object. If not defined,</span>
<span class="comments">;       the program will create its own top-level base widget.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    altps_Keywords: in, optional, type=string</span>
<span class="comments">;       A structure containing alternative keyword names (as tags) and values for</span>
<span class="comments">;       those keywords to be used when the current device is the PostScript device.</span>
<span class="comments">;       See http://www.idlcoyote.com/cg_tips/kwexpressions.php and the examples</span>
<span class="comments">;       below for details on how to use this keyword.</span>
<span class="comments">;    altps_Params: in, optional, type=IntArr(3)</span>
<span class="comments">;       A structure containing alternative parameter values to be used when </span>
<span class="comments">;       the current device is the PostScript device. Structure names are restricted</span>
<span class="comments">;       to the names "P1", "P2", "P3" and "P4"to correspond to the equivalent positional</span>
<span class="comments">;       parameter. See http://www.idlcoyote.com/cg_tips/kwexpressions.php and the </span>
<span class="comments">;       examples below for details on how to use this keyword.</span>
<span class="comments">;    background: in, optional, type=varies, default=!P.Background</span>
<span class="comments">;       The background color of the window. Specifying a background color </span>
<span class="comments">;       automatically sets the WErase keyword.</span>
<span class="comments">;    button_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn button events on for the draw widget.</span>
<span class="comments">;    command: in, required, type=string</span>
<span class="comments">;       The graphics procedure command to be executed. This parameter</span>
<span class="comments">;       must be a string and the the command must be a procedure. Examples</span>
<span class="comments">;       are 'Surface', 'Contour', 'Plot', 'cgPlot', cgContour, etc.</span>
<span class="comments">;    cmddelay: in, optional, type=float</span>
<span class="comments">;       If this keyword is set to a value other than zero, there will be a </span>
<span class="comments">;       delay of this many seconds between command execution. This will permit</span>
<span class="comments">;       "movies" of command sequences to be displayed.</span>
<span class="comments">;    drop_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn drop events on for the draw widget.</span>
<span class="comments">;    eraseit: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to cause the window to be erased before graphics commands </span>
<span class="comments">;       are drawn. This may need to be set, for example, to display images.</span>
<span class="comments">;    event_handler: in, optional, type=string</span>
<span class="comments">;        The name of an event handler procedure to accept events from</span>
<span class="comments">;        the draw widget. Write the event handler procedure with two</span>
<span class="comments">;        positional parameters. The first will be the event structure</span>
<span class="comments">;        returned from the draw widget. The second will be the cgCmdWindow</span>
<span class="comments">;        object reference (i.e., self) to allow you to manipulate the</span>
<span class="comments">;        command window.</span>
<span class="comments">;    group_leader: in, optional</span>
<span class="comments">;       The identifier of a widget to serve as a group leader for this program.</span>
<span class="comments">;       If the group leader is destroyed, this program is also destroyed. Used</span>
<span class="comments">;       when calling this program from another widget program.</span>
<span class="comments">;    keyboard_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn keyboard events on for the draw widget.</span>
<span class="comments">;    method: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if the command is an object method call rather than a </span>
<span class="comments">;       procedure call. If this keyword is set, the first positional parameter, p1,</span>
<span class="comments">;       must be present and must be a valid object reference.</span>
<span class="comments">;    motion_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn motion events on for the draw widget.</span>
<span class="comments">;    oxmargin: in, optional, type=float</span>
<span class="comments">;       A two-element array indicating the left and right X outside margins for the</span>
<span class="comments">;       graphical display. Used only when doing multiple plots with `WMulti`.</span>
<span class="comments">;    oymargin: in, optional, type=float</span>
<span class="comments">;       A two-element array indicating the bottom and top Y outside margins for the</span>
<span class="comments">;       graphical display. Used only when doing multiple plots with `WMulti`.</span>
<span class="comments">;    p1: in, optional, type=any</span>
<span class="comments">;       The first positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p2: in, optional, type=any</span>
<span class="comments">;       The second positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p3: in, optional, type=any</span>
<span class="comments">;       The third positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p4: in, optional, type=any</span>
<span class="comments">;       The fourth positional parameter appropriate for the graphics command.</span>
<span class="comments">;    replacecmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to replace a graphics command from an cgWindow.</span>
<span class="comments">;       If CmdIndex is undefined, *all* commands in the window are replaced. Use </span>
<span class="comments">;       WinID to identify the cgWindow you are interested in. If WinID is </span>
<span class="comments">;       undefined, the last cgWindow created is used for the replacement.</span>
<span class="comments">;    storage: in, optional, type=any</span>
<span class="comments">;       Any user-defined IDL variable will be stored in the object storage location.</span>
<span class="comments">;       Defined here for convenience. Same as `Storage` keyword for the SetProperty method.</span>
<span class="comments">;    tracking_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn tracking events on for the draw widget.</span>
<span class="comments">;    waspect: in, optional, type=float, default=normal</span>
<span class="comments">;       Set this keyword to the aspect ratio you would like the window to have.</span>
<span class="comments">;       The aspect ratio is calculated as (ysize/xsize). Must be a float value.</span>
<span class="comments">;       If this keyword is set, the window will maintain this aspect ratio,</span>
<span class="comments">;       even when it is resized.</span>
<span class="comments">;    wdestroyobjects: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, and any of the input parameters p1-p4 is an object,</span>
<span class="comments">;       the object parameter will be destroyed when the window is destroyed.</span>
<span class="comments">;    wheel_events: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword to turn wheel events on for the draw widget.</span>
<span class="comments">;    wmulti: in, optional, type=intarr(5)</span>
<span class="comments">;        Set this keyword in exactly the same way you would set the !P.Multi keyword.</span>
<span class="comments">;        It will allow you to display multi-plots in the cgWindow graphics window.</span>
<span class="comments">;    wtitle: in, optional, type=string, default='Resizeable Graphics Window'</span>
<span class="comments">;       The title of the graphics window if the program creates its own top-level</span>
<span class="comments">;       base widget. A window index number is appended to the title so multiple cgWindow </span>
<span class="comments">;       programs can be selected. Also used to register the widget program and as the</span>
<span class="comments">;       title of the object when it is stored.</span>
<span class="comments">;    wxpos: in, optional, type=integer, default=5</span>
<span class="comments">;       The x offset in device coordinates of the window from the upper-left corner of </span>
<span class="comments">;       the display, if the program creates its own top-level base. Otherwise, this keyword</span>
<span class="comments">;       is ignored.</span>
<span class="comments">;    wypos: in, optional, type=integer, default=5</span>
<span class="comments">;       The y offset in device coordinates of the window from the upper-left corner of </span>
<span class="comments">;       the display, if the program creates its own top-level base. Otherwise, this keyword</span>
<span class="comments">;       is ignored.</span>
<span class="comments">;    wxsize: in, optional, type=integer, default=640</span>
<span class="comments">;       The x size in device coordinates of the graphics window.</span>
<span class="comments">;    wysize: in, optional, type=integer, default=512</span>
<span class="comments">;       The y size in device coordinates of the the graphics window.</span>
<span class="comments">;    _extra: in, optional</span>
<span class="comments">;       The "extra" keywords for the command that is being added to the window.</span>
<span class="comments">;-</span>
FUNCTION cgCmdWindow::Init, parent, $
   AltPS_Keywords=altps_Keywords, $ <span class="comments">; A structure of PostScript alternative keywords and values.</span>
   AltPS_Params=altps_Params, $     <span class="comments">; A structure of PostScript alternative parameters and values. </span>
   Background = background, $       <span class="comments">; The background color. Set to !P.Background by default.</span>
   Button_Events=button_events, $   <span class="comments">; Set this keyword to allow button events in the draw widget.</span>
   CmdDelay=cmdDelay, $             <span class="comments">; Set this keyword to a value to "wait" before executing the next command.</span>
   Command=command, $               <span class="comments">; The graphics "command" to execute.</span>
   Drop_Events=drop_events, $       <span class="comments">; Set this keyword to allow drop events in the draw widget.</span>
   EraseIt = eraseit, $             <span class="comments">; Set this keyword to erase the display before executing the command.</span>
   Event_Handler=event_handler, $   <span class="comments">; Set this keyword to the name of an event handler procedure to handle draw widget events.</span>
   Group_Leader = group_leader, $   <span class="comments">; The group leader of the cgWindow program.</span>
   Keyboard_Events=keyboard_events, $ <span class="comments">; Set this keyword to allow keyboard events in the draw widget.</span>
   Method=method, $                 <span class="comments">; If set, will use CALL_METHOD instead of CALL_PROCEDURE to execute command.</span>
   Motion_Events=motion_events, $   <span class="comments">; Set this keyword to allow motion events in the draw widget.</span>
   OXMargin = xomargin, $           <span class="comments">; Set the !X.OMargin. A two element array.</span>
   OYMargin = yomargin, $           <span class="comments">; Set the !Y.OMargin. A two element array</span>
   P1=p1, $                         <span class="comments">; The first postitional parameter in a graphics command loaded for display.</span>
   P2=p2, $                         <span class="comments">; The sedond postitional parameter in a graphics command loaded for display.</span>
   P3=p3, $                         <span class="comments">; The third postitional parameter in a graphics command loaded for display.</span>
   P4=p4, $                         <span class="comments">; The fourth postitional parameter in a graphics command loaded for display. </span>
   ReplaceCmd=replacecmd, $         <span class="comments">; Replace the current command and execute in the current window.</span>
   Storage=storage, $               <span class="comments">; A storage pointer location. Used like a user value in a widget.</span>
   Tracking_Events=tracking_events, $ <span class="comments">; Set this keyword to allow tracking events in the draw widget.</span>
   WAspect = waspect, $             <span class="comments">; Set the window aspect ratio to this value.</span>
   WDestroyObjects=wdestroyobjects, $ <span class="comments">; Set this keyword to destroy object parameters upon exit.</span>
   Wheel_Events=wheel_events, $     <span class="comments">; Set this keyword to allow wheel events in the draw widget.</span>
   WMulti = wmulti, $               <span class="comments">; Set this in the same way !P.Multi is used.</span>
   WTitle = title, $                <span class="comments">; The window title.</span>
   WXPos = xpos, $                  <span class="comments">; The X offset of the window on the display. The window is centered if not set.</span>
   WXSize = xsize, $                <span class="comments">; The X size of the cgWindow graphics window in pixels. By default: 400.</span>
   WYPos = ypos, $                  <span class="comments">; The Y offset of the window on the display. The window is centered if not set.</span>
   WYSize = ysize, $                <span class="comments">; The Y size of the cgWindow graphics window in pixels. By default: 400.</span>
   _Extra = extra                   <span class="comments">; Any extra keywords. Usually the "command" keywords.</span>

    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, 0
    ENDIF
   
    <span class="comments">; Check keywords.</span>
    method = Keyword_Set(method)
    
    <span class="comments">; Get the global defaults.</span>
    cgWindow_GetDefs, $
       AdjustSize = d_adjustsize, $                      <span class="comments">; Adjust charsize to window size.</span>
       Background = d_background, $                      <span class="comments">; The background color. </span>
       Delay = d_delay, $                                <span class="comments">; The amount of delay between command execution.</span>
       EraseIt = d_eraseit, $                            <span class="comments">; Set this keyword to erase the display before executing the commands.</span>
       Multi = d_multi, $                                <span class="comments">; Set this in the same way !P.Multi is used.   </span>
       XOMargin = d_xomargin, $                          <span class="comments">; Set the !X.OMargin. A two element array.</span>
       YOMargin = d_yomargin, $                          <span class="comments">; Set the !Y.OMargin. A two element array</span>
       XSize = d_xsize, $                                <span class="comments">; The X size of the cgWindow graphics window.</span>
       YSize = d_ysize, $                                <span class="comments">; The Y size of the cgWindow graphics window.</span>
       Title = d_title, $                                <span class="comments">; The window title.</span>
       XPos = d_xpos, $                                  <span class="comments">; The X offset of the window on the display.</span>
       YPos = d_ypos, $                                  <span class="comments">; The Y offset of the window on the display. </span>
       Aspect = d_aspect, $                              <span class="comments">; The aspect ratio of the window.</span>
       Palette = d_palette, $                            <span class="comments">; The color table palette to use for the window.</span>
       
       <span class="comments">; PDF properties.</span>
       PDF_Unix_Convert_Cmd = d_pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
       PDF_Path = d_pdf_path, $                          <span class="comments">; The path to the Ghostscript conversion command.</span>
   
       <span class="comments">; ImageMagick Properties.</span>
       IM_Transparent = d_im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
       IM_Density = d_im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
       IM_Raster = d_im_raster, $                        <span class="comments">; Create raster files via ImageMagick.</span>
       IM_Resize = d_im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
       IM_Options = d_im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
       IM_Width = d_im_width, $                          <span class="comments">; The width of the raster file output.</span>
        
       <span class="comments">; PostScript properties.</span>
       PS_Decomposed = d_ps_decomposed, $                <span class="comments">; Sets the PostScript color mode.</span>
       PS_Delete = d_ps_delete, $                        <span class="comments">; Delete PS file when making IM raster.</span>
       PS_Metric = d_ps_metric, $                        <span class="comments">; Select metric measurements in PostScript output.</span>
       PS_Encapsulated = d_ps_encapsulated, $            <span class="comments">; Create Encapsulated PostScript output.    </span>
       PS_FONT = d_ps_font, $                            <span class="comments">; Select the font for PostScript output.</span>
       PS_CHARSIZE = d_ps_charsize, $                    <span class="comments">; Select the character size for PostScript output.</span>
       PS_QUIET = d_ps_quiet, $                          <span class="comments">; Select the QUIET keyword for PS_Start.</span>
       PS_SCALE_FACTOR = d_ps_scale_factor, $            <span class="comments">; Select the scale factor for PostScript output.</span>
       PS_TT_FONT = d_ps_tt_font                         <span class="comments">; Select the true-type font to use for PostScript output.</span>
        
    <span class="comments">; If method is set, the first positional parameter must be present,</span>
    <span class="comments">; and it must be a valid object reference.</span>
    IF method THEN BEGIN
        IF N_Elements(p1) EQ 0 THEN $
            Message, 'The parameter P1 must be present to make a method call.'
        IF ~Obj_Valid(p1) THEN $
            Message, 'The parameter P1 must be a valid object reference when making method calls.'
    ENDIF
    SetDefaultValue, waspect, d_aspect 
    SetDefaultValue, xsize, d_xsize 
    SetDefaultValue, ysize, d_ysize 
    SetDefaultValue, xpos, d_xpos 
    SetDefaultValue, ypos, d_ypos 
    SetDefaultValue, button_events, 0, /Boolean
    SetDefaultValue, drop_events, 0, /Boolean
    SetDefaultValue, keyboard_events, 0, /Boolean
    SetDefaultValue, motion_events, 0, /Boolean
    SetDefaultValue, tracking_events, 0, /Boolean
    SetDefaultValue, wheel_events, 0, /Boolean
    IF N_Elements(storage) NE 0 THEN self.storage = Ptr_New(storage)
    IF N_Elements(background) EQ 0 THEN BEGIN
        background = d_background
        IF N_Elements(command) EQ 0 THEN eraseit = 1
        IF (N_Elements(command) NE 0) && cgCoyoteGraphic(command) THEN eraseit = 1
    ENDIF ELSE BEGIN
        eraseit = 1
    ENDELSE
    IF N_Elements(eraseIt) EQ 0 THEN eraseIt = d_eraseit ELSE eraseIt = Keyword_Set(eraseIt)

    <span class="comments">; The commands will be placed in a linked list for execution.</span>
    self.cmds = Obj_New('LinkedList')
    IF Obj_Valid(self.cmds) EQ 0 THEN Message, 'Failed to make the LinkedList for the commands.'
    
    <span class="comments">; Add a command, if you have one. Otherwise, just make the window.</span>
    IF (N_Elements(command) NE 0) THEN BEGIN
        thisCommand = Obj_New('cgWindow_Command', COMMAND=command, $
                P1=p1, P2=p2, P3=p3, P4=p4, KEYWORDS=extra, TYPE=method, $
                ALTPS_KEYWORDS=altps_Keywords, ALTPS_PARAMS=altps_Params, $
                DESTROYOBJECTS=Keyword_Set(wdestroyobjects))
        IF Obj_Valid(thisCommand) THEN self.cmds -> Add, thisCommand ELSE Message, 'Failed to make command object.'
    ENDIF 
    
    <span class="comments">; If there is a palette, use it. Otherwise, use the current color table vectors.</span>
    IF Total(d_palette) NE 0 THEN BEGIN
        IF Size(d_palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
        dims = Size(d_palette, /DIMENSIONS)
        threeIndex = Where(dims EQ 3)
        IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
        IF threeIndex[0] EQ 0 THEN d_palette = Transpose(d_palette)
        self.r = Ptr_New(d_palette[*,0])
        self.g = Ptr_New(d_palette[*,1])
        self.b = Ptr_New(d_palette[*,2])
    ENDIF ELSE BEGIN
        TVLCT, rr, gg, bb, /Get
        self.r = Ptr_New(rr)
        self.g = Ptr_New(gg)
        self.b = Ptr_New(bb)
    ENDELSE
    
    <span class="comments">; Create the widgets for the program.</span>
    IF N_Elements(parent) NE 0 THEN BEGIN
       self.tlb = parent
       createParent = 0
    ENDIF ELSE BEGIN    
       self.tlb = Widget_Base(/TLB_SIZE_EVENTS, MBar=menuID, UNAME='TLB_RESIZE')
       createParent = 1
    ENDELSE
    
    <span class="comments">; Create buttons if you created the parent widget.</span>
    IF createParent THEN BEGIN
    
        fileID = Widget_Button(menuID, Value='File')
        saveID = Widget_Button(fileID, Value='Save Window As...', /MENU)
        button = Widget_Button(saveID, Value='PostScript File', UNAME='POSTSCRIPT')
        button = Widget_Button(saveID, Value='PDF File', UNAME='PDF')
        
        <span class="comments">; If you can find ImageMagick on this machine, you can convert to better</span>
        <span class="comments">; looking raster files.</span>
        IF cgHasImageMagick() EQ 1 THEN BEGIN
            imraster = Widget_Button(saveID, Value='Raster Image File', /MENU)
            button = Widget_Button(imraster, Value='BMP', UNAME='IMAGEMAGICK_BMP')
            button = Widget_Button(imraster, Value='GIF', UNAME='IMAGEMAGICK_GIF')
            button = Widget_Button(imraster, Value='JPEG', UNAME='IMAGEMAGICK_JPEG')
            button = Widget_Button(imraster, Value='PNG', UNAME='IMAGEMAGICK_PNG')
            button = Widget_Button(imraster, Value='TIFF', UNAME='IMAGEMAGICK_TIFF')
        ENDIF ELSE BEGIN
            raster = Widget_Button(saveID, Value='Raster Image File', /MENU)
            button = Widget_Button(raster, Value='BMP', UNAME='RASTER_BMP')
            button = Widget_Button(raster, Value='GIF', UNAME='RASTER_GIF')
            button = Widget_Button(raster, Value='JPEG', UNAME='RASTER_JPEG')
            button = Widget_Button(raster, Value='PNG', UNAME='RASTER_PNG')
            button = Widget_Button(raster, Value='TIFF', UNAME='RASTER_TIFF')
        ENDELSE
        
        button = Widget_Button(fileID, Value='Save Current Visualization', /Separator, UNAME='SAVECOMMANDS')
        button = Widget_Button(fileID, Value='Restore Visualization', UNAME='RESTORECOMMANDS')
        button = Widget_Button(fileID, Value='Quit', /Separator, UNAME='QUIT')
    
    ENDIF
    
    <span class="comments">; Check to see if you have to create a window with a particular aspect ratio.</span>
    <span class="comments">; If so, your xsize and ysize values will need to be adjusted.</span>
    IF waspect NE 0 THEN BEGIN
         IF waspect GE 1 THEN BEGIN
            xsize = Round(ysize / waspect)
         ENDIF ELSE BEGIN
            ysize = Round(xsize * waspect)
         ENDELSE
     ENDIF
    
    <span class="comments">; Create draw widget. UNIX versions of IDL have a bug in which creating</span>
    <span class="comments">; a draw widget as the very first window in an IDL session causes both</span>
    <span class="comments">; !P.Background and !P.Color to be set to white. I know, it's odd. But</span>
    <span class="comments">; doing this little trick fixes the problem.</span>
    tempBackground = !P.Background
    tempColor = !P.Color
    retain = (StrUpCase(!Version.OS_Family) EQ 'UNIX') ? 2 : 1
    IF ~createParent THEN BEGIN
        notify_realize = 'cgCmdWindowDrawRealize'
        kill_notify = 'cgCmdWindowKillNotify'
    ENDIF
    self.drawID = Widget_Draw(self.tlb, XSIZE=xsize, YSize=ysize, RETAIN=retain, $
       UVALUE=self, Notify_Realize=notify_realize, $
       UNAME='DRAW_WIDGET', Kill_Notify=kill_notify, $
       BUTTON_EVENTS=button_events, $
       KEYBOARD_EVENTS=keyboard_events, $
       MOTION_EVENTS=motion_events, $
       TRACKING_EVENTS=tracking_events) 
    release = Float(!Version.Release) 
    IF (N_Elements(wheel_events) NE 0) && (release GE 6.2) THEN $
       Widget_Control, self.drawID, DRAW_WHEEL_EVENTS=wheel_events
    IF (N_Elements(drop_events) NE 0) && (release GE 6.3) THEN $
       Widget_Control, self.drawID, SET_DROP_EVENTS=drop_events
       
    
    !P.Background = Temporary(tempBackground)
    !P.Color = Temporary(tempColor)
    
    <span class="comments">; Do we need to center the widget? Only do this if you created the parent.</span>
    IF (xpos EQ -1) && (ypos EQ -1) && createParent THEN BEGIN
        DefSysV, '!FSC_WINDOW_LIST', EXISTS=exists
        IF ~exists THEN BEGIN
           xpos = 5
           ypos = 5
        ENDIF ELSE BEGIN
            IF Obj_Valid(!FSC_WINDOW_LIST) THEN BEGIN
                count = !FSC_WINDOW_LIST -> Get_Count()
                xpos = 5 + (30*count)
                ypos = 5 + (25*count)
            ENDIF ELSE BEGIN
                xpos = 5
                ypos = 5           
            ENDELSE
        ENDELSE
        cgCenterTLB, self.tlb, xpos, ypos, /NOCENTER, /DEVICE
    ENDIF ELSE BEGIN
        IF createParent THEN cgCenterTLB, self.tlb, xpos, ypos, /NOCENTER, /DEVICE
    ENDELSE
    
    <span class="comments">; Display the widget and get window index number.</span>
    currentWindow = !D.Window
    IF createParent THEN BEGIN 
        Widget_Control, self.tlb, /Realize
        Widget_Control, self.drawID, Get_Value=wid
        self.wid = wid
        WSet, wid
        IF N_Elements(title) EQ 0 THEN BEGIN
            title = d_title
            title = title + ' (' + StrTrim(wid,2) + ')'
        ENDIF
        Widget_Control, self.tlb, TLB_Set_Title=title
    ENDIF ELSE BEGIN
        IF N_Elements(title) EQ 0 THEN title = "cgCmdWindow"
    ENDELSE
    self.title = title
    

    <span class="comments">; Load object properties.</span>
    self.background = Ptr_New(background)
    IF N_Elements(cmdDelay) NE 0 THEN self.delay = cmdDelay ELSE self.delay = d_delay
    self.eraseIt = eraseIt
    IF N_Elements(wmulti) NE 0 THEN BEGIN
       FOR j=0,N_Elements(wmulti)-1 DO self.pmulti[j] = wmulti[j]
    ENDIF ELSE self.pmulti = d_multi
    IF N_Elements(xomargin) NE 0 THEN self.xomargin = xomargin ELSE self.xomargin = d_xomargin
    IF N_Elements(yomargin) NE 0 THEN self.yomargin = yomargin ELSE self.yomargin = d_yomargin
    self.adjustsize = d_adjustsize
    self.createParent = createParent
    self.destroyObjects = Keyword_Set(wdestroyobjects)
    self.im_transparent = d_im_transparent
    self.im_density = d_im_density
    self.im_options = d_im_options
    self.im_raster = d_im_raster
    self.im_resize = d_im_resize
    self.im_width = d_im_width
    self.msysvar = Ptr_New(/Allocate_Heap)
    self.pdf_unix_convert_cmd = d_pdf_unix_convert_cmd
    self.pdf_path = d_pdf_path
    self.ps_decomposed = d_ps_decomposed
    self.ps_delete = d_ps_delete
    self.ps_encapsulated = d_ps_encapsulated
    self.ps_metric = d_ps_metric
    self.ps_charsize = d_ps_charsize
    self.ps_font = d_ps_font
    self.ps_quiet = d_ps_quiet
    self.ps_scale_factor = d_ps_scale_factor
    self.ps_tt_font = d_ps_tt_font
    self.waspect = waspect

    IF createParent THEN BEGIN
    
        <span class="comments">; Get it running.</span>
        WIDGET_CONTROL, /MANAGED, self.tlb
        XManager, 'cgwindow', self.tlb, /No_Block, $
            Event_Handler='cgCmdWindow_Dispatch_Events', $
            Cleanup = 'cgCmdWindow_Cleanup', $
            Group_Leader=group_leader
            
        <span class="comments">; Store the self object in UVALUE of TLB. This is so it can be cleaned up properly.</span>
        Widget_Control, self.tlb, SET_UValue=self
        
        <span class="comments">; Store the object reference on the external linked list.</span>
        self -> StoreObjectReference
        
        <span class="comments">; Execute the commands</span>
        self -> ExecuteCommands
        
    ENDIF
    
    <span class="comments">; Restore the current graphics window, if you can.</span>
    IF (currentWindow GE 0) && WindowAvailable(currentWindow) THEN BEGIN
       WSet, currentWindow
    ENDIF ELSE WSet, -1
    RETURN, 1

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; This program is called when the draw widget is realized. The purpose is to find</span>
<span class="comments">; and set the window index number in the program, store the object reference on</span>
<span class="comments">; an external linked list so it can found again later, and to execute the loaded</span>
<span class="comments">; commands.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     drawID: in, required</span>
<span class="comments">;         The widget identifier of the draw widget.</span>
<span class="comments">;-</span>
PRO cgCmdWindowDrawRealize, drawID

    Widget_Control, drawID, Get_UVALUE=theObject, Get_VALUE=wid
    theObject -> SetProperty, WID=wid
    
    <span class="comments">; Store the object reference on the external linked list.</span>
    theObject -> StoreObjectReference
    
    <span class="comments">; Execute the commands</span>
    theObject -> ExecuteCommands
    
END



<span class="comments">;+</span>
<span class="comments">; This program is called when the draw widget is destroyed. The purpose</span>
<span class="comments">; is to clean up the object.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     drawID: in, required</span>
<span class="comments">;         The widget identifier of the draw widget.</span>
<span class="comments">;-</span>
PRO cgCmdWindowKillNotify, drawID

    Widget_Control, drawID, GET_UVALUE=theObject
    Obj_Destroy, theObject
    
END

<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The cleanup method for the cgCmdWindow object.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::Cleanup

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Free any pointers.</span>
    Ptr_Free, self.background
    Ptr_Free, self.r
    Ptr_Free, self.g
    Ptr_Free, self.b
    Ptr_Free, self.msysvar
    Ptr_Free, self.storage
    
    <span class="comments">; Destroy the command objects.</span>
    IF Obj_Valid(self.cmds) THEN BEGIN
        count = self.cmds -> Get_Count()
        FOR j=0,count-1 DO Obj_Destroy, self.cmds -> Get_Item(j, /DEREFERENCE)
        Obj_Destroy, self.cmds
    ENDIF
    
    <span class="comments">; You have to remove yourself from the list of valid cgWindows.</span>
    theList = !FSC_WINDOW_LIST
    IF Obj_Valid(theList) THEN BEGIN
        structs = theList -> Get_Item(/ALL, /DEREFERENCE)
        index = Where(structs.windowObj[*] EQ self, count)
        IF count GT 0 THEN theList -> Delete, index[0]
    ENDIF 
    
    <span class="comments">; If the list doesn't have any more cgWindows objects in it,</span>
    <span class="comments">; delete the list so it doesn't waste memory. </span>
    IF ((theList -> Get_Count()) EQ 0) THEN Obj_Destroy, theList
    
    <span class="comments">; If your widget ID is valid, destroy the widget program.</span>
    IF self.createParent && Widget_Info(self.tlb, /VALID_ID) THEN Widget_Control, self.tlb, /Destroy
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This procedure builds a command structure and saves the structure</span>
<span class="comments">; to the main IDL level. Its purpose is to allow the user to work</span>
<span class="comments">; with restored commands independently of the window interface.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     structname: in, optional, type=string, default="cmd"</span>
<span class="comments">;         The name of the command structure to be saved at the </span>
<span class="comments">;         main IDL level.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     quiet: in, optional, type=boolean</span>
<span class="comments">;         If set, the message indicated where the variable was saved</span>
<span class="comments">;         and what its name is is not printed in the IDL command window.</span>
<span class="comments">;-</span>
PRO cgWindow_Command::CreateCommandStruct, structName, Quiet=quiet

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Struct variable name</span>
    IF N_Elements(structName) EQ 0 THEN structName='cmd'

    cmdString = self.command
    cmdStruct = Create_Struct('Command', cmdString, 'nparams', self.nparams, 'type', self.type)
    CASE self.nparams OF
        0:
        1: cmdStruct = Create_Struct(cmdStruct, 'p1', *self.p1)
        2: cmdStruct = Create_Struct(cmdStruct, 'p1', *self.p1, 'p2', *self.p2)
        3: cmdStruct = Create_Struct(cmdStruct, 'p1', *self.p1, 'p2', *self.p2, 'p3', *self.p3)
        4: cmdStruct = Create_Struct(cmdStruct, 'p1', *self.p1, 'p2', *self.p2, 'p3', *self.p3, 'p4', *self.p4)
    ENDCASE
    IF Ptr_Valid(self.keywords) THEN BEGIN
        cmdStruct = Create_Struct(cmdStruct, 'keywords', *self.keywords)
    ENDIF

    <span class="comments">; Copy the variable to the MAIN level</span>
    (Scope_VarFetch(structName, /Enter, Level=1)) = Temporary(cmdStruct)
    IF NOT Keyword_Set(quiet) THEN $
        PRINT, 'Created command struct variable ', structName, ' in IDL $MAIN level.'

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This procedure makes and returns a copy of a command object.</span>
<span class="comments">;-</span>
FUNCTION cgWindow_Command::Copy

    IF Ptr_Valid(self.keywords) THEN BEGIN
    
        CASE self.nparams OF
           0: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, $
                KEYWORDS=*self.keywords, TYPE=self.type, $
                DESTROYOBECTS=self.destroyObjects)
           1: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, $
                KEYWORDS=*self.keywords, TYPE=self.type, $
                DESTROYOBECTS=self.destroyObjects)
           2: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, P2=*self.p2, $
                KEYWORDS=*self.keywords, TYPE=self.type, $
                DESTROYOBECTS=self.destroyObjects)
           3: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, P2=*self.p2, $
                P3=*self.p3, KEYWORDS=*self.keywords, TYPE=self.type, $
                DESTROYOBECTS=self.destroyObjects)
           4: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, P2=*self.p2, $
                P3=*self.p3, P4=*self.p4, KEYWORDS=*self.keywords, TYPE=self.type, $
                DESTROYOBECTS=self.destroyObjects)
        ENDCASE
        
    ENDIF ELSE BEGIN
    
        CASE self.nparams OF
           0: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, $
                TYPE=self.type, DESTROYOBECTS=self.destroyObjects)
           1: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, $
                 TYPE=self.type, DESTROYOBECTS=self.destroyObjects)
           2: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, P2=*self.p2, $
                 TYPE=self.type, DESTROYOBECTS=self.destroyObjects)
           3: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, p2=*self.p2, P3=*self.p3, $
                 TYPE=self.type, DESTROYOBECTS=self.destroyObjects)
           4: copyObj = Obj_New('cgWindow_Command', COMMAND=self.command, P1=*self.p1, p2=*self.p2, P3=*self.p3, P4=*self.p4, $
                 TYPE=self.type, DESTROYOBECTS=self.destroyObjects)
        ENDCASE
    
    ENDELSE
    
    RETURN, copyObj
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This procedure returns the keyword in a command object, if there</span>
<span class="comments">; are any keywords.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     has_keywords: out, optional, type=boolean</span>
<span class="comments">;         If set to 1, the function returned keywords. If set to 0,</span>
<span class="comments">;         there were no keywords in the command to return.</span>
<span class="comments">;-</span>
FUNCTION cgWindow_Command::Get_Keywords, HAS_KEYWORDS=has_keywords
    IF Ptr_Valid(self.keywords) THEN BEGIN
        has_keywords = 1
        RETURN, *self.keywords 
    ENDIF ELSE BEGIN
        has_keywords = 0
        RETURN, Ptr_New()
    ENDELSE
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


PRO cgWindow_Command::Draw, SUCCESS=success, KEYWORDS=keywords

    Compile_Opt idl2
    
    <span class="comments">; Can't really catch CALL_PROCEDURE errors, so I'm not sure what this is doing here.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        success = 0
        RETURN
    ENDIF
    
    <span class="comments">; It seems it is not possible to catch errors generated by CALL_PROCEDURE,</span>
    <span class="comments">; so I have to fake it out. I reset the !ERROR_STATE structure at the beginning</span>
    <span class="comments">; and assume failure. After I get through the code, I check to see if the</span>
    <span class="comments">; !ERROR_STATE.MSG field is still a null string. If it is, I assume we successfully</span>
    <span class="comments">; executed the command and change the success flag.</span>
    success = 0
    Message, /RESET
    
    <span class="comments">; Do we have alternative keywords?</span>
    IF Ptr_Valid(self.altps_Keywords) THEN BEGIN
       keywords = self -> EvaluateKeywords(*self.keywords, SUCCESS=success)
       IF success EQ 0 THEN Ptr_Free, self.keywords
    ENDIF ELSE BEGIN
        IF Ptr_Valid(self.keywords) THEN BEGIN
            keywords = *self.keywords
            keywords = self -> ReplaceEscapeSequences(keywords)
        ENDIF
    ENDELSE
    
    <span class="comments">; Do we have alternative parameters?</span>
    IF Ptr_Valid(self.altps_params) THEN BEGIN
    
        altTags = Tag_Names(*self.altps_params)
        IF (Where(altTags EQ 'P1') NE -1) THEN BEGIN
            IF (!D.Name EQ 'PS') $
                THEN p1 = (*self.altps_params).p1 $
                ELSE IF Ptr_Valid(self.p1) THEN p1 = *self.p1
        ENDIF ELSE IF Ptr_Valid(self.p1) THEN p1 = *self.p1
        IF (Where(altTags EQ 'P2') NE -1) THEN BEGIN
            IF (!D.Name EQ 'PS') $
                THEN p2 = (*self.altps_params).p2 $
                ELSE IF Ptr_Valid(self.p2) THEN p2 = *self.p2
        ENDIF ELSE IF Ptr_Valid(self.p2) THEN p2 = *self.p2
        IF (Where(altTags EQ 'P3') NE -1) THEN BEGIN
            IF (!D.Name EQ 'PS') $
                THEN p3 = (*self.altps_params).p3 $
                ELSE IF Ptr_Valid(self.p3) THEN p3 = *self.p3
        ENDIF ELSE IF Ptr_Valid(self.p3) THEN p3 = *self.p3
        IF (Where(altTags EQ 'P4') NE -1) THEN BEGIN
            IF (!D.Name EQ 'PS') $
                THEN p4 = (*self.altps_params).p4 $
                ELSE IF Ptr_Valid(self.p4) THEN p4 = *self.p4
        ENDIF ELSE IF Ptr_Valid(self.p4) THEN p4 = *self.p4
    
    ENDIF ELSE BEGIN
        IF Ptr_Valid(self.p1) THEN p1 = *self.p1
        IF Ptr_Valid(self.p2) THEN p2 = *self.p2
        IF Ptr_Valid(self.p3) THEN p3 = *self.p3
        IF Ptr_Valid(self.p4) THEN p4 = *self.p4
    ENDELSE
    
    <span class="comments">; Remove escape sequences, if you need to.</span>
    IF Size(p1, /TNAME) EQ 'STRING' THEN p1 = self -> ReplaceEscapeSequences(p1)
    IF Size(p2, /TNAME) EQ 'STRING' THEN p2 = self -> ReplaceEscapeSequences(p2)
    IF Size(p3, /TNAME) EQ 'STRING' THEN p3 = self -> ReplaceEscapeSequences(p3)
    IF Size(p4, /TNAME) EQ 'STRING' THEN p4 = self -> ReplaceEscapeSequences(p4)

    <span class="comments">; What kind of command is this?</span>
    CASE self.type OF 
    
        <span class="comments">; Command calls a procedure.</span>
        0: BEGIN
        
             IF Ptr_Valid(self.keywords) THEN BEGIN
                 CASE self.nparams OF
                     0: Call_Procedure, self.command, _Extra=keywords
                     1: Call_Procedure, self.command, p1, _Extra=keywords
                     2: Call_Procedure, self.command, p1, p2, _Extra=keywords
                     3: Call_Procedure, self.command, p1, p2, p3, _Extra=keywords
                     4: Call_Procedure, self.command, p1, p2, p3, p4, _Extra=keywords
                 ENDCASE
             ENDIF ELSE BEGIN
                 CASE self.nparams OF
                     0: Call_Procedure, self.command
                     1: Call_Procedure, self.command, p1
                     2: Call_Procedure, self.command, p1, p2
                     3: Call_Procedure, self.command, p1, p2, p3
                     4: Call_Procedure, self.command, p1, p2, p3, p4
                 ENDCASE
             ENDELSE
             
             END
             
        <span class="comments">; Command calls a method.</span>
        1: BEGIN

             IF Ptr_Valid(self.keywords) THEN BEGIN
                 CASE self.nparams OF
                     0: Message, 'Call_Method requires at least one positional parameter.'
                     1: Call_Method, self.command, p1, _Extra=keywords
                     2: Call_Method, self.command, p1, p2, _Extra=keywords
                     3: Call_Method, self.command, p1, p2, p3, _Extra=keywords
                     4: Call_Method, self.command, p1, p2, p3, p4, _Extra=keywords
                 ENDCASE
             ENDIF ELSE BEGIN
                 CASE self.nparams OF
                     0: Message, 'Call_Method requires at least one positional parameter.'
                     1: Call_Method, self.command, p1
                     2: Call_Method, self.command, p1, p2
                     3: Call_Method, self.command, p1, p2, p3
                     4: Call_Method, self.command, p1, p2, p3, p4
                 ENDCASE
             ENDELSE
             
           END
    
    ENDCASE
    
    <span class="comments">; If nothing has been put into the message field, we much have executed the command</span>
    <span class="comments">; successfully.</span>
    IF !Error_State.MSG EQ "" THEN success = 1 

    <span class="comments">; For some reason, CALL_PROCEDURE does not flush the graphics buffer on UNIX machines.</span>
    <span class="comments">; We have to do it ourself to get the program to resize correctly on UNIX machines.</span>
    EMPTY
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; This method replaces stored keyword values with alternative keyword values, if they</span>
<span class="comments">; are available. The return variable is a list of the keywords with the</span>
<span class="comments">; alternative values substituted for the stored values.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;    keywords: in, required, type=structure</span>
<span class="comments">;       The list of input keywords.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     success: out, optional, type=boolean</span>
<span class="comments">;         If the command executed successfully, return a 1. Otherwise</span>
<span class="comments">;         return a 0.</span>
<span class="comments">;-</span>
FUNCTION cgWindow_Command::EvaluateKeywords, keywords, SUCCESS=success

  <span class="comments">; Error handling.</span>
  Catch, theError
  IF theError NE 0 THEN BEGIN
     Catch, /CANCEL
     success = 0
     void = Error_Message()
     IF N_Elements(keywords) NE 0 THEN RETURN, keywords ELSE RETURN, 0
  ENDIF
  
  Compile_Opt idl2
  
  <span class="comments">; Assume success.</span>
  success = 1
  
  <span class="comments">; Need to have keywords.</span>
  IF N_Elements(keywords) EQ 0 THEN $
      Message, 'A keyword structure must be passed to the method.'

  <span class="comments">; Get the keyword names.</span>
  tags = Tag_Names(keywords)
  
  <span class="comments">; Find the keywords to be evaluated in this keyword structure.</span>
  evalTags = Tag_Names(*self.altps_keywords)
  theseTags = Ptr_New(/Allocate_Heap)
  FOR j=0,N_Elements(evalTags)-1 DO BEGIN
     index = Where(tags EQ evalTags[j], count)
     IF (count EQ 1) THEN BEGIN
        IF N_Elements(*theseTags) NE 0 THEN *theseTags = [*theseTags, index] ELSE *theseTags = [index] 
     ENDIF ELSE IF count GT 1 THEN Message, 'Ambiguous keywords to evaluate.'
  ENDFOR
  
  <span class="comments">; Evaluate the keywords and, if necessary, replace the keyword value</span>
  <span class="comments">; with the evaluated value. The evaluated keyword value must initially be a </span>
  <span class="comments">; STRING that can be evaluated with the EXECUTE command.</span>
  FOR j=0,N_Elements(tags)-1 DO BEGIN
    index = Where(*theseTags EQ j, count)
    IF count EQ 0 THEN BEGIN
      IF N_Elements(mkeys) EQ 0 THEN BEGIN
        mkeys = Create_Struct(tags[j], keywords.(j)) 
      ENDIF ELSE BEGIN
        mkeys = Create_Struct(mkeys, tags[j], keywords.(j))
      ENDELSE
    ENDIF ELSE BEGIN
    
      <span class="comments">; If this is PostScript, use the alternative keyword value.</span>
      tagValue = (!D.Name EQ 'PS') ? (*self.altps_keywords).(index) : keywords.(j)
      IF N_Elements(mkeys) EQ 0 THEN BEGIN
        mkeys = Create_Struct(tags[j], tagValue)
      ENDIF ELSE BEGIN
        mkeys = Create_Struct(mkeys, tags[j], tagValue)
      ENDELSE
    ENDELSE
    
  ENDFOR
  
  <span class="comments">; Evaluate string keywords for escape sequences (e.g, $\mu$).</span>
  <span class="comments">;mkeys = cgWindow_Command -> ReplaceEscapeSequences(mkeys)</span>
 
  Ptr_Free, theseTags
  RETURN, mkeys
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method lists the current command by printing a representation</span>
<span class="comments">; of the command in the command log window.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;    prefix: in, optional, type=string</span>
<span class="comments">;       A prefix for the printed command (e.g., an index number, etc.).</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
PRO cgWindow_Command::List, prefix

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    cmdString = self.command
    CASE self.nparams OF
        0:
        1: cmdString = cmdString + ', p1'
        2: cmdString = cmdString + ', p1, p2'
        3: cmdString = cmdString + ', p1, p2, p3'
        4: cmdString = cmdString + ', p1, p2, p3, p4'
    ENDCASE
    IF Ptr_Valid(self.keywords) THEN BEGIN
        tags = Tag_Names(*self.keywords)
        FOR j=0,N_Elements(tags)-1 DO BEGIN
            cmdString = cmdString + ', ' + tags[j] + '=value'
        ENDFOR
    ENDIF
    
    IF N_Elements(prefix) NE 0 THEN prefix = '   ' + prefix + ' ' ELSE prefix = '   '
    
    Print, prefix + cmdString
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; This method searches for escape sequences in text keywords and replaces</span>
<span class="comments">; them if necessary with the particular token from cgSymbol. To create an</span>
<span class="comments">; micrometer symbol, for example, you might specify an XTITLE keyword like</span>
<span class="comments">; this: XTITLE='Length ($\mu$M)'. The symbol name should be proceeded by</span>
<span class="comments">; a "$\" and ended with a "$".</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     aString: in, required</span>
<span class="comments">;        Either a scalar or array of strings, or a structure of keyword parameters. </span>
<span class="comments">;        If a structure, then the ReplaceEscapeSequences method is called recursively.</span>
<span class="comments">;-</span>
FUNCTION cgWindow_Command::ReplaceEscapeSequences, aString

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(aString) EQ 0 THEN RETURN, "" ELSE RETURN, aString
    ENDIF
    
    <span class="comments">; Must have a parameter.</span>
    IF N_Elements(aString) EQ 0 THEN Message, 'Must pass a string or structure of keywords.'
    
    <span class="comments">; What kind of thing is the parameter?</span>
    type = Size(aString, /TNAME)
    
    <span class="comments">; If this is a structure of keyword parameters, sort though and call all string</span>
    <span class="comments">; parameters recursively.</span>
    IF type EQ "STRUCT" THEN BEGIN
    
        tags = Tag_Names(aString)
        FOR j=0,N_Elements(tags)-1 DO BEGIN
           type = Size(aString.(j), /TNAME)
           IF (type EQ 'STRING') || (type EQ 'STRUCT') || (type EQ 'POINTER') THEN BEGIN
              aString.(j) = self -> ReplaceEscapeSequences(aString.(j))
           ENDIF
        ENDFOR
        RETURN, aString
        
    ENDIF
    
    <span class="comments">; Is this a pointer type?</span>
    IF type EQ 'POINTER' THEN BEGIN
    
       IF Size(*aString, /TNAME) EQ 'STRING' THEN *aString = self -> ReplaceEscapeSequences(*aString)
    
    ENDIF
    
    <span class="comments">; If this is a string, then do your thing.</span>
    IF type EQ 'STRING' THEN BEGIN
    
        FOR j=0,N_Elements(aString)-1 DO BEGIN
            thisString = aString[j]
            thisString = cgCheckForSymbols(thisString)
            aString[j] = thisString
        ENDFOR
        
        RETURN, aString
        
    ENDIF

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>



<span class="comments">;+</span>
<span class="comments">; The clean-up routine for the command object.</span>
<span class="comments">;-</span>
PRO cgWindow_Command::Cleanup

    <span class="comments">; Need to destroy parameter objects?</span>
    IF self.destroyobjects THEN BEGIN
       IF Ptr_Valid(self.p1) && Obj_Valid(*self.p1) THEN Obj_Destroy, *self.p1
       IF Ptr_Valid(self.p2) && Obj_Valid(*self.p2) THEN Obj_Destroy, *self.p2
       IF Ptr_Valid(self.p3) && Obj_Valid(*self.p3) THEN Obj_Destroy, *self.p3
       IF Ptr_Valid(self.p4) && Obj_Valid(*self.p4) THEN Obj_Destroy, *self.p4
    ENDIF
    Ptr_Free, self.p1
    Ptr_Free, self.p2
    Ptr_Free, self.p3
    Ptr_Free, self.p4
    Ptr_Free, self.keywords
    Ptr_Free, self.altps_keywords
    Ptr_Free, self.altps_params
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; The initialization routine for the command object.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   altps_keywords: in, optional, type=structure</span>
<span class="comments">;       A structure of alternative keyword names and values to be used</span>
<span class="comments">;       when the PostScript device is the current graphics device.</span>
<span class="comments">;   altps_params: in, optional, type=structure</span>
<span class="comments">;       A structure of alternative parameters and values to be used</span>
<span class="comments">;       when the PostScript device is the current graphics device.</span>
<span class="comments">;   command: in, required, type=string</span>
<span class="comments">;       The command that is being stored in the command object.</span>
<span class="comments">;   destroyobjects: in, optional, type=boolean, default=0</span>
<span class="comments">;       If this keyword is set, and any of the input parameters p1-p4 is an object,</span>
<span class="comments">;       the object parameter will be destroyed when the window is destroyed.</span>
<span class="comments">;   keywords: in, optional, type=structure</span>
<span class="comments">;       A structure containing keyword:value pairs to be executed</span>
<span class="comments">;       with the command.</span>
<span class="comments">;   P1: in, optional, type=varies</span>
<span class="comments">;       The first positional parameter of the command being stored</span>
<span class="comments">;       in the structure.</span>
<span class="comments">;   P2: in, optional, type=varies</span>
<span class="comments">;       The second positional parameter of the command being stored</span>
<span class="comments">;       in the structure.</span>
<span class="comments">;   P3: in, optional, type=varies</span>
<span class="comments">;       The third positional parameter of the command being stored</span>
<span class="comments">;       in the structure.</span>
<span class="comments">;   P4: in, optional, type=varies</span>
<span class="comments">;       The fourth positional parameter of the command being stored</span>
<span class="comments">;       in the structure.</span>
<span class="comments">;   type: in, optional, type=integer, default=0</span>
<span class="comments">;       The type of command. 0 indicates a procedure. 1 indicates an object method.</span>
<span class="comments">;-</span>
FUNCTION cgWindow_Command::INIT, $
    ALTPS_KEYWORDS=altps_keywords, $
    ALTPS_PARAMS=altps_params, $
    COMMAND=command, $
    DESTROYOBJECTS=destroyObjects, $
    KEYWORDS=keywords, $
    P1=p1, P2=p2, P3=p3, P4=p4, $
    TYPE=type
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, 0
    ENDIF

    self.command = command
    IF N_Elements(p1) NE 0 THEN self.p1 = Ptr_New(p1)
    IF N_Elements(p2) NE 0 THEN self.p2 = Ptr_New(p2)
    IF N_Elements(p3) NE 0 THEN self.p3 = Ptr_New(p3)
    IF N_Elements(p4) NE 0 THEN self.p4 = Ptr_New(p4)
    IF N_Elements(keywords) NE 0 THEN self.keywords = Ptr_New(keywords)
    IF N_Elements(altps_keywords) NE 0 THEN self.altps_keywords = Ptr_New(altps_keywords)
    IF N_Elements(altps_params) NE 0 THEN self.altps_params = Ptr_New(altps_params)
    self.destroyobjects = Keyword_Set(destroyObjects)
    self.type = Keyword_Set(type)
    self.nparams = (N_Elements(p1) NE 0) + (N_Elements(p2) NE 0) + (N_Elements(p3) NE 0) + (N_Elements(p4) NE 0)
    RETURN, 1
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; The structure definition module for structure that is stored</span>
<span class="comments">; on the window manager list.</span>
<span class="comments">;-</span>
PRO cgWindow_ID__Define

   struct = { cgWINDOW_ID, $
                 tlb: 0L, $
                 wid: 0L, $
                 title: "", $
                 windowObj: Obj_New() $
             }
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; The clean-up method for the cgCmdWindow object.</span>
<span class="comments">;-</span>
PRO cgCmdWindow_Cleanup, tlb
    Widget_Control, tlb, Get_UValue=self
    IF Obj_Valid(self) THEN Obj_Destroy, self
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; The class definition module for the cgWindow_Command object.</span>
<span class="comments">;-</span>
PRO cgWindow_Command__Define

   <span class="comments">; The definition of the command object.</span>
   class = { cgWindow_Command, $
              command: "", $             <span class="comments">; The command to execute.</span>
              p1: Ptr_New(), $           <span class="comments">; The first parameter.</span>
              p2: Ptr_New(), $           <span class="comments">; The second parameter.</span>
              p3: Ptr_New(), $           <span class="comments">; The third parameter.</span>
              p4: Ptr_New(), $           <span class="comments">; The fourth parameter.</span>
              nparams: 0, $              <span class="comments">; The number of parameters.</span>
              keywords: Ptr_New(), $     <span class="comments">; The command keywords.</span>
              destroyobjects: 0B, $      <span class="comments">; A flag to destroy parameter objects upon exit.</span>
              altps_keywords: Ptr_New(), $ <span class="comments">; Structure of keywords to evaluate at run-time.</span>
              altps_params: Ptr_New(), $  <span class="comments">; Structure of parameters to evaluate at run-time.</span>
              type: 0 $                  <span class="comments">; =0 call_procedure =1 call_method</span>
            }
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; Adds a command object of class cgWINDOW_COMMAND to the command list </span>
<span class="comments">; maintained by the window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     command: in, required, type=object</span>
<span class="comments">;         A command object of class cgWINDOW_COMMAND.</span>
<span class="comments">;         </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     index: in, optional, type=integer</span>
<span class="comments">;         The index number of where the command should be added in the command list.</span>
<span class="comments">;         The command is added to the end of the command list by default.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::AddCommand, command,  INDEX=index

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; If the command is a valid object, add it to the command list.</span>
    IF Obj_Valid(command) THEN self.cmds -> Add, command, index, /Before

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Provides a programmatic way to create a PostScript file from the window.</span>
<span class="comments">; Call by setting the CREATE_PS keyword with cgControl.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     filename:  in, required, type=string</span>
<span class="comments">;         The name of the PostScript file to generate.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::AutoPostScriptFile, filename

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        
        <span class="comments">; Close the PostScript file.</span>
        PS_END, /NoFix     

        <span class="comments">; Set the window index number back.</span>
        IF N_Elements(currentWindow) NE 0 THEN BEGIN
            IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
        ENDIF
        
        RETURN
    ENDIF
    
    <span class="comments">; Make this window the current graphics windows.</span>
    currentWindow = !D.Window
    WSet, self.wid

    IF N_Elements(filename) EQ 0 THEN filename='cgwindow.ps'

    <span class="comments">; Allow the user to configure the PostScript file.</span>
    PS_Start, GUI=0, $
        FILENAME=filename, $
        DECOMPOSED=self.ps_decomposed, $
        EUROPEAN=self.ps_metric, $
        ENCAPSULATED=self.ps_encapsulated, $
        GROUP_LEADER=self.tlb, $
        SCALE_FACTOR=self.ps_scale_factor, $
        CHARSIZE=self.ps_charsize, $
        FONT=self.ps_font, $
        QUIET=self.ps_quiet, $
        TT_FONT=self.ps_tt_font
    
    <span class="comments">; Execute the graphics commands.</span>
    self -> ExecuteCommands
    
    <span class="comments">; Clean up.</span>
    PS_End, NOMESSAGE=self.ps_quiet

    <span class="comments">; Set the window index number back.</span>
    IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; Provides a programmatic way to create a raster file from the window.</span>
<span class="comments">; Call by setting the create_png, etc. keyword with cgControl.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     filetype:  in, required, type=string</span>
<span class="comments">;         The type of raster file (e.g., PNG, JPEG, etc.).</span>
<span class="comments">;     filename:  in, required, type=string</span>
<span class="comments">;         The name of the output file.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::AutoRasterFile, filetype, filename

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        
        <span class="comments">; Close the PostScript file.</span>
        PS_END, /NoFix     

        <span class="comments">; Set the window index number back.</span>
        IF N_Elements(currentWindow) NE 0 THEN BEGIN
            IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
        ENDIF
        
        RETURN
    ENDIF
    
    <span class="comments">; Make this window the current graphics windows.</span>
    currentWindow = !D.Window
    WSet, self.wid

    IF N_Elements(filetype) EQ 0 then filetype = 'PNG'
    IF N_Elements(filename) EQ 0 THEN filename = 'cgwindow.' + StrLowCase(filetype)
    IF StrUpCase(filetype) EQ 'PDF' THEN rastertype = -1 ELSE rastertype = self.im_raster
    
    <span class="comments">; Strip the extension off the filename.</span>
    outname = cgRootName(filename, DIRECTORY=dirName)
    
    <span class="comments">; Put it back together without an extension.</span>
    outputFilename = Filepath(ROOT_DIR=dirName, outname)
    
    <span class="comments">; What kind of raster file.</span>
    CASE rasterType OF
    
        <span class="comments">; PDF File.</span>
       -1: BEGIN
       
           thisname = outputFilename + '.ps'
           outname = outputFilename + '.pdf'
           PS_Start, $
                DECOMPOSED=self.ps_decomposed, $
                FILENAME=thisname, $
                GROUP_LEADER=self.tlb, $
                METRIC=self.ps_metric, $
                KEYWORDS=keywords, $ <span class="comments">; Returned PSConfig keywords.</span>
                SCALE_FACTOR=self.ps_scale_factor, $
                CHARSIZE=self.ps_charsize, $
                FONT=self.ps_font, $
                QUIET=1, $
                TT_FONT=self.ps_tt_font
                           
           <span class="comments">; Draw the graphics.</span>
           self -> ExecuteCommands
           
           <span class="comments">; Close the file and make a PDF file.</span>
           PS_End
           cgPS2PDF, thisname, outname, DELETE_PS=self.ps_delete, /SILENT, SUCCESS=success, $
              UNIX_CONVERT_CMD=self.pdf_unix_convert_cmd, GS_PATH=self.pdf_path
           IF ~success THEN BEGIN
              Message, 'Unable to create PDF file. See cgPS2PDF documentation.'
           ENDIF ELSE BEGIN
              IF ~self.ps_quiet THEN Print, 'PDF output will be created here: ' + outname
           ENDELSE
           END
    
        <span class="comments">; Normal raster.</span>
        0: BEGIN
           void = cgSnapshot(TYPE=fileType, FILENAME=outputFilename, /NODIALOG)
           Print, 'Output file is located here: ' + outputFilename 
           END
           
        <span class="comments">; Raster via ImageMagick.</span>
        1: BEGIN
        
           <span class="comments">; Create a PostScript file first.</span>
           thisname = outputFilename + '.ps'
           PS_Start, $
                DECOMPOSED=self.ps_decomposed, $
                FILENAME=thisname, $
                GROUP_LEADER=self.tlb, $
                METRIC=self.ps_metric, $
                KEYWORDS=keywords, $ <span class="comments">; Returned PSConfig keywords.</span>
                SCALE_FACTOR=self.ps_scale_factor, $
                CHARSIZE=self.ps_charsize, $
                FONT=self.ps_font, $
                QUIET=1, $
                TT_FONT=self.ps_tt_font
                
           <span class="comments">; Cannot successfully convert encapsulated landscape file to raster.</span>
           <span class="comments">; Limitation of ImageMagick, and specifically, GhostScript, which does</span>
           <span class="comments">; the conversion.</span>
           IF keywords.encapsulated && keywords.landscape THEN BEGIN
                Message, 'ImageMagick cannot successfully convert an encapsulated ' + $
                         'PostScript file in landscape mode to a raster file. Returning...'
           ENDIF
           
           <span class="comments">; Draw the graphics.</span>
           self -> ExecuteCommands

           <span class="comments">; Close the file and convert to proper file type.</span>
            CASE filetype OF
                'BMP':  PS_END, /BMP, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width, NOMESSAGE=self.ps_quiet
                'GIF':  PS_END, /GIF, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width, NOMESSAGE=self.ps_quiet
                'JPEG': PS_END, /JPEG, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width, NOMESSAGE=self.ps_quiet
                'PNG':  PS_END, /PNG,  DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width, NOMESSAGE=self.ps_quiet
                'TIFF': PS_END, /TIFF, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width, NOMESSAGE=self.ps_quiet
           ENDCASE
           <span class="comments">;IF ~self.ps_quiet THEN Print, 'Output file is located here: ' + outfilename</span>
           END
    
    ENDCASE

    <span class="comments">; Set the window index number back.</span>
    IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method copies the contents of the draw widget to the current graphics window using</span>
<span class="comments">; the DEVICE COPY method. The DEVICE COPY command looks like this::</span>
<span class="comments">;</span>
<span class="comments">;    DEVICE, COPY=[origin[0], origin[1], extent[0], extent[1], destination[0], destination[1], self.wid]</span>
<span class="comments">;</span>
<span class="comments">; If the IMAGE keyword is used, the window contents are stored in a band-interleaved image variable</span>
<span class="comments">; and the window contents are not copied into the current graphics window.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    destination: in, optional, type=intarr(2)</span>
<span class="comments">;        A two-element array specifying the device coordinates of the lower-left</span>
<span class="comments">;        corner of the copied region in the destination window. By default, [0,0].</span>
<span class="comments">;    extent: in, optional, type=intarr(2)</span>
<span class="comments">;       A two-element array specifying the number of columns and rows to copy.</span>
<span class="comments">;       If missing, the entire draw widget window is copied. By default, [!D.X_Size, !D.Y_Size].</span>
<span class="comments">;    image: out, optional, type=byte</span>
<span class="comments">;       Set this keyword to a named IDL variable that returns a copy of the draw</span>
<span class="comments">;       widget contents as a band interleaved (MxNx3) image. If this keyword is set</span>
<span class="comments">;       nothing is copied from the window.</span>
<span class="comments">;    origin: in, optional, type=intarr(2)</span>
<span class="comments">;       A two-element array specifying the device coordinates of the lower-left</span>
<span class="comments">;       corner of region in the draw widget window to be copied. By default, [0,0].</span>
<span class="comments">;-</span>
PRO cgCmdWindow::Copy, $
   DESTINATION=dest, $
   EXTENT=extent,             $
   IMAGE=image,               $
   ORIGIN=origin

   Compile_Opt idl2
    
   <span class="comments">; Error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
   ENDIF
    
   <span class="comments">; Get the window ID of the window we are copying to.</span>
   destination = !D.Window
   
   <span class="comments">; Make the draw widget the current graphics window.</span>
   WSet, self.wid

   <span class="comments">; Check the input parameters</span>
   IF (N_Elements(origin) NE 2) THEN origin = [0, 0]
   IF (N_Elements(extent) NE 2) THEN extent = [!D.X_Size, !D.Y_Size]
   IF (N_Elements(dest  ) NE 2) THEN dest   = [0, 0]

   <span class="comments">; If we're using an output variable, capture the current window</span>
   IF Arg_Present(image) THEN BEGIN
      image = cgSnapshot(origin[0], origin[1], extent[0], extent[1], TRUE=3)
      IF (destination NE -1) THEN WSet, destination
   ENDIF ELSE BEGIN
      IF (destination NE -1) THEN WSet, destination ELSE Message, 'No current window to copy into.'
      DEVICE, COPY=[origin[0], origin[1], extent[0], extent[1], dest[0], dest[1], self.wid]
   ENDELSE
   
   
END


<span class="comments">;+</span>
<span class="comments">; This method allows you to turn draw widget events on and off and to set</span>
<span class="comments">; the name of an event handler procedure to accept these widget events.</span>
<span class="comments">; An event handler procedure must be defined to get the events processed</span>
<span class="comments">; correctly. </span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     button_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn button events on for the draw widget.</span>
<span class="comments">;     drop_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn drop events on for the draw widget.</span>
<span class="comments">;     event_handler: in, optional, type=string</span>
<span class="comments">;         The name of an event handler procedure to accept events from</span>
<span class="comments">;         the draw widget. Write the event handler procedure with two</span>
<span class="comments">;         positional parameters. The first will be the event structure</span>
<span class="comments">;         returned from the draw widget. The second will be the cgCmdWindow</span>
<span class="comments">;         object reference (i.e., self) to allow you to manipulate the</span>
<span class="comments">;         command window.</span>
<span class="comments">;     keyboard_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn keyboard events on for the draw widget.</span>
<span class="comments">;     motion_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn motion events on for the draw widget.</span>
<span class="comments">;     storage: in, optional, type=any</span>
<span class="comments">;         Any user-defined IDL variable will be stored in the object storage location.</span>
<span class="comments">;         Defined here for convenience. Same as `Storage` keyword for the SetProperty method.</span>
<span class="comments">;     tracking_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn tracking events on for the draw widget.</span>
<span class="comments">;     wheel_events: in, optional, type=boolean</span>
<span class="comments">;         Set this keyword to turn wheel events on for the draw widget.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::DrawWidgetConfig, $
   Button_Events=button_events, $
   Drop_Events=drop_events, $
   Event_Handler=event_handler, $
   Keyboard_Events=keyboard_events, $
   Motion_Events=motion_events, $
   Storage=storage, $
   Tracking_Events=tracking_events, $
   Wheel_Events=wheel_events

   IF N_Elements(button_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Button_Events=Keyword_Set(button_events)
   IF N_Elements(drop_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Drop_Events=Keyword_Set(drop_events)
   IF N_Elements(event_handler) NE 0 THEN self.event_handler = event_handler
   IF N_Elements(keyboard_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Keyboard_Events=Keyword_Set(keyboard_events)
   IF N_Elements(motion_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Motion_Events=Keyword_Set(motion_events)
   IF N_Elements(storage) NE 0 THEN self -> SetProperty, Storage=storage
   IF N_Elements(tracking_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Tracking_Events=Keyword_Set(tracking_events)
   IF N_Elements(wheel_events) NE 0 THEN $
      Widget_Control, self.drawID, Draw_Wheel_Events=Keyword_Set(wheel_events)
   
END



<span class="comments">;+</span>
<span class="comments">; This event handler processes draw widget events and sends the events</span>
<span class="comments">; to a user-defined event handler, if such and event handler exists.</span>
<span class="comments">; The event handler must be defined to accept two positional parameters.</span>
<span class="comments">; The first is the event structure returned by the draw widget, and the</span>
<span class="comments">; second is the cgCmdWindow object reference.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;         An event structure.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::DrawWidgetEvents, event

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Make the draw widget the current graphics window.</span>
    WSet, self.wid

    <span class="comments">; Pass the event on to the event handler, if there is one.</span>
    IF self.event_handler NE "" THEN BEGIN
       Call_Procedure, self.event_handler, event
    ENDIF ELSE Message, 'No event handler has been specified for draw widget events from cgCmdWindow.'
    
END



<span class="comments">;+</span>
<span class="comments">; Sends the window commands to a PostScript file.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;         An event structure.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::CreatePostScriptFile, event

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        
        <span class="comments">; Close the PostScript file.</span>
        PS_END, /NoFix     

        <span class="comments">; Set the window index number back.</span>
        IF N_Elements(currentWindow) NE 0 THEN BEGIN
            IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
        ENDIF
        
        RETURN
    ENDIF
    
    <span class="comments">; Make this window the current graphics windows</span>
    currentWindow = !D.Window
    WSet, self.wid
    
    <span class="comments">; Construct a file name, if you have one.</span>
    ext = self.ps_encapsulated ? '.eps' : '.ps'
    IF self.lastWriteFile NE "" THEN BEGIN
        filename = Filepath(ROOT_DIR=self.lastWriteDir, self.lastWriteFile + ext)
    ENDIF ELSE BEGIN
         CD, CURRENT=thisDir
         filename = Filepath(ROOT_DIR=thisDir, 'cgwindow' + ext)
    ENDELSE

    <span class="comments">; Allow the user to configure the PostScript file.</span>
    PS_Start, /GUI, $
        CANCEL=cancelled, $
        CHARSIZE=self.ps_charsize, $
        DECOMPOSED=self.ps_decomposed, $
        EUROPEAN=self.ps_metric, $
        ENCAPSULATED=self.ps_encapsulated, $
        FILENAME=filename, $
        FONT=self.ps_font, $
        GROUP_LEADER=self.tlb, $
        KEYWORDS=keywords, $
        SCALE_FACTOR=self.ps_scale_factor, $
        QUIET=self.ps_quiet, $
        TT_FONT=self.ps_tt_font
    IF cancelled THEN RETURN
    
    <span class="comments">; Save the name of the last output file.</span>
    self.lastWriteDir = File_DirName(keywords.filename)
    self.lastWriteFile = cgRootName(keywords.filename)
    
    <span class="comments">; Execute the graphics commands.</span>
    self -> ExecuteCommands
    
    <span class="comments">; Clean up.</span>
    PS_End
    
    <span class="comments">; Set the window index number back.</span>
    IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; Deletes a command object from the command list maintained by the window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     cmdIndex: in, optional, type=integer</span>
<span class="comments">;         The zero-based index of the command to delete. If undefined, the</span>
<span class="comments">;         index of the last command in the window is used.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     all: in, optional, type=boolean</span>
<span class="comments">;         If set, all the commands in the command list are deleted.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::DeleteCommand, cmdIndex, ALL=all

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Get the command count.</span>
    count = self.cmds -> Get_Count()
    
    <span class="comments">; Delete all the commands? Is so, delete and RETURN.</span>
    IF Keyword_Set(all) THEN BEGIN
        self.cmds -> Delete_Nodes, /DESTROY
        self -> ExecuteCommands
        RETURN
    ENDIF
    
    <span class="comments">; Need a command index?</span>
    IF N_Elements(cmdIndex) EQ 0 THEN BEGIN
        cmdIndex = count - 1
    ENDIF 
    
    <span class="comments">; Do we have a command with this command number?</span>
    IF cmdIndex GT (count-1) THEN Message, 'A command with index ' + StrTrim(cmdIndex,2) + ' does not exist.'
    
    IF cmdIndex GE 0 THEN BEGIN
        self.cmds -> Delete, cmdIndex, /Destroy
        self -> ExecuteCommands
    ENDIF ELSE Message, 'A negative command index number is not allowed.'
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; All widget events come here and are dispatched to the proper object method.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;         An event structure.</span>
<span class="comments">;-</span>
PRO cgCmdWindow_Dispatch_Events, event

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Get the window object.</span>
    Widget_Control, event.top, GET_UVALUE=self
    
    <span class="comments">; Get the event type. If the type is an object, then</span>
    <span class="comments">; this must be a resize event from the TLB.</span>
    eventType = Widget_Info(event.id, /UNAME)
    
    <span class="comments">; Dispatch the events to the proper method.</span>
    CASE eventType OF   
        'DRAW_WIDGET': self -> DrawWidgetEvents, event
        'IMAGEMAGICK_BMP': self -> SaveAsRaster, event
        'IMAGEMAGICK_GIF': self -> SaveAsRaster, event
        'IMAGEMAGICK_JPEG': self -> SaveAsRaster, event
        'IMAGEMAGICK_PNG': self -> SaveAsRaster, event
        'IMAGEMAGICK_TIFF': self -> SaveAsRaster, event
        'POSTSCRIPT': self -> CreatePostscriptFile, event
        'PDF': self -> SaveAsRaster, event
        'RASTER_BMP': self -> SaveAsRaster, event
        'RASTER_GIF': self -> SaveAsRaster, event
        'RASTER_JPEG': self -> SaveAsRaster, event
        'RASTER_PNG': self -> SaveAsRaster, event
        'RASTER_TIFF': self -> SaveAsRaster, event
        'RESTORECOMMANDS': self -> RestoreCommands
        'SAVECOMMANDS': self -> SaveCommands
        'TLB_RESIZE': self -> Resize, event.x, event.y
        'QUIT': Obj_Destroy, self
        ELSE: Message, 'Unknown type of event: ' + eventtype + '. Cannot dispatch properly.'
    ENDCASE
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method executes the commands on the command list.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::ExecuteCommands

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        !P.Multi = thisMulti
        !X.OMargin = thisXOmargin
        !Y.OMargin = thisYOmargin
        IF N_Elements(rr) NE 0 THEN TVLCT, rr, gg, bb
        IF (!D.Flags AND 256) NE 0 THEN WSet, -1
        RETURN
    ENDIF
    
    <span class="comments">; Make sure you are suppose to be executing these commands.</span>
    IF Keyword_Set(self.noExecuteCommands) THEN RETURN
    
    <span class="comments">; Store the current !P.MULTI state.</span>
    thisMulti = !P.Multi
    thisXOmargin = !X.OMargin
    thisYOmargin = !Y.OMargin

    <span class="comments">; Make this window the current graphics window.</span>
    IF (!D.Flags AND 256) NE 0 THEN BEGIN
        currentWindow = !D.Window
        WSet, self.wid
    ENDIF
    
    <span class="comments">; Get the current color table vectors so they can be restored.</span>
    TVLCT, rr, gg, bb, /GET
    
    <span class="comments">; Load the color vectors.</span>
    TVLCT, *self.r, *self.g, *self.b
    
    <span class="comments">; Erase the window.</span>
    IF self.eraseit THEN cgErase, *self.background 
    
    <span class="comments">; Are we doing multiple commands?</span>
    IF Total(self.pmulti) NE 0 THEN !P.Multi = self.pmulti
    IF Total(self.xomargin) NE 0 THEN !X.OMargin = self.xomargin
    IF Total(self.yomargin) NE 0 THEN !Y.OMargin = self.yomargin

    <span class="comments">; How many commands are there?</span>
    n_cmds = self.cmds -> Get_Count()
    
    <span class="comments">; Execute the commands.</span>
    FOR j=0,n_cmds-1 DO BEGIN
        thisCmdObj = self.cmds -> Get_Item(j, /DEREFERENCE)
        
        <span class="comments">; Execute the command. </span>
        thisCmdObj -> Draw, SUCCESS=success
        
        <span class="comments">; Did you successfully draw this command?</span>
        IF ~success THEN BEGIN
        
            thisCmdObj -> List
            answer = Dialog_Message('Problem executing the command shown ' + $
                                    'in the console output. Delete command?', /QUESTION)
            IF StrUpCase(answer) EQ 'YES' THEN BEGIN
                self -> DeleteCommand, j
                !P.Multi = thisMulti
                !X.OMargin = thisXOmargin
                !Y.OMargin = thisYOmargin
                IF N_Elements(rr) NE 0 THEN TVLCT, rr, gg, bb
                IF (!D.Flags AND 256) NE 0 THEN WSet, -1
                RETURN
            ENDIF
        
        ENDIF
        
        <span class="comments">; Need to delay?</span>
        IF self.delay NE 0 THEN Wait, self.delay
    ENDFOR
    
    <span class="comments">; Save the current data coordinate system.</span>
    self -> SaveDataCoords
    
    <span class="comments">; If there are no commands, then just erase the window.</span>
    IF n_cmds EQ 0 THEN cgErase, *self.background 
    
    <span class="comments">; Restore the colors in effect when we entered.</span>
    TVLCT, rr, gg, bb
    
    <span class="comments">; Set the !P.Multi and outside margin system variables back to its original values.</span>
    !P.Multi = thisMulti
    !X.OMargin = thisXOmargin
    !Y.OMargin = thisYOmargin
    
    <span class="comments">; Reset the current graphics window, if possible.</span>
    IF (!D.Flags AND 256) NE 0 THEN BEGIN
       IF (currentWindow GE 0) && WindowAvailable(currentWindow) THEN BEGIN
            WSet, currentWindow
       ENDIF ELSE WSet, -1
    ENDIF

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method retrieves the value of a keyword from a particular command,</span>
<span class="comments">; if it can.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;     keyword: in, required, type=string</span>
<span class="comments">;        The name of the keyword you would like to retrieve from the command.</span>
<span class="comments">;     cmdindex: in, required, type=integer</span>
<span class="comments">;        The index number of the command you wish to retrieve the keyword from.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     success: out, optional, type=boolean</span>
<span class="comments">;         If the program can successfully get the keyword, this variable will</span>
<span class="comments">;         contain the value 1. Otherwise, it will contain the value 0.</span>
<span class="comments">;-</span>
FUNCTION cgCmdWindow::GetCommandKeyword, keyword, cmdIndex, SUCCESS=success

    Compile_Opt idl2

    Catch, theError
    IF theError NE 0 THEN BEGIN
        void = Error_Message()
        success = 0
        RETURN, success
    ENDIF
    
    <span class="comments">; Assume failure.</span>
    success = 0

    IF N_Params() NE 2 THEN BEGIN
        Print, 'Useage: keywordValue = obj -> GetCommandKeyword(keywordName, commandIndex)'
        RETURN, ""
    ENDIF
    IF Size(keyword, /TNAME) NE 'STRING' THEN Message, 'Keyword name must be a string variable.'
    
    <span class="comments">; Make sure command index is in the range.</span>
    cmdIndex = 0 > cmdIndex &lt<span class="comments">; ((self.cmds -> Get_Count()) - 1)</span>
    
    <span class="comments">; Get the keywords for the proper command.</span>
    cmdObject = self.cmds -> Get_Item(cmdIndex, /DEREFERENCE)
    keywordStruct = cmdObject -> Get_Keywords(HAS_KEYWORDS=has_keywords)
    
    <span class="comments">; Does this command have keywords?</span>
    retValue = ""
    IF has_keywords THEN BEGIN
        tagNames = Tag_Names(keywordStruct)
        keyIndex = Where(tagNames EQ StrUpCase(keyword), nameCount)
        IF nameCount GT 0 THEN BEGIN
            retvalue = keywordStruct.(nameCount)
            success = 1
        ENDIF ELSE Message, 'This command has no keyword named: ' + keyword
    ENDIF ELSE Message, 'This command has no keywords.'

    RETURN, retValue
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method retrieves properties from the object.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     adjustsize: out, optional, type=boolean</span>
<span class="comments">;         Set this keyword to adjust default character size to the display window size.</span>
<span class="comments">;     background: out, optional, type=string</span>
<span class="comments">;         The background color of the window. Only use if the ERASEIT property is also set.</span>
<span class="comments">;     commands: out, optional</span>
<span class="comments">;         A list of the commands stored in the window.</span>
<span class="comments">;     delay: out, optional, type=float</span>
<span class="comments">;         Set this keyword to the amount of "delay" you want between commands in the command list.</span>
<span class="comments">;     dimensions: out, optional, type=intarr(2)</span>
<span class="comments">;         Set this keyword to a two-element array giving the xsize and ysize</span>
<span class="comments">;         of the draw widget.</span>
<span class="comments">;     eraseit: out, optional, type=boolean</span>
<span class="comments">;         If this property is set, the cgWindow erases with the background color before</span>
<span class="comments">;         displaying the commands in the window's command list.</span>
<span class="comments">;     im_density: out, optional, type=integer, default=300</span>
<span class="comments">;         Set this keyword to the sampling density when ImageMagick creates raster image</span>
<span class="comments">;         file from PostScript outout.</span>
<span class="comments">;     im_options: out, optional, type=string, default=""</span>
<span class="comments">;         Set this keyword to any ImageMagick options you would like to pass along to the</span>
<span class="comments">;         ImageMagick convert command when creating raster image files from PostScript output.</span>
<span class="comments">;     im_resize: out, optional, type=integer, default=25</span>
<span class="comments">;         Set this keyword to percentage that the raster image file created my ImageMagick</span>
<span class="comments">;         from PostScript output should be resized.</span>
<span class="comments">;     im_raster: out, optional, type=boolean, default=1</span>
<span class="comments">;         Set this keyword to zero to create raster files using the create_png etc. keywords</span>
<span class="comments">;         directly, instead of via ImageMagick.</span>
<span class="comments">;     im_transparent: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to allow ImageMagick to create transparent backgrounds when it</span>
<span class="comments">;         makes raster image files from PostScript output.</span>
<span class="comments">;     multi: out, optional, type=Intarr(5)</span>
<span class="comments">;         Set this keyword to the !P.MULTI setting you want to use for the window.</span>
<span class="comments">;         !P.MULTI is set to this setting before command execution, and set back to</span>
<span class="comments">;         it's default value when the commands are finished executing.</span>
<span class="comments">;     noexecutecommands: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to 1 to prevent the window from executing the commands and to</span>
<span class="comments">;         0 if you want the window to execute the commands.</span>
<span class="comments">;     palette: out, optional, type=byte</span>
<span class="comments">;         Use this keyword to pass in an N-by-3 (or 3-by-N) byte array containing the</span>
<span class="comments">;         R, G, and B vectors of a color table. It is probably easier to use cgLoadCT or</span>
<span class="comments">;         XCOLORS to load color tables for the window, but this is provided as another option.</span>
<span class="comments">;     pdf_path: out, optional, type=string</span>
<span class="comments">;         Set this keyword to the name of the path to the Ghostscript command for converting PS to PDF.</span>
<span class="comments">;     pdf_unix_convert_cmd: out, optional, type=string</span>
<span class="comments">;         Set this keyword to the name of an alternative UNIX command to convert PostScript to PDF.</span>
<span class="comments">;     ps_charsize: out, optional, type=float</span>
<span class="comments">;         The PostScript character size.</span>
<span class="comments">;     ps_decomposed: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to zero to set the PostScript color mode to indexed color and to</span>
<span class="comments">;         one to set the PostScript color mode to decomposed color.</span>
<span class="comments">;     ps_delete: out, optional, type=boolean, default=1</span>
<span class="comments">;         Set this keyword to zero if you want to keep the PostScript output ImageMagick creates</span>
<span class="comments">;         when making raster file output.</span>
<span class="comments">;     ps_encapsulated: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to configure PSCONFIG to produce encapsulated PostScript output by default.</span>
<span class="comments">;     ps_font: out, optional, type=integer</span>
<span class="comments">;         Set this keyword to the type of font you want to use in PostScript output. It sets the </span>
<span class="comments">;         FONT keyword on the PSConfig command. Normally, 0 (hardware fonts) or 1 (true-type fonts).</span>
<span class="comments">;     ps_metric: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to configure PSCONFIG to use metric values and A4 page size in its interface.</span>
<span class="comments">;     ps_quiet: out, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to set the QUIET keyword on PS_Start.</span>
<span class="comments">;     ps_scale_factor: out, optional, type=float</span>
<span class="comments">;         Set his keyword to the PostScript scale factor you wish to use in creating PostScript output.</span>
<span class="comments">;     ps_tt_font: out, optional, type=string</span>
<span class="comments">;         Set this keyword to the name of a true-type font to use in creating PostScript output.</span>
<span class="comments">;     storage: out, optional</span>
<span class="comments">;         An IDL variable that was defined and stored here by the program's user .</span>
<span class="comments">;     tlb: out, optional, type=long</span>
<span class="comments">;         The widget identifier of the top-level base widget.</span>
<span class="comments">;     wid: out, optional, type=integer</span>
<span class="comments">;         The window index number of the draw widget.</span>
<span class="comments">;     xomargin: out, optional, type=intarr(2)</span>
<span class="comments">;         Sets the !X.OMargin system variable when multiple plots are displayed in the window.</span>
<span class="comments">;     yomargin: out, optional, type=intarr(2)</span>
<span class="comments">;         Sets the !Y.OMargin system variable when multiple plots are displayed in the window.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::GetProperty, $
    ADJUSTSIZE=adjustsize, $
    BACKGROUND=background, $
    COMMANDS=commands, $
    DELAY=delay, $
    DIMENSIONS=dimensions, $
    ERASEIT=eraseit, $
    IM_DENSITY=im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
    IM_RESIZE=im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
    IM_OPTIONS=im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
    IM_RASTER=im_raster, $                        <span class="comments">; Sets whether to generate raster files via ImageMagick</span>
    IM_TRANSPARENT=im_transparent, $  <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
    NOEXECUTECOMMANDS=noExecuteCommands, $ <span class="comments">; Set if you want commands to execute commands.</span>
    MULTI=multi, $
    PALETTE=palette, $
    PDF_PATH=pdf_path, $                          <span class="comments">; The path to the Ghostscript conversion command.</span>
    PDF_UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
    PS_CHARSIZE=ps_charsize, $                    <span class="comments">; Select the character size for PostScript output.</span>
    PS_DECOMPOSED=ps_decomposed, $
    PS_DELETE=ps_delete, $
    PS_ENCAPSULATED=ps_encapsulated, $
    PS_FONT=ps_font, $                            <span class="comments">; Select the font for PostScript output.</span>
    PS_METRIC=ps_metric, $
    PS_SCALE_FACTOR=ps_scale_factor, $            <span class="comments">; Select the scale factor for PostScript output.</span>
    PS_QUIET=ps_quiet, $
    PS_TT_FONT=ps_tt_font, $                      <span class="comments">; Select the true-type font to use for PostScript output.</span>
    TLB=tlb, $
    STORAGE=storage, $
    WID=wid, $
    XOMARGIN=xomargin, $
    YOMARGIN=yomargin, $
    _EXTRA=extra
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Window properties.</span>
    IF Arg_Present(adjustsize) THEN adjustsize = self.adjustsize
    IF Arg_Present(background) THEN background = *self.background
    IF Arg_Present(palette) THEN BEGIN
        len = N_Elements(*self.r)
        palette = BytArr(len,3)
        palette[*,0] = *self.r
        palette[*,1] = *self.g
        palette[*,2] = *self.b
    ENDIF
    IF Arg_Present(commands) THEN commands = self.cmds
    IF Arg_Present(dimensions) THEN BEGIN
        thisWindow = !D.Window
        WSet, self.wid
        dimensions = [!D.X_Size, !D.Y_Size]
        IF thisWindow GE 0 THEN WSet, thisWindow
    ENDIF
    IF Arg_Present(delay) THEN delay = self.delay
    IF Arg_Present(eraseit) THEN eraseit = self.eraseit
    IF Arg_Present(multi) THEN multi = self.pmulti
    IF Arg_Present(tlb) THEN tlb = self.tlb
    IF Arg_Present(storage) THEN IF Ptr_Valid(self.storage) THEN storage = *self.storage
    IF Arg_Present(wid) THEN wid = self.wid
    IF Arg_Present(xomargin) THEN xomargin = self.xomargin
    IF Arg_Present(yomargin) THEN yomargin = self.yomargin
    
     <span class="comments">; PDF properties.</span>
     pdf_unix_convert_cmd = self.pdf_unix_convert_cmd
     pdf_path = self.pdf_path
    
     <span class="comments">; PostScript properties.</span>
     ps_charsize = self.ps_charsize
     ps_decomposed = self.ps_decomposed
     ps_delete = self.ps_delete
     ps_encapsulated = self.ps_encapsulated
     ps_metric = self.ps_metric
     ps_font = self.ps_font
     ps_quiet = self.ps_quiet
     ps_scale_factor = self.ps_scale_factor
     ps_tt_font = self.ps_tt_font
     
     <span class="comments">; ImageMagick properties.</span>
     im_transparent = self.im_transparent
     im_density = self.im_density
     im_options = self.im_options
     im_resize = self.im_resize
     im_raster = self.im_raster
     
     noExecuteCommands = self.noExecuteCommands
     
    <span class="comments">; You may have gotten keywords you don't know what to deal with. Inform</span>
    <span class="comments">; the user there.</span>
    IF N_Elements(extra) NE 0 THEN BEGIN
       tags = Tag_Names(extra)
       FOR j=0,N_Elements(tags)-1 DO BEGIN
          Message, 'The following property could NOT be obtained in the GetProperty method: ' + tags[j], /Informational
       ENDFOR
    ENDIF
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">;     This method invalidates a widget ID. It is used for restored</span>
<span class="comments">;     visualizations, so that the current window doesn't get inadvertenly</span>
<span class="comments">;     destroyed by a widget identifier from an old program.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::InvalidateWidgetID
    self.tlb = -1
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method lists the command indicated by the command index. In the</span>
<span class="comments">; absence of the command index, all commands are listed.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;      cmdindex: in, optional, type=index</span>
<span class="comments">;         The index number of the command you wish to list. If not supplied,</span>
<span class="comments">;         all the commands in the window are listed.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;       createcommandstruct: out, optional, type=structure</span>
<span class="comments">;          Set to a named variable to return a command structure of this command.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::ListCommand, cmdIndex, CREATECOMMANDSTRUCT=createCommandStruct

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Need a command structure?</span>
    createCommandStruct = Keyword_Set(createCommandStruct)

    <span class="comments">; How many commands are there?</span>
    count = self.cmds -> Get_Count()

    IF N_Elements(cmdIndex) EQ 0 THEN BEGIN
        FOR j = 0, count-1 DO BEGIN
            thisCmdObj = self.cmds -> Get_Item(j, /DEREFERENCE)

            <span class="comments">; Preface the commands with their index number.</span>
            thisCmdObj -> List, StrTrim(j,2) + '.'

            <span class="comments">; Create the command struct</span>
            IF createCommandStruct THEN thisCmdObj -> CreateCommandStruct, 'cmd' + StrTrim(j,2)
        ENDFOR
    ENDIF ELSE BEGIN
        IF cmdIndex LT (count-1) THEN BEGIN
            thisCmdObj = self.cmds -> Get_Item(cmdIndex, /DEREFERENCE)

            <span class="comments">; Preface the commands with their index number.</span>
            thisCmdObj -> List, StrTrim(cmdIndex,2) + '.'

            <span class="comments">; Create the command struct</span>
            IF createCommandStruct THEN thisCmdObj -> CreateCommandStruct, 'cmd' + StrTrim(cmdIndex,2)
        ENDIF ELSE Message, 'The command index is out of range of the number of commands.'
    ENDELSE

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method loads color table vectors into the program.</span>
<span class="comments">; The XCOLORS_DATA keyword is required to get color vector</span>
<span class="comments">; information from XCOLORS.</span>
<span class="comments">;  </span>
<span class="comments">; :Params:</span>
<span class="comments">;     r: in, optional, type=bytarr(256)</span>
<span class="comments">;        The red color vector.</span>
<span class="comments">;     g: in, optional, type=bytarr(256)</span>
<span class="comments">;        The green color vector.</span>
<span class="comments">;     b: in, optional, type=bytarr(256)</span>
<span class="comments">;        The blue color vector.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;      xcolors_data: in, optional, type=structure</span>
<span class="comments">;         The information XColors sends to an object when colors are changed</span>
<span class="comments">;         in XColors.</span>
<span class="comments">; </span>
<span class="comments">;-</span>
PRO cgCmdWindow::LoadColors, r, g, b, XCOLORS_DATA=colorData

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Load the vectors</span>
    IF N_Elements(r) NE 0 THEN *self.r = r
    IF N_Elements(g) NE 0 THEN *self.g = g
    IF N_Elements(b) NE 0 THEN *self.b = b
    
    IF N_Elements(colorData) NE 0 THEN BEGIN
       *self.r = colorData.r
       *self.g = colorData.g
       *self.b = colorData.b
    ENDIF
    
    <span class="comments">; Execute the commands.</span>
    self -> ExecuteCommands
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method creates PostScript, PDF, BMP, GIF, JPEG, PNG, and TIFF file output</span>
<span class="comments">; from the pixmap window contents. The method assumes ImageMagick and Ghostscript</span>
<span class="comments">; are installed correctly.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    filename: in, optional, type=string, default='idl.ps'</span>
<span class="comments">;        The name of the output file. The type of file is determined from the</span>
<span class="comments">;        file name extension.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::Output, filename

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Need a filename?</span>
    IF N_Elements(filename) EQ 0 THEN filename = 'idl.ps'
    
    <span class="comments">; The type of file is determined by the filename extension.</span>
    rootname = cgRootName(filename, DIRECTORY=dir, EXTENSION=ext)
    CASE StrUpCase(ext) OF
       'PS':   self -> AutoPostScriptFile, filename
       'EPS':  self -> AutoPostScriptFile, filename
       'PDF':  self -> AutoRasterFile, 'PDF', filename
       'BMP':  self -> AutoRasterFile, 'BMP', filename
       'GIF':  self -> AutoRasterFile, 'GIF', filename
       'JPG':  self -> AutoRasterFile, 'JPEG', filename
       'JPEG': self -> AutoRasterFile, 'JPEG', filename
       'PNG':  self -> AutoRasterFile, 'PNG', filename
       'TIF':  self -> AutoRasterFile, 'TIFF', filename
       'TIFF': self -> AutoRasterFile, 'TIFF', filename
       ELSE: Message, 'Unknown file type: ' + StrUpCase(ext) + '.'
    ENDCASE
    
 END



<span class="comments">;+</span>
<span class="comments">; Packages the command up into a command object that can be added to the window</span>
<span class="comments">; or used to replace commands that are already in the window.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The command, packaged as a cgWindow_Command object, is returned.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    command: in, required, type=string</span>
<span class="comments">;       The graphics procedure command to be executed. This parameter</span>
<span class="comments">;       must be a string and the the command must be a procedure. Examples</span>
<span class="comments">;       are 'Surface', 'Contour', 'Plot', 'cgPlot', cgContour, etc.</span>
<span class="comments">;    p1: in, optional, type=any</span>
<span class="comments">;       The first positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p2: in, optional, type=any</span>
<span class="comments">;       The second positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p3: in, optional, type=any</span>
<span class="comments">;       The third positional parameter appropriate for the graphics command.</span>
<span class="comments">;    p4: in, optional, type=any</span>
<span class="comments">;       The fourth positional parameter appropriate for the graphics command.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to add the packaged command to the command list.</span>
<span class="comments">;    altps_Keywords: in, optional, type=string</span>
<span class="comments">;       A structure containing alternative keyword names (as tags) and values for</span>
<span class="comments">;       those keywords to be used when the current device is the PostScript device.</span>
<span class="comments">;       See http://www.idlcoyote.com/cg_tips/kwexpressions.php and the examples</span>
<span class="comments">;       below for details on how to use this keyword.</span>
<span class="comments">;    altps_Params: in, optional, type=IntArr(3)</span>
<span class="comments">;       A structure containing alternative parameter values to be used when </span>
<span class="comments">;       the current device is the PostScript device. Structure names are restricted</span>
<span class="comments">;       to the names "P1", "P2", "P3" and "P4" to correspond to the equivalent positional</span>
<span class="comments">;       parameter. See http://www.idlcoyote.com/cg_tips/kwexpressions.php and the </span>
<span class="comments">;       examples below for details on how to use this keyword.</span>
<span class="comments">;    cmdindex: in, optional, type=integer</span>
<span class="comments">;       The command list index. This is used when adding or replacing a command. If the</span>
<span class="comments">;       command index is undefined when replacing a command, all the commands in the command</span>
<span class="comments">;       list are replaced with the command that is being added. If the command index is </span>
<span class="comments">;       undefined when adding a command, the command is added to the end of the command list.</span>
<span class="comments">;    execute: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword is you want to execute the commands in the command list as soon as</span>
<span class="comments">;       the current command is added to the list. Otherwise, no command execution takes place.</span>
<span class="comments">;    method: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword if the command is an object method call rather than a </span>
<span class="comments">;       procedure call. If this keyword is set, the first positional parameter, p1,</span>
<span class="comments">;       must be present and must be a valid object reference.</span>
<span class="comments">;    multi: in, optional, type=intarr(5)</span>
<span class="comments">;       A replacement value to assign to the self.pmulti value. It is</span>
<span class="comments">;       a way to reset multiple command plotting to single command plotting</span>
<span class="comments">;       for a new single command. Like calling: object -> SetPropery, MULTI=multi. Used only if</span>
<span class="comments">;       `ReplaceCmd` is set.</span>
<span class="comments">;    replacecmd: in, optional, type=boolean, default=0</span>
<span class="comments">;       Set this keyword to replace a graphics command with this packaged command on the command list</span>
<span class="comments">;       If `CmdIndex` is undefined, *all* the commands on the command list are replaced. </span>
<span class="comments">;    _extra: in, optional</span>
<span class="comments">;       Any extra keywords are collected by keyword inheritance for the command structure.</span>
<span class="comments">;- </span>
FUNCTION cgCmdWindow::PackageCommand, command, p1, p2, p3, p4, $
   AddCmd=addCmd, $                 <span class="comments">; Add the command to the command list</span>
   AltPS_Keywords=altps_Keywords, $ <span class="comments">; A structure of PostScript alternative keywords and values.</span>
   AltPS_Params=altps_Params, $     <span class="comments">; A structure of PostScript alternative parameters and values. </span>
   CmdIndex=cmdIndex, $             <span class="comments">; The location of the command in the command list.</span>
   DestroyObjects=destroyobjects, $ <span class="comments">; Set this keyword to destroy parameter objects on exit.</span>
   Execute=execute, $               <span class="comments">; Execute the commands in the window, if this keyword set.</span>
   Method=method, $                 <span class="comments">; A flag that indicates a method call.</span>
   Multi=multi, $                   <span class="comments">; If you are replacing all commands, you may want to change the way they are displayed.</span>
   ReplaceCmd=replaceCmd, $         <span class="comments">; Set this keyword to replace one or all commands in the command list.</span>
    _Extra=extra                    <span class="comments">; Extra keywords to the command.</span>
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, Obj_New()
    ENDIF

   newCommand = Obj_New('cgWindow_Command', COMMAND=command, $
      P1=p1, P2=p2, P3=p3, P4=p4, KEYWORDS=extra, AltPS_Keywords=altps_Keywords, $
      AltPS_Params=altps_Params, TYPE=Keyword_Set(method), DESTROYOBJECTS=Keyword_Set(destroyObjects))
                        
    <span class="comments">; Replace command? If the cmdIndex is undefined, ALL commands are replaced.</span>
    IF Keyword_Set(replaceCmd) THEN self -> ReplaceCommand, newCommand, cmdIndex, Multi=multi
      
    <span class="comments">; Need to add a command?</span>
    IF Keyword_Set(addCmd) THEN self -> AddCommand, newCommand, INDEX=cmdIndex
   
    <span class="comments">; Execute the commands?</span>
    IF Keyword_Set(execute) THEN self -> ExecuteCommands
    
    <span class="comments">; Return the packaged command.</span>
    RETURN, newCommand
    
END


<span class="comments">;+</span>
<span class="comments">; This method replaces a command in the command list. If cmdIndex is missing,</span>
<span class="comments">; all the commands in the command list are replaced by this command.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    command: in, required, type=object</span>
<span class="comments">;       The new command object. </span>
<span class="comments">;    cmdindex: in, optional, type=integer</span>
<span class="comments">;       The index number of the "command" to replace. If absent, then</span>
<span class="comments">;       all the current commands are replaces with this new command.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     multi: in, optional, type=intarr(5)</span>
<span class="comments">;        A replacement value to assign to the self.pmulti value. It is</span>
<span class="comments">;        a way to reset multiple command plotting to single command plotting</span>
<span class="comments">;        for a new single command. Like calling: object -> SetPropery, MULTI=multi.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::ReplaceCommand, command, cmdIndex, MULTI=multi

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; If cmdIndex is missing, remove all the current commands with this one.</span>
    IF N_Elements(cmdIndex) EQ 0 THEN BEGIN
        self.cmds -> Delete, /ALL, /Destroy
        IF N_Elements(multi) NE 0 THEN BEGIN
            self.pmulti = multi <span class="comments">; Reset !P.Multi to new value.</span>
        ENDIF ELSE BEGIN
            self.pmulti = Intarr(5) <span class="comments">; Reset !P.Multi to zero.</span>
        ENDELSE
        self.cmds -> Add, command
    ENDIF ELSE BEGIN
    
        <span class="comments">; Get the old command first, so you can destroy it properly.</span>
        oldcmd = self.cmds -> Get_Item(cmdIndex, /DEREFERENCE)
        self.cmds -> Replace_Item, command, cmdIndex
        Obj_Destroy, oldcmd
    ENDELSE
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method resizes the graphics window and executes the commands again.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     x: in, required, type=integer</span>
<span class="comments">;        The new X size of the draw widget in device coordinates.</span>
<span class="comments">;     y: in, required, type=integer</span>
<span class="comments">;        The new Y size of the draw widget in device coordinates.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::Resize, x, y

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Make sure we have both sizes.</span>
    IF N_Params() NE 2 THEN Message, 'Resize method requires both an X and Y size be specified.'
    
    <span class="comments">; Do you need to maintain the aspect ratio of the window?</span>
    IF self.waspect NE 0 THEN BEGIN
         IF self.waspect GE 1 THEN BEGIN
             ysize = y
             xsize = Round(y / self.waspect)
         ENDIF ELSE BEGIN
             xsize = x
             ysize = Round(x * self.waspect)         
         ENDELSE
    ENDIF ELSE BEGIN
        xsize = x
        ysize = y
    ENDELSE

    Widget_Control, self.drawID, DRAW_XSIZE=xsize, DRAW_YSIZE=ysize
    self -> ExecuteCommands
    
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This event handler method saves the graphics window as a raster image file.</span>
<span class="comments">; PDF files also pass through here.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;     event: in, required, type=structure</span>
<span class="comments">;        The event structure.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::SaveAsRaster, event

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        
        <span class="comments">; Close the PostScript file.</span>
        PS_END, /NoFix     

        <span class="comments">; Set the window index number back.</span>
        IF N_Elements(currentWindow) NE 0 THEN BEGIN
            IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
        ENDIF
        
        RETURN
    ENDIF

    <span class="comments">; Only going in here for down event.</span>
    IF event.select NE 1 THEN RETURN
    
    buttonValue = Widget_Info(event.id, /UNAME)
    
    <span class="comments">; Is this a PDF file or a raster file?</span>
    IF buttonValue EQ 'PDF' THEN BEGIN
       rasterType = -1
       filetype = 'PDF'
    ENDIF ELSE BEGIN
    
        <span class="comments">; Determine if this is normal raster (0) or ImageMagick raster (1).</span>
        IF StrMid(buttonValue, 0, 6) EQ 'RASTER' THEN BEGIN
            fileType = StrMid(buttonValue, 7)
            rasterType = 0 
        ENDIF ELSE BEGIN
            filetype = StrMid(buttonValue, 12)
            rasterType = 1
        ENDELSE
        
    ENDELSE
    
    <span class="comments">; Make this window the current graphics windows.</span>
    currentWindow = !D.Window
    WSet, self.wid
    
    <span class="comments">; Construct a file name, if you have one.</span>
    CASE filetype OF
       'BMP':  ext = '.bmp'
       'GIF':  ext = '.gif'
       'JPEG': ext = '.jpg'
       'PDF':  ext = '.pdf'
       'PNG':  ext = '.png'
       'TIFF': ext = '.tif'
    ENDCASE
    IF self.lastWriteFile NE "" THEN BEGIN
        filename = Filepath(ROOT_DIR=self.lastWriteDir, self.lastWriteFile + ext)
    ENDIF ELSE BEGIN
         CD, CURRENT=thisDir
         filename = Filepath(ROOT_DIR=thisDir, 'cgwindow' + ext)
    ENDELSE
    
    <span class="comments">; Get a filename from the user.</span>
    CASE filetype OF
       'BMP':  filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
       'GIF':  filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
       'JPEG': filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
       'PDF':  filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
       'PNG':  filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
       'TIFF': filename = cgPickfile(FILE=filename, /WRITE, TITLE='Select an Output File...')
    ENDCASE
    IF filename EQ "" THEN RETURN
    
    <span class="comments">; Parset the name.</span>
    root_name = cgRootName(filename, DIRECTORY=dirName)
    outname = Filepath(ROOT_DIR=dirname, root_name)
    
    <span class="comments">; Save this name.</span>
    self.lastWriteFile = root_name
    self.lastWriteDir = dirName
    
    <span class="comments">; What kind of raster file.</span>
    CASE rasterType OF
    
        <span class="comments">; PDF File.</span>
       -1: BEGIN
       
           thisname = outname + '.ps'
           outname = outname + '.pdf'
           PS_Start, $
                DECOMPOSED=self.ps_decomposed, $
                FILENAME=thisname, $
                GROUP_LEADER=self.tlb, $
                METRIC=self.ps_metric, $
                KEYWORDS=keywords, $ <span class="comments">; Returned PSConfig keywords.</span>
                SCALE_FACTOR=self.ps_scale_factor, $
                CHARSIZE=self.ps_charsize, $
                FONT=self.ps_font, $
                QUIET=self.ps_quiet, $
                TT_FONT=self.ps_tt_font
                           
           <span class="comments">; Draw the graphics.</span>
           self -> ExecuteCommands
           
           <span class="comments">; Close the file and make a PDF file.</span>
           PS_End
           cgPS2PDF, thisname, outname, DELETE_PS=self.ps_delete, /SILENT, SUCCESS=success, $
              UNIX_CONVERT_CMD=self.pdf_unix_convert_cmd, GS_PATH=self.pdf_path
           IF ~success THEN BEGIN
              Message, 'Unable to create PDF file. See cgPS2PDF documentation.'
           ENDIF ELSE BEGIN
              IF ~self.ps_quiet THEN Print, 'PDF output will be created here: ' + outname
           ENDELSE
           END
    
        <span class="comments">; Normal raster.</span>
        0: BEGIN
           void = cgSnapshot(TYPE=fileType, FILENAME=outname, /NODIALOG)
           IF ~self.ps_quiet THEN Print, 'Output file located here: ' + outname 
           END
           
        <span class="comments">; Raster via ImageMagick.</span>
        1: BEGIN
        
           <span class="comments">; Create a PostScript file first.</span>
           thisname = outname + '.ps'
           PS_Start, $
                DECOMPOSED=self.ps_decomposed, $
                FILENAME=thisname, $
                GROUP_LEADER=self.tlb, $
                METRIC=self.ps_metric, $
                KEYWORDS=keywords, $ <span class="comments">; Returned PSConfig keywords.</span>
                SCALE_FACTOR=self.ps_scale_factor, $
                CHARSIZE=self.ps_charsize, $
                FONT=self.ps_font, $
                QUIET=1, $
                TT_FONT=self.ps_tt_font
                
           <span class="comments">; Cannot successfully convert encapsulated landscape file to raster.</span>
           <span class="comments">; Limitation of ImageMagick, and specifically, GhostScript, which does</span>
           <span class="comments">; the conversion.</span>
           IF keywords.encapsulated && keywords.landscape THEN BEGIN
                Message, 'ImageMagick cannot successfully convert an encapsulated ' + $
                         'PostScript file in landscape mode to a raster file. Returning...'
           ENDIF
           
           <span class="comments">; Draw the graphics.</span>
           self -> ExecuteCommands
           
           <span class="comments">; Close the file and convert to proper file type.</span>
           CASE filetype OF
                'BMP':  PS_END, /BMP, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width
                'GIF':  PS_END, /GIF, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width
                'JPEG': PS_END, /JPEG, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width
                'PNG':  PS_END, /PNG,  DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width
                'TIFF': PS_END, /TIFF, DELETE_PS=self.ps_delete, $
                            ALLOW_TRANSPARENT=self.im_transparent, $
                            DENSITY=self.im_density, RESIZE=self.im_resize, $
                            IM_OPTIONS=self.im_options, OUTFILENAME=outfilename, $
                            WIDTH=self.im_width
           ENDCASE
           IF ~self.ps_quiet THEN Print, 'Output will be created here: ' + outfilename
           END
    
    ENDCASE
    
    <span class="comments">; Set the window index number back.</span>
    IF WindowAvailable(currentWindow) THEN WSet, currentWindow ELSE WSet, -1
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method restores the commands from a specified file and loads them</span>
<span class="comments">; into the window.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    filename: in, required, type=string</span>
<span class="comments">;       The name of the file containing the cgWindow commands that were previously saved.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::RestoreCommands, filename

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF

    <span class="comments">; Need a file name?</span>
    IF N_Elements(filename) EQ 0 THEN BEGIN
        filename = cgPickfile(Title='Restore Coyote Graphics Commands...', $
            FILTER='*.cgs')
        IF filename EQ "" THEN RETURN
    ENDIF
    
    <span class="comments">; Does the file exist?</span>
    fileTest = File_Test(filename, /READ)
    IF ~fileTest THEN BEGIN
        text = 'The file (' + filename + ') cannot be located. Returning.'
        void = Dialog_Message(text)
        RETURN
    ENDIF
    
    <span class="comments">; Restore the file. The variables "cg_commands" and "cg_window" are restored.</span>
    Restore, FILE=filename, /Relaxed_Structure_Assignment
    
    <span class="comments">; Make this object the current object.</span>
    cgSet, self.wid
    
    <span class="comments">; Erase the current commands in the window. If this is not</span>
    <span class="comments">; done memory will leak.</span>
    cgErase, self.wid, /Window
    
    <span class="comments">; Copy the commands from the restored command list to this command list.</span>
    oldCommands = cg_commands -> Get_Item(/DEREFERENCE, /ALL)
    self.cmds -> Delete, /ALL
    FOR j=0,N_Elements(oldCommands)-1 DO BEGIN
        thisCmd = oldCommands[j] -> Copy()
        self.cmds -> Add, thisCmd
    ENDFOR
        
    <span class="comments">; Copy properties from old window object to new.</span>
    cg_window -> GetProperty, $
        BACKGROUND=background, $       <span class="comments">; The background color of the window.</span>
        DELAY=delay, $                 <span class="comments">; The delay between command execution.</span>
        ERASEIT=eraseit, $             <span class="comments">; Set the erase flag for the window</span>
        PALETTE=palette, $             <span class="comments">; Change window color table vectors.</span>
        MULTI=multi, $                 <span class="comments">; Change the !P.MULTI setting for the window.</span>
        XOMARGIN=xomargin, $           <span class="comments">; Change the !X.OMargin setting for the winow.</span>
        YOMARGIN=yomargin, $           <span class="comments">; Change the !Y.OMargin setting for the window.</span>
        IM_TRANSPARENT=im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
        IM_DENSITY=im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
        IM_RESIZE=im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
        IM_OPTIONS=im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
        IM_RASTER=im_raster, $                        <span class="comments">; Sets whether to use ImageMagick to create raster files.</span>
        PS_DELETE=ps_delete, $                        <span class="comments">; Delete the PostScript file when making IM raster files.</span>
        PS_METRIC=ps_metric, $                        <span class="comments">; Select metric measurements in PostScript output.</span>
        PS_ENCAPSULATED=ps_encapsulated, $            <span class="comments">; Select encapusulated PostScript output.</span>
        PS_FONT=ps_font, $                            <span class="comments">; Select the font for PostScript output.</span>
        PS_CHARSIZE=ps_charsize, $                    <span class="comments">; Select the character size for PostScript output.</span>
        PS_SCALE_FACTOR=ps_scale_factor, $            <span class="comments">; Select the scale factor for PostScript output.</span>
        PS_TT_FONT=ps_tt_font                         <span class="comments">; Select the true-type font to use for PostScript output.</span>
        
    self -> SetProperty, $
        BACKGROUND=background, $       <span class="comments">; The background color of the window.</span>
        DELAY=delay, $                 <span class="comments">; The delay between command execution.</span>
        ERASEIT=eraseit, $             <span class="comments">; Set the erase flag for the window</span>
        PALETTE=palette, $             <span class="comments">; Change window color table vectors.</span>
        MULTI=multi, $                 <span class="comments">; Change the !P.MULTI setting for the window.</span>
        XOMARGIN=xomargin, $           <span class="comments">; Change the !X.OMargin setting for the winow.</span>
        YOMARGIN=yomargin, $           <span class="comments">; Change the !Y.OMargin setting for the window.</span>
        IM_TRANSPARENT=im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
        IM_DENSITY=im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
        IM_RESIZE=im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
        IM_OPTIONS=im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
        IM_RASTER=im_raster, $                        <span class="comments">; Sets whether to use ImageMagick to create raster files.</span>
        PS_DELETE=ps_delete, $                        <span class="comments">; Delete the PostScript file when making IM raster files.</span>
        PS_METRIC=ps_metric, $                        <span class="comments">; Select metric measurements in PostScript output.</span>
        PS_ENCAPSULATED=ps_encapsulated, $            <span class="comments">; Select encapusulated PostScript output.</span>
        PS_FONT=ps_font, $                            <span class="comments">; Select the font for PostScript output.</span>
        PS_CHARSIZE=ps_charsize, $                    <span class="comments">; Select the character size for PostScript output.</span>
        PS_SCALE_FACTOR=ps_scale_factor, $            <span class="comments">; Select the scale factor for PostScript output.</span>
        PS_TT_FONT=ps_tt_font                         <span class="comments">; Select the true-type font to use for PostScript output.</span>
        
        
    <span class="comments">; The widget ID of the restored object must be invalidated,</span>
    <span class="comments">; or the current object (with that widget ID) will be destroyed.</span>
    cg_window -> InvalidateWidgetID
    Obj_Destroy, cg_window
    
    <span class="comments">; Execute the new commands.</span>
    self -> ExecuteCommands

END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method restores the current data coordinate system by restoring the system variable</span>
<span class="comments">; state from the last command execution.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::RestoreDataCoords

   !MAP = *self.msysvar
   !P = self.psysvar
   !X = self.xsysvar
   !Y = self.ysysvar
   !Z = self.zsysvar
   
END


<span class="comments">;+</span>
<span class="comments">; This method saves the commands from a cgWindow into a form that can be</span>
<span class="comments">; e-mailed to colleagues or restored to a cgWindow at some later time.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    filename: in, optional, type=string, default='commands.cgs'</span>
<span class="comments">;       The name of the file where the cgWindow commands are to be saved.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::SaveCommands, filename

    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    <span class="comments">; Need a file name.</span>
    IF N_Elements(filename) EQ 0 THEN BEGIN
       filename = cgPickfile(FILE='commands.cgs', $
            TITLE='Save Coyote Graphics Commands...', /Write)
       IF filename EQ "" THEN RETURN
    ENDIF
    
    <span class="comments">; Copy the commands.</span>
    cg_commands = self.cmds
    cg_window = self
    
    <span class="comments">; Save them in the file.</span>
    Save, cg_commands, cg_window, FILE=filename
   
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method saves the current data coordinate system by saving all the plotting and mapping</span>
<span class="comments">; system variables after the commands have been executed in the program.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::SaveDataCoords

   *self.msysvar = !Map
   self.psysvar = !P
   self.xsysvar = !X
   self.ysysvar = !Y
   self.zsysvar = !Z
   
END


<span class="comments">;+</span>
<span class="comments">; This method sets properties of the window object. </span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     adjustsize: in, optional, type=boolean</span>
<span class="comments">;        Set this keyword to adjust default character size to the display window size.</span>
<span class="comments">;     background: in, optional, type=string</span>
<span class="comments">;        The background color of the window. Only use if the ERASEIT property is also set.</span>
<span class="comments">;     delay: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the amount of "delay" you want between commands in the command list.</span>
<span class="comments">;     dimensions: in, optional, type=intarr(2)</span>
<span class="comments">;        Set this keyword to a two-element array giving the xsize and ysize</span>
<span class="comments">;        of the draw widget.</span>
<span class="comments">;     eraseit: in, optional, type=boolean</span>
<span class="comments">;        If this property is set, the cgWindow erases with the background color before</span>
<span class="comments">;        displaying the commands in the window's command list.</span>
<span class="comments">;     im_density: in, optional, type=integer, default=300</span>
<span class="comments">;        Set this keyword to the sampling density when ImageMagick creates raster image</span>
<span class="comments">;        file from PostScript outout.</span>
<span class="comments">;     im_options: in, optional, type=string, default=""</span>
<span class="comments">;        Set this keyword to any ImageMagick options you would like to pass along to the</span>
<span class="comments">;        ImageMagick convert command when creating raster image files from PostScript output.</span>
<span class="comments">;     im_resize: in, optional, type=integer, default=25</span>
<span class="comments">;        Set this keyword to percentage that the raster image file created my ImageMagick</span>
<span class="comments">;        from PostScript output should be resized.</span>
<span class="comments">;     im_raster: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to zero to create raster files using the create_png etc. keywords</span>
<span class="comments">;        directly, instead of via ImageMagick.</span>
<span class="comments">;     im_transparent: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to allow ImageMagick to create transparent backgrounds when it</span>
<span class="comments">;        makes raster image files from PostScript output.</span>
<span class="comments">;     multi: in, optional, type=Intarr(5)</span>
<span class="comments">;        Set this keyword to the !P.MULTI setting you want to use for the window.</span>
<span class="comments">;        !P.MULTI is set to this setting before command execution, and set back to</span>
<span class="comments">;        it's default value when the commands are finished executing.</span>
<span class="comments">;     noexecutecommands: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to 1 to prevent the window from executing the commands and to</span>
<span class="comments">;        0 if you want the window to execute the commands.</span>
<span class="comments">;     palette: in, optional, type=byte</span>
<span class="comments">;        Use this keyword to pass in an N-by-3 (or 3-by-N) byte array containing the</span>
<span class="comments">;        R, G, and B vectors of a color table. It is probably easier to use cgLoadCT or</span>
<span class="comments">;        XCOLORS to load color tables for the window, but this is provided as another option.</span>
<span class="comments">;     pdf_path: out, optional, type=string</span>
<span class="comments">;        Set this keyword to the name of the path to the Ghostscript command for converting PS to PDF.</span>
<span class="comments">;     pdf_unix_convert_cmd: out, optional, type=string</span>
<span class="comments">;        Set this keyword to the name of an alternative UNIX command to convert PostScript to PDF.</span>
<span class="comments">;     ps_charsize: in, optional, type=float</span>
<span class="comments">;        The PostScript character size.</span>
<span class="comments">;     ps_decomposed: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to zero to set the PostScript color mode to indexed color and to</span>
<span class="comments">;        one to set the PostScript color mode to decomposed color.</span>
<span class="comments">;     ps_delete: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to zero if you want to keep the PostScript output ImageMagick creates</span>
<span class="comments">;        when making raster file output.</span>
<span class="comments">;     ps_encapsulated: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to configure PSCONFIG to produce encapsulated PostScript output by default.</span>
<span class="comments">;     ps_font: in, optional, type=integer</span>
<span class="comments">;        Set this keyword to the type of font you want to use in PostScript output. It sets the </span>
<span class="comments">;        FONT keyword on the PSConfig command. Normally, 0 (hardware fonts) or 1 (true-type fonts).</span>
<span class="comments">;     ps_metric: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to configure PSCONFIG to use metric values and A4 page size in its interface.</span>
<span class="comments">;     ps_quiet: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to set the QUIET keyword on PS_Start.</span>
<span class="comments">;     ps_scale_factor: in, optional, type=float</span>
<span class="comments">;        Set his keyword to the PostScript scale factor you wish to use in creating PostScript output.</span>
<span class="comments">;     ps_tt_font: in, optional, type=string</span>
<span class="comments">;        Set this keyword to the name of a true-type font to use in creating PostScript output.</span>
<span class="comments">;     storage: in, optional</span>
<span class="comments">;        A storage location for any kind of IDL variable. This functions like a user value in</span>
<span class="comments">;        a widget program. </span>
<span class="comments">;     update: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to zero if you do not want the updates to be done immediately</span>
<span class="comments">;        after the properties are changed.</span>
<span class="comments">;     wid: in, optional, type=integer</span>
<span class="comments">;        The draw window index number. Not to be used by the user. Used by the draw widget</span>
<span class="comments">;        Notify_Realize callback routine when the draw widget is realized.</span>
<span class="comments">;     xomargin: in, optional, type=intarr(2)</span>
<span class="comments">;        Sets the !X.OMargin system variable when multiple plots are displayed in the window.</span>
<span class="comments">;     yomargin: in, optional, type=intarr(2)</span>
<span class="comments">;        Sets the !Y.OMargin system variable when multiple plots are displayed in the window.</span>
<span class="comments">;          </span>
<span class="comments">;-</span>
PRO cgCmdWindow::SetProperty, $
    ADJUSTSIZE=adjustsize, $       <span class="comments">; Adjust the default charsize to match display size.</span>
    BACKGROUND=background, $       <span class="comments">; The background color of the window.</span>
    DELAY=delay, $                 <span class="comments">; The delay between command execution.</span>
    DIMENSIONS=dimensions, $       <span class="comments">; Set the dimensions of the draw widget.</span>
    ERASEIT=eraseit, $             <span class="comments">; Set the erase flag for the window</span>
    IM_DENSITY=im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
    IM_OPTIONS=im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
    IM_RASTER=im_raster, $                        <span class="comments">; Sets whether to use ImageMagick to create raster files.</span>
    IM_RESIZE=im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
    IM_TRANSPARENT=im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
    IM_WIDTH = im_width, $                        <span class="comments">; Sets the final width of the raster files create with ImageMagick.</span>
    PDF_UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
    PDF_PATH=pdf_path, $                          <span class="comments">; The path to the Ghostscript conversion command.</span>
    PALETTE=palette, $             <span class="comments">; Change window color table vectors.</span>
    PS_CHARSIZE=ps_charsize, $                    <span class="comments">; Select the character size for PostScript output.</span>
    PS_DECOMPOSED=ps_decomposed, $                <span class="comments">; Sets the PostScript color mode.</span>
    PS_DELETE=ps_delete, $                        <span class="comments">; Delete the PostScript file when making IM raster files.</span>
    PS_ENCAPSULATED=ps_encapsulated, $            <span class="comments">; Select encapusulated PostScript output.</span>
    PS_FONT=ps_font, $                            <span class="comments">; Select the font for PostScript output.</span>
    PS_METRIC=ps_metric, $                        <span class="comments">; Select metric measurements in PostScript output.</span>
    PS_QUIET=ps_quiet, $                          <span class="comments">; Select the QUIET keyword for PS_Start.</span>
    PS_SCALE_FACTOR=ps_scale_factor, $            <span class="comments">; Select the scale factor for PostScript output.</span>
    PS_TT_FONT=ps_tt_font, $                      <span class="comments">; Select the true-type font to use for PostScript output.</span>
    NOEXECUTECOMMANDS=noExecuteCommands, $ <span class="comments">; Set if you don't want the window to execute commands.</span>
    MULTI=multi, $                 <span class="comments">; Change the !P.MULTI setting for the window.</span>
    STORAGE=storage, $             <span class="comments">; A pointer location for storing any IDL variable, like a UVALUE.</span>
    XOMARGIN=xomargin, $           <span class="comments">; Change the !X.OMargin setting for the window.</span>
    YOMARGIN=yomargin, $           <span class="comments">; Change the !Y.OMargin setting for the window.</span>
    UPDATE=update, $               <span class="comments">; Set if you want the commands to be updated after property change.</span>
    WID=wid, $                     <span class="comments">; The window index number. Used in draw widget notify realize event.</span>
    _EXTRA=extra
    
    Compile_Opt idl2
    
    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN
    ENDIF
    
    IF N_Elements(adjustsize) NE 0 THEN self.adjustsize = Keyword_Set(adjustsize)

    IF N_Elements(background) NE 0 THEN BEGIN
        IF Ptr_Valid(self.background) $
            THEN *self.background = background $
            ELSE self.background = Ptr_New(background)
    ENDIF 
    IF N_Elements(palette) NE 0 THEN BEGIN
        IF Size(palette, /N_DIMENSIONS) NE 2 THEN Message, 'Color palette is not a 3xN array.'
        dims = Size(palette, /DIMENSIONS)
        threeIndex = Where(dims EQ 3)
        IF ((threeIndex)[0] LT 0) THEN Message, 'Color palette is not a 3xN array.'
        IF threeIndex[0] EQ 0 THEN palette = Transpose(palette)
        *self.r = palette[*,0]
        *self.g = palette[*,1]
        *self.b = palette[*,2]
    ENDIF   
    IF N_Elements(dimensions) NE 0 THEN BEGIN
       IF N_Elements(dimensions) EQ 1 THEN dimensions = [dimensions, dimensions]
       Widget_Control, self.drawID, DRAW_XSIZE=dimensions[0], DRAW_YSIZE=dimensions[1]
    ENDIF
    IF N_Elements(delay) NE 0 THEN self.delay = delay
    IF N_Elements(eraseit) NE 0 THEN self.eraseit = Keyword_Set(eraseit)
    IF N_Elements(noExecuteCommands) NE 0 THEN self.noexecutecommands = Keyword_Set(noExecuteCommands)
    IF N_Elements(multi) NE 0 THEN BEGIN
        IF (N_Elements(multi) EQ 1) && (multi EQ 0) THEN multi = IntArr(5)
        FOR j=0,N_Elements(multi)-1 DO self.pmulti[j] = multi[j]
    ENDIF
    IF N_Elements(xomargin) NE 0 THEN self.xomargin = xomargin
    IF N_Elements(yomargin) NE 0 THEN self.yomargin = yomargin
    IF N_Elements(im_transparent) NE 0 THEN self.im_transparent = im_transparent
    IF N_Elements(im_density) NE 0 THEN self.im_density = im_density
    IF N_Elements(im_resize) NE 0 THEN self.im_resize = im_resize
    IF N_Elements(im_options) NE 0 THEN self.im_options = im_options
    IF N_Elements(im_raster) NE 0 then self.im_raster = im_raster
    IF N_Elements(im_width) NE 0 then self.im_width = im_width
    IF N_Elements(pdf_unix_convert_cmd) NE 0 THEN self.pdf_unix_convert_cmd = pdf_unix_convert_cmd
    IF N_Elements(pdf_path) NE 0 THEN self.pdf_path = pdf_path
    IF N_Elements(ps_decomposed) NE 0 THEN self.ps_decomposed = ps_decomposed
    IF N_Elements(ps_delete) NE 0 THEN self.ps_delete = ps_delete
    IF N_Elements(ps_metric) NE 0 THEN self.ps_metric = ps_metric
    IF N_Elements(ps_encapsulated) NE 0 THEN self.ps_encapsulated = ps_encapsulated
    IF N_Elements(ps_charsize) NE 0 THEN self.ps_charsize = ps_charsize
    IF N_Elements(ps_font) NE 0 THEN self.ps_font = ps_font
    IF N_Elements(ps_quiet) NE 0 THEN self.ps_quiet = ps_quiet
    IF N_Elements(ps_scale_factor) NE 0 THEN self.ps_scale_factor = ps_scale_factor
    IF N_Elements(ps_tt_font) NE 0 THEN self.ps_tt_font = ps_tt_font
    IF N_Elements(storage) NE 0 THEN BEGIN
       IF Ptr_Valid(self.storage) THEN *self.storage = storage ELSE self.storage = Ptr_New(storage)
    ENDIF
    
    <span class="comments">; You may have gotten keywords you don't know what to deal with. Inform</span>
    <span class="comments">; the user there.</span>
    IF N_Elements(extra) NE 0 THEN BEGIN
       tags = Tag_Names(extra)
       FOR j=0,N_Elements(tags)-1 DO BEGIN
          Message, 'The following property could NOT be set in the SetProperty method: ' + tags[j], /Informational
       ENDFOR
    ENDIF
    
    <span class="comments">; Update now?</span>
    IF Keyword_Set(update) THEN self -> ExecuteCommands
    
    <span class="comments">; Update the draw widget index number. Should only be called from the draw widget notify realize procedure.</span>
    IF N_Elements(wid) NE 0 THEN self.wid = wid
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>


<span class="comments">;+</span>
<span class="comments">; This method saves the window object reference in a linked-list system variable.</span>
<span class="comments">;-</span>
PRO cgCmdWindow::StoreObjectReference

    <span class="comments">; Each instance of cgWindow will store evidence of its</span>
    <span class="comments">; existance in a linked list.</span>
    DefSysV, '!FSC_WINDOW_LIST', EXISTS=exists
    IF ~exists THEN BEGIN
        fsc_window_list = Obj_New("LinkedList")
        DefSysV, '!FSC_WINDOW_LIST', fsc_window_list 
        fsc_window_list -> Add, {cgWINDOW_ID, self.tlb, self.wid, self.title, self}
    ENDIF ELSE BEGIN
        IF Obj_Valid(!FSC_WINDOW_LIST) THEN BEGIN
            !FSC_WINDOW_LIST -> Add, {cgWINDOW_ID, self.tlb, self.wid, self.title, self}
        ENDIF ELSE BEGIN
            !FSC_WINDOW_LIST = Obj_New('LinkedList')
            !FSC_WINDOW_LIST-> Add, {cgWINDOW_ID, self.tlb, self.wid, self.title, self}
        ENDELSE
    ENDELSE
    
END



<span class="comments">;+</span>
<span class="comments">; The definition module for the cgCmdWindow object</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    class: out, optional, type=struct</span>
<span class="comments">;        The object class structure definition. Occasionally useful.</span>
<span class="comments">;-</span>
PRO cgCmdWindow__Define, class

    class = { cgCMDWINDOW, $
              tlb: 0L, $                    <span class="comments">; The identifier of the top-level base widget.</span>
              cmds: Obj_New(), $            <span class="comments">; A linkedlist object containing the graphics commands.</span>
              wid: 0L, $                    <span class="comments">; The window index number of the graphics window.</span>
              drawid: 0L, $                 <span class="comments">; The identifier of the draw widget.</span>
              destroyObjects: 0B, $         <span class="comments">; If set, destroy object parameters upon exit.</span>
              event_handler: "", $          <span class="comments">; The name of an event handler that will receive draw widget events.</span>
              storage: Ptr_New(), $         <span class="comments">; Holder for user information, like UVALUE.</span>
              title: "", $                  <span class="comments">; The "title" of the object when it is stored.</span>
              createParent: 0B, $           <span class="comments">; Flag that indicates whether this object created its own parent widget.</span>
              lastWriteFile: "", $          <span class="comments">; The name of the last file written.</span>
              lastWriteDir: "", $           <span class="comments">; The name of the last directory written to.</span>
              
              <span class="comments">; cgWindow parameters</span>
              adjustsize: 0B, $             <span class="comments">; Adjust character size to display window.</span>
              background: Ptr_New(), $      <span class="comments">; The background color.</span>
              delay: 0.0, $                 <span class="comments">; The command delay.</span>
              eraseit: 0B, $                <span class="comments">; Do we need to erase the display.</span>
              noExecuteCommands: 0B, $      <span class="comments">; Set to stop command execution (e.g.,for loading commands)</span>
              pmulti: LonArr(5), $          <span class="comments">; Identical to !P.Multi.</span>
              xomargin: FltArr(2), $        <span class="comments">; Identical to !X.OMargin</span>
              yomargin: FltArr(2), $        <span class="comments">; Identical to !Y.OMargin</span>
              waspect: 0.0, $               <span class="comments">; The aspect ratio of the window.</span>
              r: Ptr_New(), $               <span class="comments">; The red color table vector.</span>
              g: Ptr_New(), $               <span class="comments">; The green color table vector.</span>
              b: Ptr_New(), $               <span class="comments">; The blue color table vector.</span>
              
              <span class="comments">; Data coordinate fields.</span>
              psysvar: !P, $                <span class="comments">; The !P system variable.</span>
              xsysvar: !X, $                <span class="comments">; The !X system variable.</span>
              ysysvar: !Y, $                <span class="comments">; The !Y system variable.</span>
              zsysvar: !Z, $                <span class="comments">; The !Z system variable.</span>
              msysvar: Ptr_New(), $         <span class="comments">; The !MAP system variable.</span>
              
              <span class="comments">; PostScript options.</span>
              ps_decomposed: 0L, $          <span class="comments">; Sets the PostScript color mode.</span>
              ps_delete: 0L, $              <span class="comments">; Delete the PS file when making IM image file.</span>
              ps_encapsulated: 0L, $        <span class="comments">; Encapsulated PostScript</span>
              ps_metric: 0L, $              <span class="comments">; Metric measurements in PostScript.</span>
              ps_charsize: 0.0, $           <span class="comments">; The character size to use for PostScript output.</span>
              ps_font: 0, $                 <span class="comments">; The PostScript font to use.</span>
              ps_quiet: 0, $                <span class="comments">; Select the QUIET keyword for PS_Start.</span>
              ps_scale_factor: 0, $         <span class="comments">; The PostScript scale factor.</span>
              ps_tt_font: "", $             <span class="comments">; The name of a true-type font to use for PostScript output.</span>
              
              <span class="comments">; PDF options.</span>
              pdf_unix_convert_cmd: "", $   <span class="comments">; The name of an alternative UNIX command to convert PS to PDF.</span>
              pdf_path: "", $               <span class="comments">; The name of the path to a Ghostscript conversion command.</span>

              <span class="comments">; ImageMagick output parameters.</span>
              im_transparent: 0B, $         <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
              im_density: 0L, $             <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
              im_resize: 0L, $              <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
              im_options: "", $             <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
              im_raster: 0L, $              <span class="comments">; Create raster files via ImageMagick</span>
              im_width: 0L $                <span class="comments">; Sets the width of the final raster output with ImageMagick</span>
            }
            
END <span class="comments">;----------------------------------------------------------------------------------------------------------------</span>




</code>
    </div>
  </body>
</html>