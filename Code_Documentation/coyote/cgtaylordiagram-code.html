<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgtaylordiagram.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgtaylordiagram.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgTaylorDiagram</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   The program implements a Taylor Diagram in IDL direct graphics (Coyote Graphics).</span>
<span class="comments">;     http://onlinelibrary.wiley.com/doi/10.1029/2000JD900719/abstract</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2013, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The program implements a Taylor Diagram in IDL direct graphics. Addtional information can be found</span>
<span class="comments">; `in this article &lt;http://onlinelibrary.wiley.com/doi/10.1029/2000JD900719/abstract>`.</span>
<span class="comments">; </span>
<span class="comments">; .. image:: cgtaylordiagram.png</span>
<span class="comments">; </span>
<span class="comments">; From the 2001 IPCC Reoprt::</span>
<span class="comments">; </span>
<span class="comments">;       "Taylor diagrams provide a way of graphically summarizing how closely </span>
<span class="comments">;       a pattern (or a set of patterns) matches observations.  The similarity between two </span>
<span class="comments">;       patterns is quantified in terms of their correlation, their centered root-mean-square </span>
<span class="comments">;       difference and the amplitude of their variations (represented by their standard </span>
<span class="comments">;       deviations).  These diagrams are especially useful in evaluating multiple aspects of </span>
<span class="comments">;       complex models or in gauging the relative skill of many different models."</span>
<span class="comments">;</span>
<span class="comments">;       "In general, the Taylor diagram characterizes the statistical relationship between two </span>
<span class="comments">;       fields, a "test" field (often representing a field simulated by a model) and a </span>
<span class="comments">;       "reference" field (usually representing “truth”, based on observations)."</span>
<span class="comments">;</span>
<span class="comments">;       "The two-dimensional space of the Taylor diagram can represent three different statistics </span>
<span class="comments">;       simultaneously::</span>
<span class="comments">;          - The centered RMS difference, </span>
<span class="comments">;          - The correlation, </span>
<span class="comments">;          - The standard deviation</span>
<span class="comments">;  </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    correlation: in, required, type=float</span>
<span class="comments">;        An array of correlation coefficients for the points that will be plotted on the diagram.</span>
<span class="comments">;        This array must be the same length as the `stddev` array and the `Labels` array, if it is used.</span>
<span class="comments">;    stddev: in, required, type=float</span>
<span class="comments">;        An array of standard deviations for the points that will be plotted on the diagram.</span>
<span class="comments">;        This array must be the same length as the `correlation` array and the `Labels` array, if it is used.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to add the command to the resizeable graphics window cgWindow.</span>
<span class="comments">;    c_correlation: in, optional, type=string, default="grn7"</span>
<span class="comments">;        The name of the color used for the correlation lines on the diagram.</span>
<span class="comments">;    c_stddev: in, optional, type=string, default="blu7"</span>
<span class="comments">;        The name of the color used for the standard deviation lines on the diagram.</span>
<span class="comments">;    c_ref: in, optional, type=string, default="pur7"</span>
<span class="comments">;        The name of the color used for the observed reference line on the diagram.</span>
<span class="comments">;    c_symbol: in, optional, type=string, default="red"</span>
<span class="comments">;        The name of the color used for the point symbols on the diagram.</span>
<span class="comments">;    labels: in, optional, type=string</span>
<span class="comments">;        An array of string labels for the points that will be plotted on the diagram.</span>
<span class="comments">;        This array must be the same length as the `stddev` array and the `correlation` array.</span>
<span class="comments">;    output: in, optional, type=string</span>
<span class="comments">;        The name of an output file to write the Taylor Diagram to. The type of file is taken from</span>
<span class="comments">;        the file extension. For example, OUTPUT='mydiagram.png'. It is assumed that Ghostscript and</span>
<span class="comments">;        ImageMagick have been installed properly for all raster file output. If the Output keyword is</span>
<span class="comments">;        used, nothing is drawn on the display. This keyword cannot be used with the Overplot keyword.</span>
<span class="comments">;    overplot: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to overplot onto an already existing Taylor Diagram. Many keywords are</span>
<span class="comments">;        ignored if this keyword is set. Only the data is drawn. The Output keyword cannot be used</span>
<span class="comments">;        if overplotting.</span>
<span class="comments">;    position: in, optional, type=float</span>
<span class="comments">;        A four-element, normalized array giving the position of the plot in the display window: [x0,y0,x1,y1].</span>
<span class="comments">;    ref_stddev: in, optional, type=float, default=1.0</span>
<span class="comments">;        The reference standard deviation. This is typically the "observed" or "model" value. A scalar.</span>
<span class="comments">;    rms_circles_off: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to prevent the drawing of the RMS circles that radiate out from the observed RMS value.</span>
<span class="comments">;    rms_format: in, optional, type=string, default='(I0)'</span>
<span class="comments">;        Set this keyword to a format string that is used for format the RMS circle labels.</span>
<span class="comments">;    rms_increment: in, optional, type=float, default=1.0</span>
<span class="comments">;        The RMS circles are drawn from the observed RMS value, using this value as an increment of the circle radius.</span>
<span class="comments">;    rms_labels_off: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to prevent the drawing of the RMS circle labels. If this keyword is set, only the RMS</span>
<span class="comments">;        circles are drawn.</span>
<span class="comments">;    stddev_max: in, optional, type=float</span>
<span class="comments">;        The maximum standard deviation to plot on the graph. </span>
<span class="comments">;    symbol: in, optional, type=integer, default=16</span>
<span class="comments">;        The symbol used for the data points on the diagram. Any symbol supported by `cgSymCat`.</span>
<span class="comments">;    symsize: in, optional, type=float, default=1.5</span>
<span class="comments">;        The size of the symbol used for the data points on the diagram.</span>
<span class="comments">;    window: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to replace all the commands in a current cgWindow or to</span>
<span class="comments">;        create a new cgWindow for displaying this command.</span>
<span class="comments">;         </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Here is how to use this program::</span>
<span class="comments">;    </span>
<span class="comments">;      labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']            ; Point labels.</span>
<span class="comments">;      stddev = [1.4, 0.9, 1.0, 1.272, 1.1, 0.95, 1.08, 0.5]        ; Standard Deviations</span>
<span class="comments">;      correlation = [0.8, 0.9, 0.65, 0.74, 0.91, 0.98, 0.85, 0.35] ; Correlations</span>
<span class="comments">;      ref_std = 1.0                                                ; Reference standard (observed)</span>
<span class="comments">;      stddev_max = 1.5                                             ; Standard Deviation maximum</span>
<span class="comments">;      cgTaylorDiagram, stddev, correlation, REF_STDDEV=ref_std, STDDEV_MAX=stddev_max, LABELS=labels</span>
<span class="comments">;       </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written, 10 January 2013 by David W. Fanning from a program by Fernando Santoro of</span>
<span class="comments">;            ExelisVis that I found in the IDL Code Repository on the ExelisVis web page.</span>
<span class="comments">;            Fernando did *all* of the hard work writing the program for the IDL 8 function</span>
<span class="comments">;            graphics routine. I simply copied most of his code and adapted it for non-IDL 8 </span>
<span class="comments">;            users. I also added a couple of features I though were missing from the original code.</span>
<span class="comments">;        Added OVERPLOT keyword. 21 May 2013. DWF.</span>
<span class="comments">;        Added RMS_*** keywords to allow more control over the drawing and labeling of the RMS circles </span>
<span class="comments">;            on the plot. 29 July 2013. DWF.</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
PRO cgTaylorDiagram, stddev, correlation, $
    ADDCMD=addcmd, $
    C_CORRELATION=c_correlation, $
    C_STDDEV=c_stddev, $
    C_REF=c_ref, $
    C_SYMBOL=c_symbol, $
    LABELS=labels, $
    OUTPUT=output, $
    OVERPLOT=overplot, $
    POSITION=position, $
    REF_STDDEV=ref_stddev, $
    RMS_CIRCLES_OFF=rms_circles_off, $
    RMS_FORMAT=rms_format, $
    RMS_INCREMENT=rms_increment, $
    RMS_LABELS_OFF=rms_labels_off, $
    STDDEV_MAX=stddev_max, $
    SYMBOL=symbol, $
    SYMSIZE=symsize, $
    WINDOW=window

  Compile_Opt idl2
    
  <span class="comments">; Standard error handling.</span>
  Catch, theError
  IF theError NE 0 THEN BEGIN
      Catch, /CANCEL
      void = Error_Message()
      IF N_Elements(currentState) NE 0 THEN SetDecomposedState, currentState
      RETURN
  ENDIF
  
  overplot = Keyword_Set(overplot)

  <span class="comments">; Are we doing some kind of output?</span>
  IF (N_Elements(output) NE 0) && (output NE "") && ~overplot THEN BEGIN
    
       <span class="comments">; Determine the type of file from the filename extension.</span>
       root_name = cgRootName(output, DIRECTORY=theDir, EXTENSION=ext)
       IF theDir EQ "" THEN CD, CURRENT=theDir
       outfilename = output
       outputSelection = StrUpCase(ext)
       typeOfOutput = ['PS','EPS','PDF','BMP','GIF','JPEG','JPG','PNG','TIFF', 'TIF']
       void = Where(typeOfOutput EQ outputSelection, count)
       IF count EQ 0 THEN Message, 'Cannot find ' + outputSelection + ' in allowed output types.'
       
       <span class="comments">; Set things up.</span>
       CASE outputSelection OF
          'PS': BEGIN
              ext = '.ps'
              delete_ps = 0
              END    
          'EPS': BEGIN
              ext = '.eps'
              encapsulated = 1
              delete_ps = 0
              END
          'PDF': BEGIN
              ext = '.pdf'
              pdf_flag = 1
              delete_ps = 1
              END     
          'BMP': BEGIN
              ext = '.bmp'
              bmp_flag = 1
              delete_ps = 1
              END      
          'GIF': BEGIN
              ext = '.gif'
              gif_flag = 1
              delete_ps = 1
              END
          'JPEG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END      
          'JPG': BEGIN
              ext = '.jpg'
              jpeg_flag = 1
              delete_ps = 1
              END
          'PNG': BEGIN
              ext = '.png'
              png_flag = 1
              delete_ps = 1
              END      
          'TIFF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END
          'TIF': BEGIN
              ext = '.tif'
              tiff_flag = 1
              delete_ps = 1
              END    
       ENDCASE

       <span class="comments">; We need to know the root name of the file, because we have to make a PostScript</span>
       <span class="comments">; file of the same name. At least we do if the type is not PS or EPS.</span>
       IF (outputSelection NE 'PS') && (outputSelection NE 'EPS') THEN BEGIN
           root_name = cgRootName(outfilename, DIRECTORY=theDir)
           IF theDir EQ "" THEN CD, CURRENT=theDir
           ps_filename = Filepath(ROOT_DIR=theDir, root_name + '.ps')
       ENDIF ELSE ps_filename = outfilename
       
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
         PS_Charsize = ps_charsize, $          <span class="comments">; The PostScript character size.</span>
         PS_FONT = ps_font, $                  <span class="comments">; Select the font for PostScript output.</span>
         PS_Decomposed = ps_decomposed, $      <span class="comments">; Sets the PostScript color mode.</span>
         PS_Delete = ps_delete, $              <span class="comments">; Delete PS file when making IM raster.</span>
         PS_Metric = ps_metric, $              <span class="comments">; Select metric measurements in PostScript output.</span>
         PS_Scale_factor = ps_scale_factor, $  <span class="comments">; Select the scale factor for PostScript output.</span>
         PS_TT_Font = ps_tt_font               <span class="comments">; Select the true-type font to use for PostScript output.   </span>
       
       <span class="comments">; Set up the PostScript device.</span>
       PS_Start, $
          CHARSIZE=ps_charsize, $
          DECOMPOSED=ps_decomposed, $
          FILENAME=ps_filename, $
          FONT=ps_font , $
          ENCAPSULATED=encapsulated, $
          METRIC=ps_metric, $
          SCALE_FACTOR=ps_scale_factor, $
          TT_FONT=ps_tt_font, $
          QUIET=1
    
    
  ENDIF
   
  <span class="comments">; Set up PostScript device for working with colors.</span>
  IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8

  <span class="comments">; Do they want this plot in a resizeable graphics window?</span>
  IF Keyword_Set(addcmd) THEN window = 1
  IF Keyword_Set(window) AND ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        <span class="comments">; Special treatment for overplotting or adding a command.</span>
        IF Keyword_Set(addcmd) THEN BEGIN
            cgWindow, 'cgTaylorDiagram', stddev, correlation, $
                C_CORRELATION=c_correlation, $
                C_STDDEV=c_stddev, $
                C_REF=c_ref, $
                C_SYMBOL=c_symbol, $
                LABELS=labels, $
                OUTPUT=output, $
                OVERPLOT=overplot, $
                POSITION=position, $
                REF_STDDEV=ref_stddev, $
                RMS_CIRCLES_OFF=rms_circles_off, $
                RMS_FORMAT=rms_format, $
                RMS_INCREMENT=rms_increment, $
                RMS_LABELS_OFF=rms_labels_off, $
                STDDEV_MAX=stddev_max, $
                SYMBOL=symbol, $
                SYMSIZE=symsize, $
                ADDCMD=1
             RETURN
       ENDIF
        
        <span class="comments">; Open a new window or replace the current commands, as required.</span>
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        IF wincnt EQ 0 THEN replaceCmd = 0 ELSE replaceCmd=1
        cgWindow, 'cgTaylorDiagram', stddev, correlation, $
                C_CORRELATION=c_correlation, $
                C_STDDEV=c_stddev, $
                C_REF=c_ref, $
                C_SYMBOL=c_symbol, $
                LABELS=labels, $
                OUTPUT=output, $
                OVERPLOT=overplot, $
                POSITION=position, $
                REF_STDDEV=ref_stddev, $
                RMS_CIRCLES_OFF=rms_circles_off, $
                RMS_FORMAT=rms_format, $
                RMS_INCREMENT=rms_increment, $
                RMS_LABELS_OFF=rms_labels_off, $
                STDDEV_MAX=stddev_max, $
                SYMBOL=symbol, $
                SYMSIZE=symsize, $
                REPLACECMD=replaceCmd
         RETURN
    ENDIF
    
  <span class="comments">; Do this in decomposed color mode.</span>
  SetDecomposedState, 1, CURRENT=currentState
  
  <span class="comments">; Check parameters.</span>
  IF N_Params() NE 2 THEN BEGIN
     Print, 'Calling Syntax: cgTaylorDiagram, stddev, correlation'
     RETURN
  ENDIF
  
  <span class="comments">; Default values for keywords.</span>
  SetDefaultValue, c_correlation, 'grn7'
  SetDefaultValue, c_stddev, 'blu7'
  SetDefaultValue, c_ref, 'pur7'
  SetDefaultValue, c_symbol, 'red'
  SetDefaultValue, symbol, 16
  SetDefaultValue, symsize, 1.5
  SetDefaultValue, ref_stddev, 1.0
  SetDefaultValue, rms_increment, 1.0
  SetDefaultValue, rms_format, '(I0)'
  SetDefaultValue, stddev_max, Round((Max(stddev) * 1.25) * 10)/ 10.0
  
  <span class="comments">; Skip all this if you are overplotting</span>
  IF overplot THEN GOTO, overplotComeHere
    
  <span class="comments">; Construction of the diagram.</span>
  
  <span class="comments">; PART I: Outer Axis circle and RMS circles</span>
  cir_npts = 1000     <span class="comments">;number of points of the outer circle</span>
  x = Findgen(cir_npts)/(cir_npts-1) * stddev_max
  y = SQRT(stddev_max^2 - x^2) <span class="comments">; Equation of Outer circle. stddev_max is maximun of the radius of the Correlation Circle Axis</span>

  IF N_Elements(position) EQ 0 && (Total(!P.Multi) LE 0) && (Total(!P.Position) EQ 0.0) THEN BEGIN
     position = [0.125, 0.125, 0.9, 0.9]
  ENDIF
   
  <span class="comments">; Initial plot in window.</span>
  IF !D.Window LT 0 THEN cgDisplay, 680, 640
  cgPlot, x, y, /NoData, XTITLE='Standard Deviation', YTITLE='Standard Deviation', $
      XSTYLE=9, YSTYLE=9, POSITION=position, BACKGROUND='white'
  
  <span class="comments">; PART II: Building ticks: Long and Short ticks</span>
  <span class="comments">; Long Ticks</span>
  nticks = 10
  cir_ticks = Findgen(nticks)/nticks * stddev_max
  
  <span class="comments">; Coordinates of the two extremes of the ticks for the outer circle: we will create a polyline as ticks</span>
  long_x_right = cir_ticks
  long_y_right = SQRT(stddev_max^2 - cir_ticks^2)
  long_x_left  = FltArr(nticks)
  long_y_left  = FltArr(nticks)
  
  <span class="comments">; Multiple RMS circles</span>
  multi_cir = 1000                                      <span class="comments">; Number of points of each RMS circle</span>
  number_cirs = Fix((stddev_max / rms_increment)) + 5   <span class="comments">; Number of RMS circles</span>
  initial_rms_increment = rms_increment
    
  IF ~Keyword_Set(rms_circles_off) THEN BEGIN
      FOR i=0, number_cirs-1 DO BEGIN
    
        multi_max = ref_stddev + rms_increment
        multi_min = ref_stddev - rms_increment
       
        multi_circlesx = Findgen(multi_cir)/(multi_cir-1)*(multi_max-multi_min)+multi_min
        multi_circlesy = SQRT(rms_increment^2 - (multi_circlesx-ref_stddev)^2)
    
        cgPlotS, 0 > multi_circlesx &lt<span class="comments">; stddev_max, 0 > multi_circlesy &lt; stddev_max, COLOR=c_stddev, LINESTYLE=1</span>
        number = String(rms_increment, Format=rms_format)

        IF ~Keyword_Set(rms_labels_off) THEN BEGIN
            IF (multi_circlesx[i+50] GT 0) AND (multi_circlesx[i+50] LT stddev_max) THEN BEGIN
                cgText, multi_circlesx[i+50], multi_circlesy[i+50], number, $
                   CHARSIZE=cgDefCharsize()*0.8, ALIGNMENT=1, /DATA, CLIP=0, COLOR=c_stddev
            ENDIF
        ENDIF
        rms_increment = initial_rms_increment + rms_increment
        
      ENDFOR
  ENDIF
  
  <span class="comments">; Mask: Masking part of the RMS circles out:</span>
  cgColorFill, [x, stddev_max, x[0]],[y, stddev_max, y[0]], /data, COLOR='white'
  cgPolygon, [x, stddev_max, x[0]],[y, stddev_max, y[0]], /data, COLOR='white'
  cgColorFill, [!X.Window[0],!X.Window[0], !X.Window[1], !X.Window[1], !X.Window[0]], $
               [!Y.Window[1], 1.0, 1.0, !Y.Window[1], !Y.Window[1]], /Normal, COLOR='white'
  
  cgPlotS, x, y
  
 <span class="comments">; Short Ticks</span>
 <span class="comments">; new circle where its points will be used as the end point of the short ticks</span>
  short_cir = 1000
  short_max = stddev_max*.98
  short_min = 0.0
  short_cir_x = Findgen(short_cir)/(short_cir-1)*(short_max-short_min)+short_min
  short_cir_y = SQRT(short_max^2 - short_cir_x^2)
  
  <span class="comments">;Some points of the new circle to be used as ticks</span>
  short_nticks = 20
  shortx = Findgen(short_nticks)/short_nticks *(short_max-short_min)+short_min
  shorty = SQRT(short_max^2 - shortx^2)
  
  select_shortx = FltArr(nticks)
  select_shorty = FltArr(nticks)
  
  j = 0
  FOR i=0, short_nticks-1, 2 DO BEGIN
    select_shortx[j] = shortx[i+1]
    select_shorty[j] = shorty[i+1]
    j = j+1
  ENDFOR

 <span class="comments">; Some points of the outer circle to be used as extremes for the short ticks</span>
  outer_shortx = Findgen(short_nticks)/short_nticks * stddev_max
  outer_shorty = SQRT(stddev_max^2 - outer_shortx^2)
  
  select_outerx = FltArr(nticks)
  select_outery = FltArr(nticks)
  
  j = 0
  FOR i=0, short_nticks-1, 2 DO BEGIN
    select_outerx[j] = outer_shortx[i+1]
    select_outery[j] = outer_shorty[i+1]
    j = j+1
  ENDFOR

  angles = FltArr(nticks)
  text_ang = FltArr(nticks)
  
  <span class="comments">; Plotting correlation lines and ticks.</span>
  FOR i=0,nticks-1 DO BEGIN
    cgPlotS, [long_x_right[i], long_x_left[i]], [long_y_right[i], long_y_left[i]], $
        COLOR=((i EQ 0) ? 'black' : c_correlation)
    cgPlotS, [select_outerx[i], select_shortx[i]], [select_outery[i], select_shorty[i]]
    
    <span class="comments">;the following IF statement is here because for i=0,long_x_right[i]=0.0</span>
    <span class="comments">;and therefore I get: % Program caused arithmetic error: Floating divide by 0 in line 102</span>
    IF long_x_right[i] EQ 0.0 THEN BEGIN
      angles[i] = 1.57080 <span class="comments">;90 degrees radians</span>
    ENDIF ELSE BEGIN
      angles[i] = atan(long_y_right[i]/long_x_right[i]) 
    ENDELSE
    text_ang[i] = angles[i]*(180.0/!PI)
    tick_number = [' 0.0', ' 0.1', ' 0.2', ' 0.3', ' 0.4', ' 0.5', ' 0.6', ' 0.7', ' 0.8', ' 0.9']
   
    cgText, long_x_right[i], long_y_right[i], tick_number[i], ORIENTATION=text_ang[i], $
        CLIP=0, COLOR=c_correlation, CHARSIZE=cgDefCharsize()*0.85
    
  ENDFOR
  
  last_angle = atan(select_outery[nticks-1]/select_outerx[nticks-1]) 
  short_last_ang = last_angle*(180.0/!PI)

  cgText, select_outerx[nticks-1], select_outery[nticks-1], ' 0.95', ORIENTATION=short_last_ang, $
       CLIP=0, COLOR=c_correlation, CHARSIZE=cgDefCharsize()*0.85

  cgText, stddev_max, y[N_Elements(y)-1], ' 1.0', CHARSIZE=cgDefCharsize()*0.85, CLIP=0, COLOR=c_correlation
  
  
  <span class="comments">;Extra ticks between correlation values 0.9 and 1:</span>
  <span class="comments">;Even Shorter Ticks</span>
 <span class="comments">; new circle where its points will be used as the end point of the Extra short ticks</span>
  extrashort_cir = 1000
  extrashort_max = stddev_max*.99
  sector_x = cos(angles[nticks-1]) * extrashort_max
  extrashort_min  =  sector_x
  extrashort_cir_x = Findgen(extrashort_cir)/(extrashort_cir-1)*(extrashort_max-extrashort_min)+extrashort_min
  extrashort_cir_y = SQRT(extrashort_max^2 - extrashort_cir_x^2)
  
  <span class="comments">;Select some points of the last angular sector to be used as ticks: outer circle and inside circle:</span>
  extrashort_nticks = 10
  
  extrashort_outermax = stddev_max
  sector_outerx  = cos(angles[nticks-1]) * stddev_max
  extrashort_outermin = sector_outerx
  extrashort_outerx = Findgen(extrashort_nticks)/(extrashort_nticks)*(stddev_max-extrashort_outermin)+extrashort_outermin
  extrashort_outery = SQRT(stddev_max^2 - extrashort_outerx^2)
  
  extrashortx = Findgen(extrashort_nticks)/(extrashort_nticks) *(extrashort_max-extrashort_min)+extrashort_min
  extrashorty = SQRT(extrashort_max^2 - extrashortx^2)

  
  FOR i=0, extrashort_nticks-1 DO BEGIN
    cgPlots, [extrashort_outerx[i], extrashortx[i]], [extrashort_outery[i], extrashorty[i]], COLOR=c_correlation
  ENDFOR
  
  <span class="comments">;Correlation Axis Name</span>
  cc_namex  = stddev_max - stddev_max*0.25
  cc_namey  = stddev_max - stddev_max*0.25
  cgText, cc_namex, cc_namey, 'Correlation', ORIENTATION=-45., ALIGNMENT=0.5,  COLOR=c_correlation
 

  <span class="comments">; Observed/Reference Circles. The dashed circles centered in the Observed value are the centered RMS</span>
  <span class="comments">; (root-mean-square) values.</span>
  ref_cir = 1000
  ref_max = ref_stddev
  ref_min = 0.0
  ref_cir_x = Findgen(ref_cir)/(ref_cir-1)*(ref_max-ref_min)+ref_min
  ref_cir_y = SQRT(ref_max^2 - ref_cir_x^2)
  cgPlots, ref_cir_x, ref_cir_y, LINESTYLE=2, COLOR='pur7'
  cgText, ref_max, stddev_max * 0.05, 'Observed', ALIGNMENT=0.5, COLOR='pur7'
  
  <span class="comments">; PART III: Plotting the Input Data Points</span>
  overplotComeHere:
  dataangle = ACos( correlation )            
  data_x = stddev * Cos( dataangle )     
  data_y = stddev * Sin( dataangle )  
  
  cgPlotS, data_x, data_y, PSYM=symbol, COLOR=c_symbol, SymSize=symsize
  xy = Convert_Coord(data_x, data_y, /DATA, /TO_NORMAL)
  squib = 0.0075
  IF N_Elements(labels) NE 0 THEN BEGIN
      cgText, xy[0,*], xy[1,*] + 2*squib, labels, /NORMAL, FONT=0, ALIGNMENT=0.5
  ENDIF
  
  <span class="comments">; Are we producing output? If so, we need to clean up here.</span>
  IF (N_Elements(output) NE 0) && (output NE "") && (~overplot) THEN BEGIN
    
       <span class="comments">; Get the output default values.</span>
       cgWindow_GetDefs, $
           IM_Density = im_density, $                      <span class="comments">; Sets the density parameter on ImageMagick convert command.</span>
           IM_Options = im_options, $                      <span class="comments">; Sets extra ImageMagick options on the ImageMagick convert command.</span>
           IM_Resize = im_resize, $                        <span class="comments">; Sets the resize parameter on ImageMagick convert command.</span>
           IM_Transparent = im_transparent, $              <span class="comments">; Sets the "alpha" keyword on ImageMagick convert command.</span>
           IM_Width = im_width, $                          <span class="comments">; Sets the width of raster file output created with ImageMagick.</span>
           PDF_Unix_Convert_Cmd = pdf_unix_convert_cmd, $  <span class="comments">; Command to convert PS to PDF.</span>
           PDF_Path = pdf_path                             <span class="comments">; The path to the Ghostscript conversion command.</span>
    
        <span class="comments">; Close the PostScript file and create whatever output is needed.</span>
        PS_END, DELETE_PS=delete_ps, $
             ALLOW_TRANSPARENT=im_transparent, $
             BMP=bmp_flag, $
             DENSITY=im_density, $
             GIF=gif_flag, $
             GS_PATH=pdf_path, $
             IM_OPTIONS=im_options, $
             JPEG=jpeg_flag, $
             PDF=pdf_flag, $
             PNG=png_flag, $
             RESIZE=im_resize, $
             TIFF=tiff_flag, $
             UNIX_CONVERT_CMD=pdf_unix_convert_cmd, $
             WIDTH=im_width
              
         basename = File_Basename(outfilename)
         dirname = File_Dirname(outfilename)
         IF dirname EQ "." THEN CD, CURRENT=dirname
         Print, 'Output File: ' + Filepath(ROOT_DIR=dirname, basename)
  ENDIF

  <span class="comments">; Restore color mode.</span>
  SetDecomposedState, currentState
  
END
  
  
  
  
  <span class="comments">;#######################################  Main Test Program  #############################################</span>

      labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']            <span class="comments">; Point labels.</span>
      stddev = [1.4, 0.9, 1.0, 1.272, 1.1, 0.95, 1.08, 0.5]        <span class="comments">; Standard Deviations</span>
      correlation = [0.8, 0.9, 0.65, 0.74, 0.91, 0.98, 0.85, 0.35] <span class="comments">; Correlations</span>
      ref_std = 1.0                                                <span class="comments">; Reference standard (observed)</span>
      stddev_max = 1.5                                             <span class="comments">; Standard Deviation maximum</span>
      cgTaylorDiagram, stddev, correlation, REF_STDDEV=ref_std, STDDEV_MAX=stddev_max, $
          RMS_INCREMENT=0.25, RMS_FORMAT='(F0.2)', LABELS=labels, /WINDOW

      labels = ['I',  'J', 'K', 'L',  'M', 'N', 'O',   'P']                 <span class="comments">; Point labels.</span>
      stddev = [1.25, 0.7, 1.1, 0.86, 1.5, 1.21, 0.78, 0.52]                <span class="comments">; Standard Deviations</span>
      correlation = Reverse([0.8, 0.9, 0.65, 0.74, 0.91, 0.98, 0.85, 0.35]) <span class="comments">; Correlations</span>
      cgTaylorDiagram, stddev, correlation, /OVERPLOT, LABELS=labels, /ADDCMD, C_SYMBOL='blue'
END
</code>
    </div>
  </body>
</html>