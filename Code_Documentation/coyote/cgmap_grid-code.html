<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:19 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgmap_grid.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgmap_grid.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgMap_Grid</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Provides a significantly modified MAP_GRID command that can be used together</span>
<span class="comments">;   with other Coyote Graphics routines and in resizeable graphics windows.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">;   This program provides a significantly modified MAP_GRID command that </span>
<span class="comments">;   can be used with other Coyote Graphics routines.</span>
<span class="comments">;</span>
<span class="comments">;     Description of known MAP_GRID problems::</span>
<span class="comments">;        http://www.idlcoyote.com/map_tips/noclip.html</span>
<span class="comments">;        http://www.idlcoyote.com/map_tips/missinggrid.html</span>
<span class="comments">;        http://www.idlcoyote.com/map_tips/extralines.php</span>

<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics, Map Projections</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;   FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;      David W. Fanning </span>
<span class="comments">;      1645 Sheely Drive</span>
<span class="comments">;      Fort Collins, CO 80526 USA</span>
<span class="comments">;      Phone: 970-221-0438</span>
<span class="comments">;      E-mail: david@idlcoyote.com</span>
<span class="comments">;      Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;           </span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by David W. Fanning, 7 November 2011.</span>
<span class="comments">;        Significant modification of the MAP_GRID command in IDL to fix known</span>
<span class="comments">;           problems, especially when used in conjunction with map projection spaces</span>
<span class="comments">;           set up with MAP_PROJ_INIT. David W. Fanning, 7 November 2011.</span>
<span class="comments">;        Added an ERASE=0 to the /NOGRAPHICS keyword on the Draw method call to cgMap. 27 Dec 2011.</span>
<span class="comments">;        Changed the default line thickness to !P.Thick to better support PostScript files. 28 Dec 2011. DWF.</span>
<span class="comments">;        Fixed a problem with grid labeling when values were passed with LATS or LONS keyword. 6 April 2012. DWF.</span>
<span class="comments">;        Modified slightly to allow a three-element byte array to be used as the COLOR. 18 April 2012. DWF.</span>
<span class="comments">;        If a Map object is available, I make sure to call DRAW method before drawing graphics. 12 Sept 2012. DWF.</span>
<span class="comments">;        Added cgGRID keyword to allow the cgMap object to create latitude and longitude grid in its</span>
<span class="comments">;            LatLonLabels method. Previously used by default, but it doesn't work well with global</span>
<span class="comments">;            map projections. It works best with small map areas in UTM projection space. 3 Jan 2013. DWF.</span>
<span class="comments">;        Removed some old code that was used to correct latitude and longitude values. No longer needed,</span>
<span class="comments">;            I hope, with the new cgGRID keyword. 3 Jan 2013. </span>
<span class="comments">;        Corrected bug in variable spelling that affect LONDELTA and LATDELTA keywords. 6 Jan 2013. DWF.</span>
<span class="comments">;        Lost a piece of code that allows longitude box axes. Added back in. 23 Jan 2013. DWF.</span>
<span class="comments">;        T3D keyword was not being applied. Fixed. 11 February 2013. DWF.</span>
<span class="comments">;        Added NOCLIP keyword. 15 February 2013. DWF.</span>
<span class="comments">;        Sometimes a longitude line is draw incorrectly due to the fact that the longitude vector does not</span>
<span class="comments">;           have a point in the XRANGE of the projection. A fix to that problem has failed to work in all</span>
<span class="comments">;           circumstances, so I have done more work on that algorithm to see if I can solve the problem is</span>
<span class="comments">;           a better way. Now usine Value_Locate to test for point. 19 February 2013. DWF.</span>
<span class="comments">;            </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2011-2013, Fanning Software Consulting, Inc.</span>
<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;+------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; Find the grid increment find defining the latitude and longitude delta</span>
<span class="comments">; values, if they are not currently defined.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    span: in, required, type=float</span>
<span class="comments">;       The data range.</span>
<span class="comments">;       </span>
<span class="comments">;-------------------------------------------------------------------------</span>
<a id="cgMap_Grid_Incr:source"></a>function cgMap_Grid_Incr, span
    <span class="comments">;</span>
    <span class="comments">; Determine LONDEL or LATDEL if not specified</span>
    <span class="comments">;</span>
    COMPILE_OPT hidden, IDL2
    
    IF span eq 0 THEN return, 45.
    ipow = 0
    t = abs(span) &lt<span class="comments">; 450.</span>
    WHILE t lt 5 DO BEGIN 
       t = t * 10 & ipow = ipow +1 
    ENDWHILE
    increments = [ 0.1, 1., 2., 4., 5., 10., 15., 30., 45.]
    i = 0
    WHILE t gt (increments[i] * 10) DO i = i + 1
    t = increments[i] / 10^ipow
    retvalue = span ge 0 ? t : -t
    return, retvalue
end


<span class="comments">;+------------------------------------------------------------------------</span>
<span class="comments">; Find the point on the line between points c0 and c1, expressed in</span>
<span class="comments">; DEVICE coordinates, where the longitude (Icoord = 0) or latitude</span>
<span class="comments">; (Icoord = 1) is equal to Gwant.  If the segment between c0 and c1</span>
<span class="comments">; doesn't intersect the given meridan or parallel, or either endpoint</span>
<span class="comments">; is not mappable, return NaN. Otherwise, return the device coordinate, </span>
<span class="comments">; X if Icoord = 0, or Y if Icoord = 1, of the intersection.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    c0: in, required, type=integer</span>
<span class="comments">;       Input coordinate?</span>
<span class="comments">;    c1: in, required, type=integer</span>
<span class="comments">;       Input coordinate?</span>
<span class="comments">;    icoord: in, required, type=integer</span>
<span class="comments">;       Index of input coordinate?</span>
<span class="comments">;    gwant: in, required, type=integer</span>
<span class="comments">;       Global wrapping?</span>
<span class="comments">;  </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     map_structure: in, optional, type=structure</span>
<span class="comments">;         The map structure to covert XY projected meters to lat/lon space.</span>
<span class="comments">;         </span>
<span class="comments">;-------------------------------------------------------------------------</span>
Function cgMap_Grid_Solve, c0, c1, icoord, gwant, MAP_STRUCTURE=mapStruct

    COMPILE_OPT hidden, IDL2

    hasMap = N_TAGS(mapStruct) gt 0

    p0 = CONVERT_COORD(c0, /DEVICE, /TO_DATA)
    p1 = CONVERT_COORD(c1, /DEVICE, /TO_DATA)

    if (hasMap) then begin   <span class="comments">; Convert from UV to latlon</span>
        p0 = MAP_PROJ_INVERSE(p0[0], p0[1], MAP_STRUCTURE=mapStruct)
        p1 = MAP_PROJ_INVERSE(p1[0], p1[1], MAP_STRUCTURE=mapStruct)
    endif

    p0 = p0[Icoord]
    p1 = p1[Icoord]

    <span class="comments">; Not mappable or zero interval.</span>
    if ~finite(p0) || ~finite(p1) || (p1 eq p0) then return, !values.f_nan

    if (Icoord eq 0) && (p0 gt p1) then begin <span class="comments">;Wrap if we cross dateline</span>
        if gwant ge 0 then p1 += 360. $
        else p0 -= 360.
    endif

    t = (Gwant - p0) / (p1-p0)
    if (t lt 0.0) || (t gt 1.0) then return, !values.f_nan

    low = 0.0
    high = 1.0
    tol = 1.0e-5
    del = c1 - c0
    while abs(high-low) gt tol do begin <span class="comments">;Binary chopping method</span>
        t = (low + high) / 2.
        c = c0 + t * del
        p = CONVERT_COORD(c, /DEVICE, /TO_DATA)
        if (hasMap) then $   <span class="comments">; Convert from UV to latlon</span>
            p = MAP_PROJ_INVERSE(p[0], p[1], MAP_STRUCTURE=mapStruct)
        p = p[Icoord]
        if (~FINITE(p)) then $
            return, !values.f_nan
        if (Icoord eq 0) then begin <span class="comments">;Check for dateline?</span>
            if p lt p0 then p += 360. $ <span class="comments">;Wrap?  P should be in interval p0-p1.</span>
            else if p gt p1 then p -= 360.
        endif
        if (Gwant-p0) * (Gwant - p) gt 0.0 then begin <span class="comments">;In same interval as p0 : low</span>
            low = t
            p0 = p
        endif else high = t         <span class="comments">;Keep low, and fcn at low = p0.</span>
    endwhile

    return, c[Icoord]

end


<span class="comments">;</span>
<span class="comments">;+------------------------------------------------------------------------</span>
<span class="comments">;    This routine fixes a bug in MAP_GRID that causes map labels to be</span>
<span class="comments">;    written outside the map boundary when using hardware or true-type</span>
<span class="comments">;    fonts. It checks to be sure the label is inside the map boundary</span>
<span class="comments">;    before it is written. Users can control how "exact" the boundary is</span>
<span class="comments">;    when using GCTP map projections by setting the FUZZY keyword to</span>
<span class="comments">;    a multiplication factor that is multiplied times the calculated</span>
<span class="comments">;    data range of the map projection. </span>
<span class="comments">;    </span>
<span class="comments">;    If a point is determined to be outside the map boundary, a single</span>
<span class="comments">;    data value is returned by the function. This is a signal that this</span>
<span class="comments">;    data point should not be drawn.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    xy: in, required, type=float</span>
<span class="comments">;       The input label point. Normally, a two element array.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     fuzzy: in, optional, type=float, default=0.0</span>
<span class="comments">;        This keyword applies only if the GCTP keyword is set. Set the</span>
<span class="comments">;        keyword to a value that is a percentage of the current data range.</span>
<span class="comments">;        This percentage of the range is added to or subtracted from the</span>
<span class="comments">;        values used to determine if the label is "inside" the boundary.</span>
<span class="comments">;        It allows you to be a little less exact when selecting inside </span>
<span class="comments">;        points. There are occasional aesthetic reasons for allowing fuzzy</span>
<span class="comments">;        boundaries. A reasonable value for fuzziness might be 0.0125.</span>
<span class="comments">;     gctp: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to calculate boundaries in terms of the the</span>
<span class="comments">;        current calculated data range variables !X.CRange and !Y.CRange.</span>
<span class="comments">;        Otherwise, the boundaries are taken from !Map.LL_BOX.</span>
<span class="comments">;        </span>
<span class="comments">;-------------------------------------------------------------------------</span>
<a id="cgMap_Grid_Check_Range:source"></a>function cgMap_Grid_Check_Range, xy, FUZZY=fuzzy, GCTP=gctp 

    <span class="comments">; You need at least two points coming in here.</span>
    IF N_Elements(xy) NE 2 THEN RETURN, xy
    x = xy[0]
    y = xy[1]
    IF Keyword_Set(gctp) THEN SetDefaultValue, fuzzy, 0.0
    
    <span class="comments">; If this is a CGTP projection, then check the axis range values. Otherwise,</span>
    <span class="comments">; use the LL_BOX form the map structure !MAP. The latter is more strict about</span>
    <span class="comments">; being inside the box.</span>
    IF Keyword_Set(gctp) THEN BEGIN
        IF x LT (Min(!X.CRange)- fuzzy*(!X.CRange[1]-!X.CRange[0])) THEN RETURN, xy[0]
        IF x GT (Max(!X.CRange)+ fuzzy*(!X.CRange[1]-!X.CRange[0])) THEN RETURN, xy[0]
        IF y LT (Min(!Y.CRange)- fuzzy*(!Y.CRange[1]-!Y.CRange[0])) THEN RETURN, xy[0]
        IF y GT (Max(!Y.CRange)+ fuzzy*(!Y.CRange[1]-!Y.CRange[0])) THEN RETURN, xy[0]
    ENDIF ELSE BEGIN
    
    ENDELSE
    RETURN, xy
end


<span class="comments">;+--------------------------------------------------------------------------</span>
<span class="comments">; Provides a MAP_GRID command that can be used in conjunction with other</span>
<span class="comments">; Coyote Graphics programs and in resizeable graphics windows. Any keyword </span>
<span class="comments">; appropriate for the MAP_GRID command in IDL can be used. </span>
<span class="comments">;     </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     addcmd: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object is added to the resizeable graphics</span>
<span class="comments">;        window, cgWindow. Note that a map projection command must be added to the</span>
<span class="comments">;        window before this command is added to be effective.</span>
<span class="comments">;     bcolor: optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the color to draw box axes with.</span>
<span class="comments">;     box_axes: optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw box axes on the map projection.</span>
<span class="comments">;     cggrid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to allow the latitude and longitude values to be set by</span>
<span class="comments">;        the LatLon_Labels method in the cgMap object. Previously this was used by</span>
<span class="comments">;        default, but it caused a lot of problems with global or near global map projections.</span>
<span class="comments">;        This really should be used ONLY if you are mapping a very small region of the Earth,</span>
<span class="comments">;        and maybe if you are using a UTM map projection. Othersize, it is probably not </span>
<span class="comments">;        needed, so I have made it an optional choice.</span>
<span class="comments">;     charsize: in, optional, type=float</span>
<span class="comments">;        The character size for the labels. Default is cgDefCharSize()*0.75.</span>
<span class="comments">;     clip_text: in, optional, type=boolean, default=1</span>
<span class="comments">;        Set this keyword to a zero value to turn off clipping of text labels. </span>
<span class="comments">;        By default, text labels are clipped. This keyword is ignored if the `Box_Axes` </span>
<span class="comments">;        keyword is set.</span>
<span class="comments">;     color: in, optional, type=string, default='opposite'</span>
<span class="comments">;        The name of the drawing color for the program.</span>
<span class="comments">;     fill_horizon: in, optional, type=boolean, default=0</span>
<span class="comments">;     format: in, optional, type=string</span>
<span class="comments">;        Set this keyword to a format for the grid labels.</span>
<span class="comments">;     fuzzy: in, optional, type=float, default=0.0</span>
<span class="comments">;        This keyword applies only if the MAP_STRUCTURE keyword is used. Set the</span>
<span class="comments">;        keyword to a value that is a percentage of the current data range.</span>
<span class="comments">;        This percentage of the range is added to or subtracted from the</span>
<span class="comments">;        values used to determine if the label is "inside" the boundary.</span>
<span class="comments">;        It allows you to be a little less exact when selecting inside </span>
<span class="comments">;        points. There are occasional aesthetic reasons for allowing fuzzy</span>
<span class="comments">;        boundaries. A reasonable value for fuzziness might be 0.0125.</span>
<span class="comments">;     glinestyle: in, optional</span>
<span class="comments">;        Not used. Use `Linestyle` instead.</span>
<span class="comments">;     glinethick: in, optional</span>
<span class="comments">;        Not used. Use `Thick` instead.</span>
<span class="comments">;     horizon: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to draw the current map horizon.</span>
<span class="comments">;     increment: in, optional, type=integer, default=4</span>
<span class="comments">;        Determines the smoothness of graticle lines by setting the spacing between</span>
<span class="comments">;        them. A low number is a smooth number. </span>
<span class="comments">;     label: in, optional, type=integer, default=0</span>
<span class="comments">;        An number that tells how to label the grid line. A 0 means no grid lines are </span>
<span class="comments">;        labelled. A 1 means all grid lines are labelled. A 2 means label every 2nd </span>
<span class="comments">;        grid line is labelled. A 3 means every  3rd grid line is labelled, and so on.</span>
<span class="comments">;     latalign: in, optional, type=float, default=0.0</span>
<span class="comments">;        This keyword controls the alignment of the text baseline for latitude labels. </span>
<span class="comments">;        A value of 0.0 left justifies the label, 1.0 right justifies it, and 0.5 </span>
<span class="comments">;        centers it. This keyword is ignored if the `Box_Axes` keyword is set.</span>
<span class="comments">;     latdelta: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the spacing in degrees between parallels of latitude in</span>
<span class="comments">;        the grid. If this keyword is not set, a suitable value is determined from the</span>
<span class="comments">;        current map projection.</span>
<span class="comments">;     latlabel: in, optional, type=float</span>
<span class="comments">;        The longitude at which to place latitude labels. The default is the center </span>
<span class="comments">;        longitude on the map if using Map_Set, and a longitude line on the left of the</span>
<span class="comments">;        plot if using Map_Proj_Init. This keyword is ignored if the `Box_Axes` keyword is set. </span>
<span class="comments">;     latnames: in, optional, type=string</span>
<span class="comments">;        Set this keyword equal to an array specifying the names to be used for the </span>
<span class="comments">;        latitude labels. By default, this array is automatically generated in units </span>
<span class="comments">;        of degrees. The LATNAMES array can be either type string or any single numeric </span>
<span class="comments">;        type, but should not be of mixed type. When LATNAMES is specified, the LATS </span>
<span class="comments">;        keyword must also be specified. The number of elements in the two arrays need </span>
<span class="comments">;        not be equal. If there are more elements in the LATNAMES array than in the LATS </span>
<span class="comments">;        array, the extra LATNAMES are ignored. If there are more elements in the LATS </span>
<span class="comments">;        array than in the LATNAMES array, labels in degrees will be automatically </span>
<span class="comments">;        provided for the missing latitude labels. The LATNAMES keyword can be also used </span>
<span class="comments">;        when the LATS keyword is set to a single value. It this case, the first label </span>
<span class="comments">;        supplied will be used at the specified latitude; subsequent names will be </span>
<span class="comments">;        placed at the next latitude line to the north, wrapping around the globe if </span>
<span class="comments">;        appropriate. Caution should be used when using LATNAMES in conjunction with a </span>
<span class="comments">;        single LATS value, since the number of visible latitude gridlines is dependent </span>
<span class="comments">;        on many factors. </span>
<span class="comments">;     lats: in, optional, type=float</span>
<span class="comments">;        Set this keyword equal to a one or more element vector of latitudes for which </span>
<span class="comments">;        lines will be drawn (and optionally labeled). If LATS is omitted, appropriate </span>
<span class="comments">;        latitudes will be generated based on the value of the (optional) LATDEL keyword. </span>
<span class="comments">;        If LATS is set to a single value, that latitude and a series of automatically </span>
<span class="comments">;        generated latitudes will be drawn (and optionally labeled). Automatically generated </span>
<span class="comments">;        latitudes have values that extend over the map. If LATS is a single value, that </span>
<span class="comments">;        value is taken to be the starting point for labelling (See the LABEL keyword). </span>
<span class="comments">;     lcolor: in, optional, type=string</span>
<span class="comments">;        Set this to the name of the label color to use in labeling grid lines.</span>
<span class="comments">;        By default, the same as COLOR, or if BOX_AXIS is set, then same as BCOLOR.</span>
<span class="comments">;     linestyle: in, optional, type=integer, default=1</span>
<span class="comments">;        This keyword is the same as the GLineStyle keyword, but is a more</span>
<span class="comments">;        natural way of setting the value.</span>
<span class="comments">;     lonalign: in, optional, type=float, default=0.0</span>
<span class="comments">;        This keyword controls the alignment of the text baseline for longitude labels. </span>
<span class="comments">;        A value of 0.0 left justifies the label, 1.0 right justifies it, and 0.5 </span>
<span class="comments">;        centers it. This keyword is ignored if the `Box_Axes` keyword is set.</span>
<span class="comments">;     londelta: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the spacing in degrees between parallels of longitude in</span>
<span class="comments">;        the grid. If this keyword is not set, a suitable value is determined from the</span>
<span class="comments">;        current map projection.</span>
<span class="comments">;     lonlabel: in, optional, type=float</span>
<span class="comments">;        The latitude at which to place longitude labels. The default is the center </span>
<span class="comments">;        longitude on the map if using Map_Set, and a longitude line on the left of the</span>
<span class="comments">;        plot if using Map_Proj_Init. This keyword is ignored if the `Box_Axes` keyword is set. </span>
<span class="comments">;     lonnames: in, optional, type=string</span>
<span class="comments">;        Set this keyword equal to an array specifying the names to be used for the </span>
<span class="comments">;        longitude labels. By default, this array is automatically generated in units </span>
<span class="comments">;        of degrees. The LATNAMES array can be either type string or any single numeric </span>
<span class="comments">;        type, but should not be of mixed type. When LATNAMES is specified, the LATS </span>
<span class="comments">;        keyword must also be specified. The number of elements in the two arrays need </span>
<span class="comments">;        not be equal. If there are more elements in the LATNAMES array than in the LATS </span>
<span class="comments">;        array, the extra LATNAMES are ignored. If there are more elements in the LATS </span>
<span class="comments">;        array than in the LATNAMES array, labels in degrees will be automatically </span>
<span class="comments">;        provided for the missing longitude labels. The LATNAMES keyword can be also used </span>
<span class="comments">;        when the LATS keyword is set to a single value. It this case, the first label </span>
<span class="comments">;        supplied will be used at the specified longitude; subsequent names will be </span>
<span class="comments">;        placed at the next longitude line to the north, wrapping around the globe if </span>
<span class="comments">;        appropriate. Caution should be used when using LATNAMES in conjunction with a </span>
<span class="comments">;        single LATS value, since the number of visible longitude gridlines is dependent </span>
<span class="comments">;        on many factors. </span>
<span class="comments">;     lons: in, optional, type=float</span>
<span class="comments">;        Set this keyword equal to a one or more element vector of longitudes for which </span>
<span class="comments">;        lines will be drawn (and optionally labeled). If LATS is omitted, appropriate </span>
<span class="comments">;        longitudes will be generated based on the value of the (optional) LATDEL keyword. </span>
<span class="comments">;        If LATS is set to a single value, that longitude and a series of automatically </span>
<span class="comments">;        generated longitudes will be drawn (and optionally labeled). Automatically generated </span>
<span class="comments">;        longitudes have values that extend over the map. If LATS is a single value, that </span>
<span class="comments">;        value is taken to be the starting point for labelling (See the LABEL keyword). </span>
<span class="comments">;     map_structure: in, optional</span>
<span class="comments">;        This keyword is normally used to pass in a map structure of the type</span>
<span class="comments">;        created by Map_Proj_Init. In this version of the program, it can also</span>
<span class="comments">;        be used to pass in a cgMap object, from which the map structure and other</span>
<span class="comments">;        pertinent information for creating map grid lines can be obtained.</span>
<span class="comments">;     noclip: in, optional, type=boolean, default=0</span>
<span class="comments">;        Normally, output is clipped to the map projection boundaries. Set this keyword</span>
<span class="comments">;        to be able to draw outside the map boundaries.</span>
<span class="comments">;     no_grid: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you only want labels but not grid lines.</span>
<span class="comments">;     orientation: in, optional, type=float, default=0.0</span>
<span class="comments">;        Set this keyword equal to an angle in degrees from horizontal (in the clockwise </span>
<span class="comments">;        direction) to rotate the labels. This keyword is ignored if the `Box_Axes` keyword is set. </span>
<span class="comments">;     t3d: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword if you are labeling in 3D space.</span>
<span class="comments">;     thick: in, optional, type=integer, default=!P.Thick</span>
<span class="comments">;        Sets the thickness of the grid lines.</span>
<span class="comments">;     zvalue: in, optional, type=float</span>
<span class="comments">;        Draw the grid lines at this Z-value. Implies the use of `T3D`.</span>
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
PRO cgMap_Grid, $
   ADDCMD=addcmd, $
   BCOLOR=bcolor, $
   BOX_AXES=box_axes, $
   CGGRID=cggrid, $
   CHARSIZE=charsize, $
   CLIP_TEXT=clip_text, $
   COLOR=scolor, $
   FILL_HORIZON=fill_horizon, $
   FORMAT=format, $
   FUZZY=fuzzy, $
   GLINESTYLE=glinestyle, $
   GLINETHICK=glinethick, $
   HORIZON=horizon, $
   INCREMENT=increment, $
   LABEL=label, $
   LATALIGN=latalign, $
   LATDELTA = latdelta, $
   LATLABEL=latlab, $
   LATNAMES=latnames, $
   LATS=lats, $
   LCOLOR=lcolor, $
   LINESTYLE=linestyle, $
   LONALIGN=lonalign, $
   LONDELTA=londelta, $
   LONLABEL=lonlab, $
   LONNAMES=lonnames, $
   LONS=lons, $
   MAP_STRUCTURE=mapStruct, $
   NOCLIP=noclip, $
   NO_GRID=no_grid, $
   ORIENTATION=orientation, $
   T3D=t3d, $
   THICK=thick, $
   ZVALUE=zvalue
   

    Compile_Opt strictarr

    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(thisState) NE 0 THEN SetDecomposedState, thisState
        RETURN
    ENDIF

    <span class="comments">; Should this be added to a resizeable graphics window?</span>
    IF (Keyword_Set(addcmd)) && ((!D.Flags && 256) NE 0) THEN BEGIN
    
        cgWindow, 'cgMap_Grid', $
               BOX_AXES=box_axes, $
               CHARSIZE=charsize, $
               CGGRID=cgGrid, $
               CLIP_TEXT=clip_text, $
               COLOR=scolor, $
               FILL_HORIZON=fill_horizon, $
               FORMAT=format, $
               FUZZY=fuzzy, $
               GLINESTYLE=glinestyle, $
               GLINETHICK=glinethick, $
               HORIZON=horizon, $
               INCREMENT=increment, $
               LABEL=label, $
               LATALIGN=latalign, $
               LATDELTA = latdelta, $
               LATLABEL=latlab, $
               LATNAMES=latnames, $
               LATS=lats, $
               LINESTYLE=linestyle, $
               LONALIGN=lonalign, $
               LONDELTA=londelta, $
               LONLABEL=lonlab, $
               LONNAMES=lonnames, $
               LONS=lons, $
               MAP_STRUCTURE=mapStruct, $
               NOCLIP=noclip, $
               NO_GRID=no_grid, $
               ORIENTATION=orientation, $
               T3D=t3d, $
               THICK=thick, $
               WHOLE_MAP=obsolete_keyword, $
               ZVALUE=zvalue, $
               ADDCMD=1
            
         RETURN
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    SetDefaultValue, charsize, cgDefCharsize() * 0.75
    SetDefaultValue, bcolor, "opposite"
    noclip = Keyword_Set(noclip)
    
    <span class="comments">; I want to use the more natural LINESTYLE and THICK keywords to this routine.</span>
    IF (N_Elements(linestyle) EQ 0) && (N_Elements(glinestyle) NE 0) THEN BEGIN
      linestyle = glinestyle 
    ENDIF ELSE IF (N_Elements(linestyle) EQ 0) THEN linestyle = 1 <span class="comments">; dotted</span>
    IF (N_Elements(thick) EQ 0) && (N_Elements(gthick) NE 0) THEN BEGIN
      thick = gthick 
    ENDIF ELSE IF (N_Elements(thick) EQ 0) THEN thick = !P.Thick 

    <span class="comments">; Try to do this in decomposed color, if possible.</span>
    SetDecomposedState, 1, Current=thisState
    
    <span class="comments">; Need a color.</span>
    IF N_Elements(scolor) NE 0 THEN BEGIN
        CASE Size(scolor, /TNAME) OF
           'STRING':
           'LONG': 
           'BYTE': BEGIN
               IF N_Elements(scolor) NE 3 THEN scolor = StrTrim(Fix(scolor), 2)
               END
           ELSE: scolor = StrTrim(scolor,2)
        ENDCASE 
    ENDIF ELSE scolor = "opposite"
    IF N_Elements(scolor) EQ 0 THEN color = !P.Color ELSE  color = sColor
    IF (Size(scolor, /TNAME) EQ 'BYTE') AND (N_Elements(scolor) EQ 3) THEN color = cgColor(scolor)
    IF Size(color, /TYPE) EQ 3 THEN IF GetDecomposedState() EQ 0 THEN color = Byte(color)
    IF Size(color, /TYPE) LE 2 THEN color = StrTrim(Fix(color),2)
    
    <span class="comments">; Check for label color now. Depends on other colors and value of BOX_AXES.</span>
    IF N_Elements(lcolor) EQ 0 THEN lcolor = (Keyword_Set(box_axes)) ? bcolor : color

  <span class="comments">; Determine if you have a map structure or a map object.</span>
  IF N_Elements(mapStruct) EQ 0 THEN BEGIN
     hasMap = 0
     hasMapObj = 0
  ENDIF ELSE BEGIN
     IF Obj_Valid(mapStruct) THEN BEGIN
         hasMapObj = 1
         
         mapObj = mapStruct
         mapObj -> Draw, /NoGraphics
         thisMapStruct = mapObj -> GetMapStruct()
         
         <span class="comments">; This routine is here because Map_Grid does not select good line for small areas.</span>
         IF Keyword_Set(cgGrid) THEN BEGIN
             mapObj -> LatLonLabels, LATS=mlats, LATLAB=mlatlab, LATDELTA=latdelta, LATNAMES=mlatnames, $
                                     LONS=mlons, LONLAB=mlonlab, LONDELTA=londelta, LONNAMES=mlonnames
             IF N_Elements(lats) EQ 0 THEN BEGIN
                lats = mlats
                IF (N_Elements(latnames) EQ 0) THEN latnames = mlatnames
                IF N_Elements(latlab) EQ 0 THEN latlab = mlatlab
             ENDIF
             IF N_Elements(lons) EQ 0 THEN BEGIN
                lons = mlons
                IF (N_Elements(lonnames) EQ 0) THEN lonnames = mlonnames
                IF N_Elements(lonlab) EQ 0 THEN lonlab = mlonlab
             ENDIF
         ENDIF
         
      ENDIF ELSE BEGIN
          hasMapObj = 0
          thisMapStruct = mapStruct
      ENDELSE
      hasMap = 1
  ENDELSE
  
  if ((!x.type NE 3) && ~hasMap) THEN $
     message, 'cgMap_Grid---Current ploting device must have mapping coordinates'
  
  <span class="comments">; Put a grid on a previously established map projection.</span>
  <span class="comments">;</span>
  <span class="comments">; no grid? - in case someone wants just to put labels</span>
  no_grid = keyword_set(no_grid)
  
  <span class="comments">; if Label = n, then Labels are added every n gridlines</span>
  <span class="comments">;   If box_axes is set, and LABEL isn't explicitly specified, set label.</span>
  <span class="comments">;</span>
  nlabel = (N_ELEMENTS(label) gt 0) ? $
      FIX(ABS(label[0])) : KEYWORD_SET(box_axes)
  
  have_lons =  n_elements(lons) gt 0
  have_lats =  n_elements(lats) gt 0
  
  if n_elements(zvalue) eq 0 THEN zvalue = 0
  
  <span class="comments">; CLIP_TEXT (default value = 1) = 1 to clip text within the map area,</span>
  <span class="comments">; 0 to not clip text.</span>
  IF ~noclip THEN BEGIN
     noclip = (N_ELEMENTS(clip_text) gt 0) ? ~KEYWORD_SET(clip_text) : 0
  ENDIF
  
  <span class="comments">;   Append the graphics keywords:</span>
  if n_elements(t3d) then map_struct_append, extra,'T3D',t3d
  
  
  <span class="comments">;Orientation is reversed & conflicts w/box_axes</span>
  if n_elements(orientation) and (keyword_set(box_axes) eq 0) then $
    map_struct_append, extra,'ORIENTATION', -1 * orientation
  
  
  <span class="comments">;</span>
  <span class="comments">; The gridlines can be specified by</span>
  <span class="comments">;</span>
  <span class="comments">;  1) an array of lats and/or lons</span>
  <span class="comments">;  2) a single lats or lons which is taken to be the center</span>
  <span class="comments">;     or 'for sure' lat or lon with gridlines every latdelta or londelta from it</span>
  <span class="comments">;  3) automatically calculated if lats or lons are not specified.</span>
  <span class="comments">;</span>
  <span class="comments">;</span>
  <span class="comments">; Require that LATS be specified when LATNAMES is ALSO SPECIFIED</span>
  <span class="comments">;</span>
  if (n_elements(latnames) gt 0) and n_elements(lats) le 1 then $
    message,'cgMap_Grid---The LATNAMES keyword MUST be used in conjuction '+$
    'with the LATS keyword.'
  if n_elements(lonnames) gt 0 and have_lons eq 0 then $
    message,'cgMap_Grid---The LONNAMES keyword MUST be used in conjuction '+$
    'with the LONS keyword.'
  
  <span class="comments">; Get lat/lon ranges from !MAP. Did MAP_SET specify 4 element limit?</span>
  map = hasMap ? thisMapStruct : !MAP
  if n_elements(lats) gt 1 then latmin = min(lats, max=latmax) $
  else if map.ll_box[0] ne map.ll_box[2] then begin
      latmin = map.ll_box[0]
      latmax = map.ll_box[2]
  endif else begin
      latmin = -90
      latmax = 90
  endelse
  
  if have_lons then begin        <span class="comments">;Lons directly specified?</span>
      lonmin = lons[0]
      lonmax = lons[n_elements(lons)-1]
  endif else if (map.ll_box[1] ne map.ll_box[3]) and $ <span class="comments">;Lon limit specified?</span>
    (latmax lt 90.) and (latmin gt -90.) then begin <span class="comments">; and poles not included</span>
      lonmin = map.ll_box[1]
      lonmax = map.ll_box[3] <span class="comments">;Copy limits</span>
  endif else begin                <span class="comments">;If not, use entire globe</span>
      lonmin = -180
      lonmax = 180
  endelse
  
  IF lonmax le lonmin THEN lonmax = lonmax + 360.
  
            <span class="comments">;Default grid spacings...</span>
  IF n_elements(latdelta) eq 0 THEN begin
      latdelta = cgMap_Grid_incr(latmax - latmin)
      latd = 1
  endif else latd = latdelta
  
  IF n_elements(londelta) eq 0 THEN begin
      londelta = cgMap_Grid_incr(lonmax - lonmin)
      lond = 1
  endif else lond = londelta
  
  <span class="comments">; IF the deltas are &lt; 1,</span>
  <span class="comments">; do not convert the limits into integers</span>
  IF abs(latmax - latmin) gt 5. and latd ge 1 THEN BEGIN <span class="comments">;Make range integers</span>
      latmin = float(floor(latmin))
      latmax = ceil(latmax)
  ENDIF

  IF abs(lonmax - lonmin) gt 5 and lond ge 1 THEN BEGIN <span class="comments">;Integerize long spans</span>
      lonmin = float(floor(lonmin))
      lonmax = ceil(lonmax)
  ENDIF
  
  <span class="comments">; Where we label things...</span>
  IF N_Elements(Latlab) eq 0 THEN Latlab = (lonmin + lonmax)/2
  IF N_ELements(LonLab) eq 0 THEN LonLab = (latmin +latmax)/2

  IF n_elements(latalign) eq 0 THEN latalign = .5   <span class="comments">;Text alignment of lat labels</span>
  IF n_elements(lonalign) eq 0 THEN lonalign = .5 <span class="comments">;Text alignment of lon labels</span>
  
  <span class="comments">; Is this a cylindrical proj?</span>
  is_cyl = 0
  if (hasMap) then begin
      IF Obj_Valid(mapObj) THEN is_cyl = mapObj -> Is_Cylindrical()
  endif else begin
      map_proj_info, iproj, CYLINDRICAL=is_cyl, /CURRENT
  endelse
  
  if keyword_set(increment) then step = increment $
  else step = 4 &lt<span class="comments">; (latmax - latmin)/10.</span>
  
  len = long(float((latmax-latmin)) / float(step) + 1.0)
  
  <span class="comments">; Clip to avoid roundoff errors which can cause the latitude to exceed</span>
  <span class="comments">; 90 degs by a very small amount.</span>
  lati = (float(latmax-latmin) / (len-1.)) * findgen(len) + latmin > (-90) &lt<span class="comments">; 90</span>
  
  <span class="comments">; This fudge avoids curved meridians at the poles because of the split planes</span>
  if is_cyl and map.p0lat eq 0 then begin
      del = 2.0e-2
      if lati[0] eq -90 then lati[0] = del - 90.
      if lati[len-1] eq 90 then lati[len-1] = 90. - del
  endif
  
  
  <span class="comments">;Compute longit distance between points for latitude lines.</span>
  IF lonmin EQ lonmax THEN lonmax = lonmin + 360.
  step = 4 &lt<span class="comments">; (lonmax - lonmin)/10. ;At most 4 degrees</span>
  len = (lonmax-lonmin)/step + 1
  loni = findgen(len) * step + lonmin
  IF (loni[len-1] NE lonmax) THEN loni = [loni, lonmax]
  
  
  <span class="comments">;</span>
  <span class="comments">; Determine the number of lons and the lon array</span>
  <span class="comments">;</span>
  if n_elements(lons) eq 0 then begin
      n_lons = 1+fix((lonmax-lonmin) / londelta)
      longitudes = lonmin - (lonmin mod londelta) + findgen(n_lons) * londelta
  endif else if n_elements(lons) eq 1 then begin
      i0 = ceil((lonmin - lons[0]) / float(londelta)) <span class="comments">;First tick</span>
      i1 = floor((lonmax - lons[0]) / float(londelta)) <span class="comments">;Last tick</span>
      n_lons = i1 - i0 + 1 > 1
      longitudes = (findgen(n_lons) + i0) * londelta + lons[0]
  endif else begin
      n_lons=n_elements(lons)
      longitudes=lons
  endelse
  
  <span class="comments">;</span>
  <span class="comments">; Determine the number of lats and the lat array</span>
  <span class="comments">;</span>
  if n_elements(lats) eq 0 then begin
      lat0 = latmin - (latmin mod float(latdelta)) <span class="comments">;1st lat for grid</span>
      n_lats = 1 + fix((latmax-lat0)/float(latdelta))
      latitudes = lat0 + findgen(n_lats)*latdelta
  endif else if n_elements(lats) eq 1 then begin
      i0 = ceil((latmin - lats[0]) / float(latdelta)) <span class="comments">;First tick</span>
      i1 = floor((latmax - lats[0]) / float(latdelta)) <span class="comments">;Last tick</span>
      n_lats = i1 - i0 + 1 > 1
      latitudes = (findgen(n_lats) + i0) * latdelta + lats[0]
  endif else begin
      n_lats=n_elements(lats)
      latitudes=lats
  endelse
  
  <span class="comments">;</span>
  <span class="comments">; Build the Latitude/Longitude Label Flags</span>
  <span class="comments">;</span>
  lon_label = bytarr(n_lons)
  lat_label = bytarr(n_lats)
  if nlabel ne 0 then begin
      if n_elements(lons) eq 1 then begin <span class="comments">; Ensure center is set and then go out</span>
          index=where(longitudes eq lons[0])
          for i=(index[0] > 0) mod nlabel, n_lons-1, nlabel do lon_label[i] = 1
      endif else begin
          for i=0, n_lons-1, nlabel do lon_label[i] = 1
      endelse
  
      if n_elements(lats) eq 1 then begin <span class="comments">; Make sure the center one is set</span>
                                  <span class="comments">; and go out from there</span>
          index=where(latitudes eq lats[0], count)
          for i=(index[0] > 0) mod nlabel, n_lats-1, nlabel do lat_label[i] = 1
      endif else begin            <span class="comments">; Start with latmin and label each nlabel point</span>
          for i=0, n_lats-1, nlabel do lat_label[i] = 1
      endelse
  
  endif
  
  <span class="comments">;</span>
  <span class="comments">;   Dont repeat 180 labelling if the projection is cylindrical or</span>
  <span class="comments">;   polar and both 180 and -180 are present. This can be defeated by using</span>
  <span class="comments">;   LONS=-180</span>
  <span class="comments">;</span>
  if is_cyl or (abs(map.p0lat) eq 90) then begin
      id_180 = where(longitudes eq 180,count)
      id_m180 = where(longitudes eq -180,mcount)
      if count gt 0 and mcount gt 0 then begin
          if n_elements(lons) eq 1 then begin
              if lons[0] eq -180 then lon_label[id_180]=0
          endif else lon_label[id_m180]=0
      endif
  endif
  
  n = n_lons > n_lats             <span class="comments">;</span>
  latlontxt = strarr(n, 2)
  
  if keyword_set(box_axes) then begin <span class="comments">;Draw a Box legend?</span>
      box_thick = box_axes * 0.1  <span class="comments">;From mm to Thickness in cm</span>
      dc = !d.y_ch_size           <span class="comments">;Char height to draw</span>
      if n_elements(charsize) ne 0 then dc = dc * charsize
      IF hasMapObj THEN mapObj -> Draw, /NoGraphics, Erase=0
      xw = !x.window * !d.x_size  <span class="comments">;Window coords in x & y</span>
      yw = !y.window * !d.y_size
  <span class="comments">; xww and yww = corners of the uv_range that is mappable.  If NOBORDER</span>
  <span class="comments">; was set for MAP_SET, this is the same as the window coords (xw,yw),</span>
  <span class="comments">; otherwise, this rectangle is smaller than the window rectangle.</span>
  <span class="comments">; Fudge factor for window to ensure that the edges are mappable.</span>
      del = [1,-1]* 0.01
      IF hasMapObj THEN BEGIN
        mapObj -> GetProperty, XRANGE=xrange, YRANGE=yrange
        xww = (xrange * !x.s[1] + !x.s[0]) * !d.x_size + del
        yww = (yrange * !y.s[1] + !y.s[0]) * !d.y_size + del
      ENDIF ELSE BEGIN
        xww = (map.uv_box[[0,2]] * !x.s[1] + !x.s[0]) * !d.x_size + del
        yww = (map.uv_box[[1,3]] * !y.s[1] + !y.s[0]) * !d.y_size + del
      ENDELSE
      bdel = box_thick * !d.y_px_cm <span class="comments">;Thickness of box in device units</span>
  
      xp = xw[0] - [0,bdel, bdel,0] <span class="comments">;X  & Y polygon coords for outer box</span>
      yp = yw[0] - [0,0,bdel,bdel]
                                  <span class="comments">;Draw the outline of the box</span>
      cgPlotS, xw[[0,1,1,0,0]], yw[[0,0,1,1,0]], /DEVICE, $
          COLOR=bcolor, LINESTYLE=0, THICK=thick
      cgPlotS, xw[[0,1,1,0,0]]+[-bdel, bdel, bdel, -bdel, -bdel], $
        yw[[0,0,1,1,0]]+[-bdel, -bdel, bdel, bdel, -bdel], /DEVICE, $
          COLOR=bcolor, LINESTYLE=0, THICK=thick
  
      ychar = [yw[0]-bdel-dc, yw[1]+bdel+dc/4.]
      xchar = [xw[0] - bdel - dc/4., xw[1]+bdel+dc/4.]
      boxpos = replicate(!values.f_nan, n, 2,2)
  
  <span class="comments">;Device coordinates for box annotations. Go in to avoid edges of map &</span>
  <span class="comments">;border which are fraught with singularities.  Also to avoid effects</span>
  <span class="comments">;of MAP_SET,/NOBORDER.  For box axes to be annotated, all the edges of the</span>
  <span class="comments">;map rectangle must be mappable.</span>
  <span class="comments">;</span>
  endif else box_thick = 0
  
  <span class="comments">;  Do the horizon if specified.</span>
  hcolor = (Size(color, /TNAME) EQ 'STRING') ? cgColor(color) : color
  if keyword_set(horizon) then map_horizon, COLOR=hcolor, _EXTRA=e
  if keyword_set(fill_horizon) then map_horizon, COLOR=hcolor, _EXTRA=e, /FILL
  <span class="comments">;</span>
  <span class="comments">;   ****************** Draw/Label the meridians ******************</span>
  <span class="comments">;</span>
  FOR i=0,n_lons-1 DO BEGIN
      lon=longitudes[i]
      lon2 = (lon lt -180) ? (lon + 360) : $
          ((lon gt 180) ? (lon - 360) : lon)
  
  <span class="comments">; This block of code draws longitude lines that are at the center + or</span>
  <span class="comments">; - 180 degrees, at center + or - (180-eps) to ensure that the grid</span>
  <span class="comments">;   appears on the correct side.  Its really not necessary if people</span>
  <span class="comments">;   would use the /HORIZON keyword, but they don't.</span>
  
      if is_cyl then begin
          del = lon - map.p0lon
          while del gt 180 do del -= 360.
          while del lt -180 do del += 360.
          if abs(del) eq 180 then $
              lon -= 1.0e-5 * ((del ge 0) ? 1 : -1) <span class="comments">;fudge it (sign(1.0e-5, del))</span>
      endif
  
      IF (~no_grid) THEN begin
          if (hasMap) then begin
              <span class="comments">; Make sure to clear out variable in case all points are clipped.</span>
              polylines = -1
  <span class="comments">;            uv = MAP_PROJ_FORWARD(REPLICATE(lon, N_ELEMENTS(lati)), lati, $</span>
  <span class="comments">;                MAP_STRUCTURE=thisMapStruct, POLYLINES=polylines)</span>
  <span class="comments">;;; DWF correction next two commands.</span>
              uv = MAP_PROJ_FORWARD(REPLICATE(lon, N_ELEMENTS(lati)), lati, $
                  MAP_STRUCTURE=thisMapStruct)
              polylines = [N_Elements(lati), Indgen(N_Elements(lati))]
              index = 0L
              npoly = N_ELEMENTS(polylines)
              <span class="comments">; Loop thru our polylines connectivity array.</span>
              while (index lt npoly) do begin
                  nline = polylines[index]
                  if (nline eq -1) then $
                      break
                  if (nline gt 0) then begin
                      indices = polylines[index + 1 : index + nline]
                      cgPlotS, REFORM(uv[0,indices]), REFORM(uv[1,indices]), $
                          zvalue, $
                          NOCLIP=noclip, $
                          COLOR=color, LINESTYLE=linestyle, THICK=thick, $
                          _EXTRA=extra
                  endif
                  index += nline + 1
              endwhile
          endif else begin
              cgPlotS, lon, lati, zvalue, NOCLIP=noclip, $
                   COLOR=color, LINESTYLE=linestyle, THICK=thick, _EXTRA=extra
          endelse
      endif
  
      IF N_Elements(format) EQ 0 THEN BEGIN
          fmt = (lon2 ne long(lon2)) ? '(f7.2)' : '(i4)' 
      ENDIF ELSE BEGIN 
          IF format EQ "" THEN fmt = (lon2 ne long(lon2)) ? '(f7.2)' : '(i4)' ELSE fmt = format
      ENDELSE
  
      IF lon_label[i] THEN BEGIN
  
          IF i lt n_elements(lonnames) then begin <span class="comments">;User specified label?</span>
              IF (reverse(size(lonnames[i])))[1] eq 7 then $ <span class="comments">;String?</span>
                lonname=lonnames[i] else $
                lonname=strtrim(string(lonnames[i], FORMAT=fmt),2)
          endif else $
              lonname=strtrim(string(lon2, format=fmt),2)
  
          latlontxt[i,0] = lonname
          if (box_thick eq 0) then begin
              xy = 0
              if (hasMap) then begin
                  <span class="comments">; We need to convert from latlon to UV ourself.</span>
                  uv = MAP_PROJ_FORWARD(lon, LonLab, MAP_STRUCTURE=thisMapStruct)
                  if (FINITE(uv[0]) && FINITE(uv[1])) then begin
                      xy = uv[0:1]
                      gctp = 1
                  endif
              endif else begin
                  if (noclip eq 1) || map_point_valid(lon, LonLab) then $
                      xy = [lon, LonLab]
              endelse

              IF N_Elements(xy) NE 0 THEN xy = cgMap_Grid_check_range(xy, GCTP=gctp, FUZZY=fuzzy)
              IF N_Elements(xy) EQ 2 THEN BEGIN
                 cgText, xy[0], xy[1], lonname, ALIGNMENT=lonalign, $
                     NOCLIP=1, Z=zvalue, COLOR=lcolor, CHARSIZE=charsize, _EXTRA=extra
                 Undefine, xy
              ENDIF
          endif
  
      ENDIF
  
      if box_thick ne 0 then begin
          dy = (yw[1] - yw[0]) * 0.01 <span class="comments">;1% of the height</span>
          for j=0,1 do begin      <span class="comments">;Save longitude crossings, try for edge...</span>
              k = 0
              <span class="comments">; Try to find longitude crossings.  If it doesn't cross exactly</span>
              <span class="comments">; at the edge, try going in until it crosses and is valid.</span>
              while ~finite(boxpos[i,j,0]) && abs(k) lt 3 do begin
                  boxpos[i, j, 0] = cgMap_Grid_solve( $
                      [xww[0], yw[j]+k*dy], $
                      [xww[1], yw[j]+k*dy], 0, lon, $
                      MAP_STRUCTURE=thisMapStruct)
                  k = k + (j ? -1 : 1)
              endwhile
          endfor
      endif
  ENDFOR

  <span class="comments">;</span>
  <span class="comments">; Draw/Label the parallels of latitude  ******************</span>
  <span class="comments">;</span>
  
  FOR i=0,n_lats-1 DO BEGIN
  
      lat=latitudes[i]
      IF N_Elements(format) EQ 0 THEN BEGIN
          fmt = (lat ne long(lat)) ? '(f7.2)' : '(i4)' 
      ENDIF ELSE BEGIN 
          IF format EQ "" THEN fmt = (lat ne long(lat)) ? '(f7.2)' : '(i4)'  ELSE fmt = format
      ENDELSE
      IF lat_label[i] THEN BEGIN
          IF i lt n_elements(latnames) then begin <span class="comments">;User specified latname?</span>
              IF (reverse(size(latnames[i])))[1] eq 7 then $
                latname=latnames[i] else $
                latname=strtrim(string(latnames[i],format=fmt),2)
          endif else begin
              latname=strtrim(string(lat, format=fmt),2)
          endelse
          latlontxt[i, 1] = latname
          if (box_thick eq 0) then begin
              xy = 0
              if (hasMap) then begin
                  <span class="comments">; We need to convert from latlon to UV ourself.</span>
                  uv = MAP_PROJ_FORWARD(latlab, lat, MAP_STRUCTURE=thisMapStruct)
                  if (FINITE(uv[0]) && FINITE(uv[1])) then begin
                      xy = uv[0:1]
                      gctp = 1
                  endif
              endif else begin
                  if (noclip eq 1) || map_point_valid(latlab, lat) then $
                      xy = [latlab, lat]
              endelse
              IF N_Elements(xy) NE 0 THEN xy = cgMap_Grid_check_range(xy, GCTP=gctp, FUZZY=fuzzy)
              IF N_Elements(xy) EQ 2 THEN BEGIN
                 cgText, xy[0], xy[1], latname, CHARSIZE=charsize, $
                     alignment=latalign, NOCLIP=1, COLOR=lcolor, Z=zvalue, _EXTRA=extra
                 Undefine, xy
              ENDIF
          endif
      ENDIF
  
      IF Abs(lat) EQ 90 THEN BEGIN
        oldlat = lat
        lat = -89.975 > lat &lt<span class="comments">; 89.975</span>
      ENDIF
      if (~no_grid && (ABS(lat) ne 90)) then begin
          if (hasMap) then begin
              <span class="comments">; Make sure to clear out variable in case all points are clipped.</span>
              polylines = -1
              IF (hasMapObj) THEN BEGIN
              
                     <span class="comments">; Added this because if there is not a point in the longitude vector</span>
                     <span class="comments">; that is inside our actual data range, then the line can be drawn</span>
                     <span class="comments">; at the wrong place. I don't really understand why. But this is a </span>
                     <span class="comments">; check to be sure there is a point inside the data range.</span>
                     mapObj -> GetProperty, XRANGE=xrange, YRANGE=yrange
                     index = Value_Locate(xrange, loni)
                     
                     <span class="comments">; If there is a zero in index vector than there is a point inside range</span>
                     <span class="comments">; and we continue normally. Otherwise, we try to construct a vector that</span>
                     <span class="comments">; has a point in the data range.</span>
                     void = Where(index EQ 0, count) 
                     IF count EQ 0 THEN BEGIN <span class="comments">; No point inside range, so construct one.</span>
                         thisMapStructure = mapObj -> GetMapStruct()
                         ll = Map_Proj_Inverse(xrange, yrange, MAP_STRUCTURE=thisMapStructure)
                         lonii = Reform(ll[0,*])
                         lonii = cgScaleVector(Findgen(N_Elements(loni)), lonii[0], lonii[1])
                         uv = MAP_PROJ_FORWARD(lonii, REPLICATE(lat, N_ELEMENTS(lonii)), $
                              MAP_STRUCTURE=thisMapStruct, POLYLINES=polylines)
<span class="comments">;                          uv = MAP_PROJ_FORWARD(lonii, REPLICATE(lat, N_ELEMENTS(lonii)), $</span>
<span class="comments">;                              MAP_STRUCTURE=thisMapStruct) ;;; Screws up near the poles, I think.</span>
<span class="comments">;                          polylines = [N_Elements(loni), Indgen(N_Elements(loni))]</span>
                         loni = lonii
                     ENDIF ELSE BEGIN
                        uv = MAP_PROJ_FORWARD(loni, REPLICATE(lat, N_ELEMENTS(loni)), $
                             MAP_STRUCTURE=thisMapStruct, POLYLINES=polylines)  
<span class="comments">;                            uv = MAP_PROJ_FORWARD(loni, REPLICATE(lat, N_ELEMENTS(loni)), $</span>
<span class="comments">;                               MAP_STRUCTURE=thisMapStruct) ;;; Screws up near the poles, I think.</span>
<span class="comments">;                            polylines = [N_Elements(loni), Indgen(N_Elements(loni))]                   </span>
                     ENDELSE
              ENDIF ELSE BEGIN
                  uv = MAP_PROJ_FORWARD(loni, REPLICATE(lat, N_ELEMENTS(loni)), $
                       MAP_STRUCTURE=thisMapStruct, POLYLINES=polylines)
                   <span class="comments">;   uv = MAP_PROJ_FORWARD(loni, REPLICATE(lat, N_ELEMENTS(lonii)), $</span>
                   <span class="comments">;      MAP_STRUCTURE=thisMapStruct) ;;; Screws up near the poles, I think.</span>
                   <span class="comments">;  polylines = [N_Elements(loni), Indgen(N_Elements(loni))]</span>
              ENDELSE

              index = 0L
              npoly = N_ELEMENTS(polylines)
              <span class="comments">; Loop thru our polylines connectivity array.</span>
              while (index lt npoly) do begin
                  nline = polylines[index]
                  if (nline eq -1) then $
                      break
                  if (nline gt 0) then begin
                      indices = polylines[index + 1 : index + nline]
                      cgPLOTS, REFORM(uv[0,indices]), REFORM(uv[1,indices]), $
                          zvalue, $
                          NOCLIP=noclip, $
                          COLOR=color, LINESTYLE=linestyle, THICK=thick, $
                          _EXTRA=extra
                  endif
                  index += nline + 1
              endwhile
          endif else $
              cgPLOTS, loni, lat, zvalue, NOCLIP=noclip, $
                  COLOR=color, LINESTYLE=linestyle, THICK=thick, _EXTRA=extra
      endif
  
      if box_thick ne 0 then begin
          for j=0,1 do begin <span class="comments">;Save latitude crossings</span>
              <span class="comments">; Start at edge and try for an intersection.</span>
              <span class="comments">; If that doesn't work, go in some.</span>
              k = 0
              dx = (xw[1] - xw[0]) * 0.01
              while ~finite(boxpos[i,j,1]) && abs(k) lt 3 do begin
                  boxpos[i, j, 1] = cgMap_Grid_Solve( $
                      [xw[j]+dx*k, yww[0]], $
                      [xw[j]+dx*k, yww[1]], 1, lat, $
                      MAP_STRUCTURE=thisMapStruct)
                  k = k + (j ? -1 : 1)
              endwhile
          endfor
      endif
  
  endfor
  
  
  <span class="comments">; ******************************** Do the box axes **************************</span>
  if box_thick ne 0 then begin
      for iaxis=0,1 do for j=0,1 do begin <span class="comments">; iaxis = 0 for lon axis, 1 for lat axis</span>
          v = boxpos[*,j,iaxis]       <span class="comments">;Values along axes</span>
          good = where(finite(v), count) <span class="comments">;Ignore bad values</span>
          if (count eq 0) then $  <span class="comments">;Anything there?</span>
              continue
          dy = iaxis eq 1
          v = v[good]             <span class="comments">;Remove unmappable elements</span>
          subs = sort(v)          <span class="comments">;Sort the axis crossings</span>
          v = v[subs]             <span class="comments">;Sorted Y values</span>
          vtext = (latlontxt[good,iaxis])[subs]
          v0 = ([xw[0], yw[0]])[iaxis] <span class="comments">;Starting value on axis</span>
          xp0 = xp + j * (xw[1]-xw[0] + bdel) <span class="comments">;Polygon X coords</span>
          yp0 = yp + j * (yw[1]-yw[0] + bdel) <span class="comments">;Y coords</span>
          xychar = [xchar[j], ychar[j]] <span class="comments">;Char position</span>
  
          for i=0, count-1 do begin <span class="comments">;Draw each item</span>
              z = v[i]            <span class="comments">;Axis crossing value</span>
              if iaxis eq 0 then begin
                  xp0 = (i eq (count-1) && (i and 1) && ~vtext[i]) ? $
                      [v0, xw[1], xw[1], v0] : [v0, z, z, v0]
              endif else yp0 = [v0, v0, z, z]
              if (i and 1) then $
                  cgColorFill, xp0, yp0, /DEVICE, COLOR=bcolor
              xychar[iaxis] = z
              if strlen(vtext[i]) gt 0 then begin
                  cgText, xychar[0], xychar[1], vtext[i], $
                      ORIENTATION=dy * (90-180*j), CHARSIZE=charsize, $
                      ALIGN=0.5, CLIP=0, Z=zvalue, COLOR=lcolor, /DEVICE, _EXTRA=extra
              endif
              v0 = z
          endfor
                                  <span class="comments">;Fill to the end of the axis</span>
          if i and 1 then begin
              if iaxis eq 0 then xp0 = [v0, xw[1], xw[1], v0] $
              else yp0 = [v0, v0, yw[1], yw[1]]
              cgColorFill, xp0, yp0, /DEVICE, COLOR=bcolor
          endif
      endfor
  endif   <span class="comments">; box_thick</span>

    <span class="comments">; Restore color mode</span>
    SetDecomposedState, thisState
    
end
</code>
    </div>
  </body>
</html>