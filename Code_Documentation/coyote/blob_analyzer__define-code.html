<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:55:54 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>blob_analyzer__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="blob_analyzer__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       BLOB_ANALYZER__DEFINE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">; </span>
<span class="comments">;       The purpose of this routine is to create a system for analyzing</span>
<span class="comments">;       regions of interest (ROIs) or (more commonly) "blobs" inside images.</span>
<span class="comments">;       In particular, given a suitable image (this will require judgement on</span>
<span class="comments">;       your part), the program will automatically select "blobs" or connected</span>
<span class="comments">;       regions in the image and make it possible for you to analyze these</span>
<span class="comments">;       blobs. An example program is provided to show you one way the program</span>
<span class="comments">;       can be used.</span>
<span class="comments">;       </span>
<span class="comments">;       The code is a wrapper, essentially, for LABEL_REGION and HISTOGRAM, with</span>
<span class="comments">;       a couple of my other image processing routines (FIND_BOUNDARY and FIT_ELLIPSE)</span>
<span class="comments">;       used in a supporting role.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">; </span>
<span class="comments">;       FANNING SOFTWARE CONSULTING</span>
<span class="comments">;       David Fanning, Ph.D.</span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">; </span>
<span class="comments">;       Analysis, Image Processing</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">; </span>
<span class="comments">;       analyzer = Obj_New("BLOB_ANALYZER", image)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">; </span>
<span class="comments">;   image:           A two-dimensional image array. To make this program memory efficient,</span>
<span class="comments">;                    a copy of the image is *not* stored in the object. You will be responsible</span>
<span class="comments">;                    for image operations outside this program.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ALL_NEIGHBORS:    Set this keyword to look at all eight neighbors when searching</span>
<span class="comments">;                     for connectivity. The default is to look for four neighbors on</span>
<span class="comments">;                     each side of the starting pixel. Passed directly to LABEL_REGION.</span>
<span class="comments">;                     </span>
<span class="comments">;   MASK:             A two-dimensional array, the same size as image, that identifies the</span>
<span class="comments">;                     foreground and background pixels in the image. Applying the mask</span>
<span class="comments">;                     should result in a bi-level image of 0s and 1s, where 1 identifies the </span>
<span class="comments">;                     blobs you wish to analyze. If a mask is not provided, the mask is created</span>
<span class="comments">;                     like this:</span>
<span class="comments">;                     </span>
<span class="comments">;                     mask = image > 0</span>
<span class="comments">;</span>
<span class="comments">;   SCALE:            A one- or two-dimensional given the pixel scaling parameters. By default [1.0, 1.0].</span>
<span class="comments">;                     If passed a scalar, the scale parameter is applied to both the X and Y directions of</span>
<span class="comments">;                     each pixel. Statistical output is reported with scaling unless the NOSCALE keyword</span>
<span class="comments">;                     is set. Scaling also effects the data that is output from the various methods.</span>
<span class="comments">;</span>
<span class="comments">; OBJECT METHODS:</span>
<span class="comments">; </span>
<span class="comments">;   The following methods are provided. Please see the documentation header for each method for</span>
<span class="comments">;   information on arguments and keywords that can be used with the method.</span>
<span class="comments">;</span>
<span class="comments">;   FitEllipse:       This method fits an ellipse to the blob. It returns information about the fitted</span>
<span class="comments">;                     ellipse, including the points that all the ellipse to be drawn.</span>
<span class="comments">;                     </span>
<span class="comments">;   GetIndices:       This method returns the indices for a particular blob in the image.</span>
<span class="comments">;   </span>
<span class="comments">;   GetStats:         This method returns a structure containing statistics for a particular blob in the image.</span>
<span class="comments">;                     The structure is defined as follows:</span>
<span class="comments">;                     </span>
<span class="comments">;                     stats = {INDEX: indexNumber, $                  ; The index number of this blob.</span>
<span class="comments">;                              COUNT: N_Elements(indices), $          ; The number of indices in this blob.</span>
<span class="comments">;                              PERIMETER_PTS: boundaryPts, $          ; A [2,n] array of points that describe the blob perimeter.</span>
<span class="comments">;                              PIXEL_AREA: pixelArea, $               ; The area as calculated by pixels in the blob.</span>
<span class="comments">;                              PERIMETER_AREA: perimeterArea, $       ; The area as calculated by the blob perimeter. (Smaller than pixel area.)</span>
<span class="comments">;                              CENTER: centroid[0:1], $               ; The [x,y] array that identifies the centroid of the blob.</span>
<span class="comments">;                              PERIMETER_LENGTH: perimeter_length, $  ; The perimenter length (scaled unless the NOSCALE keyword is set).</span>
<span class="comments">;                              SCALE: scale, $                        ; The [xscale, yscale] array used in scaling.</span>
<span class="comments">;                              MINCOL: Min(xyindices[0,*]), $         ; The minimum column index in the blob.</span>
<span class="comments">;                              MAXCOL: Max(xyindices[0,*]), $         ; The maximum column index in the blob.</span>
<span class="comments">;                              MINROW: Min(xyindices[1,*]), $         ; The minimum row index in the blob.</span>
<span class="comments">;                              MAXROW: Max(xyindices[1,*])}           ; The maximum row index in the blob.</span>
<span class="comments">;   </span>
<span class="comments">;   NumberOfBlobs:     The number of blobs identified in the image.</span>
<span class="comments">;   </span>
<span class="comments">;   ReportStats:       This methods reports statistics on every identified blob in the image. The </span>
<span class="comments">;                      report can be sent to the display (the default) or to a file. The format for</span>
<span class="comments">;                      the report works for most images, but you may have to change the format or override</span>
<span class="comments">;                      this method for your particular image. The reported statistics are basically the</span>
<span class="comments">;                      output of the GetStats and FitEllipse methods.</span>
<span class="comments">;</span>
<span class="comments">;    Here is an example of statistical output from the example program below.</span>
<span class="comments">;    </span>
<span class="comments">;  INDEX   NUM_PIXELS   CENTER_X    CENTER_Y   PIXEL_AREA   PERIMETER_AREA   PERIMETER_LENGTH  MAJOR_AXIS   MINOR_AXIS    ANGLE</span>
<span class="comments">;     0        426        107.89       9.78       106.50          98.00            37.56          12.15        11.29       -8.05</span>
<span class="comments">;     1        580        151.97      10.22       145.00         134.25            49.21          17.49        11.77       -0.99</span>
<span class="comments">;     2        812        266.29      15.36       203.00         190.75            52.56          17.88        14.65     -107.48</span>
<span class="comments">;     3       1438        204.53      43.29       359.50         344.13            70.23          21.68        21.12      -76.47</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">; </span>
<span class="comments">;       Requires programs from the Coyote Library. At the very least, those below are required.</span>
<span class="comments">;       It is *highly* recommended that you install the entire library. FIT_ELLIPSE has been</span>
<span class="comments">;       changed specifically for this release, so by sure you get a copy of that with this</span>
<span class="comments">;       source code.</span>
<span class="comments">;       </span>
<span class="comments">;       http://www.idlcoyote.com/programs/coyoteprograms.zip</span>
<span class="comments">;       </span>
<span class="comments">;       ERROR_MESSAGE     http://www.idlcoyote.com/programs/error_message.pro</span>
<span class="comments">;       FIND_BOUNDARY     http://www.idlcoyote.com/programs/find_boundary.pro</span>
<span class="comments">;       FIT_ELLIPSE       http://www.idlcoyote.com/programs/fit_ellipse.pro</span>
<span class="comments">;       </span>
<span class="comments">;       The program currently works only with 2D bi-level images.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">; </span>
<span class="comments">;       To run an example program. Compile the file and type "example" at the IDL command line.</span>
<span class="comments">;       </span>
<span class="comments">;       IDL> .compile blob_analyzer__define</span>
<span class="comments">;       IDL> example</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; </span>
<span class="comments">;       Written by David W. Fanning, Fanning Software Consulting, 17 August 2008.</span>
<span class="comments">;       Ideas taken from discussion with Ben Tupper and Ben's program HBB_ANALYZER.</span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>

<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::FitEllipse</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function fits an ellipse to a particular blob and returns information</span>
<span class="comments">;   about the fit to the user.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   ellipsePts = theBlobs -> FitEllipse(indexNumber)</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;     ellipsePts:   A [2,n] array containing the XY points of the fitted ellipse. The values</span>
<span class="comments">;                   are in scaled units unless the NOSCALE keyword is set, in which case the</span>
<span class="comments">;                   values are in DEVICE units.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;    indexNumber:   The index number of the blob. Indices start at 0 and go to n-1.</span>
<span class="comments">;  </span>
<span class="comments">; INPUT KEYWORDS:  </span>
<span class="comments">; </span>
<span class="comments">;    NOSCALE:       Set this keyword if you would prefer that lengths and positions NOT be</span>
<span class="comments">;                   scaled in the output of this function. If not scaled, results are in pixel</span>
<span class="comments">;                   or device coordinates. The default is to scale all output.</span>
<span class="comments">;                   </span>
<span class="comments">;    NPOINTS:       The number of points in the ellipse. By default, 120.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDRS:</span>
<span class="comments">;</span>
<span class="comments">;    AXES:          A two-element array containing the lengths of the major and minor axes,</span>
<span class="comments">;                   respectively. Lenghts are scaled unless the NOSCALE keyword is set.</span>
<span class="comments">;                   </span>
<span class="comments">;    CENTER:        A two-element array containing the [x,y] values of the center of the ellipse.</span>
<span class="comments">;                   Values are scaled unless the NOSCALE keyword is set.</span>
<span class="comments">;                   </span>
<span class="comments">;    ORIENTATION:   The orientation of the ellipse. The value is in degrees counter-clockwise of </span>
<span class="comments">;                   the postive X direction.  Note that a value of 60 is the same as a value of 240.</span>
<span class="comments">;                   In other words, there is no direction associated with this value.</span>
<span class="comments">;                   </span>
<span class="comments">;    SEMIAXES:      A two-element array containing the lengths of the semi-major and semi-minor axes,</span>
<span class="comments">;                   respectively. Lenghts are scaled unless the NOSCALE keyword is set. (Half the length</span>
<span class="comments">;                   of AXES.</span>
<span class="comments">;</span>
<span class="comments">;</span>
FUNCTION Blob_Analyzer::FitEllipse, indexNumber, $
    AXES=axes, $
    CENTER=center, $
    NOSCALE=noscale, $
    NPOINTS=npoints, $
    ORIENTATION=orientation, $
    SEMIAXES=semiAxes

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, -1
    ENDIF
    
     <span class="comments">; Argument checking.</span>
    IF N_Elements(indexNumber) EQ 0 THEN indexNumber = 0
    IF indexNumber LT 0 THEN Message, 'Required index number must be positive.'
    IF indexNumber GE self.count THEN Message, 'Index number exceeds total number of blobs.'
    IF N_Elements(npoints) EQ 0 THEN npoints = 120
    IF Keyword_Set(noscale) THEN scale = [1.0, 1.0] ELSE scale = self.scale

    <span class="comments">; Get the indices.</span>
    indices = self ->GetIndices(indexNumber, XSIZE=xsize, YSIZE=ysize)
    
    ellipsePts = Fit_Ellipse(indices, XSIZE=xsize, YSIZE=ysize, NPOINTS=npoints, $
        AXES=axes, SEMIAXES=semiAxes, ORIENTATION=orientation, SCALE=scale)
        
    RETURN, ellipsePts
END <span class="comments">; ------------------------------------------------------------------------------</span>

  
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::GetIndices</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function returns the indices of a blob to the caller.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   indices = theBlobs -> GetIndices(indexNumber)</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;     indices:     A vector of blob indices that describes the blob in the original image.</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;    indexNumber:   The index number of the blob. Indices start at 0 and go to n-1.</span>
<span class="comments">;  </span>
<span class="comments">; INPUT KEYWORDS:  </span>
<span class="comments">; </span>
<span class="comments">;    None.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDRS:</span>
<span class="comments">;</span>
<span class="comments">;    COUNT:         The number of indices in the indices vector.</span>
<span class="comments">;                   </span>
<span class="comments">;    XSIZE:         The X size of the image from which the blob is taken.</span>
<span class="comments">;                   </span>
<span class="comments">;    YSIZE:         The Y size of the image from which the blob is taken.</span>
<span class="comments">;</span>
<span class="comments">;</span>
FUNCTION Blob_Analyzer::GetIndices, indexNumber, COUNT=count, XSIZE=xsize, YSIZE=ysize

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, -1
    ENDIF
    
    <span class="comments">; Argument checking.</span>
    IF N_Elements(indexNumber) EQ 0 THEN indexNumber = 0
    IF indexNumber LT 0 THEN Message, 'Required index number must be positive.'
    IF indexNumber GE self.count THEN Message, 'Index number exceeds total number of blobs.'
    
    <span class="comments">; Return the size of the image, if the user asked for them.</span>
    IF Arg_Present(xsize) THEN xsize = self.xsize
    IF Arg_Present(ysize) THEN ysize = self.ysize
    
    <span class="comments">; Get the indices:</span>
    indices = (*self.ri)[(*self.ri)[indexNumber]:(*self.ri)[indexNumber+1]-1]
    IF Arg_Present(count) THEN count = N_Elements(indices)
    
    <span class="comments">; Return them.</span>
    RETURN, indices
    
END <span class="comments">; ------------------------------------------------------------------------------</span>


<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::GetStats</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function returns statistics of the blob in question.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   statistics = theBlobs -> GetStats(indexNumber)</span>
<span class="comments">;</span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;     statistics:   A structure of statistics that is defined like this.</span>
<span class="comments">;     </span>
<span class="comments">;                     stats = {INDEX: indexNumber, $                  ; The index number of this blob.</span>
<span class="comments">;                              COUNT: N_Elements(indices), $          ; The number of indices in this blob.</span>
<span class="comments">;                              PERIMETER_PTS: boundaryPts, $          ; A [2,n] array of points that describe the blob perimeter.</span>
<span class="comments">;                              PIXEL_AREA: pixelArea, $               ; The area as calculated by pixels in the blob.</span>
<span class="comments">;                              PERIMETER_AREA: perimeterArea, $       ; The area as calculated by the blob perimeter. (Smaller than pixel area.)</span>
<span class="comments">;                              CENTER: centroid[0:1], $               ; The [x,y] array that identifies the centroid of the blob.</span>
<span class="comments">;                              PERIMETER_LENGTH: perimeter_length, $  ; The perimenter length (scaled unless the NOSCALE keyword is set).</span>
<span class="comments">;                              SCALE: scale, $                        ; The [xscale, yscale] array used in scaling.</span>
<span class="comments">;                              MINCOL: Min(xyindices[0,*]), $         ; The minimum column index in the blob.</span>
<span class="comments">;                              MAXCOL: Max(xyindices[0,*]), $         ; The maximum column index in the blob.</span>
<span class="comments">;                              MINROW: Min(xyindices[1,*]), $         ; The minimum row index in the blob.</span>
<span class="comments">;                              MAXROW: Max(xyindices[1,*])}           ; The maximum row index in the blob.</span>
<span class="comments">;                              </span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;    indexNumber:   The index number of the blob. Indices start at 0 and go to n-1.</span>
<span class="comments">;  </span>
<span class="comments">; INPUT KEYWORDS:  </span>
<span class="comments">; </span>
<span class="comments">;    NOSCALE:       Set this keyword if you would prefer that lengths and positions NOT be</span>
<span class="comments">;                   scaled in the output of this function. If not scaled, results are in pixel</span>
<span class="comments">;                   or device coordinates. The default is to scale all output.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDRS:</span>
<span class="comments">;</span>
<span class="comments">;    INDICES:       A vector of blob indices that describes the blob in the original image.</span>
<span class="comments">;                   </span>
<span class="comments">;    XYINDICES:     A 2xN array of column/row indices that describes teh blob in the original image.</span>
<span class="comments">;    </span>
<span class="comments">; NOTES:</span>
<span class="comments">; </span>
<span class="comments">;     The statistics are calculated by calling FIND_BOUNDARY from the Coyote Library. This program</span>
<span class="comments">;     uses a chain-code algorithm to calculate the perimeter and report the blob area using either of</span>
<span class="comments">;     two methods: a strict pixel area (counts the number of pixels in the blob times the scale factor</span>
<span class="comments">;     and takes the total), or it uses the perimeter to calculate an area using the method described in</span>
<span class="comments">;     Russ, The Image Processing Handbook, 2nd Edition, pp490+. The perimeter area is almost always less </span>
<span class="comments">;     than the pixel area.</span>
<span class="comments">;</span>
FUNCTION Blob_Analyzer::GetStats, indexNumber, INDICES=indices, NOSCALE=noscale, XYINDICES=xyindices

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, -1
    ENDIF
    
    <span class="comments">; Argument checking.</span>
    IF N_Elements(indexNumber) EQ 0 THEN indexNumber = 0
    IF indexNumber LT 0 THEN Message, 'Required index number must be positive.'
    IF indexNumber GE self.count THEN Message, 'Index number exceeds total number of blobs.'
    IF Keyword_Set(noscale) THEN scale = [1.0D, 1.0D] ELSE scale = self.scale

    <span class="comments">; Get the indices.</span>
    indices = self ->GetIndices(indexNumber, XSIZE=xsize, YSIZE=ysize)
    
    <span class="comments">; Calculate the indices in terms of col/row coordinates.</span>
    xyindices = Array_Indices([xsize,ysize], indices, /DIMENSIONS)
    
    <span class="comments">; Calculate statistics.</span>
    boundaryPts = Find_Boundary(indices, $
        SCALE=scale, $
        XSIZE=xsize, $
        YSIZE=ysize, $
        AREA=pixelArea, $
        PERIM_AREA=perimeterArea, $
        CENTER=centroid, $
        PERIMETER=perimeter_length)
                                  
    <span class="comments">; Report them.</span>
    stats = {INDEX: indexNumber, $                   <span class="comments">; The index number of thisblob.</span>
             COUNT: N_Elements(indices), $           <span class="comments">; The number of indices in this blob.</span>
             PERIMETER_PTS: boundaryPts, $           <span class="comments">; A [2,n] array of points that describe the blob perimeter.</span>
             PIXEL_AREA: pixelArea, $                <span class="comments">; The area as calculated by pixels in the blob.</span>
             PERIMETER_AREA: perimeterArea, $        <span class="comments">; The area as calculated by the blob perimeter. (Smaller than pixel area.)</span>
             CENTER: centroid[0:1], $                <span class="comments">; The [x,y] array that identifies the centroid of the blob.</span>
             PERIMETER_LENGTH: perimeter_length, $   <span class="comments">; The perimenter length (scaled unless the NOSCALE keyword is set).</span>
             SCALE: scale, $                         <span class="comments">; The [xscale, yscale] array used in scaling.</span>
             MINCOL: Min(xyindices[0,*]), $          <span class="comments">; The minimum column index in the blob.</span>
             MAXCOL: Max(xyindices[0,*]), $          <span class="comments">; The maximum column index in the blob.</span>
             MINROW: Min(xyindices[1,*]), $          <span class="comments">; The minimum row index in the blob.</span>
             MAXROW: Max(xyindices[1,*])}            <span class="comments">; The maximum row index in the blob.</span>
             
     RETURN, stats
             
END <span class="comments">; ------------------------------------------------------------------------------</span>


<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::NumberOfBlobs</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function returns the number of blobs in the input image.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   numBlobs = theBlobs -> NumberOfBlobs()</span>
<span class="comments">;   </span>
<span class="comments">; RETURN VALUE:</span>
<span class="comments">;</span>
<span class="comments">;     numBlobs:   The number of blobs in the input image.</span>
<span class="comments">;                              </span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;    None.</span>
<span class="comments">;  </span>
<span class="comments">; KEYWORDS:  </span>
<span class="comments">; </span>
<span class="comments">;    None.</span>
<span class="comments">;</span>
FUNCTION Blob_Analyzer::NumberOfBlobs
    RETURN, self.count
END <span class="comments">; ------------------------------------------------------------------------------</span>

  
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::ReportStats</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function reports statistics on blobs in the image.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   theBlobs -> ReportStats</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;    None.</span>
<span class="comments">;  </span>
<span class="comments">; INPUT KEYWORDS:  </span>
<span class="comments">; </span>
<span class="comments">;    FILENAME:      The name of a file to contain the statistical output.</span>
<span class="comments">; </span>
<span class="comments">;    NOSCALE:       Set this keyword if you would prefer that lengths and positions NOT be</span>
<span class="comments">;                   scaled in the output of this function. If not scaled, results are in pixel</span>
<span class="comments">;                   or device coordinates. The default is to scale all output.</span>
<span class="comments">;</span>
<span class="comments">;    TOFILE:         Normally the report is sent to standard ouput. If this keyword is set,</span>
<span class="comments">;                    the output is sent to a file.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORDRS:</span>
<span class="comments">;</span>
<span class="comments">;    None.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">; </span>
<span class="comments">;    Here is an example of statistical output from the example program below.</span>
<span class="comments">;    </span>
<span class="comments">;  INDEX   NUM_PIXELS   CENTER_X    CENTER_Y   PIXEL_AREA   PERIMETER_AREA   PERIMETER_LENGTH  MAJOR_AXIS   MINOR_AXIS    ANGLE</span>
<span class="comments">;     0        426        107.89       9.78       106.50          98.00            37.56          12.15        11.29       -8.05</span>
<span class="comments">;     1        580        151.97      10.22       145.00         134.25            49.21          17.49        11.77       -0.99</span>
<span class="comments">;     2        812        266.29      15.36       203.00         190.75            52.56          17.88        14.65     -107.48</span>
<span class="comments">;     3       1438        204.53      43.29       359.50         344.13            70.23          21.68        21.12      -76.47</span>
<span class="comments">;</span>
PRO Blob_Analyzer::ReportStats, NOSCALE=noscale, TOFILE=tofile, FILENAME=filename

    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        IF N_Elements(lun) NE 0 THEN Free_Lun, lun
        RETURN
    ENDIF
    
     <span class="comments">; Argument checking.</span>
     tofile = Keyword_Set(tofile)
     IF tofile THEN BEGIN
        IF N_Elements(filename) EQ 0 THEN BEGIN
            filename = Dialog_Pickfile(Title='Select file for statistical ouput.')
            IF filename EQ "" THEN RETURN
        ENDIF
        
            <span class="comments">; Open the file for writing.</span>
            OpenW, lun, filename, /GET_LUN, WIDTH=100
     ENDIF
     
     <span class="comments">; Get the stats and output them to the display or to a file.</span>
     header = '  INDEX   NUM_PIXELS   CENTER_X    CENTER_Y   PIXEL_AREA   PERIMETER_AREA   PERIMETER_LENGTH  MAJOR_AXIS   MINOR_AXIS    ANGLE'
     
     <span class="comments">; Write the header.</span>
     IF tofile THEN $
        PrintF, lun, header ELSE $
        Print, header
        
     <span class="comments">; Write the rest of the information.</span>
     format = '(x,I5, 6x,I5, 4x,F10.2, 1x,F10.2, 3x,F10.2, 5x,F10.2, 7x,F10.2, 5x,F10.2, 3x,F10.2, 2x,F10.2)' 
     FOR j=0, self.count-1 DO BEGIN
        stats = self -> GetStats(j, NOSCALE=noscale)
        void = self -> FitEllipse(j, AXES=axes, ORIENTATION=angle, NOSCALE=noscale)
         IF tofile THEN BEGIN
            PrintF, lun, StrTrim(j,2), stats.count, stats.center[0], stats.center[1], $
                stats.pixel_area, stats.perimeter_area,  $
                stats.perimeter_length, axes[0], axes[1], angle, FORMAT=format
         ENDIF ELSE BEGIN
            Print, StrTrim(j,2), stats.count, stats.center[0], stats.center[1], $
                stats.pixel_area, stats.perimeter_area,  $
                stats.perimeter_length, axes[0], axes[1], angle, FORMAT=format
         ENDELSE
         
     ENDFOR
     
     <span class="comments">; Close the file, if open.</span>
     IF tofile THEN Free_Lun, lun
     
END <span class="comments">; ------------------------------------------------------------------------------</span>


PRO Blob_Analyzer::CLEANUP
    Ptr_Free, self.ri
END <span class="comments">; ------------------------------------------------------------------------------</span>


<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;  Blob_Analyzer::INIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;</span>
<span class="comments">;   This function initializes the Blob_Analyzer object.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   theBlobs = Obj_New('Blob_Analyzer', image)</span>
<span class="comments">;   </span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;</span>
<span class="comments">;   image:           A two-dimensional image array. To make this program memory efficient,</span>
<span class="comments">;                    a copy of the image is *not* stored in the object. You will be responsible</span>
<span class="comments">;                    for image operations outside this program.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ALL_NEIGHBORS:    Set this keyword to look at all eight neighbors when searching</span>
<span class="comments">;                     for connectivity. The default is to look for four neighbors on</span>
<span class="comments">;                     each side of the starting pixel. Passed directly to LABEL_REGION.</span>
<span class="comments">;                     </span>
<span class="comments">;   MASK:             A two-dimensional array, the same size as image, that identifies the</span>
<span class="comments">;                     foreground and background pixels in the image. Applying the mask</span>
<span class="comments">;                     should result in a bi-level image of 0s and 1s, where 1 identifies the </span>
<span class="comments">;                     blobs you wish to analyze. If a mask is not provided, the mask is created</span>
<span class="comments">;                     like this:</span>
<span class="comments">;                     </span>
<span class="comments">;                     mask = image > 0</span>
<span class="comments">;</span>
<span class="comments">;   SCALE:            A one- or two-dimensional given the pixel scaling parameters. By default [1.0, 1.0].</span>
<span class="comments">;                     If passed a scalar, the scale parameter is applied to both the X and Y directions of</span>
<span class="comments">;                     each pixel. Statistical output is reported with scaling unless the NOSCALE keyword</span>
<span class="comments">;                     is set. Scaling also effects the data that is output from the various methods.</span>
<span class="comments">;</span>
FUNCTION Blob_Analyzer::INIT, inputImage, $
    ALL_NEIGHBORS=all_neighbors, $
    MASK=mask, $
    SCALE=scale
    
    Compile_Opt idl2

    <span class="comments">; Error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /CANCEL
        void = Error_Message()
        RETURN, 0
    ENDIF
    
    <span class="comments">; Do you have an image. It is required.</span>
    IF N_Elements(inputImage) EQ 0 THEN Message, 'An input image is a required argument.'
    
    <span class="comments">; Is the image 2D?</span>
    ndims = Size(inputImage, /N_DIMENSIONS)
    IF ndims NE 2 THEN Message, 'The BLOB_ANALYZER only works with 2D images.'
        
    <span class="comments">; Check keywords.</span>
    IF N_Elements(mask) EQ 0 THEN BEGIN
        image = inputImage GT 0
    ENDIF ELSE BEGIN
        
        <span class="comments">; Is the mask the same size as the image?</span>
        IF Total(Size(inputImage, /DIMENSIONS) EQ Size(mask, /DIMENSIONS)) NE 2 THEN $
            Message, 'The image mask is not the same size as the input image.'
            
        <span class="comments">; Apply the mask to the image.</span>
        image = inputImage * mask
    ENDELSE
    
    <span class="comments">; Check other keywords.</span>
    IF N_Elements(scale) EQ 0 THEN scale = [1.0, 1.0]
    
    <span class="comments">; Get the size of the image.</span>
    s = Size(image, /DIMENSIONS)
    xsize = s[0]
    ysize = s[1]
    type = Size(image, /TYPE)

    <span class="comments">; Label the regions.</span>
    bigImage = Make_Array(s+2, TYPE=type)
    bigImage[1,1] = Temporary(image)
    labeledImage = Label_Region(bigImage, ALL_NEIGHBORS=Keyword_Set(all_neighbors))
    image = (Temporary(labeledImage))[1:xsize, 1:ysize]

    <span class="comments">; Get the indices of the label image by taking its histogram.</span>
    h = Histogram(image, REVERSE_INDICES=ri, BINSIZE=1.0, MIN=1)
    count = N_Elements(h)
    
    <span class="comments">; Populate the object.</span>
    self.count = count
    self.ri = Ptr_New(ri, /NO_COPY)
    self.xsize = xsize
    self.ysize = ysize
    self.scale = scale
    
    RETURN, 1
    
END <span class="comments">; ------------------------------------------------------------------------------</span>


PRO Example

  <span class="comments">; Get a file for analysis.</span>
  file = FILEPATH('r_seeberi.jpg', SUBDIRECTORY = ['examples', 'data'])
  READ_JPEG, file, image, /GRAYSCALE

  <span class="comments">; Define a structuring kernal for an opening operation on the image.</span>
  radius = 5
  kernel = SHIFT(DIST(2*radius+1), radius, radius) LE radius
  
  <span class="comments">; Apply the opening operator to the image.</span>
  openImage = MORPH_OPEN(image, kernel, /GRAY)
  
  <span class="comments">; Threshold the image to prepare to remove background noise.</span>
  <span class="comments">; Notice that changing this value can produce more or less</span>
  <span class="comments">; artifacts. You will have to decide what you can live with</span>
  <span class="comments">; in your analysis. It requires some judgement on your part.</span>
  mask = openImage GE 150
  
  <span class="comments">; Do the analysis.</span>
  blobs = Obj_New('blob_analyzer', openImage, MASK=mask, SCALE=[0.5, 0.5])
  
  <span class="comments">; Display the original image</span>
  s = Size(image, /DIMENSIONS)
  Window, XSIZE=2*s[0], YSIZE=2*s[1], Title='Blob Analyzer Example'
  LoadCT, 0
  cgImage, image, 0, /TV
  
  <span class="comments">; Display the opened image beside it.</span>
  cgImage, openImage, 1, /TV
  
  <span class="comments">; Display the blobs we located with LABEL_REGION.</span>
  count = blobs -> NumberOfBlobs()
  blank = BytArr(s[0], s[1])
  FOR j=0,count-1 DO BEGIN
    blobIndices = blobs -> GetIndices(j)
    blank[blobIndices] = image[blobIndices]
  ENDFOR
  cgImage, blank, 2, /TV
  
  <span class="comments">; Display the original image, with blob outlined and labelled.</span>
  cgImage, image, 3, /TV
  FOR j=0,count-1 DO BEGIN
    stats = blobs -> GetStats(j, /NoScale)
    PLOTS, stats.perimeter_pts[0,*] + s[0], stats.perimeter_pts[1,*], /Device, COLOR=cgColor('dodger blue')
    XYOUTS, stats.center[0]+s[0], stats.center[1]-5, /Device, StrTrim(j,2), $
        COLOR=cgColor('red'), ALIGNMENT=0.5, CHARSIZE=0.75
  ENDFOR
  
  <span class="comments">; Add labels for captions.</span>
  XYOUTS, 0.05, 0.95, 'A', FONT=0, ALIGNMENT=0.5, COLOR=cgColor('Yellow')
  XYOUTS, 0.55, 0.95, 'B', FONT=0, ALIGNMENT=0.5, COLOR=cgColor('Yellow')
  XYOUTS, 0.05, 0.45, 'C', FONT=0, ALIGNMENT=0.5, COLOR=cgColor('Yellow')
  XYOUTS, 0.55, 0.45, 'D', FONT=0, ALIGNMENT=0.5, COLOR=cgColor('Yellow')
  
  <span class="comments">; Report stats.</span>
  blobs -> ReportStats
  
  <span class="comments">; Destroy the object.</span>
  Obj_Destroy, blobs
  
END <span class="comments">; ------------------------------------------------------------------------------</span>


PRO Blob_Analyzer__DEFINE, class 

    class = { BLOB_ANALYZER, $
              count: 0L, $        <span class="comments">; The total number of blobs being analyzed.</span>
              ri: Ptr_New(), $    <span class="comments">; The reverse indices from HISTOGRAM. Used to get the blob indices.</span>
              xsize: 0L, $        <span class="comments">; The X size of the image the indices originate in.</span>
              ysize: 0L, $        <span class="comments">; The Y size of the image the indices originate in.</span>
              scale: FltArr(2) $  <span class="comments">; The X and Y pixel scale for the indices. Set to [1,1] by default.</span>
           }

END <span class="comments">; ------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>