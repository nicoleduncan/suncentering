<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:56:38 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgzplot__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgzplot__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgZPlot__Define</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   This program creates a "zoomable" line plot in an interactive window. The user can</span>
<span class="comments">;   zoom into or out of the plot. Once a plot is zoomed, the user can then pan the plot</span>
<span class="comments">;   in both the X and Y directions. See the operating instructions for how to interact</span>
<span class="comments">;   with the line plot.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2012, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;+</span>
<span class="comments">;  This program creates a "zoomable" line plot in an interactive, resizable window. The user </span>
<span class="comments">;  can zoom into or out of the plot. Once a plot is zoomed, the user can then pan the plot</span>
<span class="comments">;  in both the X and Y directions. See the operating instructions for how to interact</span>
<span class="comments">;  with the line plot.</span>
<span class="comments">;  </span>
<span class="comments">;  Operating Instructions--</span>
<span class="comments">;  </span>
<span class="comments">;  Use the LEFT mouse button to zoom the plot and the RIGHT mouse button to pan the plot.</span>
<span class="comments">;  </span>
<span class="comments">;  If you click and drag inside the plot axes, you will create a rubber band box. Select the</span>
<span class="comments">;  portion of data you wish to zoom into. The zoom will occur in both the X and Y directions.</span>
<span class="comments">;  If you wish to zoom the plot all the way back out, simply click and release the LEFT mouse</span>
<span class="comments">;  button inside the plot axes without moving the mouse.</span>
<span class="comments">;  </span>
<span class="comments">;  Once you are zoomed into a plot, you can adjust the zoom by clicking the LEFT mouse button</span>
<span class="comments">;  outside the plot axes. If you click the mouse below the plot, you will cause the X axis to</span>
<span class="comments">;  zoom out of the plot by the zoomFactor amount (normally 5% of the current range of the axis).</span>
<span class="comments">;  If you wish to zoom the X axis into the plot, simply click above in the region of the window</span>
<span class="comments">;  above the plot. Click below the plot to zoom out, above the plot to zoom in. Similarly, you </span>
<span class="comments">;  can adjust the zoom on the Y axis. Clicking to the left of the plot zooms the Y axis out, </span>
<span class="comments">;  while clicking to the right of the plot zooms the Y axis in.</span>
<span class="comments">;  </span>
<span class="comments">;  If you are zoomed into the plot, you can pan to different locations in the plot by using</span>
<span class="comments">;  the RIGHT mouse button. Hold and drag the RIGHT mouse button inside the plot axes. The</span>
<span class="comments">;  entire plot will pan in both the X and Y directions.</span>
<span class="comments">;  </span>
<span class="comments">;  File output requires that ImageMagick and GhostScript be installed on your machine. Note</span>
<span class="comments">;  that exact axis scaling is always in effect.</span>
<span class="comments">;</span>
<span class="comments">;  The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">;  to be installed on your machine.</span>
<span class="comments">;        </span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Plot examples::</span>
<span class="comments">;       cgZPlot, cgDemodata(1), PSYM=2, Color='dodger blue'</span>
<span class="comments">;       </span>
<span class="comments">;    To put this in your own widget program::</span>
<span class="comments">;        tlb = Widget_Base(Title='My Program')</span>
<span class="comments">;        cgZPlot, cgDemodata(1), PSYM=2, Color='dodger blue', Parent=tlb</span>
<span class="comments">;        Widget_Control, tlb, /Realize</span>
<span class="comments">;        Widget_Control, 'myprogram', tlb, /NoBlock</span>
<span class="comments">;    </span>
<span class="comments">; :Author:</span>
<span class="comments">;    FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;       David W. Fanning </span>
<span class="comments">;       1645 Sheely Drive</span>
<span class="comments">;       Fort Collins, CO 80526 USA</span>
<span class="comments">;       Phone: 970-221-0438</span>
<span class="comments">;       E-mail: david@idlcoyote.com</span>
<span class="comments">;       Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;     </span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written 16 May 2012, by David W. Fanning.</span>
<span class="comments">;        Added UNDO capability arbitrarily set to 50 items. 17 May 2012. DWF.</span>
<span class="comments">;        Added a REDO capability and the ability to adjust the Y range (via a button) so that </span>
<span class="comments">;           you can see the actual data Y range of all the data in the X range of a particular</span>
<span class="comments">;           view of the data. 21 May 2012. DWF.</span>
<span class="comments">;        Added a PARENT keyword and changed the algorithm slightly so that this</span>
<span class="comments">;           interactive widget functionality can be incorporated into your own</span>
<span class="comments">;           widget programs. 21 may 2012. DWF.</span>
<span class="comments">;        Added compile options idl2 to all modules. Fixed a typo for REDO button. 14 June 2012. DWF.</span>
<span class="comments">;        Separated the object code from the driver code for easier inheritance. 14 June 2012. DWF.</span>
<span class="comments">;        Removed the POLAR keyword, which can't be used in a zoom plot. 15 June 2012. DWF.</span>
<span class="comments">;        Added a persistent output save directory.  30 June 2012. DWF.</span>
<span class="comments">;        Added an ERASE method to erase the current display. 10 July 2012. DWF.</span>
<span class="comments">;        Added a LABEL keyword to add a label instead of a title to a plot. 13 July 2012. DWF.</span>
<span class="comments">;        Added the ability to include overplot objects in the zoom window. 17 July 2012. DWF.</span>
<span class="comments">;        Added a Destroy method and now remove widget GUI in CLEANUP method. 2 Oct 2012. DWF.</span>
<span class="comments">;        I had the GetProperty and SetProperty keyword inheritance mechanism screwed up. Sorted</span>
<span class="comments">;           now. 13 March 2013. DWF.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; This is the initialization method of the cgZPlot object. In general, any keyword appropriate</span>
<span class="comments">; for the cgPlot command can be used with this program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    x: in, required, type=any</span>
<span class="comments">;         If X is provided without Y, a vector representing the dependent values to be </span>
<span class="comments">;         plotted If both X and Y are provided, X is the independent parameter and </span>
<span class="comments">;         Y is the dependent parameter to be plotted.</span>
<span class="comments">;    y: in, optional, type=any</span>
<span class="comments">;         A vector representing the dependent values to be plotted.</span>
<span class="comments">;       </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     aspect: in, optional, type=float, default=none</span>
<span class="comments">;        Set this keyword to a floating point ratio that represents the aspect ratio </span>
<span class="comments">;        (ysize/xsize) of the resulting plot. The plot position may change as a result</span>
<span class="comments">;        of setting this keyword. Note that `Aspect` cannot be used when plotting with</span>
<span class="comments">;        !P.MULTI.</span>
<span class="comments">;     label: in, optional, type=string</span>
<span class="comments">;        A label is similar to a plot title, but it is aligned to the left edge</span>
<span class="comments">;        of the plot and is written in hardware fonts. Use of the label keyword</span>
<span class="comments">;        will suppress the plot title.</span>
<span class="comments">;     legends: in, optional, type=object</span>
<span class="comments">;         A single cgLegendItem object, or an array of cgLegendItem objects that will be</span>
<span class="comments">;         drawn on the plot as a legend.</span>
<span class="comments">;     max_value: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the maximum value to plot. Any values greater than this </span>
<span class="comments">;        value are treated as missing.</span>
<span class="comments">;     min_value: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the minimu value to plot. Any values smaller than this </span>
<span class="comments">;        value are treated as missing.</span>
<span class="comments">;     oplots: in, optional, type=object</span>
<span class="comments">;         A single cgOverPlot object, or an array of cgOverPlot objects that will be</span>
<span class="comments">;         overplot on the axes set up by the original data.</span>
<span class="comments">;     parent: in, optional, type=long</span>
<span class="comments">;        The identifer of the parent widget for this program's draw widget. If not</span>
<span class="comments">;        provided, the program will create it's own top-level base widget as a parent.</span>
<span class="comments">;     xlog: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to use a logarithmic X axis</span>
<span class="comments">;     xrange: in, optional, type=double</span>
<span class="comments">;        Set this keyword to a two-element array giving the X data range of the plot.</span>
<span class="comments">;     xsize: in, optional, type=int, default=640</span>
<span class="comments">;        The X size of the program's draw widget.</span>
<span class="comments">;     ylog: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to use a logarithmic Y axis</span>
<span class="comments">;     ynozero: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to use allow the Y axis to start at a value other than zero.</span>
<span class="comments">;     yrange: in, optional, type=double</span>
<span class="comments">;         Set this keyword to a two-element array giving the Y data range of the plot.</span>
<span class="comments">;     ysize: in, optional, type=int, default=512</span>
<span class="comments">;         The Y size of the program's draw widget.</span>
<span class="comments">;     zoomfactor: in, optional, type=float</span>
<span class="comments">;         Set this keyword to a number between 0.01 and 0.25. This affects the amount</span>
<span class="comments">;         of zooming when the X axis and Y axis are zoomed with the LEFT mouse button.</span>
<span class="comments">;         The default value is 0.05 or five percent of the current axis range on each</span>
<span class="comments">;         end of the axis, resulting in a 10 percent change in the axis length.</span>
<span class="comments">;     _ref_extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDL Plot or Coyote Graphic cgPlot command is </span>
<span class="comments">;        allowed in the program. Note that this is not the same as saying it is a good</span>
<span class="comments">;        idea to use every one of the these keywords. Use good judgement.</span>
<span class="comments">;-</span>
FUNCTION cgZPlot::INIT, x, y, $
    ASPECT=aspect, $
    DRAWID=drawid, $
    LABEL=label, $
    LEGENDS=legends, $
    MAX_VALUE=max_value, $
    MIN_VALUE=min_value, $
    OPLOTS=oplots, $
    PARENT=parent, $
    XLOG=xlog, $
    XRANGE=xrange, $
    XSIZE=xsize, $
    YLOG=ylog, $
    YRANGE=yrange, $
    YNOZERO=ynozero, $
    YSIZE=ysize, $
    ZOOMFACTOR=zoomfactor, $
    _REF_EXTRA=extra
    
    Compile_Opt idl2
    
    Catch, theError
    IF theError NE 0 THEN BEGIN
        Catch, /Cancel
        void = Error_Message()
        RETURN, 0
    ENDIF
    
    <span class="comments">; Set parameters and arguments.</span>
    IF N_Elements(zoomfactor) EQ 0 THEN zoomfactor = 0.05 ELSE zoomfactor = 0.01 > zoomfactor &lt<span class="comments">; 0.25</span>
    
    <span class="comments">; Call the superclass object INIT method.</span>
    IF ~self -> cgGraphicsKeywords::INIT(_STRICT_EXTRA=extra) THEN RETURN, 0   
    
    <span class="comments">; Sort out which is the dependent and which is independent data.</span>
    CASE N_Params() OF
      
       1: BEGIN
       dep = x
       indep = Findgen(N_Elements(dep))
       ENDCASE
    
       2: BEGIN
       dep = y
       indep = x
       ENDCASE
    
    ENDCASE
    
    <span class="comments">; If either of these input vectors are scalars, make them vectors.</span>
    IF N_Elements(dep) EQ 1 THEN dep = [dep]
    IF N_Elements(indep) EQ 1 THEN indep = [indep]
    
    <span class="comments">; Allocate heap for variables.</span>
    self.indep = Ptr_New(/Allocate_Heap)
    self.dep = Ptr_New(/Allocate_Heap)
    self.aspect = Ptr_New(/Allocate_Heap)
    self.max_value = Ptr_New(/Allocate_Heap)
    self.min_value = Ptr_New(/Allocate_Heap)
    self.xlog = Ptr_New(/Allocate_Heap)
    self.ylog = Ptr_New(/Allocate_Heap)
    self.ynozero = Ptr_New(/Allocate_Heap)
    self.undoList = Obj_New('LinkedList')
    self.redoList = Obj_New('LinkedList')
    IF N_Elements(oplots) NE 0 THEN self.oplots = Ptr_New(oplots) ELSE self.oplots = Ptr_New(/ALLOCATE_HEAP)
    IF N_Elements(legends) NE 0 THEN self.legends = Ptr_New(legends) ELSE self.legends = Ptr_New(/ALLOCATE_HEAP)
    
    self -> SetProperty, $
        INDEP=indep, $
        DEP=dep, $
        ASPECT=aspect, $
        MAX_VALUE=max_value, $
        MIN_VALUE=min_value, $
        XLOG=xlog, $
        XRANGE=xrange, $
        YLOG=ylog, $
        YRANGE=yrange, $
        YNOZERO=ynozero
        
    <span class="comments">; Set the draw widget size.</span>
    IF N_Elements(xsize) EQ 0 THEN self.xsize = 640 ELSE self.xsize = xsize
    IF N_Elements(ysize) EQ 0 THEN self.ysize = 512 ELSE self.ysize = ysize
    
    <span class="comments">; Do you need to create your own TLB, or will you be using someone else's?</span>
    IF N_Elements(parent) EQ 0 THEN BEGIN
        self.tlb = Widget_Base(Title='Zoom/Pan Plot', TLB_SIZE_EVENTS=1, $
           UVALUE={method:'TLB_RESIZE_EVENTS', object:self}, MBar=menuID)
           
        <span class="comments">; Menu items.</span>
        fileID = Widget_Button(menuID, Value='File')
        output = Widget_Button(fileID, Value='Save As...', /Menu)
        button = Widget_Button(output, Value='BMP File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='EPS File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='GIF File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='JPEG File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='PDF File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='PS File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='PNG File', UVALUE={method:'FileOutput', object:self})
        button = Widget_Button(output, Value='TIFF File', UVALUE={method:'FileOutput', object:self})
        
        button =  Widget_Button(fileID, Value='Undo', ACCELERATOR="Ctrl+U", $
            UVALUE={method:'Undo', object:self}, /Separator)
        button =  Widget_Button(fileID, Value='Redo', ACCELERATOR="Ctrl+R", $
            UVALUE={method:'Redo', object:self})
            
        button = Widget_Button(fileID, Value='Adjust Range to Data Viewed', ACCELERATOR="Ctrl+A", $
            UVALUE={method:'AdjustRange', object:self}, /Separator)
        
        button =  Widget_Button(fileID, Value='Quit', UVALUE={method:'Quit', object:self}, /Separator)
    ENDIF ELSE self.tlb = parent
    
    <span class="comments">; Create the draw widget and pixmap. These are the essential elements of this object</span>
    <span class="comments">; and should work in any parent widget.</span>
    retain = (StrUpCase(!Version.OS_Family) EQ 'UNIX') ? 2 : 1
    self.drawID = Widget_Draw(self.tlb, XSize=self.xsize, YSize=self.ysize, $
       UVALUE={method:'BUTTON_EVENTS', object:self}, $
       RETAIN=retain, Button_Events=1, $
       NOTIFY_REALIZE='cgzplot_notify_realize', $
       EVENT_PRO='cgZplot_Events')
    Window, /Pixmap, /Free, XSize=self.xsize, YSize=self.ysize
    self.pixmapID = !D.Window
    
    <span class="comments">; Set object properties.</span>
    self.drag = 0
    IF N_Elements(label) NE 0 THEN self.label = label
    IF N_Elements(xrange) EQ 0 THEN xrange = [Min(indep), Max(indep)]
    IF N_Elements(yrange) EQ 0 THEN yrange = [Min(dep), Max(dep)*1.05]
    self.orig_xrange = xrange
    self.orig_yrange = yrange
    self.zoomfactor = zoomfactor
    *self.xlog = Keyword_Set(xlog)
    *self.ylog = Keyword_Set(ylog)
    
    <span class="comments">; Must do exact axis scaling for smooth operation.</span>
    IF N_Elements(*self.xstyle) NE 0 THEN *self.xstyle = *self.xstyle && 1 ELSE *self.xstyle = 1
    IF N_Elements(*self.ystyle) NE 0 THEN *self.ystyle = *self.ystyle && 1 ELSE *self.ystyle = 1
    
    <span class="comments">; Realize the widget and get it going, if you created the TLB.</span>
    IF N_Elements(parent) EQ 0 THEN BEGIN
        Widget_Control, self.tlb, /Realize
        XManager, 'cgzplot', self.tlb, /No_Block, Event_Handler='cgZPlot_Events', $
           Cleanup='cgZPlot_Cleanup'
    ENDIF
    
    RETURN, 1
END

<span class="comments">;+</span>
<span class="comments">; The clean-up method for the object. When the object is destroyed, </span>
<span class="comments">; this method will free the object's pointers.</span>
<span class="comments">;-</span>
PRO cgZPlot::CLEANUP

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
    
    Ptr_Free, self.indep
    Ptr_Free, self.dep
    Ptr_Free, self.aspect
    Ptr_Free, self.max_value
    Ptr_Free, self.min_value
    Ptr_Free, self.xlog
    Ptr_Free, self.ylog
    Ptr_Free, self.ynozero
    Obj_Destroy, self.undoList
    Obj_Destroy, self.redoList
    WDelete, self.pixmapID
    
    <span class="comments">; Get rid of the overplot objects, if any.</span>
    IF Ptr_Valid(self.oplots) THEN BEGIN
      FOR j=0,N_Elements(*self.oplots)-1 DO BEGIN
         Obj_Destroy, (*self.oplots)[j]
      ENDFOR
      Ptr_Free, self.oplots
    ENDIF

    <span class="comments">; Get rid of the legend objects, if any.</span>
    IF Ptr_Valid(self.legends) THEN BEGIN
      FOR j=0,N_Elements(*self.legends)-1 DO BEGIN
         Obj_Destroy, (*self.legends)[j]
      ENDFOR
      Ptr_Free, self.legends
    ENDIF
    
    <span class="comments">; Call the superclass CLEANUP method.</span>
    self -> cgGraphicsKeywords::CLEANUP
    
    <span class="comments">; If you have a valid TLB, destroy that, too.</span>
    IF Widget_Info(self.tlb, /VALID_ID) THEN Widget_Control, self.tlb, /Destroy

END


<span class="comments">;+</span>
<span class="comments">; This method adds a cgLegendItem object or array of objects to the plot. The</span>
<span class="comments">; legend objects are drawn on the plot after the orginal plot is drawn.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    legendobject: in, optional, type=object</span>
<span class="comments">;        A cgLegendItem object, or an array of cgLegendItem objects that should be drawn</span>
<span class="comments">;        when the Draw method is called. The legend objects will be destroyed when this</span>
<span class="comments">;        object is destroyed.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     clear: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the overplot list is cleared before the new overplot objects</span>
<span class="comments">;        are added. Otherwise, the overplot object or objects is added to the end of the list</span>
<span class="comments">;        already present.</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object calls its Draw method after the overplot objects are added.</span>
<span class="comments">;     index: in, optional, type=integer, default=0</span>
<span class="comments">;         Used only if the `REPLACE` keyword is set. Specifies the replacement index.</span>
<span class="comments">;     replace: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the new object replaces a current object, in the object</span>
<span class="comments">;        array at the `INDEX` location.</span>
<span class="comments">;-</span>
PRO cgZPlot::AddLegends, legendObject, $
   CLEAR=clear, $
   DRAW=draw, $
   INDEX=index, $
   REPLACE=replace

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
  
   <span class="comments">; Clear all current legends, if needed.</span>
   IF Keyword_Set(clear) THEN BEGIN
   
        <span class="comments">; Get rid of the overplot objects, if any.</span>
        IF Ptr_Valid(self.legends) THEN BEGIN
           FOR j=0,N_Elements(*self.legends)-1 DO BEGIN
             Obj_Destroy, (*self.legends)[j]
           ENDFOR
           Ptr_Free, self.legends
         ENDIF

   ENDIF
   
   <span class="comments">; Are we replacing an object in the current list?</span>
   <span class="comments">; If so, do it and return.</span>
   IF Keyword_Set(replace) THEN BEGIN
   
       IF N_Elements(index) EQ 0 THEN index = 0
       Obj_Destroy, (*self.legends)[index]
       (*self.legends)[index] = legendObject
        RETURN
        
   ENDIF
   
   <span class="comments">; If nothing to add, return.</span>
   IF N_Elements(legendObject) EQ 0 THEN BEGIN
       IF Ptr_Valid(self.legends) EQ 0 THEN self.legends = Ptr_New(/ALLOCATE_HEAP)
       RETURN
   ENDIF
   
   <span class="comments">; Otherwise, add the legend objects.</span>
   IF Ptr_Valid(self.legends) THEN BEGIN
       *self.legends = [*self.legends, legendObject]
   ENDIF ELSE BEGIN
       self.legends = Ptr_New(legendObject)
   ENDELSE
   help, *self.legends
   <span class="comments">; Draw the object?</span>
   IF Keyword_Set(draw) THEN self -> Draw
   
END

<span class="comments">;+</span>
<span class="comments">; This method adds a cgOverplot object or array of objects to the plot. The</span>
<span class="comments">; overplot objects are drawn on the plot after the orginal plot is drawn.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    oplotobject: in, optional, type=object</span>
<span class="comments">;        A cgOverPlot object, or an array of cgOverplot objects that should be overplot</span>
<span class="comments">;        when the Draw method is called. The overplot objects will be destroyed when this</span>
<span class="comments">;        object is destroyed.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     clear: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the overplot list is cleared before the new overplot objects</span>
<span class="comments">;        are added. Otherwise, the overplot object or objects is added to the end of the list</span>
<span class="comments">;        already present.</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the object calls its Draw method after the overplot objects are added.</span>
<span class="comments">;     index: in, optional, type=integer, default=0</span>
<span class="comments">;         Used only if the `REPLACE` keyword is set. Specifies the replacement index.</span>
<span class="comments">;     replace: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the new object replaces a current object, in the object</span>
<span class="comments">;        array at the `INDEX` location.</span>
<span class="comments">;-</span>
PRO cgZPlot::AddOverplots, oplotObject, $
   CLEAR=clear, $
   DRAW=draw, $
   INDEX=index, $
   REPLACE=replace

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
  
   <span class="comments">; Are we replacing an object in the current list?</span>
   <span class="comments">; If so, do it and return.</span>
   IF Keyword_Set(replace) THEN BEGIN
   
       IF N_Elements(index) EQ 0 THEN index = 0
       Obj_Destroy, (*self.oplots)[index]
       (*self.oplots)[index] = oplotObject
        RETURN
        
   ENDIF
   
   <span class="comments">; Clear all current overplots, if needed.</span>
   IF Keyword_Set(clear) THEN BEGIN
   
        <span class="comments">; Get rid of the overplot objects, if any.</span>
        IF Ptr_Valid(self.oplots) THEN BEGIN
           FOR j=0,N_Elements(*self.oplots)-1 DO BEGIN
             Obj_Destroy, (*self.oplots)[j]
           ENDFOR
           Ptr_Free, self.oplots
         ENDIF

   ENDIF
   
   <span class="comments">; If nothing to add, return.</span>
   IF N_Elements(oplotObject) EQ 0 THEN BEGIN
       IF Ptr_Valid(self.oplots) EQ 0 THEN self.oplots = Ptr_New(/ALLOCATE_HEAP)
       RETURN
   ENDIF
   
   <span class="comments">; Otherwise, add the overplot objects.</span>
   IF Ptr_Valid(self.oplots) THEN BEGIN
       *self.oplots = [*self.oplots, oplotObject]
   ENDIF ELSE BEGIN
       self.oplots = Ptr_New(oplotObject)
   ENDELSE
   
   <span class="comments">; Draw the object?</span>
   IF Keyword_Set(draw) THEN self -> Draw
   
END



<span class="comments">;+</span>
<span class="comments">; This event handler will adjust the data Y range of the line plot to include all</span>
<span class="comments">; of the data in the current data X range, even if that data is currently not being</span>
<span class="comments">; displayed. </span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;    event: in, optional, type=structure</span>
<span class="comments">;        The event structure passed by the window manager. Not used in this event handler.</span>
<span class="comments">;-</span>
PRO cgZPlot::AdjustRange, event

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
      
   <span class="comments">; Get the current X range of the data display.</span>
   xrange = *self.xrange
   
   <span class="comments">; Locate the end points of that data range in the original data vector.</span>
   endpoints = 0 > Value_Locate(*self.indep, xrange) &lt<span class="comments">; (N_Elements(*self.indep)-1)</span>
   
   <span class="comments">; Find the corresponding points in the dependent data vector, and calculate the</span>
   <span class="comments">; Y range from those.</span>
   points = (*self.dep)[endpoints[0]:endpoints[1]]
   minrange = Min(points, Max=maxrange)
   fudge = Abs(maxrange-minrange) * 0.05
   *self.yrange = [minrange-fudge, maxrange+fudge]
   
   <span class="comments">; Redraw the plot.</span>
   self -> Draw
END


<span class="comments">;+</span>
<span class="comments">; Button down events are processed in this event handler method. Depending</span>
<span class="comments">; on which button is pressed and where the button is pressed in the graphics</span>
<span class="comments">; window, this method will either handle or dispatch the event to the appropriate </span>
<span class="comments">; event handler.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::Button_Events, event

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; Only interested in button down events.</span>
   IF event.type NE 0 THEN RETURN
   
   <span class="comments">; Left or right button determines the "mode" of the draw widget.</span>
   <span class="comments">; Left button (1) is zoom, right button (4) is pan. Everything else</span>
   <span class="comments">; is ignored.</span>
   CASE event.press OF
      1: mode = 0
      4: mode = 1
      ELSE: RETURN
   ENDCASE
   
   <span class="comments">; Where the click is determines what we do next. If the click is below bottom the X axis,</span>
   <span class="comments">; we will zoom the X axis out. If the click is above the top X axis, we will zoom the X axis </span>
   <span class="comments">; in. If the click is to the left of the Y axis we will zoom the Y axis out, if the click is</span>
   <span class="comments">; to the right of the Y axis we will zoom the Y axis in.</span>
   IF ~self -> InsidePlot(event.x, event.y) THEN BEGIN
      
      <span class="comments">; Need to do exact axis scaling to do smooth panning and zooming.</span>
      IF N_Elements(*self.xstyle) NE 0 THEN *self.xstyle = *self.xstyle && 1 ELSE *self.xstyle = 1
      IF N_Elements(*self.ystyle) NE 0 THEN *self.ystyle = *self.ystyle && 1 ELSE *self.ystyle = 1
      
      <span class="comments">; Convert the click to normalized coordinates.</span>
      !X = self.bangX
      !Y = self.bangY
      !P = self.bangP
      WSet, self.wid
      xy = Convert_Coord(event.x, event.y, /Device, /To_Normal)
      xn = xy[0]
      yn = xy[1]
      zf = self.zoomfactor
      
      <span class="comments">; Click is below bottom X axis.</span>
      IF (xn GT !X.Window[0]) && (xn LT !X.Window[1]) && (yn LT !Y.Window[0]) THEN BEGIN
          distance = Abs((*self.xrange)[1] - (*self.xrange)[0]) * zf
          (*self.xrange)[0] = ((*self.xrange)[0] - distance) > self.orig_xrange[0]
          (*self.xrange)[1] = ((*self.xrange)[1] + distance) &lt<span class="comments">; self.orig_xrange[1]</span>
      ENDIF
      
      <span class="comments">; Click is above the top X axis.</span>
      IF (xn GT !X.Window[0]) && (xn LT !X.Window[1]) && (yn GT !Y.Window[1]) THEN BEGIN
          distance = Abs((*self.xrange)[1] - (*self.xrange)[0]) * zf
          (*self.xrange)[0] = ((*self.xrange)[0] + distance) > self.orig_xrange[0]
          (*self.xrange)[1] = ((*self.xrange)[1] - distance) &lt<span class="comments">; self.orig_xrange[1]</span>
          IF (*self.xrange)[0] GE (*self.xrange)[1] THEN (*self.xrange)[0] = (*self.xrange)[1] - distance
      ENDIF

      <span class="comments">; Click is to left of left Y axis.</span>
      IF (yn GT !Y.Window[0]) && (yn LT !Y.Window[1]) && (xn LT !X.Window[0]) THEN BEGIN
          distance = Abs((*self.yrange)[1] - (*self.yrange)[0]) * zf
          (*self.yrange)[0] = ((*self.yrange)[0] - distance) > self.orig_yrange[0]
          (*self.yrange)[1] = ((*self.yrange)[1] + distance) &lt<span class="comments">; self.orig_yrange[1]</span>
      ENDIF
      
      <span class="comments">; Click is to right of right Y axis.</span>
      IF (yn GT !Y.Window[0]) && (yn LT !Y.Window[1]) && (xn GT !X.Window[1]) THEN BEGIN
          distance = Abs((*self.yrange)[1] - (*self.yrange)[0]) * zf
          (*self.yrange)[0] = ((*self.yrange)[0] + distance) > self.orig_yrange[0]
          (*self.yrange)[1] = ((*self.yrange)[1] - distance) &lt<span class="comments">; self.orig_yrange[1]</span>
          IF (*self.yrange)[0] GE (*self.yrange)[1] THEN (*self.yrange)[0] = (*self.yrange)[1] - distance
      ENDIF
      
      self -> Draw
      RETURN
      
   ENDIF
   
   <span class="comments">; Store the current click location.</span>
   self.x0 = event.x
   self.y0 = event.y
   
   <span class="comments">; Send the event to the proper event handler, depending on the mode.</span>
   Widget_Control, self.drawID, /Clear_Events
   CASE mode OF
       0: BEGIN <span class="comments">; Zooming</span>
          Widget_Control, self.drawID, Set_UValue={method:'Zoom_Events', object:self}
          END
       1: BEGIN <span class="comments">; Panning</span>
          Widget_Control, self.drawID, Set_UValue={method:'Pan_Events', object:self}
          self. drag = 1
          END
   ENDCASE
   
   <span class="comments">; Turn motion events on for this widget.</span>
   Widget_Control, self.drawID, DRAW_MOTION_EVENTS=1
     
END

<span class="comments">;+</span>
<span class="comments">; This method copies the contents of the pixmap into the display window.</span>
<span class="comments">;-</span>
PRO cgZPlot::CopyPixmap

    Compile_Opt idl2
    
    WSet, self.wid
    Device, Copy=[0, 0, self.xsize, self.ysize, 0, 0, self.pixmapID]

END   

<span class="comments">;+</span>
<span class="comments">; This method destroys the object and the GUI, if it still exists.</span>
<span class="comments">;-</span>
PRO cgZplot::Destroy
   Obj_Destroy, self
END

<span class="comments">;+</span>
<span class="comments">; This is the standard drawing method for the object. For smooth operation,</span>
<span class="comments">; the graphics are pixmap buffered. The plot is drawn into the pixmap, then</span>
<span class="comments">; copied to the draw widget window.</span>
<span class="comments">;-</span>
PRO cgZPlot::Draw

    Compile_Opt idl2
    
    <span class="comments">; Standard error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
    ENDIF
   
    WSet, self.pixmapID
    cgErase
    
   
    <span class="comments">; Draw the plot itself.</span>
    self -> DrawPlot
           
    <span class="comments">; Save the plot system variables.</span>
    self.bangX = !X
    self.bangY = !Y
    self.bangP = !P
   
    <span class="comments">; Make sure we are drawing into the right window.</span>
    WSet, self.wid
    Device, Copy=[0, 0, self.xsize, self.ysize, 0, 0, self.pixmapID]
    
    <span class="comments">; We need to save the current position of the plot in the window,</span>
    <span class="comments">; so we can determine if clicks are inside or outside this position.</span>
    self.current_position = [!X.Window[0], !Y.Window[0], !X.Window[1], !Y.Window[1]]
    
    <span class="comments">; Save the current configuration on the undoList.</span>
    IF self.drag EQ 0 THEN self -> UndoList
    
END

<span class="comments">;+</span>
<span class="comments">; This method simply gets the keywords it needs and draws the line plot.</span>
<span class="comments">; It was created primarily so the OUTPUT keyword could be used with the</span>
<span class="comments">; cgPlot command, since all the file output infrastruction has been built</span>
<span class="comments">; into that command.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    </span>
<span class="comments">;     output: in, optional, type=string</span>
<span class="comments">;         The name of the output file. File type is determined by the file extension.</span>
<span class="comments">;-</span>
PRO cgZPlot::DrawPlot, OUTPUT=output

    Compile_Opt idl2
    
    <span class="comments">; Standard error handling.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
    ENDIF

   <span class="comments">; Get the graphics keywords.</span>
   self -> cgGraphicsKeywords::GetProperty, $
        AXISCOLOR=axiscolor, $
        BACKGROUND=background, $
        CHARSIZE=charsize, $
        CHARTHICK=charthick, $
        CLIP=clip, $
        COLOR=color, $
        DATA=data, $
        DEVICE=device, $
        NORMAL=normal, $
        FONT=font, $
        NOCLIP=noclip, $
        NODATA=nodata, $
        NOERASE=noerase, $
        POSITION=position, $
        PSYM=psym, $
        SUBTITLE=subtitle, $
        SYMSIZE=symsize, $
        T3D=t3d, $
        THICK=thick, $
        TICKLEN=ticklen, $
        TITLE=title, $
        
        XCHARSIZE=xcharsize, $
        XGRIDSTYLE=xgridstyle, $
        XMARGIN=xmargin, $
        XMINOR=xminor, $
        XRANGE=xrange, $
        XSTYLE=xstyle, $
        XTHICK=xthick, $
        XTICK_GET=xtick_get, $
        XTICKFORMAT=xtickformat, $
        XTICKINTERVAL=xtickinterval, $
        XTICKLAYOUT=xticklayout, $
        XTICKLEN=xticklen, $
        XTICKNAME=xtickname, $
        XTICKS=xticks, $
        XTICKUNITS=xtickunits, $
        XTICKV=xtickv, $
        XTITLE=xtitle, $
        
        YCHARSIZE=ycharsize, $
        YGRIDSTYLE=ygridstyle, $
        YMARGIN=ymargin, $
        YMINOR=yminor, $
        YRANGE=yrange, $
        YSTYLE=ystyle, $
        YTHICK=ythick, $
        YTICK_GET=ytick_get, $
        YTICKFORMAT=ytickformat, $
        YTICKINTERVAL=ytickinterval, $
        YTICKLAYOUT=yticklayout, $
        YTICKLEN=yticklen, $
        YTICKNAME=ytickname, $
        YTICKS=yticks, $
        YTICKUNITS=ytickunits, $
        YTICKV=ytickv, $
        YTITLE=ytitle, $
       
        ZCHARSIZE=zcharsize, $
        ZGRIDSTYLE=zgridstyle, $
        ZMARGIN=zmargin, $
        ZMINOR=zminor, $
        ZRANGE=zrange, $
        ZSTYLE=zstyle, $
        ZTHICK=zthick, $
        ZTICK_GET=ztick_get, $
        ZTICKFORMAT=ztickformat, $
        ZTICKINTERVAL=ztickinterval, $
        ZTICKLAYOUT=zticklayout, $
        ZTICKLEN=zticklen, $
        ZTICKNAME=ztickname, $
        ZTICKS=zticks, $
        ZTICKUNITS=ztickunits, $
        ZTICKV=ztickv, $
        ZTITLE=ztitle, $
        ZVALUE=zvalue
        
   <span class="comments">; Draw the plot.</span>
   cgPlot, *self.indep, *self.dep, $
        OUTPUT=output, $
        ASPECT=*self.aspect, $
        LABEL=self.label, $
        MAX_VALUE=*self.max_value, $
        MIN_VALUE=*self.min_value, $
        XLOG=*self.xlog, $
        YLOG=*self.ylog, $
        YNOZERO=*self.ynozero, $
        AXISCOLOR=axiscolor, $
        BACKGROUND=background, $
        CHARSIZE=charsize, $
        CHARTHICK=charthick, $
        CLIP=clip, $
        COLOR=color, $
        DATA=data, $
        DEVICE=device, $
        NORMAL=normal, $
        FONT=font, $
        LEGENDS=*self.legends, $
        NOCLIP=noclip, $
        NODATA=nodata, $
        NOERASE=noerase, $
        OPLOTS=*self.oplots, $
        POSITION=position, $
        PSYM=psym, $
        SUBTITLE=subtitle, $
        SYMSIZE=symsize, $
        T3D=t3d, $
        THICK=thick, $
        TICKLEN=ticklen, $
        TITLE=title, $
        XCHARSIZE=xcharsize, $
        XGRIDSTYLE=xgridstyle, $
        XMARGIN=xmargin, $
        XMINOR=xminor, $
        XRANGE=xrange, $
        XSTYLE=xstyle, $
        XTHICK=xthick, $
        XTICK_GET=xtick_get, $
        XTICKFORMAT=xtickformat, $
        XTICKINTERVAL=xtickinterval, $
        XTICKLAYOUT=xticklayout, $
        XTICKLEN=xticklen, $
        XTICKNAME=xtickname, $
        XTICKS=xticks, $
        XTICKUNITS=xtickunits, $
        XTICKV=xtickv, $
        XTITLE=xtitle, $
        YCHARSIZE=ycharsize, $
        YGRIDSTYLE=ygridstyle, $
        YMARGIN=ymargin, $
        YMINOR=yminor, $
        YRANGE=yrange, $
        YSTYLE=ystyle, $
        YTHICK=ythick, $
        YTICK_GET=ytick_get, $
        YTICKFORMAT=ytickformat, $
        YTICKINTERVAL=ytickinterval, $
        YTICKLAYOUT=yticklayout, $
        YTICKLEN=yticklen, $
        YTICKNAME=ytickname, $
        YTICKS=yticks, $
        YTICKUNITS=ytickunits, $
        YTICKV=ytickv, $
        YTITLE=ytitle, $
        ZCHARSIZE=zcharsize, $
        ZGRIDSTYLE=zgridstyle, $
        ZMARGIN=zmargin, $
        ZMINOR=zminor, $
        ZRANGE=zrange, $
        ZSTYLE=zstyle, $
        ZTHICK=zthick, $
        ZTICK_GET=ztick_get, $
        ZTICKFORMAT=ztickformat, $
        ZTICKINTERVAL=ztickinterval, $
        ZTICKLAYOUT=zticklayout, $
        ZTICKLEN=zticklen, $
        ZTICKNAME=ztickname, $
        ZTICKS=zticks, $
        ZTICKUNITS=ztickunits, $
        ZTICKV=ztickv, $
        ZTITLE=ztitle, $
        ZVALUE=zvalue
        
END


<span class="comments">;+</span>
<span class="comments">; This method simply erases the display.</span>
<span class="comments">;-</span>
PRO cgZPlot::Erase

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
 
    WSet, self.pixmapID
    cgErase
    self -> CopyPixmap
    
END



<span class="comments">;+</span>
<span class="comments">; This event handler method allows the plot in the graphics window to be output</span>
<span class="comments">; to a file.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::FileOutput, event

    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; What kind of output does the user want?</span>
   Widget_Control, event.id, Get_Value=fileType
   CASE StrUpCase(fileType) OF
      'BMP FILE':  filename = 'cgzplot.bmp'
      'GIF FILE':  filename = 'cgzplot.gif'
      'EPS FILE':  filename = 'cgzplot.eps'
      'JPEG FILE': filename = 'cgzplot.jpg'
      'PDF FILE':  filename = 'cgzplot.pdf'
      'PNG FILE':  filename = 'cgzplot.png'
      'PS FILE':   filename = 'cgzplot.ps'
      'TIFF FILE': filename = 'cgzplot.tif'
   ENDCASE
   
   IF self.saveDir NE "" THEN thisDir = self.saveDir ELSE CD, CURRENT=thisDir
   
   filename = cgPickfile(PATH=thisDir, File=filename, GET_PATH=saveDir, $
       Title='Save Plot As...', /Write)
   IF filename EQ "" THEN RETURN
   
   self.saveDir = saveDir
   self -> DrawPlot, OUTPUT=filename
   
   
END

<span class="comments">;+</span>
<span class="comments">; The properties of the object (keywords) are retrieved with this method.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     aspect: out, optional, type=float</span>
<span class="comments">;        A value that represents the aspect ratio (ysize/xsize) of the resulting plot. </span>
<span class="comments">;     label: out, optional, type=string</span>
<span class="comments">;         The label that is used for the zoom plot.</span>
<span class="comments">;     legends: out, optional, type=object</span>
<span class="comments">;         The current legend objects, if there are any. If not, a null object.</span>
<span class="comments">;     max_value: out, optional, type=float</span>
<span class="comments">;         The maximum value to plot. </span>
<span class="comments">;     min_value: out, optional, type=float</span>
<span class="comments">;         The minimum value to plot. </span>
<span class="comments">;     oplots: out, optional, type=object</span>
<span class="comments">;         The current overplot objects, if there are any. If not, a null object.</span>
<span class="comments">;     undolist: out, optional, type=objref</span>
<span class="comments">;         The LinkedList object that maintains the undo list.</span>
<span class="comments">;     xlog: out, optional, type=boolean</span>
<span class="comments">;         Set if a logarithmic X axis is used in the plot.</span>
<span class="comments">;     ylog: out, optional, type=boolean</span>
<span class="comments">;         Set if a logarithmic Y axis is used in the plot.</span>
<span class="comments">;     ynozero: out, optional, type=boolean</span>
<span class="comments">;         Set if this property of the plot is set.</span>
<span class="comments">;     zoomfactor: out, optional, type=float</span>
<span class="comments">;         Set to the current zoom factor.</span>
<span class="comments">;     _ref_extra: out, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDL Plot or Coyote Graphic cgPlot command is </span>
<span class="comments">;        allowed in the program.</span>
<span class="comments">;-</span>
PRO cgZPlot::GetProperty, $
        DATA_X=indep, $
        DATA_Y=dep, $
        ASPECT=aspect, $
        LABEL=label, $
        LEGENDS=legends, $
        MAX_VALUE=max_value, $
        MIN_VALUE=min_value, $
        OPLOTS=oplots, $
        UNDOLIST=undolist, $
        XLOG=xlog, $
        YLOG=ylog, $
        YNOZERO=ynozero, $
        ZOOMFACTOR=zoomfactor, $
        _REF_EXTRA=extra
        
    Compile_Opt idl2
    
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   
    IF Arg_Present(indep) NE 0 THEN IF N_Elements(*self.indep) NE 0 THEN indep = *self.indep
    IF Arg_Present(dep) NE 0 THEN IF N_Elements(*self.dep) NE 0 THEN dep = *self.dep
    IF Arg_Present(aspect) NE 0 THEN IF N_Elements(*self.aspect) NE 0 THEN aspect = *self.aspect
    IF Arg_Present(label) NE 0 THEN IF N_Elements(self.label) NE 0 THEN label = self.label
    IF Arg_Present(legends) NE 0 THEN IF Ptr_Valid(self.legends) $
        THEN legends = *self.legends $
        ELSE legends = Obj_New()
    IF Arg_Present(max_value) NE 0 THEN IF N_Elements(*self.max_value) NE 0 THEN max_value = *self.max_value
    IF Arg_Present(min_value) NE 0 THEN IF N_Elements(*self.min_value) NE 0 THEN min_value = *self.min_value
    IF Arg_Present(oplots) NE 0 THEN IF Ptr_Valid(self.oplots) $
        THEN oplots = *self.oplots $
        ELSE oplots = Obj_New()
    IF Arg_Present(xlog) NE 0 THEN IF N_Elements(*self.xlog) NE 0 THEN xlog = *self.xlog
    IF Arg_Present(ylog) NE 0 THEN IF N_Elements(*self.ylog) NE 0 THEN ylog = *self.ylog
    IF Arg_Present(ynozero) NE 0 THEN IF N_Elements(*self.ynozero) NE 0 THEN ynozero = *self.ynozero
    IF Arg_Present(zoomfactor) NE 0 THEN zoomfactor = self.zoomfactor
    
    <span class="comments">; Get superclass properties.</span>
    IF N_Elements(extra) NE 0 THEN self -> cgGraphicsKeywords::GetProperty, _STRICT_EXTRA=extra
END

<span class="comments">;+</span>
<span class="comments">; This  method  simply determines if a button click is inside (returns 1)</span>
<span class="comments">; or outside (returns 0) the plot boundaries, determined by the plot axes.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    x: in, required, type=int</span>
<span class="comments">;        The X location of the button click in device coordinates.</span>
<span class="comments">;    y: in, required, type=int</span>
<span class="comments">;        The Y location of the button click in device coordinates.</span>
<span class="comments">;-</span>
FUNCTION cgZPlot::InsidePlot, x, y

    Compile_Opt idl2
    
    On_Error, 2
    
    <span class="comments">; Convert device coordinate location to normalized coordinate location.</span>
    <span class="comments">; Make sure you have the right system variables and window open.</span>
    bangx = !X
    bangy = !Y
    bangp = !P
    !X = self.bangx
    !Y = self.bangy
    !P = self.bangp
    WSet, self.pixmapID
    
    <span class="comments">; Do the conversion.</span>
    xy = Convert_Coord(x, y, /Device, /To_Normal)
    xpt = xy[0]
    ypt = xy[1]
    
    <span class="comments">; Restore the system variables.</span>
    !X = bangx
    !Y = bangy
    !P = bangp
    
    <span class="comments">; Is this within the plot boundaries?</span>
    p = self.current_position
    IF (xpt LT p[0]) || (xpt gt p[2]) || (ypt LT p[1]) || (ypt GT p[3]) THEN RETURN, 0 ELSE RETURN, 1
    
END


<span class="comments">;+</span>
<span class="comments">; The purpose of this method is to draw the initial line plot in the draw widget.</span>
<span class="comments">; </span>
<span class="comments">;-</span>
PRO cgZPlot::Notify_Realize

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF

    Widget_Control, self.drawID, Get_Value=wid
    self.wid = wid
    
     <span class="comments">; Draw the initial plot.</span>
    self -> Draw
    
END


<span class="comments">;+</span>
<span class="comments">; This event handler method responds to panning events until it gets a button UP event.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::Pan_Events, event


   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
    <span class="comments">; Is this a button UP event? If it is, then we are done here.</span>
    IF event.type EQ 1 THEN BEGIN
    
      <span class="comments">; Turn motion events off for this widget and clear all subsequent events.</span>
      <span class="comments">; Restore the original event handler.</span>
      Widget_Control, self.drawID, Draw_Motion_Events=0
      Widget_Control, self.drawID, /Clear_Events
      Widget_Control, self.drawID, Set_UValue={method:'Button_Events', object:self}
      self.drag = 0
    ENDIF
    
    <span class="comments">; Determine the end points of the pan and draw the plot. We are panning only in</span>
    <span class="comments">; the X direction. The Y axes will reflect ALL the data points in the X range.</span>
    <span class="comments">; Deterime the distance traveled in the XRange since you were last here.</span>
    xpts = [self.x0, event.x]
    ypts = [self.y0, event.y]
    
    <span class="comments">; Locate these points in the data coordinate space.</span>
    !X = self.bangX
    !Y = self.bangY
    !P = self.bangP
    WSet, self.wid
    xd = Convert_Coord(xpts, ypts, /Device, /To_Data)
    xdistance = (xd[0,0] - xd[0,1])
    ydistance = (xd[1,0] - xd[1,1])
    IF *self.xlog THEN BEGIN
        *self.xrange = (*self.xrange + xdistance) > 1e-6
    ENDIF ELSE BEGIN
        *self.xrange = (*self.xrange + xdistance)
    ENDELSE
    IF *self.ylog THEN BEGIN
        *self.yrange = (*self.yrange + ydistance) > 1e-6
    ENDIF ELSE BEGIN
        *self.yrange = (*self.yrange + ydistance)
    ENDELSE
    
    <span class="comments">; Update the static pan location.</span>
    self.x0 = event.x
    self.y0 = event.y
    
    <span class="comments">; Draw the plot.</span>
    self -> Draw
    
END


<span class="comments">;+</span>
<span class="comments">; This method resizes the draw widget.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">; </span>
<span class="comments">;    xsize: in, required, type=integer</span>
<span class="comments">;        The requested X size of the draw widget.</span>
<span class="comments">;    ysize: in, required, type=integer</span>
<span class="comments">;        The requested Y size of the draw widget.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">; </span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;        If this keyword is set, the DRAW method is called after the widget is resized.</span>
<span class="comments">;-</span>
PRO cgZPlot::ResizeDrawWidget, xsize, ysize, DRAW=draw

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; Delete and recreate the pixmap at the right size. </span>
   WDelete, self.pixmapID
   Window, /Pixmap, /Free, XSize=xsize, YSize=ysize
   self.pixmapID = !D.Window
   
   <span class="comments">; Make the draw widget the right size.</span>
   Widget_Control, self.drawID, Draw_XSize=xsize, Draw_YSize=ysize
   self.xsize = xsize
   self.ysize = ysize

    <span class="comments">; Draw the plot?</span>
    IF Keyword_Set(draw) THEN self -> Draw
    
END


<span class="comments">;+</span>
<span class="comments">; This method allow plot keywords to be set to appropriate values.</span>
<span class="comments">; </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;</span>
<span class="comments">;     aspect: in, optional, type=float, default=none</span>
<span class="comments">;        Set this keyword to a floating point ratio that represents the aspect ratio </span>
<span class="comments">;        (ysize/xsize) of the resulting plot. The plot position may change as a result</span>
<span class="comments">;        of setting this keyword. Note that `Aspect` cannot be used when plotting with</span>
<span class="comments">;        !P.MULTI.</span>
<span class="comments">;     dep: in, optional, type=any</span>
<span class="comments">;         The dependent data to plot.</span>
<span class="comments">;     draw: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword if you would like to immediately draw the plot after properties are set.</span>
<span class="comments">;     indep: in, optional, type=any</span>
<span class="comments">;         The independent data to plot.</span>
<span class="comments">;     label: in, optional, type=string</span>
<span class="comments">;         A label is similar to a plot title, but it is aligned to the left edge</span>
<span class="comments">;         of the plot and is written in hardware fonts. Use of the label keyword</span>
<span class="comments">;         will suppress the plot title.</span>
<span class="comments">;     legends: in, optional, type=object</span>
<span class="comments">;         A single cgLegendItem object, or an array of cgLegendItem objects that will be</span>
<span class="comments">;         drawn on the plot as a legend.</span>
<span class="comments">;     max_value: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the maximum value to plot. Any values greater than this </span>
<span class="comments">;        value are treated as missing.</span>
<span class="comments">;     min_value: in, optional, type=float</span>
<span class="comments">;        Set this keyword to the minimu value to plot. Any values smaller than this </span>
<span class="comments">;        value are treated as missing.</span>
<span class="comments">;     oplots: in, optional, type=object</span>
<span class="comments">;         A single cgOverPlot object, or an array of cgOverPlot objects that will be</span>
<span class="comments">;         overplot on the axes set up by the original data.</span>
<span class="comments">;     xlog: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to use a logarithmic X axis</span>
<span class="comments">;     ylog: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to use a logarithmic Y axis</span>
<span class="comments">;     ynozero: in, optional, type=boolean, default=0</span>
<span class="comments">;         Set this keyword to use allow the Y axis to start at a value other than zero.</span>
<span class="comments">;     zoomfactor: in, optional, type=float</span>
<span class="comments">;         Set this keyword to a number between 0.01 and 0.25. This affects the amount</span>
<span class="comments">;         of zooming when the X axis and Y axis are zoomed with the LEFT mouse button.</span>
<span class="comments">;         The default value is 0.05 or five percent of the current axis range on each</span>
<span class="comments">;         end of the axis, resulting in a 10 percent change in the axis length.</span>
<span class="comments">;     _extra: in, optional, type=any</span>
<span class="comments">;        Any keyword appropriate for the IDL Plot or Coyote Graphic cgPlot command is </span>
<span class="comments">;        allowed in the program.</span>
<span class="comments">;-</span>
PRO cgZPlot::SetProperty, $
        ASPECT=aspect, $
        DEP=dep, $
        DRAW=draw, $
        INDEP=indep, $
        LABEL=label, $
        LEGENDS=legends, $
        MAX_VALUE=max_value, $
        MIN_VALUE=min_value, $
        OPLOTS=oplots, $
        XLOG=xlog, $
        YLOG=ylog, $
        YNOZERO=ynozero, $
        ZOOMFACTOR=zoomfactor, $
        _EXTRA=extra
        
   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
    
    IF N_Elements(indep) NE 0 THEN *self.indep = indep
    IF N_Elements(dep) NE 0 THEN *self.dep = dep
    IF N_Elements(aspect) NE 0 THEN *self.aspect = aspect
    IF N_Elements(label) NE 0 THEN self.label = label
    IF N_Elements(legends) NE 0 THEN self -> AddLegends, legends, /Clear
    IF N_Elements(max_value) NE 0 THEN *self.max_value = max_value
    IF N_Elements(min_value) NE 0 THEN *self.min_value = min_value
    IF N_Elements(oplots) NE 0 THEN self -> AddOverplots, oplots, /Clear
    IF N_Elements(xlog) NE 0 THEN *self.xlog = Keyword_Set(xlog)
    IF N_Elements(ylog) NE 0 THEN *self.ylog = Keyword_Set(ylog)
    IF N_Elements(ynozero) NE 0 THEN *self.ynozero = Keyword_Set(ynozero)
    IF N_Elements(zoomfactor) NE 0 THEN self.zoomfactor = zoomfactor
    
    <span class="comments">; Superclass keywords.</span>
    IF N_Elements(extra) NE 0 THEN self -> cgGraphicsKeywords::SetProperty, _STRICT_EXTRA=extra
    
    <span class="comments">; Need to draw the plot?</span>
    IF Keyword_Set(draw) THEN self -> Draw
        
END

<span class="comments">;+</span>
<span class="comments">; This event handler method destroys the widget program.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::Quit, event

   Widget_Control, event.top, /Destroy

END


<span class="comments">;+</span>
<span class="comments">; This method performs the REDO action and restores the plot to</span>
<span class="comments">; it's previous condition.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, optional, type=structure</span>
<span class="comments">;        The event structure passed by the window manager. Not used in this method.</span>
<span class="comments">;-</span>
PRO cgZPlot::Redo, event

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; Get the list count. Return if there is nothing in the list</span>
   listCnt = self.redoList -> Get_Count()
   IF listCnt EQ 0 THEN BEGIN
      void = Dialog_Message('Nothing to REDO')
      RETURN
   ENDIF
   
   <span class="comments">; Retrieve the last item on this list.</span>
   item = self.redoList -> Get_Item()
   
   <span class="comments">; Remove the last item from the list.</span>
   IF listCnt GT 1 THEN self.redoList -> Delete

   <span class="comments">; Update the range variables and draw the plot.</span>
   IF listCnt GE 1 THEN BEGIN
     *self.xrange = item.xrange
     *self.yrange = item.yrange
     self -> Draw
   ENDIF
   
END


<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; This event handler method resizes the graphics window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::TLB_Resize_Events, event

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   WDelete, self.pixmapID
   Window, /Pixmap, /Free, XSize=event.x, YSize=event.y
   self.pixmapID = !D.Window
   Widget_Control, self.drawID, Draw_XSize=event.x, Draw_YSize=event.y
   self.xsize = event.x
   self.ysize = event.y
   self -> Draw
   
END


<span class="comments">;+</span>
<span class="comments">; This method performs the UNDO action and restores the plot to</span>
<span class="comments">; it's previous condition.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, optional, type=structure</span>
<span class="comments">;        The event structure passed by the window manager. Not used in this method.</span>
<span class="comments">;-</span>
PRO cgZPlot::Undo, event

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; Get the list count. Return if there is nothing in the list</span>
   listCnt = self.undoList -> Get_Count()
   IF listCnt EQ 0 THEN RETURN
   
   <span class="comments">; Retrieve the last item from the list, and add it to the REDO list.</span>
   item = self.undoList -> Get_Item()
   self.redoList -> Add, item
   
   <span class="comments">; Remove the last item from the list.</span>
   IF listCnt GT 1 THEN self.undoList -> Delete
   
   <span class="comments">; Get the last item on the list.</span>
   item = self.undoList -> Get_Item()
   
   <span class="comments">; Now remove this item from the list, too, if it is not the last one</span>
   IF listCnt GT 1 THEN self.undoList -> Delete
   
   <span class="comments">; Set the ranges and redraw the plot.</span>
   IF listCnt GE 1 THEN BEGIN
     *self.xrange = item.xrange
     *self.yrange = item.yrange
     self -> Draw
   ENDIF
   
END


<span class="comments">;+</span>
<span class="comments">; This method maintains the UNDO list. The list has a maximum undo capacity of 50.</span>
<span class="comments">;-</span>
PRO cgZPlot::UndoList

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
   <span class="comments">; Prepare the structure that will be stored on the list.</span>
   IF N_Elements(*self.xrange) EQ 0 THEN *self.xrange = self.orig_xrange
   IF N_Elements(*self.yrange) EQ 0 THEN *self.yrange = self.orig_yrange
   undoStruct = {xrange:*self.xrange, yrange:*self.yrange}
   
   <span class="comments">; How many items are on the list already? If 50, delete the first</span>
   <span class="comments">; item on the list.</span>
   listCnt = self.undoList -> Get_Count()
   IF listCnt GE 50 THEN self.undoList -> Delete, 0
   
   <span class="comments">; Add the item to the list.</span>
   self.undoList -> Add, undoStruct

END


<span class="comments">;+</span>
<span class="comments">; This event handler method allows the user to create a rubber-band box for zooming</span>
<span class="comments">; into the line plot.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot::Zoom_Events, event

    <span class="comments">; Is this a button UP event? If it is, all the action is done here.</span>
    <span class="comments">; If it is not, then it must be a MOTION event, and we simply draw</span>
    <span class="comments">; and erase the zoom box.</span>
    
   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
    <span class="comments">; What kind of event is this?</span>
    CASE event.type OF
        1: BEGIN <span class="comments">; button UP event</span>
        
           <span class="comments">; Turn motion events off for this widget and clear all subsequent events.</span>
           <span class="comments">; Restore the original event handler.</span>
           Widget_Control, self.drawID, Draw_Motion_Events=0
           Widget_Control, self.drawID, /Clear_Events
           Widget_Control, self.drawID, Set_UValue={method:'Button_Events', object:self}
           self -> CopyPixmap
           
           xtest = [self.x0, event.x]
           ytest = [self.y0, event.y]
           x = [Min(xtest), Max(xtest)]
           y = [Min(ytest), Max(ytest)]
           
           <span class="comments">; Make sure the up event is inside the plot.</span>
           !X = self.bangX
           !Y = self.bangY
           !P = self.bangP
           xy = Convert_Coord(x, y, /Device, /To_Normal)
           p = self.current_position
           xn = p[0] > xy[0,*] &lt<span class="comments">; p[2]</span>
           yn = p[1] > xy[1,*] &lt<span class="comments">; p[3]</span>
           
           <span class="comments">; Convert these normalized coordinates to data coordinates.</span>
           xy = Convert_Coord(xn, yn, /Normal, /To_Data)
           xd = Reform(xy[0,*])
           yd = Reform(xy[1,*])
           
           <span class="comments">; The range depends on whether you are using log axes or not.</span>
           IF *self.xlog THEN BEGIN
              x = 10^!X.CRange[0] > xd &lt<span class="comments">; 10^!X.CRange[1]</span>
           ENDIF ELSE BEGIN
              x = !X.CRange[0] > xd &lt<span class="comments">; !X.CRange[1]</span>
           ENDELSE
           IF *self.ylog THEN BEGIN
              y = 10^!Y.CRange[0] > yd &lt<span class="comments">; 10^!Y.CRange[1]</span>
           ENDIF ELSE BEGIN
              y = !Y.CRange[0] > yd &lt<span class="comments">; !Y.CRange[1]</span>
           ENDELSE
           *self.xrange = x
           *self.yrange = y
            
           <span class="comments">; Draw the plot.</span>
           self -> Draw
           END
           
        2: BEGIN <span class="comments">; motion event</span>
        
           <span class="comments">; Erase whatever is currently on the display.</span>
           self -> CopyPixmap
           
           <span class="comments">; Draw the new box.</span>
           x = [self.x0, self.x0, event.x, event.x, self.x0]
           y = [self.y0, event.y, event.y, self.y0, self.y0]
           PlotS, x, y, Color=cgColor('NAVY'), Thick=2, /Device
           END
        ELSE: 
    ENDCASE

END


<span class="comments">;+</span>
<span class="comments">; This is the main event handler for the program. All events come here</span>
<span class="comments">; to be distributed to the appropriate event handler method according</span>
<span class="comments">; to instructions packed into the UVALUE of any widget generating an</span>
<span class="comments">; event.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    event: in, required, type=structure</span>
<span class="comments">;        The event structure passed by the window manager.</span>
<span class="comments">;-</span>
PRO cgZPlot_Events, event

   Compile_Opt idl2
   
   <span class="comments">; Standard error handling.</span>
   Catch, theError
   IF theError NE 0 THEN BEGIN
      Catch, /Cancel
      void = Error_Message()
      RETURN
   ENDIF
   
    Widget_Control, event.id, Get_UValue=instructions
    Call_Method, instructions.method, instructions.object, event

END

<span class="comments">;+</span>
<span class="comments">; This is the cleanup routine for the widget. Its function is to destroy</span>
<span class="comments">; the underlying program object.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    tlb: in, required, type=int</span>
<span class="comments">;        The widget identifier of the top-level base widget that just died.</span>
<span class="comments">;-</span>
PRO cgZPlot_Cleanup, tlb

   Widget_Control, tlb, Get_UValue=instr
   Obj_Destroy, instr.object
   
END

<span class="comments">;+</span>
<span class="comments">; This is the realize notify routine for the widget. Its function call the</span>
<span class="comments">; Realize_Notify method to draw the initial plot in the display window.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    id: in, required, type=int</span>
<span class="comments">;        The widget identifier of the widget that has been realized.</span>
<span class="comments">;-</span>
PRO cgZPlot_Notify_Realize, id

   Widget_Control, id, Get_UValue=instructions
   Call_Method, 'Notify_Realize', instructions.object
   
END
<span class="comments">;+</span>
<span class="comments">; The object class definition.</span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    class: out, optional, type=struct</span>
<span class="comments">;        The class definition object. Often helpful for obtaining fields of the object structure.</span>
<span class="comments">;-</span>
PRO cgZPlot__Define, class

   Compile_Opt idl2
   
   class = { cgZPLOT, $
             INHERITS cgGraphicsKeywords, $
             ASPECT: Ptr_New(), $
             MAX_VALUE: Ptr_New(), $
             MIN_VALUE: Ptr_New(), $
             NSUM: Ptr_New(), $
             XLOG: Ptr_New(), $
             YLOG: Ptr_New(), $
             YNOZERO: Ptr_New(), $
             
             orig_xrange: DblArr(2), $
             orig_yrange: DblArr(2), $
             current_position: DblArr(4), $
             zoomFactor: 0.0, $
             undoList: Obj_New(), $
             redoList: Obj_New(), $
             oplots: Ptr_New(), $      <span class="comments">; A pointer to a cgOverPlot object or array of cgOverPlot objects.</span>
             legends: Ptr_New(), $     <span class="comments">; A pointer to a cgLegendItem object or array of cgLegendItem objects.</span>
             label: "", $              <span class="comments">; The plot label. Suppress TITLE if present.</span>
             savedir: "", $            <span class="comments">; The output directory where files are saved.</span>
             drag: 0B, $               <span class="comments">; A flag that tells me if I am panning or not. Necessary for UNDO.</span>
             
             indep: Ptr_New(), $
             dep: Ptr_New(), $
             
             tlb: 0L, $
             drawID: 0L, $
             pixmapID: 0L, $
             wid: 0L, $
             xsize: 0L, $
             ysize: 0L, $
             x0: 0L, $
             y0: 0L,$
             x1: 0L, $
             y1: 0L, $
             mode: 0B, $   0 is zoom plot, 1 is pan plot.
             bangx: !X, $
             bangy: !Y, $
             bangp: !P $
            }

END

</code>
    </div>
  </body>
</html>