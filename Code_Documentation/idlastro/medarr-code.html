<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>medarr.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="medarr.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO medarr, inarr, outarr, mask, output_mask
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MEDARR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Compute the median at each pixel across a set of 2-d images</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Each pixel in the output array contains  the median of the </span>
<span class="comments">;       corresponding pixels in the input arrays.   Useful, for example to </span>
<span class="comments">;       combine a stack of CCD images, while removing cosmic ray hits.</span>
<span class="comments">;</span>
<span class="comments">;       This routine became partially obsolete in V5.6 with the introduction</span>
<span class="comments">;       of the DIMENSION keyword to the intrinsic MEDIAN() function.   However,</span>
<span class="comments">;       it is  still useful if a input mask is needed (though it is much </span>
<span class="comments">;       faster to set invalid pixels to NaN values.)</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       MEDARR, inarr, outarr, [ mask, output_mask ]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       inarr  -- A three dimensional array containing the input arrays to </span>
<span class="comments">;                 combine together.  Each of the input arrays must be two </span>
<span class="comments">;                 dimensional and must have the same dimensions.  These arrays</span>
<span class="comments">;                 should then be stacked together into a single 3-D array,</span>
<span class="comments">;                 creating INARR.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       mask   -- Same structure as inarr, byte array with 1b where</span>
<span class="comments">;                 pixels are to be included, 0b where they are to be</span>
<span class="comments">;                 excluded.    For floating point images, it is much faster to </span>
<span class="comments">;                 set masked pixels in inarr equal to !VALUES.F_NAN (see below),</span>
<span class="comments">;                 rather than use the mask parameter.</span>
<span class="comments">;                </span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       outarr -- The output array.  It will have dimensions equal to the</span>
<span class="comments">;                 first two dimensions of the input array.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUPUT:</span>
<span class="comments">;       output_mask -- Same structure as outarr, byte array with 1b</span>
<span class="comments">;                      pixels are valid, 0b where all the input pixels</span>
<span class="comments">;                      have been masked out.</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;        This procedure was *SLOW* when using the Mask parameter because it has</span>
<span class="comments">;        to loop over  each pixel of the image.  </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Suppose one wants to combine three floating point 1024 x 1024 bias </span>
<span class="comments">;       frames which have been read into the IDL variables im1,im2,im3</span>
<span class="comments">;</span>
<span class="comments">;       IDL> bigim = fltarr(1024,1024,3)        ;Create big array to hold images</span>
<span class="comments">;       IDL> bigim(0,0,0) = im1 & bigim(0,0,1) = im2 & bigim(0,0,2) = im2  </span>
<span class="comments">;       IDL> medarr, bigim, avgbias</span>
<span class="comments">;</span>
<span class="comments">;       The variable avgbias will be the desired 1024x 1024 float image.</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       If the MASK parameter is not set, then MEDARR is just a wrapper for </span>
<span class="comments">;       MEDIAN(/EVEN, dimension = 3).    If the MASK parameter is set,</span>
<span class="comments">;       a scalar median function over the third dimension is looped over </span>
<span class="comments">;       each pixel of the first two dimensions.   The /EVEN keyword is used</span>
<span class="comments">;       with MEDIAN (which averages the two middle values), since this avoids </span>
<span class="comments">;       biasing the output for an even number of images.</span>
<span class="comments">;</span>
<span class="comments">;       Any values set to NAN (not a number) are ignored when computing the</span>
<span class="comments">;       median.    If all values for a pixel location are NAN, then the median</span>
<span class="comments">;       is also returned as NAN.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by Michael R. Greason, STX, 12 June 1990.</span>
<span class="comments">;       Don't use MEDIAN function for even number of images.</span>
<span class="comments">;          W. Landsman Sep 1996</span>
<span class="comments">;       Mask added.  RS Hill, HSTX, 13 Mar. 1997</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Use /EVEN keyword to MEDIAN    W. Landsman  September 1997</span>
<span class="comments">;       Rearranged code for faster execution   W. Landsman January 1998</span>
<span class="comments">;       Faster execution for odd number of images   W. Landsman July 2000</span>
<span class="comments">;       V5.4 fix for change in SIZE() definition of undefined variable </span>
<span class="comments">;                W. Landsman/E. Young   May 2001</span>
<span class="comments">;       Use MEDIAN(/DIMEN) for V5.6 or later   W. Landsman   November 2002</span>
<span class="comments">;       Use keyword_set() instead of ARG_present() to test for presence of mask</span>
<span class="comments">;           parameter  D. Hanish/W. Landsman   June 2003</span>
<span class="comments">;       Assume since V5.6  W. Landsman  Feb 2004</span>
<span class="comments">; </span>
<span class="comments">;-</span>
 On_error,2
<span class="comments">;                       Check parameters.</span>

 if N_params() LT 2 then begin                  <span class="comments">; # parameters.</span>
        print, "Syntax -  MEDARR, inputarr, outputarr [, maskarr, output_mask]"
        return
 endif
 
 s = size(inarr)
 if s[0] NE 3 then $                    <span class="comments">; Input array size.</span>
        message, "Input array must have 3 dimensions"
 if (N_elements(mask) EQ 0) then begin
        outarr = median(inarr,dimension=3,/even)
        return
 endif

<span class="comments">;                       Create the output array.</span>
 ncol = s[1]
 nrow = s[2]
 narr = s[3]
 type = s[s[0] + 1]
 outarr = make_array( dimen = [ncol,nrow], /NOZERO, TYPE = type )
 output_mask = make_array (dimen = [ncol,nrow], VALUE = 1b)

<span class="comments">;                       Combine the input arrays into the output array.</span>

  sm = size(mask)
  if N_elements(mask) LT 4 then $ 
	 message,'Input mask not valid... must have 3 dimensions'
  w = where(sm[0:3] eq s[0:3], cw)
  if cw eq 4 then begin
     mask_given = 1b 
  endif else begin
     message,'Mask not valid... must be same shape as input cube.'
  endelse


 for j = 0l, (nrow-1) do begin    
        for i = 0l, (ncol-1) do begin
                good_pixels = 1b   
                       wmask = where(mask[i,j,*],cwm)
                       if cwm gt 0 then begin
                          marr = inarr[i,j,wmask] 
                       endif else begin
                          good_pixels = 0b
                          output_mask[i,j] = 0b
                       endelse
  
                if good_pixels then outarr[i,j] = median(marr,/EVEN)
          
        endfor
 endfor
 
 return
 end
</code>
    </div>
  </body>
</html>