<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:04 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sxpar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sxpar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="SXPAR:source"></a>function SXPAR, hdr, name, abort, COUNT=matches, COMMENT = comments, $
                                  NoContinue = NoContinue, SILENT = silent
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      SXPAR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Obtain the value of a parameter in a FITS header</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      result = SXPAR( Hdr, Name, [ Abort, COUNT=, COMMENT =, /NoCONTINUE, </span>
<span class="comments">;                                           /SILENT  ])   </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      Hdr =  FITS header array, (e.g. as returned by READFITS) </span>
<span class="comments">;             string array, each element should have a length of 80 characters      </span>
<span class="comments">;</span>
<span class="comments">;      Name = String name of the parameter to return.   If Name is of the</span>
<span class="comments">;             form 'keyword*' then an array is returned containing values of</span>
<span class="comments">;             keywordN where N is a positive (non-zero) integer.  The value of </span>
<span class="comments">;             keywordN will be placed in RESULT[N-1].  The data type of RESULT </span>
<span class="comments">;             will be the type of the first valid match of keywordN found.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       ABORT - string specifying that SXPAR should do a RETALL</span>
<span class="comments">;               if a parameter is not found.  ABORT should contain</span>
<span class="comments">;               a string to be printed if the keyword parameter is not found.</span>
<span class="comments">;               If not supplied, SXPAR will return quietly with COUNT = 0</span>
<span class="comments">;               (and !ERR = -1) if a keyword is not found.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS: </span>
<span class="comments">;       /NOCONTINUE = If set, then continuation lines will not be read, even</span>
<span class="comments">;                 if present in the header</span>
<span class="comments">;       /SILENT - Set this keyword to suppress warning messages about duplicate</span>
<span class="comments">;                 keywords in the FITS header.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       COUNT - Optional keyword to return a value equal to the number of </span>
<span class="comments">;               parameters found by SXPAR, integer scalar</span>
<span class="comments">;</span>
<span class="comments">;       COMMENT - Array of comments associated with the returned values</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Function value = value of parameter in header.</span>
<span class="comments">;               If parameter is double precision, floating, long or string,</span>
<span class="comments">;               the result is of that type.  Apostrophes are stripped</span>
<span class="comments">;               from strings.  If the parameter is logical, 1b is</span>
<span class="comments">;               returned for T, and 0b is returned for F.</span>
<span class="comments">;               If Name was of form 'keyword*' then a vector of values</span>
<span class="comments">;               are returned.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;       !ERR is set to -1 if parameter not found, 0 for a scalar</span>
<span class="comments">;       value returned.  If a vector is returned it is set to the</span>
<span class="comments">;       number of keyword matches found.    The use of !ERR is deprecated, and</span>
<span class="comments">;       instead the COUNT keyword is preferred</span>
<span class="comments">;</span>
<span class="comments">;       If a keyword (except HISTORY or COMMENT) occurs more than once in a </span>
<span class="comments">;       header, a warning is given, and the *last* occurence is used.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       Given a FITS header, h, return the values of all the NAXISi values</span>
<span class="comments">;       into a vector.    Then place the history records into a string vector.</span>
<span class="comments">;</span>
<span class="comments">;       IDL> naxisi = sxpar( h ,'NAXIS*')         ; Extract NAXISi value</span>
<span class="comments">;       IDL> history = sxpar( h, 'HISTORY' )      ; Extract HISTORY records</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       The first 8 chacters of each element of Hdr are searched for a </span>
<span class="comments">;       match to Name.  The value from the last 20 characters is returned.  </span>
<span class="comments">;       An error occurs if there is no parameter with the given name.</span>
<span class="comments">;</span>
<span class="comments">;       If a numeric value has no decimal point it is returned as type</span>
<span class="comments">;       LONG.   If it contains more than 8 numerals, or contains the </span>
<span class="comments">;       characters 'D' or 'E', then it is returned as type DOUBLE.  Otherwise</span>
<span class="comments">;       it is returned as type FLOAT.    Very large integer values, outside</span>
<span class="comments">;       the range of valid LONG, are returned as DOUBLE.</span>
<span class="comments">;</span>
<span class="comments">;       If the value is too long for one line, it may be continued on to the</span>
<span class="comments">;       the next input card, using the OGIP CONTINUE convention.  For more info,</span>
<span class="comments">;       see http://fits.gsfc.nasa.gov/registry/continue_keyword.html</span>
<span class="comments">;</span>
<span class="comments">;       Complex numbers are recognized as two numbers separated by one or more</span>
<span class="comments">;       space characters.</span>
<span class="comments">;</span>
<span class="comments">;       If a numeric value has no decimal point (or E or D) it is returned as</span>
<span class="comments">;       type LONG.  If it contains more than 8 numerals, or contains the</span>
<span class="comments">;       character 'D', then it is returned as type DOUBLE.  Otherwise it is</span>
<span class="comments">;       returned as type FLOAT.    If an integer is too large to be stored as</span>
<span class="comments">;       type LONG, then it is returned as DOUBLE.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The functions SXPAR() and FXPAR() are nearly identical, although</span>
<span class="comments">;       FXPAR() has slightly more sophisticated parsing, and additional keywords</span>
<span class="comments">;       to specify positions in the header to search (for speed), and to force</span>
<span class="comments">;       the output to a specified data type..   There is no</span>
<span class="comments">;       particular reason for having two nearly identical procedures, but</span>
<span class="comments">;       both are too widely used to drop either one.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       GETTOK(), VALID_NUM()</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       DMS, May, 1983, STPAR Written.</span>
<span class="comments">;       D. Lindler Jan 90 added ABORT input parameter</span>
<span class="comments">;       J. Isensee Jul,90 added COUNT keyword</span>
<span class="comments">;       W. Thompson, Feb. 1992, added support for FITS complex values.</span>
<span class="comments">;       W. Thompson, May 1992, corrected problem with HISTORY/COMMENT/blank</span>
<span class="comments">;               keywords, and complex value error correction.</span>
<span class="comments">;       W. Landsman, November 1994, fix case where NAME is an empty string </span>
<span class="comments">;       W. Landsman, March 1995,  Added COMMENT keyword, ability to read</span>
<span class="comments">;               values longer than 20 character</span>
<span class="comments">;       W. Landsman, July 1995, Removed /NOZERO from MAKE_ARRAY call</span>
<span class="comments">;       T. Beck May 1998, Return logical as type BYTE</span>
<span class="comments">;       W. Landsman May 1998, Make sure integer values are within range of LONG</span>
<span class="comments">;       W. Landsman Feb 1998, Recognize CONTINUE convention </span>
<span class="comments">;       W. Landsman Oct 1999, Recognize numbers such as 1E-10 as floating point</span>
<span class="comments">;       W. Landsman Jan 2000, Only accept integer N values when name = keywordN</span>
<span class="comments">;       W. Landsman Dec 2001, Optional /SILENT keyword to suppress warnings</span>
<span class="comments">;       W. Landsman/D. Finkbeiner  Mar 2002  Make sure extracted vectors </span>
<span class="comments">;             of mixed data type are returned with the highest type.</span>
<span class="comments">;       W.Landsman Aug 2008  Use vector form of VALID_NUM()</span>
<span class="comments">;       W. Landsman Jul 2009  Eliminate internal recursive call</span>
<span class="comments">;       W. Landsman Apr 2012  Require vector numbers be greater than 0</span>
<span class="comments">;-</span>
<span class="comments">;----------------------------------------------------------------------</span>
 On_error,2
 compile_opt idl2

 if N_params() LT 2 then begin
     print,'Syntax -  result =  sxpar( hdr, name, [abort])'
     print,'   Input Keywords:    /NOCONTINUE, /SILENT'
     print,'   Output Keywords:   COUNT=,  COMMENT= '
     return, -1
 endif 

 VALUE = 0
 if N_params() LE 2 then begin
      abort_return = 0
      abort = 'FITS Header'
 end else abort_return = 1
 if abort_return then On_error,1 else On_error,2

<span class="comments">;       Check for valid header</span>

<span class="comments">;Check header for proper attributes.</span>
  if ( size(hdr,/N_dimen) NE 1 ) || ( size(hdr,/type) NE 7 ) then $
           message,'FITS Header (first parameter) must be a string array'

  nam = strtrim( strupcase(name) )      <span class="comments">;Copy name, make upper case     </span>


<span class="comments">;  Determine if NAME is of form 'keyword*'.  If so, then strip off the '*', and</span>
<span class="comments">;  set the VECTOR flag.  One must consider the possibility that NAM is an empty</span>
<span class="comments">;  string.</span>

   namelength1 = (strlen(nam) - 1 ) > 1         
   if strpos( nam, '*' ) EQ namelength1 then begin    
            nam = strmid( nam, 0, namelength1)  
            vector = 1                  <span class="comments">;Flag for vector output  </span>
            name_length = strlen(nam)   <span class="comments">;Length of name </span>
            num_length = 8 - name_length        <span class="comments">;Max length of number portion  </span>
            if num_length LE 0 then  $ 
                  message, 'Keyword length must be 8 characters or less'

<span class="comments">;  Otherwise, extend NAME with blanks to eight characters.</span>

    endif else begin  
                while strlen(nam) LT 8 do nam = nam + ' ' <span class="comments">;Make 8 chars long</span>
                vector = 0      
    endelse


<span class="comments">;  If of the form 'keyword*', then find all instances of 'keyword' followed by</span>
<span class="comments">;  a number.  Store the positions of the located keywords in NFOUND, and the</span>
<span class="comments">;  value of the number field in NUMBER.</span>

        histnam = (nam eq 'HISTORY ') || (nam eq 'COMMENT ') || (nam eq '') 
        keyword = strmid( hdr, 0, 8)
 
        if vector then begin
            nfound = where(strpos(keyword,nam) GE 0, matches)
            if  matches GT 0  then begin
                numst= strmid( hdr[nfound], name_length, num_length)
		igood = where(VALID_NUM(numst,/INTEGER), matches)
		if matches GT 0 then begin 
		     nfound = nfound[igood]
                     number = long(numst[igood])
		     g = where(number GT 0, matches)
 		     if matches GT 0 then number = number[g]

		endif 
           endif

<span class="comments">;  Otherwise, find all the instances of the requested keyword.  If more than</span>
<span class="comments">;  one is found, and NAME is not one of the special cases, then print an error</span>
<span class="comments">;  message.</span>

        endif else begin
            nfound = where(keyword EQ nam, matches)
             if (matches GT 1) && ~histnam then        $
                if ~keyword_set(silent) then $
                message,/informational, 'Warning - keyword ' +   $
                nam + ' located more than once in ' + abort
        endelse


<span class="comments">; Process string parameter </span>

 if matches GT 0 then begin
  line = hdr[nfound]
  svalue = strtrim( strmid(line,9,71),2)
  if histnam then $
        value = strtrim(strmid(line,8,71),2) else for i = 0,matches-1 do begin
      if ( strmid(svalue[i],0,1) EQ "'" ) then begin   <span class="comments">;Is it a string?</span>
                  test = strmid( svalue[i],1,strlen( svalue[i] )-1)
                  next_char = 0
                  off = 0
                  value = '' 
          NEXT_APOST:
                  endap = strpos(test, "'", next_char)      <span class="comments">;Ending apostrophe  </span>
                  if endap LT 0 then $ 
                            MESSAGE,'Value of '+name+' invalid in '+abort
                  value = value + strmid( test, next_char, endap-next_char )  

<span class="comments">;  Test to see if the next character is also an apostrophe.  If so, then the</span>
<span class="comments">;  string isn't completed yet.  Apostrophes in the text string are signalled as</span>
<span class="comments">;  two apostrophes in a row.</span>

                 if strmid( test, endap+1, 1) EQ "'" then begin    
                    value = value + "'"
                    next_char = endap+2         
                    goto, NEXT_APOST
                 endif      

<span class="comments">; Extract the comment, if any</span>
                
                slash = strpos( test, "/", endap )
                if slash LT 0 then comment = '' else    $
                        comment = strmid( test, slash+1, strlen(test)-slash-1 )

<span class="comments">; This is a string that could be continued on the next line.  Check this</span>
<span class="comments">; possibility with the following four criteria: *1) Ends with '&'</span>
<span class="comments">; (2) Next line is CONTINUE  (3) LONGSTRN keyword is present (recursive call to</span>
<span class="comments">; SXPAR) 4. /NOCONTINE is not set</span>

    if ~keyword_set(nocontinue) then begin
                off++
                val = strtrim(value,2)

                if (strlen(val) gt 0) && $
                  (strmid(val, strlen(val)-1, 1) EQ '&') && $
                  (strmid(hdr[nfound[i]+off],0,8) EQ 'CONTINUE') then $
		      if ~array_equal(keyword EQ 'LONGSTRN',0b) then begin 
                  value = strmid(val, 0, strlen(val)-1)
                  test = hdr[nfound[i]+off]
                  test = strmid(test, 8, strlen(test)-8)
                  test = strtrim(test, 2)
                  if strmid(test, 0, 1) NE "'" then message, $
                    'ERROR: Invalidly CONTINUEd string in '+ abort
                  next_char = 1
                  GOTO, NEXT_APOST
                ENDIF
    ENDIF


<span class="comments">; Process non-string value  </span>

          endif else begin

                test = svalue[i]
                slash = strpos( test, "/" )
                if slash GT 0 then begin
                        comment = strmid( test, slash+1, strlen(test)-slash-1 )
                        test = strmid( test, 0, slash )
                end else comment = ''

<span class="comments">; Find the first word in TEST.  Is it a logical value ('T' or 'F')</span>

                test2 = test
                value = gettok(test2,' ')
               if ( value EQ 'T' ) then value = 1b else $
               if ( value EQ 'F' ) then value = 0b else begin

<span class="comments">;  Test to see if a complex number.  It's  a complex number if the value and</span>
<span class="comments">;  the next word, if any, are both valid values.</span>

                if strlen(test2) EQ 0 then goto, NOT_COMPLEX
                value2 = gettok( test2, ' ') 
                if value2 EQ '' then goto, NOT_COMPLEX
                On_ioerror, NOT_COMPLEX
                value2 = float(value2)
                value = complex(value,value2)
                goto, GOT_VALUE

<span class="comments">;  Not a complex number.  Decide if it is a floating point, double precision,</span>
<span class="comments">;  or integer number.</span>

NOT_COMPLEX:
                On_IOerror, GOT_VALUE
                  if (strpos(value,'.') GE 0) || (strpos(value,'E') GT 0) $
                  || (strpos(value,'D') GE 0) then begin  <span class="comments">;Floating or double?</span>
                      if ( strpos(value,'D') GT 0 ) || $  <span class="comments">;Double?</span>
                         ( strlen(value) GE 8 ) then value = double(value) $
                                                else value = float(value)
                       endif else begin                   <span class="comments">;Long integer</span>
                            lmax = 2.0d^31 - 1.0d
                            lmin = -2.0d^31      <span class="comments">;Typo fixed Feb 2010</span>
                            value = double(value)
                            if (value GE lmin) && (value LE lmax) then $
                                value = long(value)
                       endelse

GOT_VALUE:
                On_IOerror, NULL
                endelse
             endelse<span class="comments">; if c eq apost</span>

<span class="comments">;  Add to vector if required</span>

         if vector then begin
               if ( i EQ 0 ) then begin
                     maxnum = max(number)
                     dtype = size(value,/type)
                     result = make_array( maxnum, TYPE = dtype )
                     comments = strarr( maxnum )
               endif 
               if size(value,/type) GT dtype then begin   <span class="comments">;Do we need to recast?</span>
                    result = result + 0*value
                    dtype = size(value,/type)
               endif
               result[ number[i]-1 ] =  value
               comments[ number[i]-1 ] = comment
          endif else $
                comments = comment
  endfor

  if vector then begin
         !ERR = matches     
         return, result
  endif else !ERR = 0

endif  else  begin    
     if abort_return then message,'Keyword '+nam+' not found in '+abort
     !ERR = -1
endelse     

return, value       

END                 
</code>
    </div>
  </body>
</html>