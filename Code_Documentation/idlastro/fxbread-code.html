<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbread.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbread.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXBREAD, UNIT, DATA, COL, ROW, NOSCALE=NOSCALE, VIRTUAL=VIR, $
		DIMENSIONS=DIMS0, NANVALUE=NANVALUE, ERRMSG=ERRMSG, $
                NOIEEE=NOIEEE
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXBREAD</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;	Read a data array from a disk FITS binary table file.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;	Each call to FXBREAD will read the data from one column and one row</span>
<span class="comments">;	from the FITS data file, which should already have been opened by</span>
<span class="comments">;	FXBOPEN.  One needs to call this routine for every column and every row</span>
<span class="comments">;	in the binary table.  FXBCLOSE will then close the FITS data file.</span>
<span class="comments">; Use         : </span>
<span class="comments">;	FXBREAD, UNIT, DATA, COL  [, ROW ]</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;	UNIT	= Logical unit number corresponding to the file containing the</span>
<span class="comments">;		  binary table.</span>
<span class="comments">;	COL	= Column in the binary table to read data from, either as a</span>
<span class="comments">;		  character string containing a column label (TTYPE), or as a</span>
<span class="comments">;		  numerical column index starting from column one.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	ROW	= Either row number in the binary table to read data from,</span>
<span class="comments">;		  starting from row one, or a two element array containing a</span>
<span class="comments">;		  range of row numbers to read.  If not passed, then the entire</span>
<span class="comments">;		  column is read in.</span>
<span class="comments">;</span>
<span class="comments">;		  Row must be passed for variable length arrays.</span>
<span class="comments">;</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	DATA	= IDL data array to be read from the file.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;	NOSCALE	= If set, then the output data will not be scaled using the</span>
<span class="comments">;		  optional TSCAL and TZERO keywords in the FITS header.</span>
<span class="comments">;		  Default is to scale.</span>
<span class="comments">;       NOIEEE  = If set, then the output data is not byte-swapped to </span>
<span class="comments">;                 machine order.  NOIEEE implies NOSCALE.</span>
<span class="comments">;                 Default is to perform the byte-swap.</span>
<span class="comments">;	VIRTUAL	= If set, and COL is passed as a name rather than a number,</span>
<span class="comments">;		  then if the program can't find a column with that name, it</span>
<span class="comments">;		  will then look for a keyword with that name in the header.</span>
<span class="comments">;		  Such a keyword would then act as a "virtual column", with the</span>
<span class="comments">;		  same value for every row.</span>
<span class="comments">;	DIMENSIONS = Vector array containing the dimensions to be used to read</span>
<span class="comments">;		  in the data.  Bypasses any dimensioning information stored in</span>
<span class="comments">;		  the header.  Ignored for bit arrays.  If the data type is</span>
<span class="comments">;		  double-precision complex, then an extra dimension of 2 is</span>
<span class="comments">;		  prepended to the dimensions passed by the user.</span>
<span class="comments">;	NANVALUE= Value signalling data dropout.  All points corresponding to</span>
<span class="comments">;		  IEEE NaN (not-a-number) are converted to this number.</span>
<span class="comments">;		  Ignored unless DATA is of type float, double-precision or</span>
<span class="comments">;		  complex.</span>
<span class="comments">;	ERRMSG	= If defined and passed, then any error messages will be</span>
<span class="comments">;		  returned to the user in this parameter rather than</span>
<span class="comments">;		  depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		  encountered, then a null string is returned.  In order to</span>
<span class="comments">;		  use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXBREAD, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	FXPAR, WHERE_NEGZERO, WHERENAN</span>
<span class="comments">; Common      : </span>
<span class="comments">;	Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;	information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	The binary table file must have been opened with FXBOPEN.</span>
<span class="comments">;</span>
<span class="comments">;	The data must be consistent with the column definition in the binary</span>
<span class="comments">;	table header.</span>
<span class="comments">;</span>
<span class="comments">;	The row number must be consistent with the number of rows stored in the</span>
<span class="comments">;	binary table header.</span>
<span class="comments">;</span>
<span class="comments">;	The number of elements implied by the dimensions keyword must not</span>
<span class="comments">;	exceed the number of elements stored in the file.</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	If the DIMENSIONS keyword is used, then the number of data points read</span>
<span class="comments">;	in may be less than the number of points stored in the table.</span>
<span class="comments">;</span>
<span class="comments">;	If there are no elements to read in (the number of elements is zero),</span>
<span class="comments">;	then the program sets !ERR to -1, and DATA is unmodified.</span>
<span class="comments">;</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	W. Thompson, Jan 1992.</span>
<span class="comments">;	W. Thompson, Feb 1992, modified to support variable length arrays.</span>
<span class="comments">;	W. Thompson, Jun 1992, modified way that row ranges are read in.  No</span>
<span class="comments">;			       longer works reiteratively.</span>
<span class="comments">;	W. Thompson, Jun 1992, fixed bug where NANVALUE would be modified by</span>
<span class="comments">;			       TSCAL and TZERO keywords.</span>
<span class="comments">;	W. Thompson, Jun 1992, fixed bug when reading character strings.</span>
<span class="comments">;			       Treats dimensions better when reading multiple</span>
<span class="comments">;			       rows.</span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, January 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 30 June 1993.</span>
<span class="comments">;		Added overwrite keyword to REFORM call to speed up.</span>
<span class="comments">;	Version 3, William Thompson, GSFC, 21 July 1993.</span>
<span class="comments">;		Fixed bug with variable length arrays.</span>
<span class="comments">;	Version 4, William Thompson, GSFC, 29 October 1993.</span>
<span class="comments">;		Added error message for not finding column by name.</span>
<span class="comments">;	Version 5, William Thompson, GSFC, 31 May 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;       Version 6, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;	Version 7, William Thompson, GSFC, 29 December 1994</span>
<span class="comments">;		Fixed bug where single element dimensions were lost.</span>
<span class="comments">;	Version 8, William Thompson, GSFC, 20 March 1995</span>
<span class="comments">;		Fixed bug introduced in version 7.</span>
<span class="comments">;	Version 9, Wayne Landsman, GSFC, 3 July 1996</span>
<span class="comments">;		Fixed bug involving use of virtual keyword.</span>
<span class="comments">;	Version 10, William Thompson, GSFC, 31-Jan-1997</span>
<span class="comments">;		Added call to WHERE_NEGZERO.</span>
<span class="comments">;	Version 11, Wayne Landsman, GSFC, 12 Aug, 1997</span>
<span class="comments">;		Use IDL dcomplex datatype if needed</span>
<span class="comments">;	Version 12, Wayne Landmsan, GSFC, 20 Feb, 1998</span>
<span class="comments">;		Remove call to WHERE_NEGZERO (now part of IEEE_TO_HOST)</span>
<span class="comments">;	Version 13, 18 Nov 1999, CM, Add NOIEEE keyword</span>
<span class="comments">;	Version 14, 21 Aug 2000, William Thompson, GSFC</span>
<span class="comments">;		Catch I/O errors</span>
<span class="comments">;       Version 15, W. Landsman GSFC 10 Dec 2009</span>
<span class="comments">;                Fix Dimension keyword, remove  IEEE_TO_HOST</span>
<span class="comments">; Version     :</span>
<span class="comments">;       Version 15, 10 Dec 2009</span>
<span class="comments">;-</span>
<span class="comments">;</span>
@fxbintable
	ON_ERROR, 2
	ON_IOERROR, HANDLE_IO_ERROR
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
	IF N_PARAMS() LT 3 THEN BEGIN
		MESSAGE = 'Syntax:  FXBREAD, UNIT, DATA, COL  [, ROW ]'
		GOTO, HANDLE_ERROR
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Find the logical unit number in the FXBINTABLE common block.</span>
<span class="comments">;</span>
	ILUN = WHERE(LUN EQ UNIT,NLUN)
	ILUN = ILUN[0]
	IF NLUN EQ 0 THEN BEGIN
		MESSAGE = 'Unit ' + STRTRIM(UNIT,2) + ' not opened properly'
		GOTO, HANDLE_ERROR
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If COL is of type string, then search for a column with that label.</span>
<span class="comments">;</span>
	SC = SIZE(COL)
	VIRTUAL = 0
	IF SC[SC[0]+1] EQ 7 THEN BEGIN
		SCOL = STRUPCASE(STRTRIM(COL,2))
		ICOL = WHERE(TTYPE[*,ILUN] EQ SCOL, NCOL)
		ICOL = ICOL[0]
		IF (ICOL LT 0) AND (NOT KEYWORD_SET(VIR)) THEN BEGIN
			MESSAGE = 'Column "' + SCOL + '" not found'
			GOTO, HANDLE_ERROR
		ENDIF
<span class="comments">;</span>
<span class="comments">;  If the column was not found, and VIRTUAL was set, then search for a keyword</span>
<span class="comments">;  by that name.</span>
<span class="comments">;</span>
		IF NCOL EQ 0 THEN BEGIN
			IF KEYWORD_SET(VIR) THEN BEGIN
				HEADER = HEAD[*,ILUN]
				VALUE = FXPAR(HEADER,SCOL,COUNT=CC)
				IF CC GT 0 THEN BEGIN
					DATA = VALUE
					VIRTUAL = 1
					GOTO, CHECK_ROW
				ENDIF
			ENDIF
			MESSAGE = 'Column "' + SCOL + '" not found'
			GOTO, HANDLE_ERROR
		ENDIF
<span class="comments">;</span>
<span class="comments">;  Otherwise, a numerical column was passed.  Check its value.</span>
<span class="comments">;</span>
	END ELSE ICOL = LONG(COL) - 1
	IF (ICOL LT 0) OR (ICOL GE TFIELDS[ILUN]) THEN BEGIN
		MESSAGE = 'COL must be between 1 and ' +	$
			STRTRIM(TFIELDS[ILUN],2)
		GOTO, HANDLE_ERROR
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If there are no elements in the array, then set !ERR to -1.</span>
<span class="comments">;</span>
	IF N_ELEM[ICOL,ILUN] EQ 0 THEN BEGIN
		MESSAGE,'Number of elements to read in is zero',/INFORMATIONAL
		!ERR = -1
		RETURN
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If ROW was not passed, then set it equal to the entire range.  Otherwise,</span>
<span class="comments">;  extract the range.</span>
<span class="comments">;</span>
CHECK_ROW:
	IF N_PARAMS() EQ 3 THEN ROW = [1,NAXIS2[ILUN]]
	CASE N_ELEMENTS(ROW) OF
		1:  ROW2 = LONG(ROW[0])
		2:  ROW2 = LONG(ROW[1])
		ELSE:  BEGIN
			MESSAGE = 'ROW must have one or two elements'
			GOTO, HANDLE_ERROR
			END
	ENDCASE
	ROW1 = LONG(ROW[0])
<span class="comments">;</span>
<span class="comments">;  If ROW represents a range, then make sure that the row range is legal, and</span>
<span class="comments">;  that reading row ranges is allowed (i.e., the column is not variable length.</span>
<span class="comments">;</span>
	IF ROW1 NE ROW2 THEN BEGIN
		MAXROW = NAXIS2[ILUN]
		IF (ROW1 LT 1) OR (ROW1 GT MAXROW) THEN BEGIN
			MESSAGE = 'ROW[0] must be between 1 and ' +	$
				STRTRIM(MAXROW,2)
			GOTO, HANDLE_ERROR
		END ELSE IF (ROW2 LT ROW1) OR (ROW2 GT MAXROW) THEN BEGIN
			MESSAGE = 'ROW[1] must be between ' +	$
				STRTRIM(ROW1,2) + ' and ' + STRTRIM(MAXROW,2)
			GOTO, HANDLE_ERROR
		END ELSE IF NOT VIRTUAL THEN IF MAXVAL[ICOL,ILUN] GT 0 THEN $
				BEGIN
			MESSAGE = 'Row ranges not allowed for ' +	$
				'variable-length columns'
			GOTO, HANDLE_ERROR
		ENDIF
<span class="comments">;</span>
<span class="comments">;  Otherwise, if ROW is a single number, then just make sure it's valid.</span>
<span class="comments">;</span>
	END ELSE BEGIN
		IF (ROW1 LT 1) OR (ROW1 GT NAXIS2[ILUN]) THEN BEGIN
			MESSAGE = 'ROW must be between 1 and ' +	$
				STRTRIM(NAXIS2[ILUN],2)
			GOTO, HANDLE_ERROR
		ENDIF
	ENDELSE
<span class="comments">;</span>
<span class="comments">;  If a virtual column, then simply return the value.  If necessary, then</span>
<span class="comments">;  replicate the value the correct number of times.</span>
<span class="comments">;</span>
	IF VIRTUAL THEN BEGIN
		IF ROW1 EQ ROW2 THEN DATA = VALUE ELSE	$
			DATA = REPLICATE(VALUE,ROW2-ROW1+1)
		RETURN
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Find the position of the first byte of the data array in the file.</span>
<span class="comments">;</span>
	OFFSET = NHEADER[ILUN] + NAXIS1[ILUN]*(ROW1-1) + BYTOFF[ICOL,ILUN]
	POINT_LUN,UNIT,OFFSET
<span class="comments">;</span>
<span class="comments">;  If a variable length array, then read in the number of elements, and the</span>
<span class="comments">;  pointer to the variable length array.  Change the pointing.</span>
<span class="comments">;</span>
	IF MAXVAL[ICOL,ILUN] GT 0 THEN BEGIN
		POINTER = LONARR(2)
		READU,UNIT,POINTER
		BYTEORDER, POINTER, /NTOHL
		DIMS = POINTER[0]
		POINT_LUN,UNIT,NHEADER[ILUN] + HEAP[ILUN] + POINTER[1]
<span class="comments">;</span>
<span class="comments">;  If there are no elements in the array, then set !ERR to -1.</span>
<span class="comments">;</span>
		IF DIMS EQ 0 THEN BEGIN
			MESSAGE,'Number of elements to read in is zero', $
				/INFORMATIONAL
			!ERR = -1
			RETURN
		ENDIF
<span class="comments">;</span>
<span class="comments">;  If the datatype is a bit array, then the array is treated as a byte array</span>
<span class="comments">;  with 1/8 the number of elements.</span>
<span class="comments">;</span>
		IF FORMAT[ICOL,ILUN] EQ 'X' THEN DIMS = LONG((DIMS+7)/8)
<span class="comments">;</span>
<span class="comments">;  If fixed length, then get the dimensions of the output array.</span>
<span class="comments">;</span>
	END ELSE BEGIN
		DIMS = N_DIMS[*,ICOL,ILUN]
		DIMS = DIMS[1:DIMS[0]]
	ENDELSE
<span class="comments">;</span>
<span class="comments">;  If the DIMENSIONS keyword has been passed, then use that instead of the</span>
<span class="comments">;  dimensions already determined.</span>
<span class="comments">;</span>
	IF (N_ELEMENTS(DIMS0) GT 0) AND (FORMAT[ICOL,ILUN] NE 'X')	$
			THEN BEGIN
		IF PRODUCT(DIMS0) GT PRODUCT(DIMS) THEN BEGIN
			MESSAGE = 'Requested dimensions exceeds the ' +	$
				'number of elements'
			GOTO, HANDLE_ERROR
		ENDIF
		DIMS = DIMS0
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Read in the data.  If a character string array, then read in a byte array.</span>
<span class="comments">;</span>
	DATATYPE = IDLTYPE[ICOL,ILUN]
	IF DATATYPE EQ 7 THEN DATATYPE = 1
<span class="comments">;</span>
<span class="comments">;  If only reading in a single row, then the pointer should already be set.</span>
<span class="comments">;  Otherwise, the pointer needs to be set for each row.</span>
<span class="comments">;</span>
	IF ROW1 EQ ROW2 THEN BEGIN
		DATA = MAKE_ARRAY(TYPE=DATATYPE,DIMENSION=DIMS)
		DATA = REFORM(DATA,DIMS,/OVERWRITE)
		READU,UNIT,DATA
	END ELSE BEGIN
		DIMS2 = [DIMS, ROW2-ROW1+1]
		DATA = MAKE_ARRAY(TYPE=DATATYPE, DIMENSION=DIMS2)
		DATA = REFORM(DATA, DIMS2, /OVERWRITE)
		TEMPDATA = MAKE_ARRAY(TYPE=DATATYPE, DIMENSION=DIMS)
		TEMPDATA = REFORM(TEMPDATA, DIMS, /OVERWRITE)
		NTEMP = N_ELEMENTS(TEMPDATA)
		FOR IROW = ROW1,ROW2 DO BEGIN
			OFFSET = NHEADER[ILUN] + BYTOFF[ICOL,ILUN]
			POINT_LUN,UNIT,OFFSET + NAXIS1[ILUN]*(IROW-1)
			READU,UNIT,TEMPDATA
			DATA[(IROW-ROW1)*NTEMP] = TEMPDATA[*]
		ENDFOR
	ENDELSE
<span class="comments">;</span>
<span class="comments">;  If a character string array, then convert to type string.</span>
<span class="comments">;</span>
	IF IDLTYPE[ICOL,ILUN] EQ 7 THEN BEGIN
		DATA = STRING(DATA)
		COUNT = 0
<span class="comments">;</span>
<span class="comments">;  Otherwise, if necessary, then convert the data to the native format of the</span>
<span class="comments">;  host machine.  Also, if NANVALUE is passed, then keep track of any IEEE NaN</span>
<span class="comments">;  values.</span>
<span class="comments">;</span>
	END ELSE IF IDLTYPE[ICOL,ILUN] NE 1 THEN BEGIN
		IF (N_ELEMENTS(NANVALUE) EQ 1) AND (IDLTYPE[ICOL,ILUN] GE 4) $
			AND (IDLTYPE[ICOL,ILUN] LE 6) THEN	$
			W = WHERENAN(DATA,COUNT) ELSE COUNT = 0
                IF NOT KEYWORD_SET(NOIEEE) THEN $
		       SWAP_ENDIAN_INPLACE,DATA,/SWAP_IF_LITTLE
	END ELSE COUNT = 0
<span class="comments">;</span>
<span class="comments">;  If DIMS is simply the number 1, then convert DATA either to a scalar or to a</span>
<span class="comments">;  simple vector, depending on how many rows were read in.</span>
<span class="comments">;</span>
	IF (N_ELEMENTS(DIMS) EQ 1) AND (DIMS[0] EQ 1) THEN BEGIN
		IF N_ELEMENTS(DATA) EQ 1 THEN DATA = DATA[0] ELSE	$
			DATA = REFORM(DATA,ROW2-ROW1+1,/OVERWRITE)
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If the parameters TZERO and TSCAL are non-trivial, then adjust the array by</span>
<span class="comments">;  these values.</span>
<span class="comments">;</span>
	IF NOT KEYWORD_SET(NOSCALE) AND NOT KEYWORD_SET(NOIEEE) THEN BEGIN
		BZERO  = TZERO[ICOL,ILUN]
		BSCALE = TSCAL[ICOL,ILUN]
		IF (BSCALE NE 0) AND (BSCALE NE 1) THEN DATA *= BSCALE
		IF BZERO NE 0 THEN DATA += BZERO
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Store NANVALUE everywhere where the data corresponded to IEE NaN.</span>
<span class="comments">;</span>
	IF COUNT GT 0 THEN DATA[W] = NANVALUE
<span class="comments">;</span>
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
	RETURN
<span class="comments">;</span>
<span class="comments">;  I/O error handling point.</span>
<span class="comments">;</span>
HANDLE_IO_ERROR:
	MESSAGE = 'I/O error reading file'
<span class="comments">;</span>
<span class="comments">;  Error handling point.</span>
<span class="comments">;</span>
HANDLE_ERROR:
	IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = MESSAGE ELSE MESSAGE, MESSAGE
	RETURN
	END
</code>
    </div>
  </body>
</html>