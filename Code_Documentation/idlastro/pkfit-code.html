<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pkfit.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pkfit.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="pkfit:source"></a>pro pkfit,f,scale,x,y,sky,radius,ronois,phpadu,gauss,psf, $
                  errmag,chi,sharp,niter, DEBUG= debug
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	PKFIT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Subroutine of  GETPSF to perform a one-star least-squares fit </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;	Part of the DAOPHOT PSF photometry sequence</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	PKFIT, f, scale, x, y, sky, radius, ronois, phpadu, gauss, psf, </span>
<span class="comments">;				errmag, chi, sharp, Niter, /DEBUG </span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	F      - NX by NY array containing actual picture data.           </span>
<span class="comments">;	X, Y   - the initial estimates of the centroid of the star relative</span>
<span class="comments">;		to the corner (0,0) of the subarray.  Upon return, the</span>
<span class="comments">;		final computed values of X and Y will be passed back to the</span>
<span class="comments">;		calling routine.</span>
<span class="comments">;	SKY  -   the local sky brightness value, as obtained from APER</span>
<span class="comments">;	RADIUS-  the fitting radius-- only pixels within RADIUS of the</span>
<span class="comments">;		instantaneous estimate of the star's centroid will be</span>
<span class="comments">;		included in the fit, scalar</span>
<span class="comments">;	RONOIS - readout noise per pixel, scalar</span>
<span class="comments">;	PHPADU - photons per analog digital unit, scalar</span>
<span class="comments">;	GAUSS -  vector containing the values of the five parameters defining</span>
<span class="comments">;		the analytic Gaussian which approximates the core of the PSF.</span>
<span class="comments">;	PSF   -  an NPSF by NPSF look-up table containing corrections from</span>
<span class="comments">;		the Gaussian approximation of the PSF to the true PSF.</span>
<span class="comments">;</span>
<span class="comments">; INPUT-OUTPUT:</span>
<span class="comments">;	SCALE  - the initial estimate of the brightness of the star,</span>
<span class="comments">;		expressed as a fraction of the brightness of the PSF.</span>
<span class="comments">;		Upon return, the final computed value of SCALE will be</span>
<span class="comments">;		passed back to the calling routine.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	ERRMAG - the estimated standard error of the value of SCALE</span>
<span class="comments">;		returned by this routine.</span>
<span class="comments">;	CHI    - the estimated goodness-of-fit statistic:  the ratio</span>
<span class="comments">;		of the observed pixel-to-pixel mean absolute deviation from</span>
<span class="comments">;		the profile fit, to the value expected on the basis of the</span>
<span class="comments">;		noise as determined from Poisson statistics and the </span>
<span class="comments">;		readout noise.</span>
<span class="comments">;	SHARP  - a goodness-of-fit statistic describing how much broader  </span>
<span class="comments">;		the actual profile of the object appears than the</span>
<span class="comments">;		profile of the PSF.</span>
<span class="comments">;	NITER -  the number of iterations the solution required to achieve</span>
<span class="comments">;		convergence.  If NITER = 25, the solution did not converge.</span>
<span class="comments">;		If for some reason a singular matrix occurs during the least-</span>
<span class="comments">;		squares solution, this will be flagged by setting NITER = -1.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;	No parameter checking is performed</span>
<span class="comments">; REVISON HISTORY:</span>
<span class="comments">;	Adapted from the official DAO version of 1985 January 25</span>
<span class="comments">;	Version 2.0 W. Landsman STX             November 1988</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
 s = size(f)	<span class="comments">;Get array dimensions</span>
 nx = s[1] & ny = s[2]
<span class="comments">;               ;Initialize a few things for the solution</span>
 redo = 0B		
 pkerr = 0.027/(gauss[3]*gauss[4])^2
 clamp = fltarr(3) + 1.
 dtold = fltarr(3) 
 niter = 0                                
 chiold = 1.

 if keyword_set(DEBUG) then $
     print,'PKFIT: ITER  X      Y      SCALE    ERRMAG   CHI     SHARP'

BIGLOOP:  		        <span class="comments">;Begin the big least-squares loop</span>
 niter = niter+1

 ixlo = fix(x-radius) > 0	<span class="comments">;Choose boundaries of subarray containing</span>
 iylo = fix(y-radius) > 0        <span class="comments">;points inside the fitting radius</span>
 ixhi = fix(x+radius) +1 &lt<span class="comments">; (nx-1)</span>
 iyhi = fix(y+radius) +1 &lt<span class="comments">; (ny-1)</span>
 ixx  = ixhi-ixlo+1
 iyy  = iyhi-iylo+1
 dy   =  findgen(iyy) + iylo - y    <span class="comments">;X distance vector from stellar centroid</span>
 dysq = dy^2
 dx   = findgen(ixx) + ixlo - x
 dxsq = dx^2
 rsq  = fltarr(ixx,iyy)  <span class="comments">;RSQ - array of squared </span>

 for J = 0,iyy-1 do rsq[0,j] = (dxsq+dysq[j])/radius^2

 <span class="comments">; The fitting equation is of the form</span>
 <span class="comments">;</span>
 <span class="comments">; Observed brightness =</span>
 <span class="comments">;      SCALE + delta(SCALE)  *  PSF + delta(Xcen)*d(PSF)/d(Xcen) +</span>
 <span class="comments">;                                           delta(Ycen)*d(PSF)/d(Ycen)</span>
 <span class="comments">;</span>
 <span class="comments">; and is solved for the unknowns delta(SCALE) ( = the correction to</span>
 <span class="comments">; the brightness ratio between the program star and the PSF) and</span>
 <span class="comments">; delta(Xcen) and delta(Ycen) ( = corrections to the program star's</span>
 <span class="comments">; centroid).</span>
 <span class="comments">;</span>
 <span class="comments">; The point-spread function is equal to the sum of the integral under</span>
 <span class="comments">; a two-dimensional Gaussian profile plus a value interpolated from            </span>
 <span class="comments">; a look-up table.</span>

 good = where(rsq lt 1.,ngood)
 ngood = ngood > 1

 t = fltarr(ngood,3)
 dx = dx[good mod ixx]
 dy = dy[good/ixx]
 model = dao_value(dx, dy, gauss, psf, dvdx, dvdy)

 if keyword_set(DEBUG) then begin print,'model created ' & stop & end

 t[0,0] = model
 t[0,1] = -scale*dvdx  
 t[0,2] = -scale*dvdy
 fsub = f[ixlo:ixhi,iylo:iyhi]
 fsub = fsub[good]
 rsq = rsq[good]
 df = fsub - scale*model - sky     <span class="comments">;Residual of the brightness from the PSF fit</span>

 <span class="comments">; The expected random error in the pixel is the quadratic sum of</span>
 <span class="comments">; the Poisson statistics, plus the readout noise, plus an estimated</span>
 <span class="comments">; error of 0.75% of the total brightness for the difficulty of flat-</span>
 <span class="comments">; fielding and bias-correcting the chip, plus an estimated error of </span>
 <span class="comments">; of some fraction of the fourth derivative at the peak of the profile,</span>
 <span class="comments">; to account for the difficulty of accurately interpolating within the</span>
 <span class="comments">; point-spread function.  The fourth derivative of the PSF is</span>
 <span class="comments">; proportional to H/sigma**4 (sigma is the Gaussian width parameter for</span>
 <span class="comments">; the stellar core); using the geometric mean of sigma(x) and sigma(y),</span>
 <span class="comments">; this becomes H/ sigma(x)*sigma(y) **2.  The ratio of the fitting</span>
 <span class="comments">; error to this quantity is estimated from a good-seeing CTIO frame to</span>
 <span class="comments">; be approximately 0.027 (see definition of PKERR above.)</span>

 fpos = (fsub-df) > 0	<span class="comments">;Raw data - residual = model predicted intensity</span>
 sigsq = fpos/phpadu + ronois + (0.0075*fpos)^2 + (pkerr*(fpos-sky))^2
 sig = sqrt(sigsq)
 relerr = df/sig

 <span class="comments">; SIG is the anticipated standard error of the intensity</span>
 <span class="comments">; including readout noise, Poisson photon statistics, and an estimate</span>
 <span class="comments">; of the standard error of interpolating within the PSF.  </span>

 rhosq = fltarr(ixx,iyy)

 for j = 0,iyy-1 do rhosq[0,j] = (dxsq/gauss[3]^2+dysq[j]/gauss[4]^2)

 rhosq = rhosq[good]
 if (niter GE 2) then begin    <span class="comments">;Reject any pixel with 10 sigma residual</span>
        badpix = where( ABS(relerr/chiold) GE 10.,nbad ) 
        if nbad GT 0 then begin 
            remove, badpix, fsub, df, sigsq, sig
            remove, badpix, relerr, rsq, rhosq
            ngood = ngood-badpix
        endif
 endif

 wt = 5./(5.+rsq/(1.-rsq))
 lilrho = where(rhosq LE 36.)	<span class="comments">;Include only pixels within 6 sigma of centroid</span>
 rhosq[lilrho] = 0.5*rhosq[lilrho]
 dfdsig = exp(-rhosq[lilrho])*(rhosq[lilrho]-1.)
 fpos = ( fsub[lilrho]-sky) >0 + sky

 <span class="comments">; FPOS-SKY = raw data minus sky = estimated value of the stellar</span>
 <span class="comments">; intensity (which presumably is non-negative).</span>

 sig  = fpos/phpadu + ronois + (0.0075*fpos)^2 + (pkerr*(fpos-sky))^2
 numer = total(dfdsig*df/sig)
 denom = total(dfdsig^2/sig)

 <span class="comments">; Derive the weight of this pixel.  First of all, the weight depends</span>
 <span class="comments">; upon the distance of the pixel from the centroid of the star-- it</span>
 <span class="comments">; is determined from a function which is very nearly unity for radii</span>
 <span class="comments">; much smaller than the fitting radius, and which goes to zero for</span>
 <span class="comments">;  radii very near the fitting radius.  </span>

 chi = total(wt*abs(relerr))
 sumwt = total(wt)

 wt = wt/sigsq   <span class="comments">;Scale weight to inverse square of expected mean error</span>
 if niter GE 2 then $	<span class="comments">;Reduce weight of a bad pixel</span>
         wt = wt/(1.+(0.4*relerr/chiold)^8)

 v = fltarr(3)       <span class="comments">;Compute vector of residuals and the normal matrix. </span>
 c = fltarr(3,3)

 for kk = 0,2 do begin   
    v[kk] = TOTAL(df*t[*,kk]*wt)
    for ll = 0,2 do C[kk,ll] = TOTAL(t[*,kk]*t[*,ll]*wt)
 end 

 <span class="comments">; Compute the (robust) goodness-of-fit index CHI.</span>
 <span class="comments">; CHI is pulled toward its expected value of unity before being stored</span>
 <span class="comments">; in CHIOLD to keep the statistics of a small number of pixels from</span>
 <span class="comments">; completely dominating the error analysis.</span>

 if sumwt GT 3.0 then begin  
   chi = 1.2533*chi*sqrt(1./(sumwt*(sumwt-3.)))
   chiold = ((sumwt-3.)*chi+3.)/sumwt
 endif

 C = INVERT(C)	<span class="comments">;Invert the normal matrix</span>
 dt = c#v 	<span class="comments">;Compute parameter corrections</span>

<span class="comments">; In the beginning, the brightness of the star will not be permitted</span>
<span class="comments">; to change by more than two magnitudes per iteration (that is to say,</span>
<span class="comments">; if the estimate is getting brighter, it may not get brighter by</span>
<span class="comments">; more than 525% per iteration, and if it is getting fainter, it may</span>
<span class="comments">; not get fainter by more than 84% per iteration).  The x and y</span>
<span class="comments">; coordinates of the centroid will be allowed to change by no more</span>
<span class="comments">; than one-half pixel per iteration.  Any time that a parameter</span>
<span class="comments">; correction changes sign, the maximum permissible change in that</span>
<span class="comments">; parameter will be reduced by a factor of 2.</span>

 div = where( dtold*dt LT -1.e-38, nbad )
 if nbad GT 0 then clamp[div] = clamp[div]/2.
 dtold = dt
 adt = abs(dt)

 scale = scale+dt[0]/    $
  (1.+(( dt[0]/(5.25*scale)) > (-1*dt[0]/(0.84*scale)) )/clamp[0])
 x = x + dt[1]/(1.+adt[1]/(0.5*clamp[1]))
 y = y + dt[2]/(1.+adt[2]/(0.5*clamp[2]))
 redo = 0B

<span class="comments">; Convergence criteria:  if the most recent computed correction to the</span>
<span class="comments">; brightness is larger than 0.1% or than 0.05 * sigma(brightness),</span>
<span class="comments">; whichever is larger, OR if the absolute change in X or Y is</span>
<span class="comments">; greater than 0.01 pixels, convergence has not been achieved.</span>

 sharp = 2.*gauss[3]*gauss[4]*numer/(gauss[0]*scale*denom)
 errmag = chiold*sqrt(c[0,0])
 if ( adt[0] GT ( 0.05*errmag > 0.001*scale )) then redo = 1b
 if ((adt[1] > adt[2] ) GT 0.01) then redo = 1b

 if keyword_set(DEBUG) then print,format='(1H  ,I9,2F7.2,2F9.3,F8.2,F9.2)', $ 
                       niter,x,y,scale,errmag,chiold,sharp
 if niter LT 3 then goto, BIGLOOP 	<span class="comments">;At least 3 iterations required</span>

<span class="comments">; If the solution has gone 25 iterations, OR if the standard error of </span>
<span class="comments">; the brightness is greater than 200%, give up.</span>

 if (redo and (errmag LE 1.9995) and (niter LT 25) ) then goto, BIGLOOP
 sharp = sharp>(-99.999)&lt<span class="comments">;99.999</span>

 return
 end
</code>
    </div>
  </body>
</html>