<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:21 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cntrd.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cntrd.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="cntrd:source"></a>pro cntrd, img, x, y, xcen, ycen, fwhm, SILENT= silent, DEBUG=debug, $
       EXTENDBOX = extendbox, KeepCenter = KeepCenter
<span class="comments">;+</span>
<span class="comments">;  NAME: </span>
<span class="comments">;       CNTRD</span>
<span class="comments">;  PURPOSE:</span>
<span class="comments">;       Compute the centroid  of a star using a derivative search </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       CNTRD uses an early DAOPHOT "FIND" centroid algorithm by locating the </span>
<span class="comments">;       position where the X and Y derivatives go to zero.   This is usually a </span>
<span class="comments">;       more "robust"  determination than a "center of mass" or fitting a 2d </span>
<span class="comments">;       Gaussian  if the wings in one direction are affected by the presence</span>
<span class="comments">;       of a neighboring star.</span>
<span class="comments">;</span>
<span class="comments">;  CALLING SEQUENCE: </span>
<span class="comments">;       CNTRD, img, x, y, xcen, ycen, [ fwhm , /KEEPCENTER, /SILENT, /DEBUG</span>
<span class="comments">;                                       EXTENDBOX = ]</span>
<span class="comments">;</span>
<span class="comments">;  INPUTS:     </span>
<span class="comments">;       IMG - Two dimensional image array</span>
<span class="comments">;       X,Y - Scalar or vector integers giving approximate integer stellar </span>
<span class="comments">;             center</span>
<span class="comments">;</span>
<span class="comments">;  OPTIONAL INPUT:</span>
<span class="comments">;       FWHM - floating scalar; Centroid is computed using a box of half</span>
<span class="comments">;               width equal to 1.5 sigma = 0.637* FWHM.  CNTRD will prompt</span>
<span class="comments">;               for FWHM if not supplied</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUTS:   </span>
<span class="comments">;       XCEN - the computed X centroid position, same number of points as X</span>
<span class="comments">;       YCEN - computed Y centroid position, same number of points as Y, </span>
<span class="comments">;              floating point</span>
<span class="comments">;</span>
<span class="comments">;       Values for XCEN and YCEN will not be computed if the computed</span>
<span class="comments">;       centroid falls outside of the box, or if the computed derivatives</span>
<span class="comments">;       are non-decreasing.   If the centroid cannot be computed, then a </span>
<span class="comments">;       message is displayed and XCEN and YCEN are set to -1.</span>
<span class="comments">;</span>
<span class="comments">;  OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       /SILENT - Normally CNTRD prints an error message if it is unable</span>
<span class="comments">;               to compute the centroid.   Set /SILENT to suppress this.</span>
<span class="comments">;       /DEBUG - If this keyword is set, then CNTRD will display the subarray</span>
<span class="comments">;               it is using to compute the centroid.</span>
<span class="comments">;       EXTENDBOX = {non-negative positive integer}.   CNTRD searches a box with</span>
<span class="comments">;              a half width equal to 1.5 sigma  = 0.637* FWHM to find the </span>
<span class="comments">;              maximum pixel.    To search a larger area, set EXTENDBOX to </span>
<span class="comments">;              the number of pixels to enlarge the half-width of the box.</span>
<span class="comments">;              Default is 0; prior to June 2004, the default was EXTENDBOX= 3</span>
<span class="comments">;       /KeepCenter = By default, CNTRD finds the maximum pixel in a box </span>
<span class="comments">;              centered on the input X,Y coordinates, and then extracts a new</span>
<span class="comments">;              box about this maximum pixel.   Set the /KeepCenter keyword  </span>
<span class="comments">;              to skip then step of finding the maximum pixel, and instead use</span>
<span class="comments">;              a box centered on the input X,Y coordinates.                          </span>
<span class="comments">;  PROCEDURE: </span>
<span class="comments">;       Maximum pixel within distance from input pixel X, Y  determined </span>
<span class="comments">;       from FHWM is found and used as the center of a square, within </span>
<span class="comments">;       which the centroid is computed as the value (XCEN,YCEN) at which </span>
<span class="comments">;       the derivatives of the partial sums of the input image over (y,x)</span>
<span class="comments">;       with respect to (x,y) = 0.    In order to minimize contamination from</span>
<span class="comments">;       neighboring stars stars, a weighting factor W is defined as unity in </span>
<span class="comments">;       center, 0.5 at end, and linear in between </span>
<span class="comments">;</span>
<span class="comments">;  RESTRICTIONS:</span>
<span class="comments">;       (1) Does not recognize (bad) pixels.   Use the procedure GCNTRD.PRO</span>
<span class="comments">;           in this situation. </span>
<span class="comments">;       (2) DAOPHOT now uses a newer algorithm (implemented in GCNTRD.PRO) in </span>
<span class="comments">;           which centroids are determined by fitting 1-d Gaussians to the </span>
<span class="comments">;           marginal distributions in the X and Y directions.</span>
<span class="comments">;       (3) The default behavior of CNTRD changed in June 2004 (from EXTENDBOX=3</span>
<span class="comments">;           to EXTENDBOX = 0).</span>
<span class="comments">;       (4) Stone (1989, AJ, 97, 1227) concludes that the derivative search</span>
<span class="comments">;           algorithm in CNTRD is not as effective (though faster) as a </span>
<span class="comments">;            Gaussian fit (used in GCNTRD.PRO).</span>
<span class="comments">;  MODIFICATION HISTORY:</span>
<span class="comments">;       Written 2/25/86, by J. K. Hill, S.A.S.C., following</span>
<span class="comments">;       algorithm used by P. Stetson in DAOPHOT.</span>
<span class="comments">;       Allowed input vectors        G. Hennessy       April,  1992</span>
<span class="comments">;       Fixed to prevent wrong answer if floating pt. X & Y supplied</span>
<span class="comments">;               W. Landsman        March, 1993</span>
<span class="comments">;       Convert byte, integer subimages to float  W. Landsman  May 1995</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Better checking of edge of frame David Hogg October 2000</span>
<span class="comments">;       Avoid integer wraparound for unsigned arrays W.Landsman January 2001</span>
<span class="comments">;       Handle case where more than 1 pixel has maximum value W.L. July 2002</span>
<span class="comments">;       Added /KEEPCENTER, EXTENDBOX (with default = 0) keywords WL June 2004</span>
<span class="comments">;       Some errrors were returning X,Y = NaN rather than -1,-1  WL Aug 2010</span>
<span class="comments">;-      </span>
 On_error,2                          <span class="comments">;Return to caller</span>
 compile_opt idl2
 
 if N_params() LT 5 then begin
        print,'Syntax: CNTRD, img, x, y, xcen, ycen, [ fwhm, ' 
        print,'              EXTENDBOX= , /KEEPCENTER, /SILENT, /DEBUG ]'
        PRINT,'img - Input image array'
        PRINT,'x,y - Input scalars giving approximate X,Y position'
        PRINT,'xcen,ycen - Output scalars giving centroided X,Y position'
        return
 endif else if N_elements(fwhm) NE 1 then $
      read,'Enter approximate FWHM of image in pixels: ',fwhm

 sz_image = size(img)
 if sz_image[0] NE 2 then message, $
   'ERROR - Image array (first parameter) must be 2 dimensional'

 xsize = sz_image[1]
 ysize = sz_image[2]
 dtype = sz_image[3]              <span class="comments">;Datatype</span>

<span class="comments">;   Compute size of box needed to compute centroid</span>

 if ~keyword_set(extendbox) then extendbox = 0
 nhalf =  fix(0.637*fwhm) > 2  <span class="comments">;</span>
 nbox = 2*nhalf+1             <span class="comments">;Width of box to be used to compute centroid</span>
 nhalfbig = nhalf + extendbox
 nbig = nbox + extendbox*2        <span class="comments">;Extend box 3 pixels on each side to search for max pixel value</span>
 npts = N_elements(x) 
 xcen = float(x) & ycen = float(y)
 ix = round( x )          <span class="comments">;Central X pixel        ;Added 3/93</span>
 iy = round( y )          <span class="comments">;Central Y pixel</span>

 for i = 0,npts-1 do begin        <span class="comments">;Loop over X,Y vector</span>

 pos = strtrim(x[i],2) + ' ' + strtrim(y[i],2)

 if ~keyword_set(keepcenter) then begin
 if ( (ix[i] LT nhalfbig) || ((ix[i] + nhalfbig) GT xsize-1) || $
      (iy[i] LT nhalfbig) || ((iy[i] + nhalfbig) GT ysize-1) ) then begin
     if not keyword_set(SILENT) then message,/INF, $
           'Position '+ pos + ' too near edge of image'
     xcen[i] = -1   & ycen[i] = -1
     goto, DONE
 endif

 bigbox = img[ix[i]-nhalfbig : ix[i]+nhalfbig, iy[i]-nhalfbig : iy[i]+nhalfbig]

<span class="comments">;  Locate maximum pixel in 'NBIG' sized subimage </span>

 mx = max( bigbox)     <span class="comments">;Maximum pixel value in BIGBOX</span>
 mx_pos = where(bigbox EQ mx, Nmax) <span class="comments">;How many pixels have maximum value?</span>
 idx = mx_pos mod nbig          <span class="comments">;X coordinate of Max pixel</span>
 idy = mx_pos / nbig            <span class="comments">;Y coordinate of Max pixel</span>
 if NMax GT 1 then begin        <span class="comments">;More than 1 pixel at maximum?</span>
     idx = round(total(idx)/Nmax)
     idy = round(total(idy)/Nmax)
 endif else begin
     idx = idx[0]
     idy = idy[0]
 endelse

 xmax = ix[i] - (nhalf+extendbox) + idx  <span class="comments">;X coordinate in original image array</span>
 ymax = iy[i] - (nhalf+extendbox) + idy  <span class="comments">;Y coordinate in original image array</span>
 endif else begin
    xmax = ix[i]
    ymax = iy[i]
 endelse

<span class="comments">; ---------------------------------------------------------------------</span>
<span class="comments">; check *new* center location for range</span>
<span class="comments">; added by Hogg</span>

 if ( (xmax LT nhalf) || ((xmax + nhalf) GT xsize-1) || $
      (ymax LT nhalf) || ((ymax + nhalf) GT ysize-1) ) then begin
     if not keyword_set(SILENT) then message,/INF, $
           'Position '+ pos + ' moved too near edge of image'
     xcen[i] = -1   & ycen[i] = -1
     goto, DONE
 endif
<span class="comments">; ---------------------------------------------------------------------</span>

<span class="comments">;  Extract smaller 'STRBOX' sized subimage centered on maximum pixel </span>

 strbox = img[xmax-nhalf : xmax+nhalf, ymax-nhalf : ymax+nhalf]
 if (dtype NE 4) and (dtype NE 5) then strbox = float(strbox)

 if keyword_set(DEBUG) then begin
       message,'Subarray used to compute centroid:',/inf
       print,strbox
 endif  

 ir = (nhalf-1) > 1 
 dd = indgen(nbox-1) + 0.5 - nhalf
<span class="comments">; Weighting factor W unity in center, 0.5 at end, and linear in between </span>
 w = 1. - 0.5*(abs(dd)-0.5)/(nhalf-0.5) 
 sumc   = total(w)

<span class="comments">; Find X centroid</span>

 deriv = shift(strbox,-1,0) - strbox    <span class="comments">;Shift in X & subtract to get derivative</span>
 deriv = deriv[0:nbox-2,nhalf-ir:nhalf+ir] <span class="comments">;Don't want edges of the array</span>
 deriv = total( deriv, 2 )                        <span class="comments">;Sum X derivatives over Y direction</span>
 sumd   = total( w*deriv )
 sumxd  = total( w*dd*deriv )
 sumxsq = total( w*dd^2 )

 if sumxd GE 0 then begin  <span class="comments">;Reject if X derivative not decreasing</span>
   
   if ~keyword_set(SILENT) then message,/INF, $
        'Unable to compute X centroid around position '+ pos
   xcen[i]=-1 & ycen[i]=-1
   goto,DONE
 endif 

 dx = sumxsq*sumd/(sumc*sumxd)
 if ( abs(dx) GT nhalf ) then begin    <span class="comments">;Reject if centroid outside box  </span>
   if not keyword_set(SILENT) then message,/INF, $
       'Computed X centroid for position '+ pos + ' out of range'
   xcen[i]=-1 & ycen[i]=-1 
   goto, DONE
 endif

 xcen[i] = xmax - dx    <span class="comments">;X centroid in original array</span>

<span class="comments">;  Find Y Centroid</span>

 deriv = shift(strbox,0,-1) - strbox
 deriv = deriv[nhalf-ir:nhalf+ir,0:nbox-2]
 deriv = total( deriv,1 )
 sumd =   total( w*deriv )
 sumxd =  total( w*deriv*dd )
 sumxsq = total( w*dd^2 )
 if (sumxd GE 0) then begin  <span class="comments">;Reject if Y derivative not decreasing</span>
   if not keyword_set(SILENT) then message,/INF, $
        'Unable to compute Y centroid around position '+ pos
        xcen[i] = -1   & ycen[i] = -1
        goto, DONE
 endif

 dy = sumxsq*sumd/(sumc*sumxd)
 if (abs(dy) GT nhalf) then begin <span class="comments">;Reject if computed Y centroid outside box</span>
   if ~keyword_set(SILENT) then message,/INF, $
       'Computed X centroid for position '+ pos + ' out of range'
        xcen[i]=-1 & ycen[i]=-1
        goto, DONE
 endif 
 
 ycen[i] = ymax-dy

 DONE: 

 endfor

 return
 end


</code>
    </div>
  </body>
</html>