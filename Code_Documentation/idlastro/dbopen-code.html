<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbopen.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbopen.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbopen:source"></a>pro dbopen,name,update,UNAVAIL=unavail   
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBOPEN</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Routine to open an IDL database</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       dbopen, name, update</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       name - (Optional) name or names of the data base files to open.</span>
<span class="comments">;               It has one of the following forms:</span>
<span class="comments">;</span>
<span class="comments">;               'name'          -open single data base file</span>
<span class="comments">;               'name1,name2,...,nameN' - open N files which are</span>
<span class="comments">;                               connected via pointers.</span>
<span class="comments">;               'name,*'        -Open the data base with all data</span>
<span class="comments">;                               bases connected via pointers</span>
<span class="comments">;               ''              -Interactively allow selection of</span>
<span class="comments">;                               the data base files.</span>
<span class="comments">;</span>
<span class="comments">;               If not supplied then '' is assumed.</span>
<span class="comments">;               name may optionally be a string array with one name</span>
<span class="comments">;               per element.</span>
<span class="comments">;</span>
<span class="comments">;       update - (Optional) Integer flag specifing openning for update.</span>
<span class="comments">;               0       - Open for read only</span>
<span class="comments">;               1       - Open for update</span>
<span class="comments">;               2       - Open index file for update only</span>
<span class="comments">;               !PRIV must be 2 or greater to open a file for update.</span>
<span class="comments">;               If a file is opened for update only a single data base</span>
<span class="comments">;               can be specified.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       none</span>
<span class="comments">;</span>
<span class="comments">; INPUT-OUTPUT KEYWORD:</span>
<span class="comments">;       UNAVAIL - If present, a "database doesn't exit" flag is returned</span>
<span class="comments">;                 through it.  0 = the database exists and was opened (if</span>
<span class="comments">;                 no other errors arose).  1 = the database doesn't exist.</span>
<span class="comments">;                 Also if present, the error message for non-existent databases</span>
<span class="comments">;                 is suppressed.  The action, however, remains the same.  </span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;       The .DBF and .dbx files are opened using unit numbers obtained by</span>
<span class="comments">;       GET_LUN.  Descriptions of the files are placed in the common block</span>
<span class="comments">;       DB_COM.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       DBCLOSE, DB_INFO(), SELECT_W, ZPARCHECK</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       For IDL Version 2  W. Landsman May 1990 -- Will require further </span>
<span class="comments">;           modfication once SCREEN_SELECT is working</span>
<span class="comments">;       Modified to work under Unix, D. Neill, ACC, Feb 1991.</span>
<span class="comments">;       UNAVAIL keyword added.  M. Greason, Hughes STX, Feb 1993.</span>
<span class="comments">;       William Thompson, GSFC/CDS (ARC), 1 June 1994</span>
<span class="comments">;               Added support for external (IEEE) representation.</span>
<span class="comments">;       William Thompson, GSFC, 3 November 1994</span>
<span class="comments">;                       Modified to allow ZDBASE to be a path string.</span>
<span class="comments">;       8/29/95 JKF/ACC - forces lowercase for input database names.</span>
<span class="comments">;       W. Landsman, Use CATCH to catch errors    July, 1997</span>
<span class="comments">;       W. Landsman Use vector call to FDECOMP, STRSPLIT()    Sep 2006</span>
<span class="comments">;       W. Landsman Remove obsolete keywords to OPEN   Sep 2006</span>
<span class="comments">;       Replace SCREEN_SELECT with SELECT_W, remove IEEE_TO_HOST  WL  Jan 2009</span>
<span class="comments">;       Fix typos in BYTEORDER introduced Jan 2009 G. Scandariato/W.L.Feb. 2009</span>
<span class="comments">;       Support new DB format which allows entry lengths > 32767 bytes </span>
<span class="comments">;              W.L. October 2010</span>
<span class="comments">;       William Thompson, fixed bug opening multiple databases Dec 2010</span>
<span class="comments">;       Fix problem with external databases WL Sep 2011</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;------------------------------------------------------------------------</span>
On_error,2
<span class="comments">;</span>
<span class="comments">; data base common block</span>
<span class="comments">;</span>
common db_com,QDB,QITEMS,QDBREC
<span class="comments">;</span>
<span class="comments">; QDB(*,i) contains the following for each data base opened</span>
<span class="comments">;</span>
<span class="comments">;       bytes</span>
<span class="comments">;         0-18   data base name character*19</span>
<span class="comments">;         19-79  data base title character*61</span>
<span class="comments">;         80-81  number of items (integer*2)</span>
<span class="comments">;         82-83  record length of DBF file (integer*2)</span>
<span class="comments">;         84-87  number of entries in file (integer*4)</span>
<span class="comments">;         88-89  position of first item for this file in QITEMS (I*2)</span>
<span class="comments">;         90-91  position of last item for this file (I*2)</span>
<span class="comments">;         92-95  Last Sequence number used (item=SEQNUM) (I*4)</span>
<span class="comments">;         96     Unit number of .DBF file</span>
<span class="comments">;         97     Unit number of .dbx file (0 if none exists)</span>
<span class="comments">;         98-99  Index number of item pointing to this file (0 for first db)</span>
<span class="comments">;         100-103 Number of entries with space allocated</span>
<span class="comments">;         104    Update flag (0 open for read only, 1 open for update)</span>
<span class="comments">;         105-108  record length of DBF file (integer*4)</span>
<span class="comments">;         118    Equals 1 if more 32767 bytes can be stored in database (new format)</span>
<span class="comments">;         119    Equals 1 if external data representation (IEEE) is used</span>
<span class="comments">;</span>
<span class="comments">;  QITEMS(*,i) contains decription of item number i with following</span>
<span class="comments">;  byte assignments:</span>
<span class="comments">;</span>
<span class="comments">;       0-19    item name (character*20)</span>
<span class="comments">;       20-21   IDL data type (integer*2)</span>
<span class="comments">;       22-23   Number of values for item (1 for scalar) (integer*2)</span>
<span class="comments">;               in bytes 179-182 in new format</span>
<span class="comments">;       24-25   Starting byte position in original DBF record </span>
<span class="comments">;                In bytes 183-186 (integer*2) New DB format</span>
<span class="comments">;       26-27   Number of bytes per data value (integer*2)</span>
<span class="comments">;       28      Index type</span>
<span class="comments">;       29-97   Item description</span>
<span class="comments">;       98-99   print format field length</span>
<span class="comments">;       100     flag (1 if this items points to a data base)</span>
<span class="comments">;       101-119 Data base this item points to</span>
<span class="comments">;       120-125 Print format</span>
<span class="comments">;       126-170 Print headers</span>
<span class="comments">;       171-172 Starting byte in record returned by DBRD</span>
<span class="comments">;       173-174 Data base number in QDB</span>
<span class="comments">;       175-176 Data base number this item points to</span>
<span class="comments">;       177-178 Item number within the specific data base</span>
<span class="comments">;       179-182 Number of values for item (1 for scalar) (integer*4)</span>
<span class="comments">;       183-186  Starting byte position in original DBF record (integer*4)</span>
<span class="comments">;       187-190 Starting byte in record returned by DBRD</span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; check for valid input parameters</span>
<span class="comments">;</span>
if N_params() lt 1 then name=''
if N_params() lt 2 then update=0
 catch, error_status
 if error_status NE 0 then begin 
       print,!ERR_STRING
       return
  endif

zparcheck,'DBOPEN',name,1,7,[0,1],'Data base name[s]'
zparcheck,'DBOPEN',update,2,[1,2,3,4,5],0,'Update flag'
<span class="comments">;</span>
<span class="comments">; check privilege</span>
<span class="comments">;</span>
if update and (!priv lt 2) then  $
        message,'!PRIV must be 2 or greater to open with update'
<span class="comments">;</span>
<span class="comments">; check UNAVAIL</span>
<span class="comments">;</span>
unav_flg = arg_present(unavail) 
unavail = 0
totret = 1
<span class="comments">;---------------------------------------------------------------------</span>
<span class="comments">;       PROCESS INPUT NAMES (CREATE STRING ARRAY)</span>
<span class="comments">;</span>
<span class="comments">; Process scalar name</span>
<span class="comments">;</span>
s=size(name) & ndim=s[0]
if ndim eq 0 then begin
<span class="comments">;</span>
<span class="comments">; process name=''</span>
<span class="comments">;</span>
    if strtrim(name) EQ '' then begin
        names = list_with_path('*.dbh', 'ZDBASE', Count = N)
        if n EQ 0 then message, $
           'No database (.dbh) files found in ZDBASE or current directory'
        fdecomp,names,disk,dir,fnames,qual,ver
        
        select_w,fnames,isel,'db_titles', $
                'Select data base file to open',1
        fnames=fnames[intarr(1)+isel]
      end else $
<span class="comments">;</span>
<span class="comments">; separate names into string array</span>
<span class="comments">;</span>
        fnames = strlowcase( strsplit(name,',',/extract))
   end else begin
<span class="comments">;</span>
<span class="comments">; name is already a string vector</span>
<span class="comments">;</span>
    fnames=name
end
<span class="comments">;</span>
<span class="comments">; if update, only one data base can be opened</span>
<span class="comments">;</span>
if update then if N_elements(fnames) gt 1 then $
        message,'Only one file can be specified if mode is update'
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;       LOOP AND OPEN EACH DATA BASE</span>
<span class="comments">;</span>
<span class="comments">; close any data bases already open</span>
<span class="comments">;</span>
dbclose
<span class="comments">;</span>
<span class="comments">;</span>
offset=0                <span class="comments">;byte offset in dbrd record for data base</span>
tot_items=0             <span class="comments">;total number of items all opened data bases</span>
get_lun,unit            <span class="comments">;get unit number to use for .dbh files</span>
dbno=0                  <span class="comments">;present data base number</span>
while dbno lt n_elements(fnames) do begin
    dbname=strtrim(fnames[dbno])
<span class="comments">;</span>
<span class="comments">; process * if second in list  -----------------------</span>
<span class="comments">;</span>
    if dbname eq '*' then begin         <span class="comments">;get data base names from pointers</span>
        if dbno ne 1 then begin         <span class="comments">;* must be second data base</span>
            message,'Invalid use of * specification',/continue
            goto,ABORT   
        endif
        pointers=qitems[100,*]          <span class="comments">;find pointer items</span>
        good=where(pointers,n)
        if n eq 0 then goto,done        <span class="comments">;no pointers</span>
        pnames=string(qitems[101:119,*])<span class="comments">;file names for pointers</span>
        fnames=[fnames[0],pnames[good]] <span class="comments">;new file list</span>
        dbname=strtrim(fnames[1])       <span class="comments">;new second name</span>
    end
<span class="comments">;</span>
<span class="comments">; open .dbh file and read contents ------------------------</span>
<span class="comments">;</span>
    dbhname = find_with_def(dbname+'.dbh', 'ZDBASE')

    openr,unit,dbhname,ERROR=err     

    if err NE 0 then begin
        if unav_flg EQ 0 then begin
                message,'Error opening .dbh file '+ dbname,/CONTINUE
                print,!SYSERR_STRING
        endif else totret = 0
        unavail = 1
        goto, ABORT 
    end
    db=bytarr(120)
    readu,unit,db
    
    external = db[119] eq 1     <span class="comments">;Is external data rep. being used?</span>
    newdb = db[118] eq 1        <span class="comments">; New db format allowing longwords</span>
    totbytes = newdb ? long(db,105,1) :  fix(db,82,1)
    totbytes = totbytes[0]      <span class="comments">;Make sure is scalar</span>
     nitems=fix(db,80,1) & nitems=nitems[0] <span class="comments">;number of items or fields in file</span>

    if external then begin
        if newdb then begin
        byteorder, totbytes, /NTOHL  &  db[105] = byte(totbytes,0,4) 
	endif else begin
        byteorder, totbytes, /NTOHS  &  db[82] = byte(totbytes,0,2)
	endelse
        byteorder, nitems,/NTOHS   &  db[80] = byte(nitems,0,2)
    endif
    items=bytarr(200,nitems)
    readu,unit,items
    close,unit
    if external then begin
        tmp = fix(items[20:27,*],0,4,nitems)
        byteorder,tmp, /ntohs
        items[20,0] = byte(tmp,0,8,nitems)
<span class="comments">;</span>
        tmp = fix(items[98:99,*],0,1,nitems)
        byteorder,tmp,/NTOHS
        items[98,0] = byte(tmp,0,2,nitems)
<span class="comments">;</span>
        tmp = fix(items[171:178,*],0,4,nitems)
        byteorder,tmp,/NTOHS
        items[171,0] = byte(tmp,0,8,nitems)     
	
	if newdb then begin
        tmp = long(items[179:186,*],0,2,nitems)
        byteorder,tmp,/NTOHL

        items[179,0] = byte(tmp,0,8,nitems)
	endif
    endif

<span class="comments">;</span>
<span class="comments">; add computed information to items ---------------------------</span>
<span class="comments">;</span>
    sbyte = newdb ?  long(items[183:186,*],0,nitems)+offset : $ 
                     fix(items[24:25,*],0,nitems)+offset 

    for i=0,nitems-1 do begin
        if newdb then items[187,i]= byte(sbyte[i],0,4)  else $
	              items[171,i] = byte(sbyte[i],0,2)
	            <span class="comments">;starting byte in DBRD record</span>
        items[173,i]=byte(dbno,0,2)     <span class="comments">;data base number</span>
        items[177,i]=byte(i,0,2)        <span class="comments">;item number</span>
    end
    offset=offset+totbytes
<span class="comments">;</span>
<span class="comments">; open .dbf file ---------------------------------</span>
<span class="comments">;</span>
    get_lun,unitdbf
    dbf_file = find_with_def(dbname+'.dbf', 'ZDBASE')

    if update eq 1 then $
         openu,unitdbf,dbf_file else $ 
         openr,unitdbf,dbf_file,error=err
    if err ne 0 then begin
        message,'Error opening '+dbname+'.dbf',/continue
        free_lun,unitdbf
        goto,abort
    end

    p=assoc(unitdbf,lonarr(2))
    head = p[0]
    if external then byteorder, head, /NTOHL
    db[96]=unitdbf                      <span class="comments">;unit number of .dbf file</span>
    db[84]=byte(head[0],0,4)            <span class="comments">;number of entries</span>
    db[92]=byte(head[1],0,4)            <span class="comments">;last seqnum used</span>
    db[88]=byte(tot_items,0,2)          <span class="comments">;starting item number for this db</span>
    tot_items=tot_items+nitems          <span class="comments">;new total number of items</span>
    db[90]=byte(tot_items-1,0,2)        <span class="comments">;last item number for this db</span>
    db[104]=update                      <span class="comments">;opened for update</span>
<span class="comments">;</span>
<span class="comments">; open index file if necessary -----------------------------</span>
<span class="comments">;</span>

    index=where(items[28,*] gt 0,nindex)        <span class="comments">;indexed items</span>
   
    if nindex gt 0 then begin           <span class="comments">;need to open index file.</span>
        get_lun,unitind
        dbx_file = find_with_def(dbname+'.dbx', 'ZDBASE')
        if update gt 0 then $
                  openu,unitind,dbx_file,error=err $
           else openr,unitind,dbx_file,error=err
        if err ne 0 then begin
                message,'Error opening index file for '+dbname,/continue
                free_lun,unitdbf
                free_lun,unitind
                goto,abort
        endif
        db[97]=unitind                  <span class="comments">;unit number for index file</span>
    end
<span class="comments">;</span>
<span class="comments">; add to common block ---------------------</span>
<span class="comments">;</span>

    if dbno eq 0 then begin
        qdb=db
        qitems=items
      end else begin
        old=qdb
        qdb=bytarr(120,dbno+1)
        qdb[0,0] = old
        qdb[0,dbno] = db
        old=qitems
        qitems=bytarr(200,tot_items)
        qitems[0,0] = old
        qitems[0,tot_items-nitems] = items
    end
<span class="comments">;</span>
    dbno=dbno+1
end<span class="comments">; loop on data bases</span>
done: free_lun,unit


<span class="comments">;--------------------------------------------------------------------</span>
<span class="comments">;               LINK PROCESSING</span>
<span class="comments">;</span>
<span class="comments">; determine linkages between data bases</span>
<span class="comments">;</span>
numdb = N_elements(fnames)
if numdb gt 1 then begin
    pnames=strupcase(qitems[101:119,*])
    for i=1,numdb-1 do begin
        dbname=strupcase(qdb[0:18,i])   <span class="comments">;name of the data base</span>
        for j=0,tot_items-1 do if pnames[j] eq dbname then goto,found
<span class="comments">;</span>
<span class="comments">; if we made it here we can not link the file -----------</span>
<span class="comments">;</span>
        message,'Unable to link data base file '+dbname,/continue
        goto,abort
<span class="comments">;</span>
<span class="comments">; found linkage item ------------------------------------</span>
<span class="comments">;</span>

found:
        item_number=j           <span class="comments">;number of item supplying link</span>
        item_db=fix(qitems[173:174,item_number],0,1) & item_db=item_db[0]
        if item_db ge i then begin
                message,'Unable to link data base '+dbname + $
                        'to previous data base.',/continue
                print,' Possible incorrect ordering of input data bases'
                goto,abort
        endif
        qitems[175,item_number]=byte(i,0,2)     <span class="comments">;data base number pointed to</span>
        qdb[98,i]=byte(item_number,0,2)         <span class="comments">;item number pointing to this db</span>
nextdb:
    endfor
endif

<span class="comments">;</span>
<span class="comments">; create an assoc variable for the first db</span>
<span class="comments">;</span>

unit=db_info('unit_dbf',0)
len=db_info('length',0)
qdbrec=assoc(unit,bytarr(len))
<span class="comments">;----------------------------------------------------------------------------</span>
<span class="comments">; done</span>
<span class="comments">;</span>

return
<span class="comments">;</span>
<span class="comments">; abort</span>
<span class="comments">;</span>
abort:
dbclose                         <span class="comments">;close any open data bases</span>
free_lun,unit
if (totret NE 0) then retall else return
end
</code>
    </div>
  </body>
</html>