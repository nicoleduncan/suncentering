<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:01 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sixlin.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sixlin.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="sixlin:source"></a>pro sixlin,xx,yy,a,siga,b,sigb,weight=weight
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       SIXLIN</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Compute linear regression coefficients by six different methods.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Adapted from the FORTRAN program (Rev. 1.1)  supplied by Isobe, </span>
<span class="comments">;       Feigelson, Akritas, and Babu Ap. J. Vol. 364, p. 104 (1990).   </span>
<span class="comments">;       Suggested when there is no understanding about the nature of the </span>
<span class="comments">;       scatter about a linear relation, and NOT when the errors in the </span>
<span class="comments">;       variable are calculable.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       SIXLIN, xx, yy, a, siga, b, sigb, [WEIGHT = ]  </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       XX - vector of X values</span>
<span class="comments">;       YY - vector of Y values, same number of elements as XX</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       A - Vector of 6 Y intercept coefficients</span>
<span class="comments">;       SIGA - Vector of standard deviations of 6 Y intercepts</span>
<span class="comments">;       B - Vector of 6 slope coefficients</span>
<span class="comments">;       SIGB - Vector of standard deviations of slope coefficients</span>
<span class="comments">;</span>
<span class="comments">;       The output variables are computed using linear regression for each of </span>
<span class="comments">;       the following 6 cases:</span>
<span class="comments">;               (0) Ordinary Least Squares (OLS) Y vs. X (c.f. linfit.pro)</span>
<span class="comments">;               (1) Ordinary Least Squares  X vs. Y</span>
<span class="comments">;               (2) Ordinary Least Squares Bisector</span>
<span class="comments">;               (3) Orthogonal Reduced Major Axis</span>
<span class="comments">;               (4) Reduced Major-Axis </span>
<span class="comments">;               (5) Mean ordinary Least Squares</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;      WEIGHT -  vector of weights, same number of elements as XX and YY</span>
<span class="comments">;                For 1 sigma Gausssian errors, the weights are 1/sigma^2 but</span>
<span class="comments">;                the weight vector can be more general.   Default is no </span>
<span class="comments">;                weighting. </span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Isobe et al. make the following recommendations</span>
<span class="comments">;</span>
<span class="comments">;       (1) If the different linear regression methods yield similar results</span>
<span class="comments">;               then quoting OLS(Y|X) is probably the most familiar.</span>
<span class="comments">;</span>
<span class="comments">;       (2) If the linear relation is to be used to predict Y vs. X then</span>
<span class="comments">;               OLS(Y|X) should be used.   </span>
<span class="comments">;</span>
<span class="comments">;       (3) If the goal is to determine the functional relationship between</span>
<span class="comments">;               X and Y then the OLS bisector is recommended.</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written   Wayne Landsman          February, 1991         </span>
<span class="comments">;       Corrected sigma calculations      February, 1992</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Added WEIGHT keyword   J. Moustakas   Februrary 2007</span>
<span class="comments">;-</span>
 compile_opt idl2
 On_error, 2                                   <span class="comments">;Return to Caller</span>

 if N_params() LT 5 then begin   
    print,'Syntax - SIXLIN, xx, yy, a, siga, b, sigb, {WEIGHT =]'   
    return
  endif

 b = dblarr(6) &  siga = b & sigb =b
 x = double(xx)      <span class="comments">;Keep input X and Y vectors unmodified</span>
 y = double(yy)
 rn = N_elements(x)

 if rn LT 2 then $
    message,'Input X and Y vectors must contain at least 2 data points'

 if rn NE N_elements(y) then $
    message,'Input X and Y vectors must contain equal number of data points'

 if (n_elements(weight) eq 0L) then weight = replicate(1.0,rn) else begin
    if (rn ne n_elements(weight)) then $
      message,'Input X and WEIGHT vectors must contain equal number of data points'
 endelse
 
<span class="comments">; Compute averages and sums</span>

 sumw = total(weight) 
 
 xavg = total( weight * x)/sumw
 yavg = total( weight * y)/sumw
 x = x - xavg
 y = y - yavg
 sxx = total( weight * x^2)
 syy = total( weight * y^2)
 sxy = total( weight * x*y)
 if sxy EQ 0. then $
      message,'SXY is zero, SIXLIN is terminated'
 if sxy LT 0. then sign = -1.0 else sign = 1.0

<span class="comments">; Compute the slope coefficients</span>

 b[0] = sxy / sxx
 b[1] = syy / sxy
 b[2] = (b[0]*b[1] - 1.D + sqrt((1.D + b[0]^2)*(1.D +b[1]^2)))/(b[0] + b[1] )
 b[3] = 0.5 * ( b[1] - 1.D/b[0] + sign*sqrt(4.0D + (b[1]-1.0/b[0])^2))
 b[4] = sign*sqrt( b[0]*b[1] )
 b[5] = 0.5 * ( b[0] + b[1] )

<span class="comments">; Compute Intercept Coefficients</span>

 a = yavg - b*xavg

<span class="comments">;  Prepare for computation of variances</span>

 gam1 = b[2] / ( (b[0] + b[1]) *   $
         sqrt( (1.D + b[0]^2)*(1.D + b[1]^2)) )
 gam2 = b[3] / (sqrt( 4.D*b[0]^2 + ( b[0]*b[1] - 1.D)^2))
 sum1 = total( weight * ( x*( y - b[0]*x ) )^2)
 sum2 = total( weight * ( y*( y - b[1]*x ) )^2)
 sum3 = total( weight * x * y * ( y - b[0]*x) * (y - b[1]*x ) )
 cov = sum3 / ( b[0]*sxx^2 )

<span class="comments">; Compute variances of the slope coefficients</span>

 sigb[0] = sum1 / sxx^2
 sigb[1] = sum2 / sxy^2
 sigb[2] = (gam1^2) * ( ( (1.D + b[1]^2) ^2 )*sigb[0] +  $
                  2.D*(1.D + b[0]^2) * (1.D + b[1]^2)*cov + $
                  (  (1.D + b[0]^2)^2)*sigb[1] )
 sigb[3] = (gam2^2)*( sigb[0]/b[0]^2 + 2.D*cov + b[0]^2*sigb[1] )
 sigb[4] = 0.25*(b[1]*sigb[1]/b[1] + $
                     2.D*cov + b[0]*sigb[1]/b[1] )
 sigb[5] = 0.25*(sigb[0] + 2.D*cov + sigb[1] )

<span class="comments">; Compute variances of the intercept coefficients</span>

 siga[0] = total( weight * ( ( y - b[0]*x) * (1.D - sumw*xavg*x/sxx) )^2 )
 siga[1] = total( weight * ( ( y - b[1]*x) * (1.D - sumw*xavg*y/sxy) )^2 ) 
 siga[2] = total( weight * ( (x * (y - b[0]*x) * (1.D + b[1]^2) / sxx + $
                  y * (y - b[1]*x) * (1.D + b[0]^2) / sxy)*  $
                  gam1 * xavg * sumw - y + b[2] * x) ^ 2)
 siga[3] = total( weight * ( ( x * ( y - b[0]*x) / sxx + $
                   y * ( y - b[1]*x) * b[0]^2/ sxy) * gam2 * $
                   xavg * sumw / sqrt( b[0]^2) - y + b[3]*x) ^ 2 )
 siga[4] = total( weight * ( ( x * ( y - b[0] * x) * sqrt( b[1] / b[0] ) / sxx + $
                   y * ( y - b[1] * x) * sqrt( b[0] / b[1] ) / sxy) * $
                  0.5 * sumw * xavg - y + b[4] * x)^2 )

 siga[5] = total( weight * ( (x * ( y - b[0] * x) / sxx +  $
                  y * ( y - b[1] * x) / sxy)*    $
                  0.5 * sumw * xavg - y + b[5]*x )^2 )

<span class="comments">; Convert variances to standard deviation</span>

 sigb = sqrt(sigb)
 siga = sqrt(siga)/sumw
 
 return
 end
</code>
    </div>
  </body>
</html>