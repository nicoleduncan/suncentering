<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:41 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hor2eq.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hor2eq.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   HOR2EQ</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Converts local horizon coords (alt-az) of something to equatorial (ra-dec).</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     This is a nice code to calculate equatorial (ra,dec) coordinates from</span>
<span class="comments">;     horizon (alt,az) coords.    It is typically accurate to about 1 arcsecond</span>
<span class="comments">;     or better (I have checked the output against the publicly available XEPHEM</span>
<span class="comments">;     software). It performs precession, nutation, aberration, and refraction</span>
<span class="comments">;     corrections.  The perhaps best thing about it is that it can take arrays</span>
<span class="comments">;     as inputs, in all variables and keywords EXCEPT Lat, lon, and Altitude</span>
<span class="comments">;    (the code assumes these aren't changing), and uses vector arithmetic in</span>
<span class="comments">;     every calculation except when calculating the precession matrices.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;    HOR2EQ, alt, az, jd, ra, dec, [ha, LAT= , LON= , /WS, OBSNAME= , $</span>
<span class="comments">;                       /B1950 , PRECESS_= 0, NUTATE_= 0, REFRACT_= 0, $</span>
<span class="comments">;                       ABERRATION_= 0, ALTITUDE= , /VERBOSE, _EXTRA= ]</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUT VARIABLES</span>
<span class="comments">;       alt  : altitude (in degrees) [scalar or vector]</span>
<span class="comments">;       az   : azimuth angle (in degrees, measured EAST from NORTH, but see</span>
<span class="comments">;              keyword WS below.) [scalar or vector]</span>
<span class="comments">;       JD   : Julian Date [scalar or vector], double precision</span>

<span class="comments">;       Note: if RA and DEC are arrays, then alt and az will also be arrays.</span>
<span class="comments">;             If RA and DEC are arrays, JD may be a scalar OR an array of</span>
<span class="comments">;              the same dimensionality.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       lat   : north geodetic latitude of location in degrees</span>
<span class="comments">;       lon   : EAST longitude of location in degrees</span>
<span class="comments">;               (Specify west longitude with a negative sign.)</span>
<span class="comments">;       /WS   : Set this to get the azimuth measured westward from south</span>
<span class="comments">;               (not East of North).</span>
<span class="comments">;       obsname   : Set this to a valid observatory name to be used by the</span>
<span class="comments">;               astrolib OBSERVATORY procedure, which will return the latitude</span>
<span class="comments">;               and longitude to be used by this program.</span>
<span class="comments">;       /B1950  : Set this if your ra and dec are specified in B1950,</span>
<span class="comments">;               FK4 coordinates (instead of J2000, FK5)</span>
<span class="comments">;       precess_ : Set this to 1 to force precession [default], 0 for no</span>
<span class="comments">;                 precession.</span>
<span class="comments">;       nutate_  : Set this to 1 to force nutation [default], 0 for no nutation.</span>
<span class="comments">;       aberration_ : Set this to 1 to force aberration correction [default],</span>
<span class="comments">;                 0 for no correction.</span>
<span class="comments">;       refract_  : Set to 1 to force refraction correction [default], 0 for</span>
<span class="comments">;                   no correction.</span>
<span class="comments">;       altitude: The altitude of the observing location, in meters. [default=0].</span>
<span class="comments">;       /verbose: Set this for verbose output.  The default is verbose=0.</span>
<span class="comments">;   _extra: This is for setting TEMPERATURE or PRESSURE explicitly, which are</span>
<span class="comments">;           used by CO_REFRACT to calculate the refraction effect of the</span>
<span class="comments">;           atmosphere. If you don't set these, the program will make an</span>
<span class="comments">;           intelligent guess as to what they are (taking into account your</span>
<span class="comments">;            altitude).  See CO_REFRACT for more details.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT VARIABLES</span>
<span class="comments">;       ra   : Right Ascension of object  (J2000) in degrees (FK5); scalar or</span>
<span class="comments">;              vector.</span>
<span class="comments">;       dec  : Declination of object (J2000) in degrees (FK5), scalar or vector.</span>
<span class="comments">;       ha   : hour angle (in degrees) (optional)</span>
<span class="comments">;</span>
<span class="comments">; DEPENDENCIES:</span>
<span class="comments">;       NUTATE, PRECESS, ADSTRING(), SUNPOS, OBSERVATORY (from the astrolib)</span>
<span class="comments">;       CO_NUTATE, CO_ABERRATION, CO_REFRACT, HADEC2ALTAZ</span>
<span class="comments">;</span>
<span class="comments">; BASIC STEPS</span>
<span class="comments">;   Precess Ra-Dec to current equinox.</span>
<span class="comments">;   Nutation Correction to Ra-Dec</span>
<span class="comments">;   Aberration correction to Ra-Dec</span>
<span class="comments">;   Calculate Local Mean Sidereal Time</span>
<span class="comments">;   Calculate Local Apparent Sidereal Time</span>
<span class="comments">;   Calculate Hour Angle</span>
<span class="comments">;   Do Spherical Trig to find Apparent Alt-Az</span>
<span class="comments">;   Apply refraction correction to find observed Alt.</span>
<span class="comments">;</span>
<span class="comments">;CORRECTIONS I DO NOT MAKE:</span>
<span class="comments">;   *  Deflection of Light by the sun due to GR. (typically milliarcseconds,</span>
<span class="comments">;        can be arcseconds within one degree of the sun)</span>
<span class="comments">;   *  The Effect of Annual Parallax (typically &lt; 1 arcsecond)</span>
<span class="comments">;   *  and more (see below)</span>
<span class="comments">;</span>
<span class="comments">; TO DO</span>
<span class="comments">;    * Better Refraction Correction.  Need to put in wavelength dependence,</span>
<span class="comments">;       and integrate through the atmosphere.</span>
<span class="comments">;    * Topocentric Parallax Correction (will take into account elevation of</span>
<span class="comments">;          the observatory)</span>
<span class="comments">;    * Proper Motion (but this will require crazy lookup tables or something).</span>
<span class="comments">;    * Difference between UTC and UT1 in determining LAST -- is this important?</span>
<span class="comments">;    * Effect of Annual Parallax (is this the same as topocentric Parallax?)</span>
<span class="comments">;    * Polar Motion</span>
<span class="comments">;    * Better connection to Julian Date Calculator.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   You are at Kitt Peak National Observatory, looking at a star at azimuth</span>
<span class="comments">;   angle 264d 55m 06s and elevation 37d 54m 41s (in the visible).  Today is</span>
<span class="comments">;   Dec 25, 2041 and the local time is 10 PM precisely.  What is the ra and dec</span>
<span class="comments">;   (J2000) of the star you're looking at?   The temperature here is about 0</span>
<span class="comments">;   Celsius, and the pressure is 781 millibars.    The Julian date for this</span>
<span class="comments">;   time is 2466879.7083333</span>
<span class="comments">;</span>
<span class="comments">;  IDL> hor2eq, ten(37,54,41), ten(264,55,06), 2466879.7083333d, ra, dec, $</span>
<span class="comments">;           /verb, obs='kpno', pres=781.0, temp=273.0</span>
<span class="comments">;</span>
<span class="comments">; The program produces this output (because the VERBOSE keyword was set):</span>
<span class="comments">;</span>
<span class="comments">; Latitude = +31 57 48.0   Longitude = *** 36  0.0   ; longitude prints weirdly b/c of negative input to ADSTRING!!</span>
<span class="comments">; Julian Date =  2466879.708333</span>
<span class="comments">; Az, El =  17 39 40.4  +37 54 41.0   (Observer Coords)</span>
<span class="comments">; Az, El =  17 39 40.4  +37 53 39.6   (Apparent Coords)</span>
<span class="comments">; LMST = +03 53 54.1</span>
<span class="comments">; LAST = +03 53 53.6</span>
<span class="comments">; Hour Angle = +03 38 30.1  (hh:mm:ss)</span>
<span class="comments">; Ra, Dec:  00 15 23.5  +15 25  1.9   (Apparent Coords)</span>
<span class="comments">; Ra, Dec:  00 15 24.2  +15 25  0.1   (J2041.9841)</span>
<span class="comments">; Ra, Dec:  00 13 14.1  +15 11  0.3   (J2000)</span>
<span class="comments">;</span>
<span class="comments">; The star is therefore Algenib!  Compare the derived Ra, Dec with what XEPHEM</span>
<span class="comments">; got:</span>
<span class="comments">; Ra, Dec:      00 13 14.2  +15 11  1.0   (J2000)</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Chris O'Dell</span>
<span class="comments">;       Univ. of Wisconsin-Madison</span>
<span class="comments">;   Observational Cosmology Laboratory</span>
<span class="comments">;   Email: odell@cmb.physics.wisc.edu</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;     Made all integers type LONG  W. Landsman   September 2007</span>
<span class="comments">;     Fixed for case of scalar Julian date but vector positions W L June 2009</span>
<span class="comments">;-</span>

<a id="hor2eq:source"></a>pro hor2eq, alt, az, jd, ra, dec, ha, lat=lat, lon=lon, WS=WS, obsname=obsname,$
           B1950 = B1950, verbose=verbose, precess_=precess_, nutate_=nutate_, $
           refract_ = refract_, aberration_ = aberration_, altitude=altitude, $
           _extra = _extra

 On_error,2
 compile_opt idl2
 if N_params() LT 4 then begin
   print,'Syntax - HOR2EQ, alt, az, jd, ra, dec, [ha, LAT= , LON= , /WS, '
   print,'        OBSNAME= ,/B1950 , PRECESS_= 0, NUTATE_= 0, REFRACT_= 0, '
   print,'        ABERRATION_= 0, ALTITUDE= , /VERBOSE, TEMPERATURE=, PRESSURE='
   return
 endif
<span class="comments">;*******************************************************************************</span>
<span class="comments">; INITIALIZE STUFF</span>

<span class="comments">; If no lat or lng entered, use Pine Bluff Observatory values</span>
if n_elements(lat) eq 0 then lat = 43.0783d
<span class="comments">; (btw, this is the declination of the zenith)</span>
if n_elements(lon) eq 0 then lon = -89.865d

if keyword_set(obsname) then begin
        <span class="comments">;override lat,lon if observatory name has been specified</span>
        observatory, obsname, obs
        lat = obs.latitude
        lon = -1*obs.longitude <span class="comments">; minus sign is becase OBSERVATORY uses west</span>
<span class="comments">;                              ;longitude as positive.</span>
        altitude = obs.altitude
endif

if n_elements(precess_) eq 0 then precess_ = 1
if n_elements(nutate_) eq 0 then nutate_ = 1
if n_elements(aberration_) eq 0 then aberration_ = 1
if n_elements(refract_) eq 0 then refract_ = 1
v = keyword_set(verbose)

<span class="comments">; conversion factors</span>
d2r = !dpi/180.
h2d = 15.

alt_ = alt   <span class="comments">;do this so we don't change ra, dec arrays.</span>
az_ = az

if v then print, 'Latitude = ', adstring(lat), '   Longitude = ', adstring(lon)
if v then print, 'Julian Date = ', jd, format='(A,f15.6)'
if v then print,'Az, El = ', adstring(az_, alt_), '   (Observer Coords)'

<span class="comments">;*******************************************************************************************</span>
<span class="comments">; Make Correction for ATMOSPHERIC REFRACTION</span>
<span class="comments">; (use this for visible and radio wavelengths; author is unsure about other wavelengths)</span>
if refract_ then alt_ = co_refract(alt_, altitude=altitude, _extra=_extra)
if v then print,'Az, El = ', adstring(az_, alt_), '   (Apparent Coords)'

if keyword_set(WS) then az_ = az_ - 180.

co_nutate, jd, 45.,45., dra1, ddec1, eps=eps, d_psi=d_psi

<span class="comments">;******************************************************************************</span>
<span class="comments">;Calculate LOCAL APPARENT SIDEREAL TIME</span>
<span class="comments">; first get local mean sidereal time (lmst)</span>
<span class="comments">; get LST (in hours) - note:this is indep of tzone since giving jd</span>
ct2lst, lmst, lon, 0, jd
lmst = lmst*h2d <span class="comments">; convert LMST to degrees (btw, this is the RA of the zenith)</span>
<span class="comments">; calculate local APPARENT sidereal time (last)</span>
last = lmst + d_psi *cos(eps)/3600. <span class="comments">; add correction in degrees</span>
if v then print, 'LMST = ', adstring(lmst/15.)
if v then print, 'LAST = ', adstring(last/15.)

<span class="comments">;****************************************************************************</span>
<span class="comments">; Now do the spherical trig to get APPARENT Hour Angle [degrees], and</span>
<span class="comments">; declination [degrees].</span>
altaz2hadec, alt_, az_, lat, ha, dec

<span class="comments">; Find Right Ascension (in degrees, from 0 to 360.)</span>
 ra = (last - ha + 360.) mod 360.

if v then print, 'Hour Angle = ', adstring(ha/15.), '  (hh:mm:ss)'
if v then print, 'Ra, Dec: ', adstring(ra,dec), '   (Apparent Coords)'


<span class="comments">;*****************************************************************************</span>
<span class="comments">; calculate NUTATION and ABERRATION Corrections to Ra-Dec</span>
co_nutate, jd, ra, dec, dra1, ddec1, eps=eps, d_psi=d_psi
co_aberration, jd, ra, dec, dra2, ddec2, eps=eps

<span class="comments">;******************************************************************************</span>
<span class="comments">; Make Nutation and Aberration Corrections (if wanted)</span>
ra = ra - (dra1*nutate_ + dra2*aberration_)/3600.
dec = dec - (ddec1*nutate_ + ddec2*aberration_)/3600.
J_now = (JD - 2451545.)/365.25 + 2000.0 <span class="comments">; compute current equinox</span>
Njd = N_elements(J_now)
Npos = N_elements(ra)
if (Njd EQ 1) and (Npos GT 1) then J_now = replicate(J_now, Npos) 
if v then print, 'Ra, Dec: ', adstring(ra,dec), '   (J'+ $
           strcompress(string(J_now),/rem)+')'

<span class="comments">;*****************************************************************************</span>
<span class="comments">; PRECESS coordinates to current date</span>
<span class="comments">; (uses astro lib procedure PRECESS.pro)</span>

if precess_ then begin
        if keyword_set(B1950) then begin
                for i=0, Npos-1 do begin
                        ra_i = ra[i] & dec_i = dec[i]
                        precess, ra_i, dec_i, J_now[i], 1950.0, /FK4
                        ra[i] = ra_i & dec[i] = dec_i
                endfor
        endif else begin
                for i=0, Npos-1 do begin
                        ra_i = ra[i] & dec_i = dec[i]
                        precess, ra_i, dec_i, J_now[i], 2000.0
                        ra[i] = ra_i & dec[i] = dec_i
                endfor
        endelse
endif
if keyword_set(B1950) then s_now='   (J1950)' else s_now='   (J2000)'
if v then print, 'Ra, Dec: ', adstring(ra,dec), s_now

Return
END
</code>
    </div>
  </body>
</html>