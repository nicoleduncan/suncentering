<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:20 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>boxave.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="boxave.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="boxave:source"></a>function boxave, array, xsize, ysize
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       BOXAVE</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Box-average a 1 or 2 dimensional array.   </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This procedure differs from the intrinsic REBIN function in the follow </span>
<span class="comments">;       2 ways: </span>
<span class="comments">;</span>
<span class="comments">;       (1) the box size parameter is specified rather than the output </span>
<span class="comments">;               array size</span>
<span class="comments">;       (2) for INTEGER arrays, BOXAVE computes intermediate steps using REAL*4 </span>
<span class="comments">;               (or REAL*8 for 64bit integers) arithmetic.   This is </span>
<span class="comments">;               considerably slower than REBIN but avoids integer truncation</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       result = BOXAVE( Array, Xsize,[ Ysize ] )     </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       ARRAY - Two dimensional input Array to be box-averaged.  Array may be </span>
<span class="comments">;               one or 2 dimensions and of any type except character.   </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       XSIZE - Size of box in the X direction, over which the array is to</span>
<span class="comments">;               be averaged.  If omitted, program will prompt for this </span>
<span class="comments">;               parameter.  </span>
<span class="comments">;       YSIZE - For 2 dimensional arrays, the box size in the Y direction.</span>
<span class="comments">;               If omitted, then the box size in the X and Y directions are </span>
<span class="comments">;               assumed to be equal</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       RESULT - Output array after box averaging.  If the input array has </span>
<span class="comments">;               dimensions XDIM by YDIM, then RESULT has dimensions</span>
<span class="comments">;               XDIM/NBOX by YDIM/NBOX.  The type of RESULT is the same as</span>
<span class="comments">;               the input array.  However, the averaging is always computed</span>
<span class="comments">;               using REAL arithmetic, so that the calculation should be exact.</span>
<span class="comments">;               If the box size did not exactly divide the input array, then</span>
<span class="comments">;               then not all of the input array will be boxaveraged.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       BOXAVE boxaverages all points simultaneously using vector subscripting</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       If im_int is a 512 x 512 integer array, then the two statements</span>
<span class="comments">;</span>
<span class="comments">;               IDL> im = fix(round(rebin(float(im_int), 128, 128)))</span>
<span class="comments">;               IDL> im  = boxave( im_int,4)</span>
<span class="comments">;</span>
<span class="comments">;       give equivalent results.   The use of REBIN is faster, but BOXAVE is</span>
<span class="comments">;       is less demanding on virtual memory, since one does not need to make</span>
<span class="comments">;       a floating point copy of the entire array.      </span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written, W. Landsman, October 1986</span>
<span class="comments">;       Call REBIN for REAL*4 and REAL*8 input arrays, W. Landsman Jan, 1992</span>
<span class="comments">;       Removed /NOZERO in output array definition     W. Landsman 1995</span>
<span class="comments">;       Fixed occasional integer overflow problem      W. Landsman Sep. 1995</span>
<span class="comments">;       Allow unsigned data types                      W. Landsman Jan. 2000</span>
<span class="comments">;       Assume since V5.4, Allow 64bit integers        W. Landsman Apr  2006</span>
<span class="comments">;-</span>
 On_error,2
 compile_opt idl2

 if N_params() EQ 0 then $
     message,'Syntax -   out =  BOXAVE( array, xsize, [ysize ])',/NoName

 s = size(array)
 if ( s[0] NE 1 ) and ( s[0] NE 2 ) then $
     message,'Input array (first parameter) must be 1 or 2 dimensional'

 if N_elements(xsize) EQ 0 then read,'BOXAVE: Enter box size: ',xsize 
 if N_elements(ysize) EQ 0 then ysize = xsize

 s = size(array)
 ninx = s[1]                                  
 noutx = ninx/xsize     
 type = s[ s[0] + 1]
 integer = (type LT 4) or (type GE 12)

 if s[0] EQ 1 then begin                <span class="comments">; 1 dimension?</span>

     if integer then begin 

        if xsize LT 2 then return, array
        counter = lindgen(noutx)*xsize
        output = array[counter]
        for i=1,xsize-1 do output = output + array[counter + i]
        if type GE 14 then nboxsq = double(xsize) else nboxsq = float(xsize)

      endif else return, rebin( array, noutx)     <span class="comments">;Use REBIN if not integer</span>

  endif else begin              <span class="comments">; 2 dimensions</span>

        niny = s[2]
        nouty = niny/ysize
        if integer then begin                        <span class="comments">;Byte, Integer, or Long</span>

           if type GE 14 then begin 
               nboxsq = double( xsize*ysize )
               output = dblarr( noutx, nouty)     <span class="comments">;Create output array </span>
           endif else begin
                nboxsq = float( xsize*ysize )
                output = fltarr( noutx, nouty)     <span class="comments">;Create output array </span>
           endelse
           counter = lindgen( noutx*nouty )     
           counter = xsize*(counter mod noutx) + $
                    (ysize*ninx)*long((counter/noutx))

           for i = 0L,xsize-1 do $
           for j = 0L,ysize-1 do $
                 output = output + array[counter + (i + j*ninx)]

        endif else $
           return, rebin( array, noutx, nouty)       <span class="comments">;Use REBIN if not integer</span>
 endelse

 case type of 
 12:  return, uint(round( output/nboxsq ))               <span class="comments">;Unsigned Integer</span>
 13:  return, ulong( round(output/nboxsq))               <span class="comments">;Unsigned Long</span>
 14:  return, round(output/nboxsq, /L64)                 <span class="comments">;64bit integer</span>
 15:  return, ulong64(round(output/nboxsq,/L64))         <span class="comments">;Unsigned 64bit  </span>
  2:  return, fix( round( output/ nboxsq ))              <span class="comments">;Integer</span>
  3:  return, round( output / nboxsq )                   <span class="comments">;Long</span>
  1:  return, byte( round( output/nboxsq) )              <span class="comments">;Byte</span>
 endcase

 end
</code>
    </div>
  </body>
</html>