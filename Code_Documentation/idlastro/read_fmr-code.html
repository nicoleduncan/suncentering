<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:59 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>read_fmr.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="read_fmr.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;  READ_FMR</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Read a journal (ApJ, AJ) machine-readable table into IDL</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;  Given a machine readable table name and optionally column</span>
<span class="comments">;  numbers, this FUNCTION reads the format information in the</span>
<span class="comments">;  meta-header and outputs a IDL function containing either the</span>
<span class="comments">;  complete table or only the requested columns.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;  data = read_fmr(filename)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;  filename [STRING]: the name of the file containing the machine</span>
<span class="comments">;  readable table. If filename is missing a dialog to select the</span>
<span class="comments">;  filename will be presented</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;   /HELP  - if set show the help</span>
<span class="comments">;</span>
<span class="comments">;   COLUMNS -  [(array of) integers or strings] of column(s) to be returned.</span>
<span class="comments">;     If columns is of type integer they represent indices for which</span>
<span class="comments">;     column numbers to return, if they are strings the columns with the</span>
<span class="comments">;     corresponding names will be returned in the order as given.</span>
<span class="comments">;</span>
<span class="comments">;   MISSINGVALUE [float]: value with which to replace the missing values in the </span>
<span class="comments">;        table, default is NaN.</span>
<span class="comments">;</span>
<span class="comments">;   /USE_COLNUM - If  specified and non-zero then column names will be generated</span>
<span class="comments">;        as 'C1, C2,  .... Cn'  for the number of columns in the table, rather</span>
<span class="comments">;        than using the table names.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;  The ouput data structure will look like:</span>
<span class="comments">;    TYPE            STRING    'mr_structure'</span>
<span class="comments">;    NAME            STRING    Array[X]</span>
<span class="comments">;    UNIT            STRING    Array[X]</span>
<span class="comments">;    DESCRIPTION     STRING    Array[X]</span>
<span class="comments">;    DATA            STRUCT    -> &lt;Anonymous> Array[1]</span>
<span class="comments">;  where name contains the names of each columns</span>
<span class="comments">;  unit contains the given units</span>
<span class="comments">;  description contains the short descriptions and</span>
<span class="comments">;  data holds the values of the separate columns.   By default the tag names are</span>
<span class="comments">;  taken from the column names, with modifications necessary to make them a </span>
<span class="comments">;  valid tag name.    For example, the column name 'B-V' will be converted to </span>
<span class="comments">;  'B_V' to become a valid tag name.    If the /USE_COLNUM keyword is set, then</span>
<span class="comments">;  the column will be named  C0,  C1, ... , CX, where X stands for the total </span>
<span class="comments">;  number of columns read.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;  (1) The file to be read should be formatted as a machine readable datafile.</span>
<span class="comments">;  (2) Use of the COLUMN keyword currently requires use of the EXECUTE, and so</span>
<span class="comments">;      cannot be used with the IDL Virtural machine.</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;  meas = read_fmr('smith.dat',col=[2,5,6], /Use_colnum)</span>
<span class="comments">;   plot,meas.data.c1,ytitle=meas.name[1]+' ('+meas.unit[1]+')'</span>
<span class="comments">;</span>
<span class="comments">;  and</span>
<span class="comments">;  data = read_fmr('smith.dat',col=['Name','Date'], /Use_colnum)</span>
<span class="comments">;   print,meas.data.c0</span>
<span class="comments">;   </span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;  Version 1:</span>
<span class="comments">;  Written by Sacha Hony (ESA) Nov 14 2003</span>
<span class="comments">;   Based heavily on mrcolextract by Greg Schwarz (AAS Journals</span>
<span class="comments">;   staff scientist) on 8/16/00.</span>
<span class="comments">;</span>
<span class="comments">;  Version 1.1:</span>
<span class="comments">;    Fixed bug where column=[3,4] always returned the first few columns</span>
<span class="comments">;</span>
<span class="comments">;  VErsion 2.0 By default use column names as tag names W. Landsman Feb 2010</span>
<span class="comments">;-</span>

FUNCTION read_fmr,filename, $
                  columns=columns, $
                  missingvalue=missingvalue, $
                  help=help, $
		  use_colnum = use_colnum

  compile_opt idl2
  <span class="comments">;; Only print the usage info and return if asked for help</span>
  IF keyword_set(help) THEN BEGIN
      doc_library,'read_fmr'
      return,0
  ENDIF
  
  <span class="comments">;; If no filename is given then pop-up the dialog_pickfile dialog</span>
  IF NOT keyword_set(filename) THEN BEGIN
       filename =dialog_pickfile(filter=['*.dat;*.asc*;*.txt','*'], $
                                 /must_exist)
   ENDIF
  
  <span class="comments">;; Check that file exists and is readable otherwise bail-out</span>
  IF NOT FILE_TEST(filename) THEN BEGIN
      message,'The file: '+filename+' does cannot be found or read', $
              /informational
      return,0
  ENDIF
  
  IF NOT keyword_set(missingvalue) THEN missingvalue=!VALUES.F_NAN
  
<span class="comments">;; Variables needed to read single lines of the file</span>
  dumI=' '
  tmp=''
  irow=0L <span class="comments">;; Make sure it can hold a lot of lines</span>
  startpos=' '
  endpos=' '

<span class="comments">;; Variable in which the total information of the files is collected  </span>
  names=''
  units=''
  descriptions=''
  startposs=0
  idltypes=0
  
  openr,lun,filename,/get_lun
  
<span class="comments">;; Read the first few lines into a dummy variable</span>
<span class="comments">;; because this info is not needed.  However, keep</span>
<span class="comments">;; track of the number of lines.</span>
  WHILE (strpos(dumI,'Bytes Format') EQ -1) DO BEGIN
      readf,lun,dumI
      irow=irow+1L
  END 
  
  readf,lun,dumI
  irow=irow+1L
  
<span class="comments">;; Read until you reach a '------' line terminator</span>
  WHILE (strpos(tmp,'-----------------') EQ -1) DO BEGIN
      irow=irow+1L
      
<span class="comments">;; Extract out the 6-8th positions.  </span>
<span class="comments">;; If there is a number you have a column</span>
      readf,lun,f='(1X,A3,1X,A3,1X,A80)',startpos,endpos,tmp
      
<span class="comments">;; If startpos is --- then you are at the end </span>
<span class="comments">;; so set the 9999 flag so it isn't counted</span>
      IF (startpos EQ '---') THEN startpos = '9999'

<span class="comments">;; If starpos is blank then this is either a continuation</span>
<span class="comments">;; line or a column that is only one digit wide.  You can</span>
<span class="comments">;; tell by checking if endpos is also blank.  If it is a </span>
<span class="comments">;; column then set startpos and endpos to the same value</span>
      IF (startpos EQ '   ') THEN BEGIN
          startpos = endpos
          IF (endpos EQ '   ') THEN startpos = '9999'
      ENDIF
      IF (fix(startpos) GE 1 AND fix(startpos) LE 999) THEN BEGIN
          
<span class="comments">;; Squeeze out the blanks.</span>
          less_blanks = strcompress(tmp)
          
<span class="comments">;; Separate the non-location info by sorting into an array that is </span>
<span class="comments">;; delimited by blank spaces.  The first position is the format,</span>
<span class="comments">;; the second is the units, the third is the name, and the last</span>
<span class="comments">;; positions are the short description of the column</span>
          
<span class="comments">;;(SH Nov 18 2003) strsplit is not available in older versions of IDL</span>
         components=strsplit(less_blanks,' ',/extract)
 
<span class="comments">;; Determine the column type (A|I|F|E)</span>
          vtype = strmid(components[0],0,1)
          CASE vtype OF
              'A': idltype = 7
              'I': idltype = 2
              'F': idltype = 5
              'E': idltype = 5
          ENDCASE
          
          <span class="comments">;; Add the collected data to the lists</span>
          names=[names,components[2]]
          units=[units,components[1]]
          <span class="comments">;; Take the rest of the strings a description</span>
          description=''
          FOR i=3,n_elements(components)-1 DO description=description+ $
            components[i]+' '
          descriptions=[descriptions,description]
          startposs=[startposs,startpos-1]
          idltypes=[idltypes,idltype]
      ENDIF 
  ENDWHILE

<span class="comments">;; iskip is the end (maybe see below) of the meta-header </span>
  iskip=irow
  
<span class="comments">;; Continue reading the file to get the number of lines</span>
  lastdash=0L
  WHILE NOT eof(lun) DO BEGIN
      readf,lun,dumI
      irow=irow+1L
<span class="comments">;; If you encounter another '--------' (e.g. the end of a</span>
<span class="comments">;; notes subsection) mark it because you don't want to </span>
<span class="comments">;; read the previous information as data!</span>
      IF (strmid(dumI,0,6) EQ '------') THEN BEGIN
          lastdash=irow
      ENDIF
  ENDWHILE
  
  <span class="comments">;; Make sure we close the file and free the lun</span>
  free_lun,lun
  
<span class="comments">;; If you found a '-------' line then set iskip to the last dash</span>
<span class="comments">;; line so not to read any extra headers</span>
  IF (lastdash NE 0L) THEN BEGIN
      iskip=lastdash
  ENDIF

<span class="comments">;; Clean the arrays from the first dummy element</span>
  names=names[1:*]
  units=units[1:*]
  descriptions=descriptions[1:*]
  startposs=startposs[1:*]
  idltypes=idltypes[1:*]
  ncolumns = n_elements(startposs)
  if keyword_set(USE_COLNUM) then $
      fieldnames = 'C' + strtrim(indgen(ncolumns),2) else begin
      if !VERSION.RELEASE GE '6.4' then $
          fieldnames = IDL_VALIDNAME(names,/convert_all) else begin
      	  fieldnames = strarr(ncolumns)
          for i=0, ncolumns-1 do $
               fieldnames[i] = IDL_VALIDNAME(names[i],/convert_all)
         endelse
	 endelse
  
  <span class="comments">;; now fill the template stuff for read_ascii</span>
  template = {VERSION:1.00000, $
              DATASTART:iskip, $
              DELIMITER:0B, $
              MISSINGVALUE:missingvalue, $
              COMMENTSYMBOL:'', $
              FIELDCOUNT:ncolumns, $
              FIELDTYPES:idltypes, $
              FIELDNAMES: fieldnames, $
              FIELDLOCATIONS:startposs, $
              FIELDGROUPS:indgen(ncolumns)}
  
  data = read_ascii(filename,template=template)
  

  <span class="comments">;; This is all if the columns keyword is given then</span>
  <span class="comments">;; only certain columns are requested. So do the selections here</span>
  IF keyword_set(columns) THEN BEGIN

      ncolumns = n_elements(columns)
   
      <span class="comments">;; are they strings?</span>
      IF size(columns,/TNAME) EQ 'STRING' THEN BEGIN

          <span class="comments">;; first convert the columns and the output names to uppercase</span>
          <span class="comments">;; to be able to compare them directly without strcmp</span>
          names_up   = strupcase(names)
          columns_up = strupcase(columns)

          <span class="comments">;; create an array to hold the requested column numbers set</span>
          <span class="comments">;; these to -1</span>
          idx_columns = make_array(ncolumns,value=-1)

          <span class="comments">;; Now match each string with the names</span>
          FOR i=0,ncolumns-1 DO BEGIN
              <span class="comments">;; take the first instance where the uppercase name and</span>
              <span class="comments">;; uppercase column match</span>
              idx_columns[i] = ( where(names_up EQ columns_up[i]) )[0]
          ENDFOR

          <span class="comments">;; Are there elements which did not find a match?</span>
          idx_missing_columns = where(idx_columns EQ -1,cnt)

          <span class="comments">;; All the elements of idx_columns are -1</span>
          IF (cnt EQ ncolumns) THEN BEGIN
              message,'None of the column names could be found in the table', $
                      /informational
              return,0
          ENDIF

          <span class="comments">;; Some elements are matched but some are missing</span>
          IF (cnt NE 0) THEN BEGIN
              message,'The following columns are not present in the table:', $
                      /informational
              message,columns[idx_missing_columns], $
                      /informational
              <span class="comments">;; Only take the valid columns and still continue</span>
              idx_columns =idx_columns[where(idx_columns NE -1)]
          ENDIF

      ENDIF ELSE BEGIN
          <span class="comments">;; Assume the columns are numbers which indicate the</span>
          <span class="comments">;; requested column numbers</span>

          max_column=n_tags(data)-1
          columns = fix(columns)
          <span class="comments">;; make sure they are not higher than the available number</span>
          <span class="comments">;; of columns and not negative</span>
          idx_columns = columns[where( (columns LE max_column) AND $
                                       (columns GE 0) ,cnt)]

          IF (cnt EQ 0) THEN BEGIN
              message,'The requested columns are not present in the file', $
                      /informational
              return,0
          ENDIF

          <span class="comments">;; Some elements are matched but some are too high</span>
          IF cnt NE ncolumns THEN BEGIN
              message,'Some column numbers are out of range.'+ $
                      ' Valid range=[0,'+ $
                      strcompress(string(max_column),/remove_all)+']', $
                      /informational
          ENDIF
      ENDELSE

<span class="comments">;; now take the requested columns</span>
      names=names[idx_columns]
      units=units[idx_columns]
      if ~keyword_set(use_colnum) then fieldnames = fieldnames[idx_columns] $
         else fieldnames = 'C' + strtrim(indgen(ncolumns),2)
      descriptions=descriptions[idx_columns]
      ncolumns = n_elements(names)
      

      <span class="comments">;; We need this to restructure the data structure to hold only</span>
      <span class="comments">;; the requested columns</span>
      exec_string = 'data={' + fieldnames[0] + $
                    ':data.('+string(idx_columns[0])+')'
      FOR i=1,ncolumns-1 DO BEGIN
          exec_string = exec_string + ',' + fieldnames[i] + $
                        ':data.('+string(idx_columns[i])+')'
      ENDFOR
      exec_string=exec_string+'}'
      foo = execute(exec_string)
  ENDIF
  
  
  out = {type:'mr_structure', $
         name:names, $
         unit:units, $
         description:descriptions, $
         data:data}
  
  message,"Read "+strcompress(ncolumns)+" columns from "+ $
          filename,/informational
  
  return,out
  
END
</code>
    </div>
  </body>
</html>