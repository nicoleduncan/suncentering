<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>modfits.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="modfits.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="MODFITS:source"></a>pro MODFITS, filename, data, header, EXTEN_NO = exten_no, ERRMSG = errmsg, $
    EXTNAME = extname
           
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      MODFITS</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Modify a FITS file by updating the header and/or data array.  </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;      Update the data and/or header in a specified FITS extension or primary</span>
<span class="comments">;      HDU.</span>
<span class="comments">;    </span>
<span class="comments">;      The size of the supplied FITS header or data array does not</span>
<span class="comments">;      need to match the size of the existing header or data array.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      MODFITS, Filename_or_fcb, Data, [ Header, EXTEN_NO =, EXTNAME= , ERRMSG=]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      FILENAME/FCB = Scalar string containing either the name of the FITS file  </span>
<span class="comments">;                  to be modified, or the IO file control block returned after </span>
<span class="comments">;                  opening the file with FITS_OPEN,/UPDATE.   The explicit</span>
<span class="comments">;                  use of FITS_OPEN can save time if many extensions in a </span>
<span class="comments">;                  single file will be updated.</span>
<span class="comments">;</span>
<span class="comments">;      DATA - data array to be inserted into the FITS file.   Set DATA = 0</span>
<span class="comments">;               to leave the data portion of the FITS file unmodified.   Data</span>
<span class="comments">;               can also be an IDL structure (e.g. as returned by MRDFITS). </span>
<span class="comments">;               provided that it does not include IDL pointers.</span>
<span class="comments">;</span>
<span class="comments">;      HEADER - FITS header (string array) to be updated in the FITS file.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;      A specific extension can be specified with either the EXTNAME or</span>
<span class="comments">;      EXTEN_NO keyword</span>
<span class="comments">; </span>
<span class="comments">;      EXTEN_NO - scalar integer specifying the FITS extension to modified.  For</span>
<span class="comments">;               example, specify EXTEN = 1 or /EXTEN to modify the first </span>
<span class="comments">;               FITS extension.</span>
<span class="comments">;      EXTNAME - string name of the extension to modify.   </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       ERRMSG - If this keyword is supplied, then any error mesasges will be</span>
<span class="comments">;               returned to the user in this parameter rather than depending on</span>
<span class="comments">;               on the MESSAGE routine in IDL.   If no errors are encountered</span>
<span class="comments">;               then a null string is returned.               </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;     (1) Modify the value of the DATE keyword in the primary header of a </span>
<span class="comments">;             file TEST.FITS.</span>
<span class="comments">;</span>
<span class="comments">;              IDL> h = headfits('test.fits')      ;Read primary header</span>
<span class="comments">;              IDL> sxaddpar,h,'DATE','2001-03-23' ;Modify value of DATE </span>
<span class="comments">;              IDL> modfits,'test.fits',0,h        ;Update header only</span>
<span class="comments">;</span>
<span class="comments">;       (2) Replace the values of the primary image array in 'test.fits' with </span>
<span class="comments">;               their absolute values</span>
<span class="comments">;</span>
<span class="comments">;               IDL> im = readfits('test.fits')    ;Read image array</span>
<span class="comments">;               IDL> im = abs(im)                  ;Take absolute values</span>
<span class="comments">;               IDL> modfits,'test.fits',im        ;Update image array</span>
<span class="comments">;</span>
<span class="comments">;       (3) Add some HISTORY records to the FITS header in the first extension</span>
<span class="comments">;               of a file 'test.fits'</span>
<span class="comments">;       </span>
<span class="comments">;               IDL> h = headfits('test.fits',/ext)  ;Read first extension hdr</span>
<span class="comments">;               IDL> sxaddhist,['Comment 1','Comment 2'],h</span>
<span class="comments">;               IDL> modfits,'test.fits',0,h,/ext    ;Update extension hdr</span>
<span class="comments">;</span>
<span class="comments">;       (4) Change 'OBSDATE' keyword to 'OBS-DATE' in every extension in a </span>
<span class="comments">;           FITS file.    Explicitly open with FITS_OPEN to save compute time.</span>
<span class="comments">;</span>
<span class="comments">;               fits_open,'test.fits',io,/update    ;Faster to explicity open</span>
<span class="comments">;               for i = 1,nextend do begin          ;Loop over extensions</span>
<span class="comments">;                   fits_read,io,0,h,/header_only,exten_no=i,/No_PDU ;Get header     </span>
<span class="comments">;                   date= sxpar(h,'OBSDATE')         ;Save keyword value</span>
<span class="comments">;                   sxaddpar,h,'OBS-DATE',date,after='OBSDATE' </span>
<span class="comments">;                   sxdelpar,h,'OBSDATE'             ;Delete bad keyword</span>
<span class="comments">;                   modfits,io,0,h,exten_no=i        ;Update header</span>
<span class="comments">;               endfor</span>
<span class="comments">;</span>
<span class="comments">;           Note the use of the /No_PDU keyword in the FITS_READ call -- one </span>
<span class="comments">;           does *not* want to append the primary header, if the STScI </span>
<span class="comments">;           inheritance convention is adopted.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Uses the BLKSHIFT procedure to shift the contents of the FITS file if </span>
<span class="comments">;       the new data or header differs in size by more than 2880 bytes from the</span>
<span class="comments">;       old data or header.    If a file control block (FCB) structure is </span>
<span class="comments">;       supplied, then the values of START_HEADER, START_DATA and NBYTES may </span>
<span class="comments">;       be modified if the file size changes.</span>
<span class="comments">;</span>
<span class="comments">;       Also see the procedures FXHMODIFY to add a single FITS keyword to a </span>
<span class="comments">;       header in a FITS files, and FXBGROW to enlarge the size of a binary </span>
<span class="comments">;       table.</span>
<span class="comments">;       </span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1) Cannot be used to modify the data in FITS files with random </span>
<span class="comments">;           groups or variable length binary tables.   (The headers in such</span>
<span class="comments">;           files *can* be modified.)</span>
<span class="comments">;</span>
<span class="comments">;       (2) If a data array but no FITS header is supplied, then MODFITS does </span>
<span class="comments">;           not check to make sure that the existing header is consistent with</span>
<span class="comments">;           the new data.</span>
<span class="comments">;</span>
<span class="comments">;       (3) Does not work with compressed files</span>
<span class="comments">;</span>
<span class="comments">;       (4) The Checksum keywords will not be updated if the array to be </span>
<span class="comments">;           updated is supplied as a structure (e.g. from MRDFITS). </span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       Functions:   N_BYTES(), SXPAR()</span>
<span class="comments">;       Procedures:  BLKSHIFT, CHECK_FITS, FITS_OPEN, FITS_READ</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written,    Wayne Landsman          December, 1994</span>
<span class="comments">;       Fixed possible problem when using WRITEU after READU   October 1997</span>
<span class="comments">;       New and old sizes need only be the same within multiple of 2880 bytes</span>
<span class="comments">;       Added call to IS_IEEE_BIG()     W. Landsman   May 1999</span>
<span class="comments">;       Added ERRMSG output keyword     W. Landsman   May 2000</span>
<span class="comments">;       Update tests for incompatible sizes   W. Landsman   December 2000</span>
<span class="comments">;       Major rewrite to use FITS_OPEN procedures W. Landsman November 2001</span>
<span class="comments">;       Add /No_PDU call to FITS_READ call  W. Landsman  June 2002</span>
<span class="comments">;       Update CHECKSUM keywords if already present in header, add padding </span>
<span class="comments">;       if new data  size is smaller than old  W.Landsman December 2002</span>
<span class="comments">;       Only check XTENSION value if EXTEN_NO > 1   W. Landsman Feb. 2003</span>
<span class="comments">;       Correct for unsigned data on little endian machines W. Landsman Apr 2003</span>
<span class="comments">;       Major rewrite to allow changing size of data or header W.L. Aug 2003</span>
<span class="comments">;       Fixed case where updated header exactly fills boundary W.L. Feb 2004</span>
<span class="comments">;       More robust error reporting W.L. Dec 2004</span>
<span class="comments">;       Make sure input header ends with a END W.L.  March 2006</span>
<span class="comments">;       Assume since V5.5, remove VMS support, assume FITS_OPEN will</span>
<span class="comments">;           perform byte swapping   W.L. Sep 2006 </span>
<span class="comments">;       Update FCB structure if file size changes W.L. March 2007</span>
<span class="comments">;       Fix problem when data size must be extended W.L. August 2007</span>
<span class="comments">;       Don't assume supplied FITS header is 80 bytes W. L. Dec 2007</span>
<span class="comments">;       Check for new END position after adding CHECKSUM  W.L. July 2008</span>
<span class="comments">;       Added EXTNAME input keyword  W.L. July 2008</span>
<span class="comments">;       Allow data to be an IDL structure  A. Conley/W.L. June 2009</span>
<span class="comments">;       Use V6.0 notation, add /NOZERO to BLKSHIFT W.L. Feb 2011</span>
<span class="comments">;       Don't try to update Checksums when structure supplied W.L. April 2011</span>
<span class="comments">;       Allow structure with only 1 element  W.L.  Feb 2012</span>
<span class="comments">;-</span>
  On_error,2                    <span class="comments">;Return to user</span>
  compile_opt idl2

<span class="comments">; Check for filename input</span>

   if N_params() LT 1 then begin                
      print,'Syntax - ' + $
        'MODFITS, Filename, Data, [ Header, EXTEN_NO=, EXTNAME=, ERRMSG= ]'
      return
   endif

   if ~keyword_set( EXTEN_NO ) then exten_no = 0
   if N_params() LT 2 then Header = 0
   nheader = N_elements(Header)
   updated = 0b

<span class="comments">;Make sure END statement is the last line in supplied FITS header   </span>
   
   if nheader GT 1 then begin
         endline = where( strmid(Header,0,8) EQ 'END     ', Nend)
         if Nend EQ 0 then begin
         message,/INF,  $
	  'WARNING - An END statement has been appended to the FITS header'
         Header = [ Header, 'END' + string( replicate(32b,77) ) ]
	 endif else header = header[0:endline]  
   endif 
   
   ndata = N_elements(data)
   dtype = size(data,/TNAME)
   printerr =  ~arg_present(ERRMSG) 
   fcbsupplied = size(filename,/TNAME) EQ 'STRUCT'

   if (nheader GT 1) && (ndata GT 1) && (dtype NE 'STRUCT') then begin
        check_fits, data, header, /FITS, ERRMSG = MESSAGE
        if message NE '' then goto, BAD_EXIT
   endif

<span class="comments">; Open file and read header information</span>
         
   if (exten_no EQ 0) && (~keyword_set(EXTNAME)) then begin 
         if nheader GT 0 then $
             if strmid( header[0], 0, 8)  NE 'SIMPLE  ' then begin 
                 message = $
                'Input header does not contain required SIMPLE keyword'
                 goto, BAD_EXIT
             endif
   endif else begin
         if nheader GT 0 then $
             if strmid( header[0], 0, 8)  NE 'XTENSION' then begin 
              message = $
             'ERROR - Input header does not contain required XTENSION keyword'
              goto, BAD_EXIT
              endif
   endelse

<span class="comments">; Was a file name or file control block supplied?</span>

   if ~fcbsupplied then begin 
       fits_open, filename, io,/update,/No_Abort,message=message
       if message NE '' then GOTO, BAD_EXIT
    endif else begin 
       if filename.open_for_write EQ 0 then begin
             message = 'FITS file is set for READONLY, cannot be updated'
             goto, BAD_EXIT
       endif
       io = filename
   endelse

<span class="comments">; Getting starting position of data and header</span>

   if keyword_set(extname) then begin 
       exten_no = where( strupcase(io.extname) EQ strupcase(extname), Nfound)
       if Nfound EQ  0 then begin       
          message,'Extension name ' + extname + ' not found in FITS file'
	  GOTO, BAD_EXIT
       endif
   endif    	   
   unit = io.unit
   start_d = io.start_data[exten_no]
   if exten_no NE io.nextend then begin
        start_h = io.start_header[exten_no+1] 
        nbytes = start_h - start_d
   endif else nbytes = N_BYTES(data)

   FITS_READ,Io,0,oldheader,/header_only, exten=exten_no, /No_PDU, $
       message = message,/no_abort
   if message NE '' then goto, BAD_EXIT
    dochecksum = sxpar(oldheader,'CHECKSUM', Count = N_checksum)
   checksum = N_checksum GT 0  
   

<span class="comments">; Update header, including any CHECKSUM keywords if present </span>

   if nheader GT 1 then begin
        noldheader = start_d - io.start_header[exten_no]
 
        if dtype EQ 'UINT' then $
              sxaddpar,header,'BZERO',32768,'Data is unsigned integer'
        if dtype EQ 'ULONG' then $
              sxaddpar,header,'BZERO',2147483648,'Data is unsigned long'
        if checksum then begin 
               if (Ndata GT 1) && (dtype NE 'STRUCT') then $
	        FITS_ADD_CHECKSUM, header, data else $
                FITS_ADD_CHECKSUM, header 
        endif
<span class="comments">; Position of 'END' card may have changed - Bug fix July 2008	</span>
        endline = where( strmid(Header,0,8) EQ 'END     ', Nend)

        newbytes = N_elements(header)*80 
        block = (newbytes-1)/2880 - (Noldheader-1)/2880
        if block NE 0 then begin  
            BLKSHIFT, io.unit, start_d, block*2880L, /NOZERO
            start_d = start_d + block*2880L
	    io.start_data[exten_no:*] = io.start_data[exten_no:*] + block*2880L
            io.nbytes = io.nbytes + block*2880L
            if exten_no NE io.nextend then begin
                    start_h = start_h + block*2880L
		    io.start_header[exten_no+1:*] = block*2880L + $
		        io.start_header[exten_no+1:*]
	     endif		
        endif
        point_lun, unit, io.start_header[exten_no]      <span class="comments">;Position header start  </span>
        bhdr = replicate(32b, newbytes)
        for n = 0l, endline[0] do bhdr[80*n] = byte( header[n] )
         writeu, unit, bhdr
        remain = newbytes mod 2880
	if remain GT 0 then writeu, unit, replicate( 32b, 2880 - remain)
	updated = 1b
 
   endif 

   if (ndata GT 1) || (dtype EQ 'STRUCT') then begin
 
        newbytes = N_BYTES(data)    <span class="comments">;total number of bytes in supplied data</span>
        block = (newbytes-1)/2880 - (nbytes-1)/2880
        if (block NE 0) && (exten_no NE io.nextend) then begin
              BLKSHIFT, io.unit, start_h, block*2880L,/NOZERO
	      io.nbytes = io.nbytes + block*2880L
	      io.start_header[exten_no+1:*] = block*2880L + $
		        io.start_header[exten_no+1:*]
	      io.start_data[exten_no+1:*] = block*2880L + $
		        io.start_data[exten_no+1:*]
        endif
      
        if (nheader EQ 0) && (dtype NE 'STRUCT') then begin
                check_fits,data,oldheader,/FITS,ERRMSG = message
                if message NE '' then goto, BAD_EXIT
        endif
 
        junk = fstat(unit)   <span class="comments">;Need this before changing from READU to WRITEU</span>
        point_lun, unit, start_d
        if dtype EQ 'UINT' then newdata = fix(data - 32768)
        if dtype EQ 'ULONG' then newdata = long(data - 2147483648)
         if N_elements(newdata) GT 0 then writeu, unit, newdata  else $
                                         writeu, unit ,data
        remain = newbytes mod 2880
	if remain GT 0 then begin
             padnum = 0b
             if exten_no GT 0 then begin 
                 exten = sxpar( oldheader, 'XTENSION')
	         if exten EQ 'TABLE   ' then padnum = 32b
             endif
	     writeu, unit, replicate( padnum, 2880 - remain)
	endif
	updated = 1b
    endif       

   if ~fcbsupplied then FITS_CLOSE,io  else filename = io
   if ~updated then message,'FITS file not modified',/INF    
   
         
   return 

BAD_EXIT:
    if N_elements(io) GT 0 then if ~fcbsupplied then fits_close,io
    if printerr then message,'ERROR - ' + message,/CON else errmsg = message
    if fcbsupplied then fname = filename.filename else fname = filename
    message,'FITS file ' + fname + ' not modified',/INF
    return
   end 
</code>
    </div>
  </body>
</html>