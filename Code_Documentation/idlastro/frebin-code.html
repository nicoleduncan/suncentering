<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>frebin.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="frebin.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="frebin:source"></a>function frebin,image,nsout,nlout,total=total
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   FREBIN</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Shrink or expand the size of an array an arbitary amount using interpolation</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION: </span>
<span class="comments">;   FREBIN is an alternative to CONGRID or REBIN.    Like CONGRID it</span>
<span class="comments">;   allows expansion or contraction by an arbitary amount. ( REBIN requires </span>
<span class="comments">;   integral factors of the original image size.)    Like REBIN it conserves </span>
<span class="comments">;   flux by ensuring that each input pixel is equally represented in the output</span>
<span class="comments">;   array.       </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   result = FREBIN( image, nsout, nlout, [ /TOTAL] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;    image - input image, 1-d or 2-d numeric array</span>
<span class="comments">;    nsout - number of samples in the output image, numeric scalar</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;    nlout - number of lines in the output image, numeric scalar</span>
<span class="comments">;            If not supplied, then set equal to 1</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;   /total - if set, the output pixels will be the sum of pixels within</span>
<span class="comments">;          the appropriate box of the input image.  Otherwise they will</span>
<span class="comments">;          be the average.    Use of the /TOTAL keyword conserves surface flux.</span>
<span class="comments">; </span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;    The resized image is returned as the function result.    If the input</span>
<span class="comments">;    image is of type DOUBLE or FLOAT then the resized image is of the same</span>
<span class="comments">;    type.     If the input image is BYTE, INTEGER or LONG then the output</span>
<span class="comments">;    image is usually of type FLOAT.   The one exception is expansion by</span>
<span class="comments">;    integral amount (pixel duplication), when the output image is the same</span>
<span class="comments">;    type as the input image.  </span>
<span class="comments">;     </span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;     Suppose one has an 800 x 800 image array, im, that must be expanded to</span>
<span class="comments">;     a size 850 x 900 while conserving surface flux:</span>
<span class="comments">;</span>
<span class="comments">;     IDL> im1 = frebin(im,850,900,/total) </span>
<span class="comments">;</span>
<span class="comments">;     im1 will be a 850 x 900 array, and total(im1) = total(im)</span>
<span class="comments">; NOTES:</span>
<span class="comments">;    If the input image sizes are a multiple of the output image sizes</span>
<span class="comments">;    then FREBIN is equivalent to the IDL REBIN function for compression,</span>
<span class="comments">;    and simple pixel duplication on expansion.</span>
<span class="comments">;</span>
<span class="comments">;    If the number of output pixels are not integers, the output image</span>
<span class="comments">;    size will be truncated to an integer.  The platescale, however, will</span>
<span class="comments">;    reflect the non-integer number of pixels.  For example, if you want to</span>
<span class="comments">;    bin a 100 x 100 integer image such that each output pixel is 3.1</span>
<span class="comments">;    input pixels in each direction use:</span>
<span class="comments">;           n = 100/3.1   ; 32.2581</span>
<span class="comments">;          image_out = frebin(image,n,n)</span>
<span class="comments">;</span>
<span class="comments">;     The output image will be 32 x 32 and a small portion at the trailing</span>
<span class="comments">;     edges of the input image will be ignored.</span>
<span class="comments">; </span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;    None.</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;    Adapted from May 1998 STIS  version, written D. Lindler, ACC</span>
<span class="comments">;    Added /NOZERO, use INTERPOLATE instead of CONGRID, June 98 W. Landsman  </span>
<span class="comments">;    Fixed for nsout non-integral but a multiple of image size  Aug 98 D.Lindler</span>
<span class="comments">;    DJL, Oct 20, 1998, Modified to work for floating point image sizes when</span>
<span class="comments">;		expanding the image. </span>
<span class="comments">;    Improve speed by addressing arrays in memory order W.Landsman Dec/Jan 2001</span>
<span class="comments">;-</span>
<span class="comments">;----------------------------------------------------------------------------</span>
      On_error,2
      compile_opt idl2

      if N_params() LT 1 then begin
           print,'Syntax = newimage = FREBIN(image, nsout, nlout, [/TOTAL])'  
           return,-1
       endif

       if n_elements(nlout) eq 0 then nlout=1
<span class="comments">;</span>
<span class="comments">; determine size of input image</span>
<span class="comments">;</span>
	ns = n_elements(image[*,0])
	nl = n_elements(image)/ns
<span class="comments">;</span>
<span class="comments">; determine if we can use the standard rebin function</span>
<span class="comments">;</span>
        dtype = size(image,/TNAME)
	if dtype EQ 'DOUBLE' then begin
		sbox = ns/double(nsout) 
		lbox = nl/double(nlout)
	   end else begin
		sbox = ns/float(nsout) 
		lbox = nl/float(nlout)
	end	

<span class="comments">; Contraction by an integral amount </span>

	if (nsout eq long(nsout)) && (nlout eq long(nlout)) then begin
	if ((ns mod nsout) EQ 0) && ((nl mod nlout) EQ 0) then $
                if (dtype EQ 'DOUBLE') || (dtype EQ 'FLOAT') then begin
 		   if keyword_set(total) then $
		   return,rebin(image,nsout,nlout)*sbox*lbox else $
		   return,rebin(image,nsout,nlout) 
                endif else begin 
 		   if keyword_set(total) then $
		   return,rebin(float(image),nsout,nlout)*sbox*lbox else $
		   return,rebin(float(image),nsout,nlout)
                endelse 


<span class="comments">; Expansion by an integral amount</span>
	if ((nsout mod ns) EQ 0) && ((nlout mod nl) EQ 0) then begin
                xindex = long(lindgen(nsout)/(nsout/ns))
                if nl EQ 1 then begin
 		if keyword_set(total) then $
		return,interpolate(image,xindex)*sbox else $        
		return,interpolate(image,xindex)  
                endif
                yindex = long(lindgen(nlout)/(nlout/nl))
 		if keyword_set(total) then $
		return,interpolate(image,xindex,yindex,/grid)*sbox*lbox else $
		return,interpolate(image,xindex,yindex,/grid)  
	endif
   endif
	    ns1 = ns-1
	    nl1 = nl-1

<span class="comments">; Do 1-d case separately</span>

  if nl EQ 1 then begin
           if dtype eq 'DOUBLE' then result = dblarr(nsout,/NOZERO) $
			        else result = fltarr(nsout,/NOZERO)
	    for i=0L,nsout-1 do begin
	    	    rstart = i*sbox	       <span class="comments">;starting position for each box</span>
	    	    istart = long(rstart)
	    	    rstop = rstart + sbox      <span class="comments">;ending position for each box</span>
	    	    istop = long(rstop)&lt<span class="comments">;ns1</span>
	    	    frac1 = rstart-istart
	    	    frac2 = 1.0 - (rstop-istop)
<span class="comments">;</span>
<span class="comments">; add pixel values from istart to istop and  subtract fraction pixel </span>
<span class="comments">; from istart to rstart and fraction pixel from rstop to istop</span>
<span class="comments">;</span>
	   	     result[i] = total(image[istart:istop]) $
	   			- frac1 * image[istart]  $
	   			- frac2 * image[istop] 
	    endfor
 	    if keyword_set(total) then return,result $
	    			  else return,temporary(result)/(sbox*lbox)
 endif 

<span class="comments">; Now do 2-d case</span>
<span class="comments">; First, bin in second dimension</span>
<span class="comments">;</span>
	    if dtype eq 'DOUBLE' then temp = dblarr(ns,nlout, /NOZERO) $
			         else temp = fltarr(ns,nlout, /NOZERO)

<span class="comments">; loop on output image lines</span>
<span class="comments">;</span>
	    for i=0L,nlout-1 do begin
	    	    rstart = i*lbox		<span class="comments">;starting position for each box</span>
	    	    istart = long(rstart)
	    	    rstop = rstart + lbox	<span class="comments">;ending position for each box</span>
	    	    istop = long(rstop)&lt<span class="comments">;nl1</span>
	    	    frac1 = rstart-istart
	    	    frac2 = 1.0 - (rstop-istop)
<span class="comments">;</span>
<span class="comments">; add pixel values from istart to istop and  subtract fraction pixel </span>
<span class="comments">; from istart to rstart and fraction pixel from rstop to istop</span>
<span class="comments">;</span>

                     if istart EQ istop then $
	   	       temp[0,i] = (1.0 - frac1 - frac2)*image[*,istart] $
                       else $
	   	       temp[0,i] = total(image[*,istart:istop],2) $
	   			- frac1 * image[*,istart]  $
	   			- frac2 * image[*,istop] 
	    endfor
           temp = transpose(temp)
<span class="comments">;</span>
<span class="comments">; bin in first dimension</span>
<span class="comments">;</span>
	    if dtype eq 'DOUBLE' then result = dblarr(nlout,nsout,/NOZERO) $
			         else result = fltarr(nlout,nsout,/NOZERO)

<span class="comments">;</span>
<span class="comments">; loop on output image samples</span>
<span class="comments">;</span>
	    for i=0L,nsout-1 do begin
	    	    rstart = i*sbox	       <span class="comments">;starting position for each box</span>
	    	    istart = long(rstart)
	    	    rstop = rstart + sbox      <span class="comments">;ending position for each box</span>
	    	    istop = long(rstop)&lt<span class="comments">;ns1</span>
	    	    frac1 = rstart-istart
	    	    frac2 = 1.0 - (rstop-istop)
<span class="comments">;</span>
<span class="comments">; add pixel values from istart to istop and  subtract fraction pixel </span>
<span class="comments">; from istart to rstart and fraction pixel from rstop to istop</span>
<span class="comments">;</span>

		    if istart eq istop then $
                        result[0,i] = (1.-frac1-frac2)*temp[*,istart] else $
		    	result[0,i] = total(temp[*,istart:istop],2)   $
		    		- frac1 * temp[*,istart]  $
		    		- frac2 * temp[*,istop]
	    end

<span class="comments">;            </span>
	    if keyword_set(total) then $
                        return, transpose(result) $
	    	   else return, transpose(result)/(sbox*lbox)
	    			  
end
</code>
    </div>
  </body>
</html>