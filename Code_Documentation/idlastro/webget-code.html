<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:12 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>webget.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="webget.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;    WEBGET()</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;    Use the IDL SOCKET procedure to get data from http servers</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION: </span>
<span class="comments">;     WEBGET() can access http servers - even from behind a firewall - </span>
<span class="comments">;     and perform simple downloads. Currently, text and FITS files can be </span>
<span class="comments">;     accessed.    </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: </span>
<span class="comments">;      a=webget(URL)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS: </span>
<span class="comments">;      URL - scalar string giving a fully qualified url of the form</span>
<span class="comments">;          'http://server.eso.org/path/file.html'.    WEBGET() can</span>
<span class="comments">;          also use other valid URLs that contain 'GET' or 'POST' codes.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD PARAMETERS: </span>
<span class="comments">;       COPYFILE - if set to a valid filename (file must have write permission),</span>
<span class="comments">;            the data contents of the web server's answer is copied to that </span>
<span class="comments">;            file.</span>
<span class="comments">;       HTTP10 - If set, then use the HTTP 1.0 </span>
<span class="comments">;       POST - if set to a structure, the structure tags and values</span>
<span class="comments">;              will be used as post variables and POST'ed to the URL.</span>
<span class="comments">;              If POST is not set, the normal HTTP GET is used to</span>
<span class="comments">;              retrieve the URL.</span>
<span class="comments">;       /SILENT - If set, the information error messages are suppressed</span>
<span class="comments">;       TIMEOUT - Integer scalar giving number of seconds to wait to connect </span>
<span class="comments">;                or for data to arrive before giving up and issuing an error.</span>
<span class="comments">;                Default=15 seconds </span>
<span class="comments">; OUTPUTS: A structure with the following fields:</span>
<span class="comments">;</span>
<span class="comments">;            .Header - the HTTP header sent by the server</span>
<span class="comments">;</span>
<span class="comments">;            .Text   - The text part of the downloaded file. If the</span>
<span class="comments">;                     content type of the file was not of class</span>
<span class="comments">;                     'text',  this will be an empty string.</span>
<span class="comments">;</span>
<span class="comments">;            .ImageHeader - Header file of a FITS-image. FITS images</span>
<span class="comments">;                          are read when the content type is</span>
<span class="comments">;                          'image/fits' or 'application/octet-stream'</span>
<span class="comments">;                          (for dss-access). If the file is not a FITS</span>
<span class="comments">;                          image,  this will be an empty string.</span>
<span class="comments">;</span>
<span class="comments">;            .Image - The FITS image read from the server. If the file</span>
<span class="comments">;                    did not contain a FITS image,  this will be zero.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS: </span>
<span class="comments">;     The mime-type recognition is extremely limited. Only the content-type is </span>
<span class="comments">;     determined. Any text-file  will be stored in out.Text. The only other </span>
<span class="comments">;     category which can be fetched is FITS files,  which will be stored in </span>
<span class="comments">;     out.Image and out.ImageHeader.</span>
<span class="comments">;</span>
<span class="comments">;     PROXY: If you are behind a firewall and have to access the net through a </span>
<span class="comments">;         Web proxy,  set the environment variable 'http_proxy' to point to </span>
<span class="comments">;         your proxy server and port, e.g. </span>
<span class="comments">;         'setenv http_proxy=http://web-proxy.mpia-hd.mpg.de:3128'</span>
<span class="comments">;</span>
<span class="comments">;               The URL *MUST* begin with "http://".</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE: </span>
<span class="comments">;     Open a socket to the webserver and download the header. After deciding </span>
<span class="comments">;     whether it is text or binary, either store the text or try to read a </span>
<span class="comments">;     FITS file.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE: </span>
<span class="comments">;      IDL> a=webget('http://www.mpia.de/index.html')</span>
<span class="comments">;      IDL> print,a.Text</span>
<span class="comments">;      or</span>
<span class="comments">;</span>
<span class="comments">;          > PointingRA=0.0</span>
<span class="comments">;          > PointingDE=30.0</span>
<span class="comments">;          > QueryURL = strcompress("http://archive.eso.org/dss/dss/image?ra="+$</span>
<span class="comments">;          >                          string(PointingRA)+$</span>
<span class="comments">;          >                          "&dec="+$</span>
<span class="comments">;          >                          string(PointingDE)+$</span>
<span class="comments">;          >                          "&x=10&y=10&Sky-Survey=DSS1&mime-type=download-fits", $</span>
<span class="comments">;          >                          /remove)</span>
<span class="comments">;          > a=webget(QueryURL)</span>
<span class="comments">;          > tvscl,a.Image</span>
<span class="comments">;          > print,a.ImageHead</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY: </span>
<span class="comments">;     Written by M. Feldt, Heidelberg, Oct 2001 &lt;mfeldt@mpia.de></span>
<span class="comments">;     Use /swap_if_little_endian keyword to SOCKET  W. Landsman August 2002</span>
<span class="comments">;     Less restrictive search on Content-Type   W. Landsman   April 2003</span>
<span class="comments">;     Modified to work with FIRST image server-  A. Barth, Nov 2006</span>
<span class="comments">;     Better recovery from errors  W. Landsman  April 2007</span>
<span class="comments">;     Add support for POST access               J.D. Smith    June 2007</span>
<span class="comments">;     Recognize "fits" image type used by SKYVIEW   W. Landsman  June 2007</span>
<span class="comments">;     Upgraded, partially, to HTTP 1.1				M. Perrin, July 2007</span>
<span class="comments">;       The HTTP 1.1 support is presently INCOMPLETE: virtual servers are</span>
<span class="comments">;       supported, but chunked transfer encoding is not yet supported, so</span>
<span class="comments">;       technically this is not fully HTTP 1.1 compliant.</span>
<span class="comments">;     Added http10 keyword  W. Landsman   August 2007</span>
<span class="comments">;     Assume since V5.6, sockets always available  W. Landsman Nov 2007</span>
<span class="comments">;     Fix problem when using proxy server   W. Landsman July 2008</span>
<span class="comments">;     Fix problem with /SILENT keyword  W. Landsman  Jan 2009</span>
<span class="comments">;     Added check for missing Mime TYPE in CLASSANDTYPE, Zarro, December 2011</span>
<span class="comments">;     Timeout applies to connecting as well as reading, default is now 15</span>
<span class="comments">;               seconds  W Landsman January 2012</span>
<span class="comments">;-</span>

PRO MimeType,  Header, Class, Type, Length
<span class="comments">;;</span>
<span class="comments">;; MIME type recognition</span>
<span class="comments">;</span>
  Class = 'text'
  Type = 'simple'               <span class="comments">; in case no information found...    </span>
  def = strupcase(strmid(header,0,13))
  g = where(def EQ 'CONTENT-TYPE:', Ng)
  if Ng GT 0 then begin
       ClassAndType = strmid(Header[g[0]], 14, strlen(Header[g[0]])-1)
       temp=strsplit(ClassAndType, '/', /extract)
       Class=temp[0]
       if n_elements(temp) gt 1 then Type=temp[1]
  ENDIF 
  def = strupcase(strmid(header,0,15))
  g = where(def EQ 'CONTENT-LENGTH:', Ng)
  if Ng GT 0 then $
         Length = long(strmid(Header[g[0]], 15, strlen(Header[g[0]])-1))
  return
END 

FUNCTION webget,  url,  SILENT=silent, COPYFILE=copyfile, POST=post, $
   HTTP10=http10, timeout=timeout
   compile_opt idl2
  <span class="comments">;;</span>
   <span class="comments">;;</span>
  <span class="comments">;; define the result fields</span>
  <span class="comments">;;</span>
  Header = strarr(256)
  Data = strarr(256)
  Image = 0
  ImageHeader = ''
  
  <span class="comments">;; Setup post variables</span>
  if n_elements(post) ne 0 then begin 
     method='POST'
     t=tag_names(post)
     post_vars=strarr(n_elements(t))
     for i=0,n_elements(t)-1 do $
        post_vars[i]=strlowcase(t[i])+'='+strtrim(post.(i),2)
     post_vars=strjoin(post_vars,'&')
     post_data=['Content-Type: application/x-www-form-urlencoded',$
                'Content-Length: '+strtrim(strlen(post_vars),2), $
                '', $
                post_vars]
  endif else method='GET'
  
  
  <span class="comments">;;</span>
  <span class="comments">;; open the connection and request the file</span>
  <span class="comments">;;</span>
  ProtocolString = keyword_set(http10) ? "HTTP/1.0" : " HTTP/1.1"
  UserAgentString= "IDL "+!version.release+' on '+!VERSION.OS+'/'+!VERSION.ARCH
  Proxy = getenv('http_proxy')
  slash1 = StrPos(strmid(url, 7), '/')    <span class="comments">;Position of first slash</span>
  Server = StrMid(url, 7, slash1 )
  if N_elements(timeout) EQ 0 then timeout=15

  IF Proxy NE '' THEN BEGIN 
     <span class="comments">;;</span>
     <span class="comments">;; sort out proxy name</span>
     <span class="comments">;;</span>
     LastColon = StrPos(Proxy, ':', /Reverse_Search)
     ProxyPort = fix(StrMid(Proxy, LastColon+1))
     ProxyServer = StrMid(Proxy, 7, LastColon-7)
     <span class="comments">;; open the connection and send the 'GET' command</span>
     socket, unit, ProxyServer,  ProxyPort, /get_lun, /swap_if_little_endian, $
             read_timeout=timeout,connect_timeout=timeout
     printf, unit, method+' '+url+ProtocolString
  ENDIF ELSE BEGIN 
     <span class="comments">;;</span>
     <span class="comments">;; same thing easier without proxy</span>
     <span class="comments">;;</span>
     purl = strmid(url,slash1+7)
     Port = 80
     socket, unit, Server,  Port, /get_lun,/swap_if_little_endian, $
          connect_timeout=timeout,read_timeout=timeout
     printf, unit, method+' '+purl + ProtocolString
  ENDELSE 
  <span class="comments">;; These lines are the same for either with or without proxy.</span>
  <span class="comments">;; in HTTP 1.1 we MUST include the Host: line to allow requests</span>
  <span class="comments">;; from co-hosted virtual servers to operate properly.</span>
  printf, unit, "Host: "+Server
  printf, unit, 'User-Agent: '+ UserAgentString
  <span class="comments">;; HTTP 1.1 clients must either support persistent connections, or indicate</span>
  <span class="comments">;; they do not by stating Connection: close</span>
  printf, unit, "Connection: close"

  <span class="comments">;; Add the POST data, if requested</span>
  if n_elements(post) ne 0 then printf,unit,transpose(post_data)
  <span class="comments">;; Blank line required to terminate HTTP request.</span>
  printf, unit, ''

  LinesRead = 0
  text = 'xxx'
  <span class="comments">;;</span>
  <span class="comments">;; now read the header</span>
  <span class="comments">;;</span>
On_IOERROR, done
  WHILE  text NE '' do begin
      readf, unit, text
      Header[LinesRead] = text
      LinesRead = LinesRead+1
      IF LinesRead MOD 256 EQ 0 THEN $
        Header=[Header, StrArr(256)]
  ENDWHILE 
DONE: On_IOERROR, NULL
  <span class="comments">;;</span>
  if LinesRead EQ 0 then begin
      message,'Unable to read HTTP server',/CON
      free_lun,unit
      return,{Header:'', Text:'', ImageHeader:ImageHeader,  Image: Image}
  endif    
  Header = Header[0:LinesRead-1]
  MimeType, Header, Class,  Type, Length<span class="comments">; analyze the header</span>
  <span class="comments">;;</span>
  IF Keyword_Set(CopyFile) THEN BEGIN
      openw, wunit, CopyFile, /get_lun
      aaa = bytarr(Length,/nozero)
      readu, unit, aaa
      writeu, wunit, aaa
      free_lun, wunit
      free_lun, unit
      return, 1
  ENDIF 
  <span class="comments">;;</span>
  text = '' <span class="comments">;initialize text fields</span>
  LinesRead = 0l
  <span class="comments">;;</span>

  CASE Class OF 
      'text': BEGIN 
          <span class="comments">;;</span>
          <span class="comments">;; read anything of class 'text'</span>
          WHILE  eof(unit) EQ 0 do begin
              readf, unit, text
              Data[LinesRead] = text
              LinesRead = LinesRead+1
              IF LinesRead MOD 256 EQ 0 THEN $
                Data=[Data, StrArr(256)]
          ENDWHILE 
          if LinesRead EQ 0 then if not keyword_set(SILENT) then $
	       message,'ERROR - no lines of text read',/CON
          Data = Data[0:(LinesRead-1) > 0 ]
      END 
      'image':BEGIN
          CASE Type OF
              'x-fits': Image = readfits(unit, ImageHeader)
	      'fits': Image = readfits(unit, ImageHeader)
              else: message,'Unrecognized  image type of ' + type
          ENDCASE 
      END 
      'application':BEGIN 
          CASE Type OF
              'octet-stream':BEGIN <span class="comments">; try reading a FITS file because ESO </span>
                                   <span class="comments">; answers this way</span>
                  Image = readfits(unit, ImageHeader)
               END 
               'force-download': BEGIN     <span class="comments">; need this for FIRST survey</span>
                   image = readfits(unit, imageheader)
               END

          ENDCASE 
      END 
  ENDCASE 

  IF LinesRead EQ 0 THEN Data = ''
  free_lun, unit
  return, {Header:Header, Text:Data, ImageHeader:ImageHeader,  Image: Image}
END
</code>
    </div>
  </body>
</html>