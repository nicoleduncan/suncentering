<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:25 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbext_dbf.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbext_dbf.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbext_dbf:source"></a>pro dbext_dbf,list,dbno,sbyte,nbytes,idltype,nval,v1,v2,v3,v4,v5,v6, $
        v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18, item_dbno=item_dbno
	
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBEXT_DBF</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Subroutine of DBEXT to extract values of up to 18 items from a database </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This is a subroutine of DBEXT, which is the routine a user should </span>
<span class="comments">;       normally use.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       dbext_dbf,list,dbno,sbyte,nbytes,idltype,nval,v1,[ v2,v3,v4,v5,v6,v7,</span>
<span class="comments">;                  v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18 ITEM_DBNO = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       list - list of entry numbers to extract desired items.   It is the </span>
<span class="comments">;               entry numbers in the primary data base unless dbno is greater </span>
<span class="comments">;               than or equal to -1.  In that case it is the entry number in </span>
<span class="comments">;               the specified data base.</span>
<span class="comments">;       dbno - number of the opened db file</span>
<span class="comments">;               if set to -1 then all data bases are included</span>
<span class="comments">;       sbyte - starting byte in the entry.  If single data base then it must </span>
<span class="comments">;               be the starting byte for that data base only and not the </span>
<span class="comments">;               concatenation of db records </span>
<span class="comments">;       nbytes - number of bytes in the entry</span>
<span class="comments">;       idltype - idl data type of each item to be extracted</span>
<span class="comments">;       nval - number of values per entry of each item to be extracted</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       v1...v18 - the vectors of values for up to 18 items</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       item_dbno - A vector of the individual database numbers for each item.</span>
<span class="comments">;               Simplifies the code for linked databases</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       DB_INFO(), DB_ITEM_INFO(), DBRD, DBXVAL(), IS_IEEE_BIG(), IEEE_TO_HOST</span>
<span class="comments">; HISTORY</span>
<span class="comments">;       version 1  D. Lindler  Nov. 1987</span>
<span class="comments">;       Extract multiple valued entries    W. Landsman   May 1989</span>
<span class="comments">;       William Thompson, GSFC/CDS (ARC), 1 June 1994</span>
<span class="comments">;               Added support for external (IEEE) representation.</span>
<span class="comments">;       Work with multiple element string items  W. Landsman  August 1995</span>
<span class="comments">;       Increase speed for external databases on IEEE machines WBL August 1996</span>
<span class="comments">;       IEEE conversion implemented on blocks of entries using BIG</span>
<span class="comments">;       Added keyword ITEM_DBNO     R. Schwartz, GSFC/SDAC, August 1996</span>
<span class="comments">;       Return a vector even if only 1 value W. Thompson  October 1996</span>
<span class="comments">;       Change variable name of BYTESWAP to BSWAP  W. Thompson Mar 1997</span>
<span class="comments">;       Use /OVERWRITE with reform   W. Landsman   May 1997</span>
<span class="comments">;       Increase maximum number of items to 18  W. Landsman  November 1999</span>
<span class="comments">;       2 May 2003, W. Thompson, Use DBXVAL with BSWAP instead of IEEE_TO_HOST.</span>
<span class="comments">;       Avoid EXECUTE() for V6.1 or later  W. Landsman Jan 2007 </span>
<span class="comments">;       Assume since V6.1  W. Landsman June 2009</span>
<span class="comments">;       Change arrays to LONG to support entries >32767 bytes WL Oct 2010</span>
<span class="comments">;-</span>
<span class="comments">;</span>
 compile_opt idl2
<span class="comments">;*****************************************************************</span>
<span class="comments">;</span>
COMMON db_com,qdb,qitems,qdbrec
nitems=n_elements(sbyte)                                <span class="comments">;number of items</span>
external = db_info('external')                          <span class="comments">;External format?</span>
bswap = external * (~IS_IEEE_BIG() )              <span class="comments">;Need to byteswap?</span>
if dbno ge 0 then bswap = bswap[dbno] + bytarr(nitems) else $
        if n_elements(item_dbno) eq nitems then bswap=bswap[item_dbno] $
        else begin
        sbyte1 = db_item_info('bytepos')
        itnums = intarr(nitems)
        for i=0,nitems-1 do itnums[i] = (where( sbyte[i] eq sbyte1))[0]
        dbno1  = db_item_info('dbnumber', itnums)
        bswap  = bswap[dbno1]
endelse
        
scalar=0
if n_elements(list) eq 1 then begin
        scalar=1
        savelist=list
        list=lonarr(1)+list
        if list[0] eq -1 then list=lindgen(db_info('entries',0))+1
end
nlist=n_elements(list)
<span class="comments">;</span>
<span class="comments">; create a big array to hold all extracted values in</span>
<span class="comments">; byte format</span>
<span class="comments">;</span>
totbytes=total(nbytes)
big=bytarr(totbytes,nlist)
<span class="comments">;</span>
<span class="comments">; generate vector of bytes in entries to extract</span>
<span class="comments">;</span>
index=lonarr(totbytes)
ipos=0
for i=0,nitems-1 do begin
     for j=0,nbytes[i]-1 do index[ipos+j]=sbyte[i]+j
     ipos=ipos+nbytes[i]
endfor
<span class="comments">;</span>
<span class="comments">; generate vector of byte positions in big for each item</span>
<span class="comments">;</span>
bpos=lonarr(nitems)
if nitems gt 1 then for i=1,nitems-1 do bpos[i]=bpos[i-1]+nbytes[i-1]
<span class="comments">;</span>
<span class="comments">; loop on records and extract info into big</span>
<span class="comments">;</span>
if dbno ge 0 then begin
        <span class="comments">;</span>
        <span class="comments">; bypass dbrd for increased performance</span>
        <span class="comments">;</span>
        if dbno eq 0 then begin
                for i=0L,nlist-1 do begin
                    if list[i] ge 0 then begin
                        entry=qdbrec[list[i]]
                        big[0,i] = entry[index]
                    endif
                endfor
            end else begin      <span class="comments">;mapped I/O</span>
                unit=db_info('unit_dbf',dbno)
                rec_size=db_info('length',dbno)
                for i=0L,nlist-1 do begin
                    if list[i] ge 0 then begin
                        p=assoc(unit,bytarr(rec_size,/nozero),rec_size*list[i])
                        entry=p[0]
                        big[0,i] = entry[index]
                    end
                endfor
        end
   end else begin
        for i = 0L, nlist-1 do begin
           if list[i] GE 0 then begin
                dbrd,list[i],entry, /noconvert
                big[0,i] = entry[index]
            endif
        end
end
<span class="comments">;</span>
<span class="comments">; now extract each value and convert to correct type</span>
<span class="comments">;</span>
last = bpos + nbytes -1

for i = 0,nitems-1 do begin
    item = dbxval(big, idltype[i], nval[i], bpos[i], nbytes[i], bswap=bswap[i])
    st = 'v' + strtrim(i+1,2)
    if nlist GT 1 then $
       (SCOPE_VARFETCH(st)) = reform(item,/overwrite) else $
       (SCOPE_VARFETCH(st)) = [item]

  endfor<span class="comments">;for i loop on items</span>
<span class="comments">;</span>
if scalar then list=savelist    <span class="comments">;restore scalar value</span>
return
end
</code>
    </div>
  </body>
</html>