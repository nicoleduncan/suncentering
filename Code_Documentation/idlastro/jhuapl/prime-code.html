<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:33 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>prime.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="prime.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     PRIME</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Return an array with the specified number of prime numbers.</span>
<span class="comments">; EXPLANATATION:</span>
<span class="comments">;     This procedure is similar to PRIMES in the standard IDL distribution,</span>
<span class="comments">;     but stores results in a common block, and so is much faster </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       p = prime(n)</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       n = desired number of primes, scalar positive integer</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       p = resulting array of primes, vector of positive integers</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       prime_com</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Note: Primes that have been found in previous calls are</span>
<span class="comments">;         remembered and are not regenerated.</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       R. Sterner  17 Oct, 1985.</span>
<span class="comments">;       R. Sterner,  5 Feb, 1993 --- fixed a bug that missed a few primes.</span>
<span class="comments">;       Converted to IDL V5          March 1999</span>
<span class="comments">;</span>
<span class="comments">; Copyright (C) 1985, Johns Hopkins University/Applied Physics Laboratory</span>
<span class="comments">; This software may be used, copied, or redistributed as long as it is not</span>
<span class="comments">; sold and this copyright notice is reproduced on each copy made.  This</span>
<span class="comments">; routine is provided as is without any express or implied warranties</span>
<span class="comments">; whatsoever.  Other limitations apply as described in the file disclaimer.txt.</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------</span>
 
<a id="prime:source"></a>	function prime,n, help=hlp
 
	common prime_com, max, pmax
 
	if (n_params(0) lt 1) or keyword_set(hlp) then begin
	  print,' Return an array with the specified number of prime numbers.'
	  print,' p = prime(n)'
	  print,'   n = desired number of primes.    in'
	  print,'   p = resulting array of primes.   out'
	  print,' Note: Primes that have been found in previous calls are'
	  print,'   remembered and are not regenerated.'
	  return, -1
	endif
 
	if n_elements(max) eq 0 then max = 0	<span class="comments">; Make MAX defined.</span>
	if n le max then return, pmax[0:n-1]	<span class="comments">; Enough primes in memory.</span>
	p = lonarr(n)				<span class="comments">; Need to find primes.</span>
	if max eq 0 then begin			<span class="comments">; Have none now. Start with 8.</span>
	  p[0] = [2,3,5,7,11,13,17,19]
	  if n le 8 then return, p[0:n-1]	<span class="comments">; Need 8 or less.</span>
	  i = 8					<span class="comments">; Need more than 8.</span>
	  t = 19L				<span class="comments">; Search start value.</span>
	endif else begin			<span class="comments">; Start with old primes.</span>
	  p[0] = pmax				<span class="comments">; Move old primes into big arr.</span>
	  i = max				<span class="comments">; Current prime count.</span>
	  t = p[max-1]				<span class="comments">; Biggest prime so far.</span>
	endelse
 
loop:	if i eq n then begin			<span class="comments">; Have enough primes.</span>
	  max = n				<span class="comments">; Count.</span>
	  pmax = p				<span class="comments">; Array of primes.</span>
	  return, p				<span class="comments">; Return primes.</span>
	endif
loop2:	t = t + 2				<span class="comments">; Next test value, t.</span>
	it = 1					<span class="comments">; Start testing with 1st prime.</span>
loop3:	pr = p[it]				<span class="comments">; Pick next test prime.</span>
	pr2 = pr*pr				<span class="comments">; Square it.</span>
	if pr2 gt t then begin			<span class="comments">; Selected prime > sqrt(t)?</span>
	  i = i + 1				<span class="comments">; Yes, count</span>
	  p[i-1] = t				<span class="comments">; and store new prime.</span>
	  goto, loop				<span class="comments">; Go check if done.</span>
	endif
	if pr2 eq t then goto, loop2		<span class="comments">; Test number, t, was a square.</span>
	if (t mod pr) eq 0 then goto, loop2	<span class="comments">; Curr prime divides t.</span>
	it = it + 1				<span class="comments">; Check next prime.</span>
	goto, loop3
	end
</code>
    </div>
  </body>
</html>