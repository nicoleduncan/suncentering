<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>factor.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="factor.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FACTOR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Find prime factors of a given number.</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       factor, x, p, n</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       x = Number to factor (>1).       in</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       Keywords:</span>
<span class="comments">;         /QUIET  means do not print factors.</span>
<span class="comments">;         /DEBUG  Means list steps as they happen.</span>
<span class="comments">;         /TRY    Go beyond 20000 primes.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       p = Array of prime numbers.      out</span>
<span class="comments">;       n = Count of each element of p.  out</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Note: see also prime, numfactors, print_fact.</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       R. Sterner.  4 Oct, 1988.</span>
<span class="comments">;       RES 25 Oct, 1990 --- converted to IDL V2.</span>
<span class="comments">;       R. Sterner, 1999 Jun 30 --- Improved (faster, bigger).</span>
<span class="comments">;       R. Sterner, 1999 Jul  7 --- Bigger values (used unsigned).</span>
<span class="comments">;       R. Sterner, 1999 Jul  9 --- Tried to make backward compatable.</span>
<span class="comments">;       R. Sterner, 2000 Jan 06 --- Fixed to ignore non-positive numbers.</span>
<span class="comments">;       Johns Hopkins University Applied Physics Laboratory.</span>
<span class="comments">;</span>
<span class="comments">; Copyright (C) 1988, Johns Hopkins University/Applied Physics Laboratory</span>
<span class="comments">; This software may be used, copied, or redistributed as long as it is not</span>
<span class="comments">; sold and this copyright notice is reproduced on each copy made.  This</span>
<span class="comments">; routine is provided as is without any express or implied warranties</span>
<span class="comments">; whatsoever.  Other limitations apply as described in the file disclaimer.txt.</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------</span>
<span class="comments">; NAME:</span>
<span class="comments">;       SPC</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return a string with the specified number of spaces (or other char).</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       s = spc(n, [text])</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       n = number of spaces (= string length).   in </span>
<span class="comments">;        text = optional text string.              in</span>
<span class="comments">;          # spaces returned is n-strlen(strtrim(text,2))</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       Keywords:</span>
<span class="comments">;         CHARACTER=ch  Character other than a space.</span>
<span class="comments">;           Ex: CHAR='-'.</span>
<span class="comments">;         /NOTRIM means do not do a strtrim on text.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       s = resulting string.                     out</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Note: Number of requested spaces is reduced by the</span>
<span class="comments">;         length of given string.  Useful for text formatting.</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by R. Sterner, 16 Dec, 1984.</span>
<span class="comments">;       RES --- rewritten 14 Jan, 1986.</span>
<span class="comments">;       R. Sterner, 27 Jun, 1990 --- added text.</span>
<span class="comments">;       R. Sterner, 1994 Sep  7 --- Allowed text arrays.</span>
<span class="comments">;       R. Sterner, 1999 Jul  2 --- Added /NOTRIM keyword.</span>
<span class="comments">;       Johns Hopkins University Applied Physics Laboratory.</span>
<span class="comments">;</span>
<span class="comments">; Copyright (C) 1984, Johns Hopkins University/Applied Physics Laboratory</span>
<span class="comments">; This software may be used, copied, or redistributed as long as it is not</span>
<span class="comments">; sold and this copyright notice is reproduced on each copy made.  This</span>
<span class="comments">; routine is provided as is without any express or implied warranties</span>
<span class="comments">; whatsoever.  Other limitations apply as described in the file disclaimer.txt.</span>
<span class="comments">;-------------------------------------------------------------</span>
 
<a id="spc:source"></a>	function spc,n, text, character=char, notrim=notrim, help=hlp
 
	if (n_params(0) lt 1) or keyword_set(hlp) then begin
	  print,' Return a string with the specified number of spaces (or '+$
	    'other char).' 
	  print,' s = spc(n, [text])' 
	  print, '  n = number of spaces (= string length).   in '
	  print,'   text = optional text string.              in'
	  print,'     # spaces returned is n-strlen(strtrim(text,2))'
	  print,'   s = resulting string.                     out' 
	  print,' Keywords:'
	  print,'   CHARACTER=ch  Character other than a space.'
	  print,"     Ex: CHAR='-'."
	  print,'   /NOTRIM means do not do a strtrim on text.'
	  print,' Note: Number of requested spaces is reduced by the'
	  print,'   length of given string.  Useful for text formatting.'
	  return, -1
	endif
 
	if n_params(0) eq 1 then begin
	  n2 = n
	endif else begin
	  if keyword_set(notrim) then $
	    ntxt=strlen(text) else ntxt=strlen(strtrim(text,2))
<span class="comments">;	  n2 = n - strlen(strtrim(text,2))</span>
	  n2 = n - ntxt
	endelse
 
	ascii = 32B
	if n_elements(char) ne 0 then ascii = (byte(char))[0]
 
	num = n_elements(n2)
	out = strarr(num)
	for i = 0, num-1 do begin
	  if n2[i] le 0 then out[i] = '' else $
	    out[i] = string(bytarr(n2[i]) + ascii)
	endfor
 
	if n_elements(out) eq 1 then out=out[0]
	return, out
 
	end


<span class="comments">;-------------------------------------------------------------</span>
<span class="comments">; NAME:</span>
<span class="comments">;       PRINT_FACT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Print prime factors found by the factor routine.</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       print_fact, p, n</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       p = prime factors.          in</span>
<span class="comments">;       n = number of each factor.  in</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">; NOTES:</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       R. Sterner  4 Oct, 1988.</span>
<span class="comments">;       RES 25 Oct, 1990 --- converted to IDL V2.</span>
<span class="comments">;       R. Sterner, 26 Feb, 1991 --- Renamed from print_factors.pro</span>
<span class="comments">;       R. Sterner, 1999 Jun 30 --- Better output format.</span>
<span class="comments">;       R. Sterner, 1999 Jul  7 --- Bigger values (used unsigned).</span>
<span class="comments">;       R. Sterner, 1999 Jul  9 --- Made backward compatable.</span>
<span class="comments">;</span>
<span class="comments">; Copyright (C) 1988, Johns Hopkins University/Applied Physics Laboratory</span>
<span class="comments">; This software may be used, copied, or redistributed as long as it is not</span>
<span class="comments">; sold and this copyright notice is reproduced on each copy made.  This</span>
<span class="comments">; routine is provided as is without any express or implied warranties</span>
<span class="comments">; whatsoever.  Other limitations apply as described in the file disclaimer.txt.</span>
<span class="comments">;-------------------------------------------------------------</span>
 
<a id="print_fact:source"></a>	pro print_fact, p, n, help=hlp
 
	if (n_params(0) lt 2) or keyword_set(hlp) then begin
	  print,' Print prime factors found by the factor routine.'
	  print,' print_fact, p, n'
	  print,'   p = prime factors.          in'
	  print,'   n = number of each factor.  in'
	  return
	endif
 
	<span class="comments">;-------  Drop unused primes  ---------------</span>
	w = where(n gt 0)	<span class="comments">; Find only primes used.</span>
	p2 = p[w]
	n2 = n[w]
 
	<span class="comments">;-------  Use largest available integer type  --------------</span>
	flag = !version.release ge 5.2
	if flag eq 1 then begin
	  err=execute('t=1ULL')		<span class="comments">; Use 64 bit int (hide from old IDL).</span>
	endif else begin
	  t = 1L			<span class="comments">; Use long int (best available in old).</span>
	endelse
 
	<span class="comments">;-------  Compute number from it's prime factors.  ----------</span>
	for i = 0, n_elements(p2)-1 do t = t * p2[i]^n2[i]
 
	<span class="comments">;-------  Prepare output  -----------------------</span>
	a = strtrim(t,2)+' = '			<span class="comments">; Start factors string.</span>
	b = ''					<span class="comments">; Start exponents string.</span>
	last = n_elements(p2)-1			<span class="comments">; Last factors index.</span>
	for i=0, last do begin
	  a = a + strtrim(p2[i],2)		<span class="comments">; Insert next factor.</span>
	  lena = strlen(a)			<span class="comments">; Length of factor string.</span>
	  nxtb = strtrim(n2[i],2)		<span class="comments">; Next exponent.</span>
	  if nxtb eq '1' then nxtb=' '		<span class="comments">; Weed out 1s.</span>
	  b = b+spc(lena,b,/notrim)+nxtb	<span class="comments">; Insert next exponent.</span>
	  if i ne last then a=a+' x '		<span class="comments">; Not last, add x.</span>
	endfor
 
	<span class="comments">;------  Print exponents and factors  -----------</span>
	print,' '
	print,' '+b
	print,' '+a
 
	return
	end


 
<a id="factor:source"></a>	pro factor, x, p, n, quiet=quiet, debug=debug, try=try, help=hlp
 
	if (n_params(0) lt 1) or keyword_set(hlp) then begin
	  print,' Find prime factors of a given number.'
	  print,' factor, x, p, n'
	  print,'   x = Number to factor (>1).       in'
	  print,'   p = Array of prime numbers.      out'
	  print,'   n = Count of each element of p.  out'
	  print,' Keywords:'
	  print,'   /QUIET  means do not print factors.'
	  print,'   /DEBUG  Means list steps as they happen.'
	  print,'   /TRY    Go beyond 20000 primes.'
	  print,' Note: see also prime, numfactors, print_fact.'
	  return
	endif
 
	if x le 0 then return
 
	flag = !version.release ge 5.2
 
	s = sqrt(x)			<span class="comments">; Only need primes up to sqrt(x).</span>
	g = long(50 + 0.13457*s)	<span class="comments">; Upper limit of # primes up to s.</span>
	np = 50				<span class="comments">; Start with np (50) primes.</span>
	p = prime(np)			<span class="comments">; Find np primes.</span>
	n = intarr(n_elements(p))	<span class="comments">; Divisor count.</span>
 
	if flag eq 1 then $		<span class="comments">; Working number.</span>
	  err=execute('t=ulong64(x)') $	<span class="comments">; Use best integer available.</span>
	  else t=long(x)		<span class="comments">; Best pre-5.2 integer.</span>
	i = 0L				<span class="comments">; Index of test prime.</span>
 
loop:	pt = p[i]			<span class="comments">; Pull test prime.</span>
	if keyword_set(debug) then $
	  print,' Trying '+strtrim(pt,2)+' into '+strtrim(t,2)
	if flag eq 1 then $
	  err=execute('t2=ulong64(t/pt)') $
	  else t2=long(t/pt)
	if t eq t2*pt then begin	<span class="comments">; Check if it divides.</span>
	  if keyword_set(debug) then $
	    print,'   Was a factor.  Now do '+strtrim(t2,2)
	  n[i] = n[i] + 1		<span class="comments">; Yes, count it.</span>
	  t = t2			<span class="comments">; Result after division.</span>
	  if t2 eq 1 then goto, done	<span class="comments">; Check if done.</span>
	  goto, loop			<span class="comments">; Continue.</span>
	endif else begin
	  i = i + 1			<span class="comments">; Try next prime.</span>
	  if i ge np then begin
	    s = sqrt(t)			<span class="comments">; Only need primes up to sqrt(x).</span>
	    g = long(50 + 0.13457*s)	<span class="comments">; Upper limit of # primes up to s.</span>
	    if g le np then goto, last	<span class="comments">; Must be done.</span>
	    np = (np+50)&lt<span class="comments">;g		; Want 50 more primes.</span>
	    if (np gt 20000) and (not keyword_set(try)) then begin
	      print,' Too hard.  Tried '+strtrim(np-50,2)+' primes.'
	      print,' Trying to crack '+strtrim(t,2)
	      print,' To go farther use keyword /TRY.'
	      return
	    endif
	    if keyword_set(debug) then $
	      print,' Finding more primes: '+strtrim(np,2)+ $
	      '.  Max needed = '+strtrim(g,2)
	    p = prime(np)		<span class="comments">; Find primes.</span>
	    n = [n,intarr(50)]		<span class="comments">; Make room for more factors.</span>
	  endif
	  if i ge g then goto, last	<span class="comments">; Nothing up to sqrt works.</span>
	  goto, loop			<span class="comments">; Continue.</span>
	endelse
 
last:	p = [p,t]			<span class="comments">; Residue was > sqrt, must be prime.</span>
	n = [n,1]			<span class="comments">; Must occur only once. (else &lt; sqrt).</span>
 
done:	w = where(n gt 0)
	n = n[w]			<span class="comments">; Trim excess off tables.</span>
	p = p[w]
 
	if not keyword_set(quiet) then print_fact, p, n
 
	return
	end

</code>
    </div>
  </body>
</html>