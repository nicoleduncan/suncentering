<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pixwt.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pixwt.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	PIXWT</span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;	Circle-rectangle overlap area computation.</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;	Compute the fraction of a unit pixel that is interior to a circle.</span>
<span class="comments">;	The circle has a radius r and is centered at (xc, yc).  The center of</span>
<span class="comments">;	the unit pixel (length of sides = 1) is at (x, y).</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	CCD data processing</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	area = Pixwt( xc, yc, r, x, y )</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	xc, yc : Center of the circle, numeric scalars</span>
<span class="comments">;	r      : Radius of the circle, numeric scalars</span>
<span class="comments">;	x, y   : Center of the unit pixel, numeric scalar or vector</span>
<span class="comments">; OPTIONAL INPUT PARAMETERS:</span>
<span class="comments">;	None.</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;	None.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	Function value: Computed overlap area.</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       What is the area of overlap of a circle with radius 3.44 units centered</span>
<span class="comments">;       on the point 3.23, 4.22 with the pixel centered at [5,7]</span>
<span class="comments">;</span>
<span class="comments">;       IDL> print,pixwt(3.23,4.22,3.44,5,7)  ==>  0.6502</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;    None.</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	Divides the circle and rectangle into a series of sectors and</span>
<span class="comments">;	triangles.  Determines which of nine possible cases for the</span>
<span class="comments">;	overlap applies and sums the areas of the corresponding sectors</span>
<span class="comments">;	and triangles.    Called by aper.pro</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;      If improved speed is needed then a C version of this routines, with</span>
<span class="comments">;      notes on how to linkimage it to IDL is available at   </span>
<span class="comments">;       ftp://ftp.lowell.edu/pub/buie/idl/custom/</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Ported by Doug Loucks, Lowell Observatory, 1992 Sep, from the</span>
<span class="comments">;    routine pixwt.c, by Marc Buie.</span>
<span class="comments">;-</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
<span class="comments">; Function Arc( x, y0, y1, r )</span>
<span class="comments">;</span>
<span class="comments">; Compute the area within an arc of a circle.  The arc is defined by</span>
<span class="comments">; the two points (x,y0) and (x,y1) in the following manner:  The circle</span>
<span class="comments">; is of radius r and is positioned at the origin.  The origin and each</span>
<span class="comments">; individual point define a line which intersects the circle at some</span>
<span class="comments">; point.  The angle between these two points on the circle measured</span>
<span class="comments">; from y0 to y1 defines the sides of a wedge of the circle.  The area</span>
<span class="comments">; returned is the area of this wedge.  If the area is traversed clockwise</span>
<span class="comments">; then the area is negative, otherwise it is positive.</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
FUNCTION Arc, x, y0, y1, r
RETURN, 0.5 * r*r * ( ATAN( FLOAT(y1)/FLOAT(x) ) - ATAN( FLOAT(y0)/FLOAT(x) ) )
END


<span class="comments">; ---------------------------------------------------------------------------</span>
<span class="comments">; Function Chord( x, y0, y1 )</span>
<span class="comments">;</span>
<span class="comments">; Compute the area of a triangle defined by the origin and two points,</span>
<span class="comments">; (x,y0) and (x,y1).  This is a signed area.  If y1 > y0 then the area</span>
<span class="comments">; will be positive, otherwise it will be negative.</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
FUNCTION Chord, x, y0, y1
RETURN, 0.5 * x * ( y1 - y0 )
END


<span class="comments">; ---------------------------------------------------------------------------</span>
<span class="comments">; Function Oneside( x, y0, y1, r )</span>
<span class="comments">;</span>
<span class="comments">; Compute the area of intersection between a triangle and a circle.</span>
<span class="comments">; The circle is centered at the origin and has a radius of r.  The</span>
<span class="comments">; triangle has verticies at the origin and at (x,y0) and (x,y1).</span>
<span class="comments">; This is a signed area.  The path is traversed from y0 to y1.  If</span>
<span class="comments">; this path takes you clockwise the area will be negative.</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
FUNCTION Oneside, x, y0, y1, r

true = 1
size_x  = SIZE( x )

CASE size_x[ 0 ] OF
   0    : BEGIN
      IF x EQ 0 THEN RETURN, x
      IF ABS( x ) GE r THEN RETURN, Arc( x, y0, y1, r )
      yh = SQRT( r*r - x*x )
      CASE true OF
         ( y0 LE -yh ) : BEGIN
            CASE true OF
               ( y1 LE -yh ) : RETURN, Arc( x, y0, y1, r )
               ( y1 LE  yh ) : RETURN, Arc( x, y0, -yh, r ) $
                               + Chord( x, -yh, y1 )
               ELSE          : RETURN, Arc( x, y0, -yh, r ) $
                               + Chord( x, -yh, yh ) + Arc( x, yh, y1, r )
            ENDCASE
         END

         ( y0 LT  yh ) : BEGIN
            CASE true OF
               ( y1 LE -yh ) : RETURN, Chord( x, y0, -yh ) $
                               + Arc( x, -yh, y1, r )
               ( y1 LE  yh ) : RETURN, Chord( x, y0, y1 )
               ELSE          : RETURN, Chord( x, y0, yh ) + Arc( x, yh, y1, r )
            ENDCASE
         END

         ELSE          : BEGIN
            CASE true OF
               ( y1 LE -yh ) : RETURN, Arc( x, y0, yh, r ) $
                               + Chord( x, yh, -yh ) + Arc( x, -yh, y1, r )
               ( y1 LE  yh ) : RETURN, Arc( x, y0, yh, r ) + Chord( x, yh, y1 )
               ELSE          : RETURN, Arc( x, y0, y1, r )
            ENDCASE
         END
      ENDCASE
   END

   ELSE : BEGIN
      ans = x
      t0 = WHERE( x EQ 0, count )
      IF count EQ n_elements( x ) THEN RETURN, ans

      ans = x * 0
      yh = ans
      to = WHERE( ABS( x ) GE r, tocount )
      ti = WHERE( ABS( x ) LT r, ticount )
      IF tocount NE 0 THEN ans[ to ] = Arc( x[to], y0[to], y1[to], r )
      IF ticount EQ 0 THEN RETURN, ans

      yh[ ti ] = SQRT( r*r - x[ti]*x[ti] )

      t1 = WHERE( y0[ti] LE -yh[ti], count )
      IF count NE 0 THEN BEGIN
         i = ti[ t1 ]

         t2 = WHERE( y1[i] LE -yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] =  Arc( x[j], y0[j], y1[j], r )
         ENDIF

         t2 = WHERE( ( y1[i] GT -yh[i] ) AND ( y1[i] LE  yh[i] ), count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Arc( x[j], y0[j], -yh[j], r ) $
                   + Chord( x[j], -yh[j], y1[j] )
         ENDIF

         t2 = WHERE( y1[i] GT yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Arc( x[j], y0[j], -yh[j], r ) $
                   + Chord( x[j], -yh[j], yh[j] ) $
                   + Arc( x[j], yh[j], y1[j], r )
         ENDIF
      ENDIF

      t1 = WHERE( ( y0[ti] GT -yh[ti] ) AND ( y0[ti] LT yh[ti] ), count )
      IF count NE 0 THEN BEGIN
         i = ti[ t1 ]

         t2 = WHERE( y1[i] LE -yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Chord( x[j], y0[j], -yh[j] ) $
                   + Arc( x[j], -yh[j], y1[j], r )
         ENDIF

         t2 = WHERE( ( y1[i] GT -yh[i] ) AND ( y1[i] LE  yh[i] ), count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Chord( x[j], y0[j], y1[j] )
         ENDIF

         t2 = WHERE( y1[i] GT yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Chord( x[j], y0[j], yh[j] ) $
                   + Arc( x[j], yh[j], y1[j], r )
         ENDIF
      ENDIF

      t1 = WHERE( y0[ti] GE yh[ti], count )
      IF count NE 0 THEN BEGIN
         i = ti[ t1 ]

         t2 = WHERE ( y1[i] LE -yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Arc( x[j], y0[j], yh[j], r ) $
                   + Chord( x[j], yh[j], -yh[j] ) $
                   + Arc( x[j], -yh[j], y1[j], r )
         ENDIF

         t2 = WHERE( ( y1[i] GT -yh[i] ) AND ( y1[i] LE  yh[i] ), count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Arc( x[j], y0[j], yh[j], r ) $
                   + Chord( x[j], yh[j], y1[j] )
         ENDIF

         t2 = WHERE( y1[i] GT yh[i], count )
         IF count NE 0 THEN BEGIN
            j = ti[ t1[ t2 ] ]
            ans[j] = Arc( x[j], y0[j], y1[j], r )
         ENDIF
      ENDIF

      RETURN, ans
   END
ENDCASE

END


<span class="comments">; ---------------------------------------------------------------------------</span>
<span class="comments">; Function Intarea( xc, yc, r, x0, x1, y0, y1 )</span>
<span class="comments">;</span>
<span class="comments">; Compute the area of overlap of a circle and a rectangle.</span>
<span class="comments">;    xc, yc  :  Center of the circle.</span>
<span class="comments">;    r       :  Radius of the circle.</span>
<span class="comments">;    x0, y0  :  Corner of the rectangle.</span>
<span class="comments">;    x1, y1  :  Opposite corner of the rectangle.</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
FUNCTION Intarea, xc, yc, r, x0, x1, y0, y1
<span class="comments">;</span>
<span class="comments">; Shift the objects so that the circle is at the origin.</span>
<span class="comments">;</span>
x0 = x0 - xc
y0 = y0 - yc
x1 = x1 - xc
y1 = y1 - yc

RETURN, Oneside( x1, y0, y1, r ) + Oneside( y1, -x1, -x0, r ) +$
        Oneside( -x0, -y1, -y0, r ) + Oneside( -y0, x0, x1, r )

END


<span class="comments">; ---------------------------------------------------------------------------</span>
<span class="comments">; FUNCTION Pixwt( xc, yc, r, x, y )</span>
<span class="comments">;</span>
<span class="comments">; Compute the fraction of a unit pixel that is interior to a circle.</span>
<span class="comments">; The circle has a radius r and is centered at (xc, yc).  The center of</span>
<span class="comments">; the unit pixel (length of sides = 1) is at (x, y).</span>
<span class="comments">; ---------------------------------------------------------------------------</span>
FUNCTION Pixwt, xc, yc, r, x, y
RETURN, Intarea( xc, yc, r, x-0.5, x+0.5, y-0.5, y+0.5 )
END
</code>
    </div>
  </body>
</html>