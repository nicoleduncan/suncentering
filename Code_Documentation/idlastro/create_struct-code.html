<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:23 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>create_struct.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="create_struct.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="create_struct:source"></a>pro create_struct, struct, strname, tagnames, tag_descript, DIMEN = dimen, $
              CHATTER = chatter, NODELETE = nodelete
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       CREATE_STRUCT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Create an IDL structure from a list of tag names and dimensions</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Dynamically create an IDL structure variable from list of tag names </span>
<span class="comments">;       and data types of arbitrary dimensions.   Useful when the type of</span>
<span class="comments">;       structure needed is not known until run time.</span>
<span class="comments">;</span>
<span class="comments">;       Unlike the intrinsic function CREATE_STRUCT(), this procedure does not</span>
<span class="comments">;       require the user to know the number of tags before run time.   (Note</span>
<span class="comments">;       there is no name conflict since the intrinsic CREATE_STRUCT is a </span>
<span class="comments">;       function, and this file contains a procedure.)</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       CREATE_STRUCT, STRUCT, strname, tagnames, tag_descript, </span>
<span class="comments">;                             [ DIMEN = , /CHATTER, /NODELETE ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       STRNAME -   name to be associated with structure (string)</span>
<span class="comments">;               Must be unique for each structure created.   Set</span>
<span class="comments">;               STRNAME = '' to create an anonymous structure</span>
<span class="comments">;</span>
<span class="comments">;       TAGNAMES -  tag names for structure elements (string or string array)</span>
<span class="comments">;                Any strings that are not valid IDL tag names (e.g. 'a\2')</span>
<span class="comments">;                will be converted by IDL_VALIDNAME to a valid tagname by </span>
<span class="comments">;                replacing with underscores as necessary (e.g. 'a_2')</span>
<span class="comments">;</span>
<span class="comments">;       TAG_DESCRIPT -  String descriptor for the structure, containing the</span>
<span class="comments">;               tag type and dimensions.  For example, 'A(2),F(3),I', would</span>
<span class="comments">;               be the descriptor for a structure with 3 tags, strarr(2), </span>
<span class="comments">;               fltarr(3) and Integer scalar, respectively.</span>
<span class="comments">;               Allowed types are 'A' for strings, 'B' or 'L' for unsigned byte </span>
<span class="comments">;               integers, 'I' for integers, 'J' for longword integers, </span>
<span class="comments">;               'K' for 64bit integers, 'F' or 'E' for floating point, </span>
<span class="comments">;               'D' for double precision  'C' for complex, and 'M' for double </span>
<span class="comments">;               complex.   Uninterpretable characters in a format field are </span>
<span class="comments">;               ignored.</span>
<span class="comments">;</span>
<span class="comments">;               For vectors, the tag description can also be specified by</span>
<span class="comments">;               a repeat count.  For example, '16E,2J' would specify a </span>
<span class="comments">;               structure with two tags, fltarr(16), and lonarr(2)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;       DIMEN -    number of dimensions of structure array (default is 1)</span>
<span class="comments">;</span>
<span class="comments">;       CHATTER -  If set, then CREATE_STRUCT() will display</span>
<span class="comments">;                  the dimensions of the structure to be created, and prompt</span>
<span class="comments">;                  the user whether to continue.  Default is no prompt.</span>
<span class="comments">;</span>
<span class="comments">;       /NODELETE - If set, then the temporary file created</span>
<span class="comments">;                  CREATE_STRUCT will not be deleted upon exiting.   See below</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       STRUCT -   IDL structure, created according to specifications </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES: </span>
<span class="comments">;</span>
<span class="comments">;       IDL> create_struct, new, 'name',['tag1','tag2','tag3'], 'D(2),F,A(1)'</span>
<span class="comments">;</span>
<span class="comments">;       will create a structure variable new, with structure name NAME</span>
<span class="comments">;</span>
<span class="comments">;       To see the structure of new:</span>
<span class="comments">;</span>
<span class="comments">;       IDL> help,new,/struc</span>
<span class="comments">;       ** Structure NAME, 3 tags, 20 length:</span>
<span class="comments">;          TAG1            DOUBLE         Array(2)</span>
<span class="comments">;          TAG2            FLOAT          0.0</span>
<span class="comments">;          TAG3            STRING         Array(1)</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Generates a temporary procedure file using input information with</span>
<span class="comments">;       the desired structure data types and dimensions hard-coded.</span>
<span class="comments">;       This file is then executed with CALL_PROCEDURE.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       If CREATE_STRUCT cannot write a temporary .pro file in the current </span>
<span class="comments">;       directory, then it will write the temporary file in the getenv('HOME')</span>
<span class="comments">;       directory.</span>
<span class="comments">;</span>
<span class="comments">;       Note that 'L' now specifies a LOGICAL (byte) data type and not a</span>
<span class="comments">;       a LONG data type for consistency with FITS binary tables</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       The name of the structure must be unique, for each structure created.</span>
<span class="comments">;       Otherwise, the new variable will have the same structure as the </span>
<span class="comments">;       previous definition (because the temporary procedure will not be</span>
<span class="comments">;       recompiled).  ** No error message will be generated  ***</span>
<span class="comments">;</span>
<span class="comments">; SUBROUTINES CALLED:</span>
<span class="comments">;       REPCHR() </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Version 1.0 RAS January 1992</span>
<span class="comments">;       Modified 26 Feb 1992 for Rosat IDL Library (GAR)</span>
<span class="comments">;       Modified Jun 1992 to accept arrays for tag elements -- KLV, Hughes STX</span>
<span class="comments">;       Accept anonymous structures W. Landsman  HSTX    Sep. 92</span>
<span class="comments">;       Accept 'E' and 'J' format specifications   W. Landsman Jan 93</span>
<span class="comments">;       'L' format now stands for logical and not long array</span>
<span class="comments">;       Accept repeat format for vectors        W. Landsman Feb 93</span>
<span class="comments">;       Accept complex and double complex (for V4.0)   W. Landsman Jul 95</span>
<span class="comments">;       Work for long structure definitions  W. Landsman Aug 97</span>
<span class="comments">;       Write temporary file in HOME directory if necessary  W. Landsman Jul 98</span>
<span class="comments">;       Use OPENR,/DELETE for OS-independent file removal W. Landsman Jan 99</span>
<span class="comments">;       Use STRSPLIT() instead of GETTOK() W. Landsman  July 2002</span>
<span class="comments">;       Assume since V5.3 W. Landsman  Feb 2004</span>
<span class="comments">;       Added RESOLVE_ROUTINE to ensure recompilation W. Landsman Sep. 2004</span>
<span class="comments">;       Delete temporary with FILE_DELETE   W. Landsman Sep 2006</span>
<span class="comments">;       Assume since V5.5, delete VMS reference  W.Landsman Sep 2006</span>
<span class="comments">;       Added 'K' format for 64 bit integers, IDL_VALIDNAME check on tags</span>
<span class="comments">;                       W. Landsman  Feb 2007</span>
<span class="comments">;       Use vector form of IDL_VALIDNAME() if V6.4 or later W.L. Dec 2007</span>
<span class="comments">;       Suppress compilation mesage of temporary file A. Conley/W.L. May 2009</span>
<span class="comments">;       Remove FDECOMP, some cleaner coding  W.L. July 2009</span>
<span class="comments">;       Do not limit string length to 1000 chars   P. Broos,  Feb 2011</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------------</span>

 compile_opt idl2
 if N_params() LT 4 then begin
   print,'Syntax - CREATE_STRUCT, STRUCT, strname, tagnames, tag_descript,' 
   print,'                  [ DIMEN = , /CHATTER, /NODELETE ]'
   return
 endif

 if ~keyword_set( chatter) then chatter = 0        <span class="comments">;default is 0</span>
 if (N_elements(dimen) eq 0) then dimen = 1            <span class="comments">;default is 1</span>

 if (dimen lt 1) then begin
  print,' Number of dimensions must be >= 1. Returning.'
  return
 endif

<span class="comments">; For anonymous structure, strname = ''</span>
  anonymous = 0b
  if (strlen( strtrim(strname,2)) EQ 0 ) then anonymous = 1b

 good_fmts = [ 'A', 'B', 'I', 'L', 'F', 'E', 'D', 'J','C','M', 'K' ]
 fmts = ["' '",'0B','0','0B','0.0','0.0','0.0D0','0L','complex(0)', $
           'dcomplex(0)', '0LL']
 arrs = [ 'strarr', 'bytarr', 'intarr', 'bytarr', 'fltarr', 'fltarr', $
          'dblarr', 'lonarr','complexarr','dcomplexarr','lon64arr']
 ngoodf = N_elements( good_fmts )

<span class="comments">; If tagname is a scalar string separated by commas, convert to a string array</span>

 if size(tagnames,/N_dimensions) EQ 0 then begin
            tagname = strsplit(tagnames,',',/EXTRACT) 
 endif else tagname = tagnames

 Ntags = N_elements(tagname)

<span class="comments">; Make sure supplied tag names are valid.</span>

 if !VERSION.RELEASE GE '6.4' then $ 
          tagname = idl_validname( tagname, /convert_all ) else $
 for k = 0, Ntags -1 do $ 
         tagname[k] = idl_validname( tagname[k], /convert_all )

<span class="comments">;  If user supplied a scalar string descriptor then we want to break it up</span>
<span class="comments">;  into individual items.    This is somewhat complicated because the string</span>
<span class="comments">;  delimiter is not always a comma, e.g. if 'F,F(2,2),I(2)', so we need</span>
<span class="comments">;  to check positions of parenthesis also.</span>

 sz = size(tag_descript)
 if sz[0] EQ 0 then begin
      tagvar = strarr( Ntags)
      temptag = tag_descript
      for i = 0, Ntags - 1 do begin
         comma = strpos( temptag, ',' )
         lparen = strpos( temptag, '(' )
         rparen = strpos( temptag, ')' )
            if ( comma GT lparen ) and (comma LT Rparen) then pos = Rparen+1 $
                                                         else pos = comma 
             if pos EQ -1 then begin
                 if i NE Ntags-1 then message, $
         'WARNING - could only parse ' + strtrim(i+1,2) + ' string descriptors'
                 tagvar[i] = temptag 
                 goto, DONE
             endif else begin
                    tagvar[i] = strmid( temptag, 0, pos )
                    temptag = strmid( temptag, pos+1)
              endelse
             endfor
             DONE:
            
 endif else tagvar = tag_descript

<span class="comments">; create string array for IDL statements, to be written into </span>
<span class="comments">; 'temp_'+strname+'.pro'</span>

 pro_string = strarr (ntags + 2) 

 if (dimen EQ 1) then begin

   pro_string[0] = "struct =  { " + strname + " $"
   pro_string[ntags+1] = " } "

 endif else begin

   dimen = long(dimen)                <span class="comments">;Changed to LONG from FIX Mar 95</span>
   pro_string[0] = "struct "   + " = replicate ( { " + strname + " $"
   pro_string[ntags+1] = " } , " + string(dimen) + ")"

 endelse

 tagvar = strupcase(tagvar) 

 for i = 0, ntags-1 do begin

   goodpos = -1
   for j = 0,ngoodf-1 do begin
         fmt_pos = strpos( tagvar[i], good_fmts[j] )
         if ( fmt_pos GE 0 ) then begin
              goodpos = j
              break
         endif
   endfor

  if goodpos EQ -1 then begin 
      print,' Format not recognized: ' + tagvar[i]
      print,' Allowed formats are :',good_fmts
      stop,' Redefine tag format (' + string(i) + ' ) or quit now'
  endif 


    if fmt_pos GT 0 then begin

           repeat_count = strmid( tagvar[i], 0, fmt_pos )
           if strnumber( repeat_count, value ) then begin
                fmt = arrs[ goodpos ] + '(' + strtrim(fix(value), 2) + ')'
           endif else begin 
                print,' Format not recognized: ' + tagvar[i]
                stop,' Redefine tag format (' + string(i) + ' ) or quit now'
           endelse

    endif else  begin

<span class="comments">; Break up the tag descriptor into a format and a dimension</span>
    tagfmts = strmid( tagvar[i], 0, 1)
    tagdim = strtrim( strmid( tagvar[i], 1, 80),2)
    if strmid(tagdim,0,1) NE '(' then tagdim = ''
    fmt = (tagdim EQ '') ? fmts[goodpos] : arrs[goodpos] + tagdim 
    endelse

  if anonymous and ( i EQ 0 ) then comma = '' else comma = " , "

      pro_string[i+1] = comma + tagname[i] + ": " + fmt + " $"      

 endfor

<span class="comments">; Check that this structure definition is OK (if chatter set to 1)</span>
 
 if keyword_set ( Chatter )  then begin
   ans = ''
   print,' Structure ',strname,' will be defined according to the following:'
   temp = repchr( pro_string, '$', '')
   print, temp
   read,' OK to continue? (Y or N)  ',ans
   if strmid(strupcase(ans),0,1) eq 'N' then begin
      print,' Returning at user request.'
     return
   endif
 endif 

<span class="comments">; --- Determine if a file already exists with same name as temporary file</span>

 tempfile = 'temp_' + strlowcase( strname )
 while file_test( tempfile + '.pro' ) do tempfile = tempfile + 'x'
 
<span class="comments">; ---- open temp file and create procedure</span>
<span class="comments">; ---- If problems writing into the current directory, try the HOME directory</span>

 cd,current= prodir 
 cdhome = 0
 openw, unit, tempfile +'.pro', /get_lun, ERROR = err
 if (err LT 0)  then begin
      prodir = getenv('HOME')
      tempfile = prodir + path_sep() + tempfile
      while file_test( tempfile + '.pro' ) do tempfile = tempfile + 'x'
      openw, unit, tempfile +'.pro', /get_lun, ERROR = err
      if err LT 0 then message,'Unable to create a temporary .pro file'
      cdhome = 1
  endif
 name = file_basename(tempfile)
 printf, unit, 'pro ' +  name + ', struct'
 printf,unit,'compile_opt hidden'
 for j = 0,N_elements(pro_string)-1 do $
        printf, unit, strtrim( pro_string[j] )
 printf, unit, 'return'
 printf, unit, 'end'
 free_lun, unit

<span class="comments">; If using the HOME directory, it needs to be included in the IDL !PATH</span>

 if cdhome then cd,getenv('HOME'),curr=curr
  resolve_routine, name
  Call_procedure, name, struct
 if cdhome then cd,curr

 if keyword_set( NODELETE ) then begin
    message,'Created temporary file ' + tempfile + '.pro',/INF
    return
 endif else file_delete, tempfile + '.pro'
  
  return
  end         <span class="comments">;pro create_struct</span>


</code>
    </div>
  </body>
</html>