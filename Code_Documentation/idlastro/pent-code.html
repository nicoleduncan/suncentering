<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pent.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pent.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="pent:source"></a> function pent,p,t,x,m,n
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       PENT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return the information entropy of a time series</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This function will return S, the information entropy of a time series</span>
<span class="comments">;       for a set of trial periods </span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       Time series analysis, period finding, astronomical utilities.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       Result = PENT(P, T, X, [N, M ] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       P - array of trial period values.</span>
<span class="comments">;       T - array of observation times (same units as P).</span>
<span class="comments">;       X - array of observations.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       N   - If  four parameters are given then the 4th parameter is assumed</span>
<span class="comments">;               to be N. Then NxN boxes are used to calculate S.</span>
<span class="comments">;       M,N - If five parameters are given then parameter 4 is M and parameter</span>
<span class="comments">;               5 is N. S is then calculated using MxN boxes - M partitions for the</span>
<span class="comments">;               phase and N partitions for the data.</span>
<span class="comments">;       </span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       This function returns S, the information entropy of the time series for</span>
<span class="comments">;       the periods given in P as defined by Cincotta, Me'ndez & Nu'n~ez</span>
<span class="comments">;       (Astrophysical Journal 449, 231-235, 1995). The minima of S occur at</span>
<span class="comments">;       values of P where X shows periodicity.</span>
<span class="comments">;   </span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       The procedure involves dividing the phase space into N^2 partitions </span>
<span class="comments">;       (NxN boxes) and then calculating:</span>
<span class="comments">;       </span>
<span class="comments">;               __ N^2</span>
<span class="comments">;         S = - \        mu_i . ln(mu_i)  for all mu_i &lt;> 0</span>
<span class="comments">;               /_  </span>
<span class="comments">;                 i = 1 </span>
<span class="comments">;</span>
<span class="comments">;       where  mu_i is the number of data points in partition i normalised by </span>
<span class="comments">;       the number of partitions.</span>
<span class="comments">;</span>
<span class="comments">;       The option of using MxN boxes is an additional feature of this routine.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       To generate a similar sythetic data set to Cincotta et al. we</span>
<span class="comments">;        do the following:</span>
<span class="comments">;</span>
<span class="comments">;       IDL> P0 = 173.015                        ; Fundamental period</span>
<span class="comments">;       IDL> T = randomu(seed,400)*15000         ; 400 random observation times</span>
<span class="comments">;       IDL> A0 = 14.0                           ; Mean magnitude</span>
<span class="comments">;       IDL> M0 = -0.5  * sin(2*!pi*T/P0)        ; Fundamental mode</span>
<span class="comments">;       IDL> M1 = -0.15 * sin(4*!pi*T/P0)        ; 1st harmonic</span>
<span class="comments">;       IDL> M2 = -0.05 * sin(6*!pi*T/P0)        ; 2nd harmonic</span>
<span class="comments">;       IDL> sig = randomu(seed,400)*0.03        ; noise</span>
<span class="comments">;       IDL> U = A0 + M0 + M1 + M2 + sig         ; Synthetic data</span>
<span class="comments">;       IDL> Ptest = 100. + findgen(2000)/2.     ; Trial periods </span>
<span class="comments">;       IDL> S = pent(Ptest,T,U)                 ; Calculate S</span>
<span class="comments">;               ... this takes a few seconds ...</span>
<span class="comments">;       IDL> plot,Ptest,S,xtitle="P",ytitle="S"  ; plot S v. P</span>
<span class="comments">;       IDL> print,Ptest(where(S eq min(S)))     ; Print best period (+/- 0.5)</span>
<span class="comments">;</span>
<span class="comments">;       The plot produced should be similar to Fig. 2 of Cincotta et al.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;</span>
<span class="comments">;       My own (limited) experience with this routine suggests that it is not</span>
<span class="comments">;       as good as other techniques for finding  weak,  multi-periodic signals in </span>
<span class="comments">;       poorly sampled  data, but is good for establishing periods of eclipsing</span>
<span class="comments">;       binary stars when M is quite large (try MxN = 64x16, 128x16 or even </span>
<span class="comments">;       256x16).  This suggests it may be good for other periodic light curves </span>
<span class="comments">;       (Cepheids, RR Lyrae etc.).</span>
<span class="comments">;       I would be glad to receive reports of other peoples experience with</span>
<span class="comments">;       this technique (e-mail pflm@bro730.astro.ku.dk).</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by:   Pierre Maxted, 14Sep95</span>
<span class="comments">;       Modifications:</span>
<span class="comments">;       Normalisation of S corrected, T-min(T) taken out of loop.</span>
<span class="comments">;               -  Pierre Maxted, 15Sep95</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>

 on_error,2 <span class="comments">; return to caller</span>

<span class="comments">; Check suitable no. of parameters have been entered.</span>

  case N_params() of 
   3 : begin
        n = 8.0 
        m = 8.0
       end
   4 : begin
        n = float(fix(m)) 
        m = n
       end
   5 : begin
        m = float(fix(m)) 
        n = float(fix(n))
       end
  else : message,/noname,' Syntax - Result = ( P, T, X [ [,M ] ,N ])'
  endcase

  nbox = m*n
  np = n_elements(p)
  npts = n_elements(x)

  if n_elements(t) ne  npts  then message , $
     'Input arrays T and X  must have same number of elements'

  if npts lt 3 then message,' Insufficient data in input arrays'

  npts = float(npts)

  S = fltarr(np)
 
   norm = (X - min(X))/(max(x) - min(x))   <span class="comments">; normalised data</span>
   norm = norm - (norm eq 1.0)*(0.1/n) <span class="comments">; norm = 1 -> norm = 0.99..</span>
   ni = 1 + n*(floor(norm*n))

   Tplus = T-min(T)  <span class="comments">; take this operation out of the loop</span>
 
  for j = 0l,np - 1l do begin
 
   phi = ( Tplus / P[j] ) mod  1.0
 
   mu = histogram(floor(phi*m) + ni,max=nbox,min=0.0)/(npts)
 
   mu = mu[where(mu gt 0.0)]
   S[j] = -total(mu*alog(mu))
   
  endfor
  
  S = S/alog(nbox) <span class="comments">; normalise S</span>

  return,S

end   <span class="comments">; That's all folks</span>


</code>
    </div>
  </body>
</html>