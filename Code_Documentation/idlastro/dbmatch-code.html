<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbmatch.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbmatch.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbmatch:source"></a>function dbmatch, item, values, listin, FULLSTRING = fullstring
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBMATCH</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Find the entry number in a database for each element of item values</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       DBMATCH() is especially useful for finding a one-to-one </span>
<span class="comments">;       correspondence between entries in different databases, and thus to </span>
<span class="comments">;       create the vector needed for database pointers.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       list = DBMATCH( item, values, [ listin, /FULLSTRING ] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       ITEM - Item name or number, scalar</span>
<span class="comments">;       VALUES -  scalar or vector containing item values to search for.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       LISTIN - list of entries to be searched.  If not supplied, or</span>
<span class="comments">;               set to -1, then all entries are searched</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       LIST - vector of entry numbers with the same number of elements as </span>
<span class="comments">;               VALUES.  Contains a value of 0 wherever the corresponding item</span>
<span class="comments">;               value was not found.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       /FULLSTRING - By default, one has a match if a search string is </span>
<span class="comments">;               included in any part of a database value (substring match).   </span>
<span class="comments">;               But if /FULLSTRING is set, then all characters in the database</span>
<span class="comments">;               value must match the search string (excluding leading and </span>
<span class="comments">;               trailing blanks).    Both types of string searches are case</span>
<span class="comments">;               insensitive.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       DBMATCH is meant to be used for items which do not have duplicate values</span>
<span class="comments">;       in a database (e.g. catalog numbers).  If more than one entry is found</span>
<span class="comments">;       for a particular item value, then only the first one is stored in LIST.</span>
<span class="comments">;</span>
<span class="comments">;       When linked databases are opened together, DBMATCH can only be </span>
<span class="comments">;       used to search on items in the primary database.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Make a vector which points from entries in the Yale Bright Star catalog</span>
<span class="comments">;       to those in the Hipparcos catalog, using the HD number</span>
<span class="comments">;</span>
<span class="comments">;       IDL> dbopen, 'yale_bs'            ;Open the Yale Bright star catalog</span>
<span class="comments">;       IDL> dbext, -1, 'HD', hd          ;Get the HD numbers</span>
<span class="comments">;       IDL> dbopen, 'hipparcos'          ;Open the Hipparcos catalog</span>
<span class="comments">;       IDL> list = dbmatch( 'HD', HD)    ;Get entries in Hipparcos catalog </span>
<span class="comments">;                                         ;corresponding to each HD number.</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       DB_ITEM, DB_ITEM_INFO(), DBEXT, DBFIND_SORT()</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written,    W. Landsman      STX     February, 1990</span>
<span class="comments">;       Fixed error when list in parameter used May, 1992</span>
<span class="comments">;       Faster algorithm with sorted item when listin parameter supplied </span>
<span class="comments">;       Added keyword FULLSTRING,check for empty database, William Thompson, </span>
<span class="comments">;               GSFC, 15 March 1995</span>
<span class="comments">;       Work for more than 32767 values, added CATCH W. Landsman   July 1997</span>
<span class="comments">;       Change some loop variables to type LONG,  W. Landsman  July 1999</span>
<span class="comments">;       Remove loop for substring searches (faster)  W. landsman August 1999</span>
<span class="comments">;       Replace DATATYPE() with size(/TNAME)  W. Landsman  November 2001</span>
<span class="comments">;       Fixed typo when search on sorted items W. Landsman February 2002</span>
<span class="comments">;       Fixed bug from Nov 2001 where /FULLSTRING was always set.  W.L Feb 2007</span>
<span class="comments">;-</span>
 On_error,2

 if N_params() LT 2 then begin
     print,'Syntax --  list = DBMATCH( item, values, [ listin, /FULLSTRING] )'
     return,-1
 endif 


 catch, error_status
 if error_status NE 0 then begin 
        print,!ERR_STRING
        if N_elements(listin) NE 0 then return,listin else return, -1
 endif

 nvals = N_elements( values )
 if nvals EQ 0 then message, $ 
       'ERROR - No search values (second parameter) supplied'

 if N_params() LT 3 then listin = lonarr(1) - 1

 db_item,item,itnum
 index = db_item_info( 'INDEX', itnum)           <span class="comments">;Get index type of item</span>
 list = lonarr( nvals )

 nentries = db_info('entries')
 if nentries[0] eq 0 then begin                 <span class="comments">;Return if database is empty</span>
        message,'ERROR - No entries in database ' + db_info("NAME",0),/INF
        return,listin*0
 endif 

 if index[0] GE 2 then begin                      <span class="comments">;Sorted item</span>

    if listin[0] NE -1 then min_listin = min( listin, MAX = max_listin)

    for i = 0l,nvals-1 do begin

        val = [values[i],values[i]]

<span class="comments">;       We don't supply the LISTIN parameter directly to DBFIND_SORT.  Since</span>
<span class="comments">;       we know that we need only 1 match for each item value, we can do</span>
<span class="comments">;       the restriction to the LISTIN values faster than DBFIND_SORT can</span>

        tmplist = -1
        dbfind_sort,itnum[0],1,val, tmplist, $    <span class="comments">;Search all entries to start</span>
                fullstring=fullstring, Count = Nmatch_sort
 
           if ( listin[0] NE -1 ) then begin

                if Nmatch_sort EQ 0 then goto, FOUND_MATCH

                good = where( ( tmplist LE max_listin ) and $ 
                              ( tmplist GE min_listin ), Ngood)

                if ( Ngood EQ 0 ) then goto, FOUND_MATCH

                tmplist = tmplist[good]

                for j = 0L, Ngood - 1  do begin
                   test = where( listin EQ tmplist[j], Nfound ) 
                   if Nfound GE 1 then begin
                         list[i] = tmplist[j]
                         goto, FOUND_MATCH
                   endif
                endfor 

         endif else if ( Nmatch_sort GT 0 ) then list[i] = tmplist[0]
 
        FOUND_MATCH:
   endfor

  endif else begin                                 <span class="comments">;Non-sorted item</span>

    if listin[0] EQ -1 then tmplist = lindgen( nentries[0] )+1 else $
                            tmplist = listin
    dbext, tmplist, itnum, itvals
    typ = size(itvals,/TNAME)
    if typ EQ 'STRING' then begin
                itvals = strupcase( strtrim(itvals,2) )
                vals   = strupcase( strtrim(values,2) )
    endif else vals = values
    for i=0L,nvals-1 do begin             
       if typ NE 'STRING' then begin                  <span class="comments">;Fixed Feb 2007</span>
               good = where( itvals EQ vals[i], Nfound ) 
               if Nfound GT 0 then list[i] = tmplist[ good[0] ]  <span class="comments">;Fixed May-92</span>

        endif else begin                 <span class="comments">;Can't use WHERE on string arrays</span>
                                         <span class="comments">;unless FULLSTRING is set</span>

               if keyword_set(fullstring) then begin
                   good = where( itvals EQ vals[i], Nfound)
                   if Nfound GT 0 then list[i] = tmplist[ good[0] ]
                end else begin
                      good = where(strpos( itvals, vals[i]) GE 0, Nfound) 
                      if Nfound GT 0 then begin
                             list[i] = tmplist[good[0]]
                             goto, DONE
                       endif
                    
                endelse
             endelse
    DONE:       
    endfor
endelse

return,list

end
</code>
    </div>
  </body>
</html>