<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:59 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>rdfloat.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="rdfloat.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="rdfloat:source"></a>pro rdfloat,name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17, $
            v18,v19,SKIPLINE = skipline, NUMLINE = numline,DOUBLE=double, $
            SILENT = silent, COLUMNS = columns
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      RDFLOAT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Quickly read a numeric ASCII data file into IDL floating/double vectors.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;      Columns of data may be separated by tabs or spaces.      This </span>
<span class="comments">;      program is fast but is restricted to data files where all columns can </span>
<span class="comments">;      be read as floating point (or all double precision).   </span>
<span class="comments">;</span>
<span class="comments">;      Use READCOL if  greater flexibility is desired.   Use READFMT to read a </span>
<span class="comments">;      fixed-format ASCII file.   Use FORPRINT to print columns of data.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      RDFLOAT, name, v1, [ v2, v3, v4, v5, ...  v19] </span>
<span class="comments">;                         COLUMNS, /DOUBLE, SKIPLINE = , NUMLINE = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      NAME - Name of ASCII data file, scalar string.  In VMS, an extension of </span>
<span class="comments">;              .DAT is assumed, if not supplied.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;      COLUMNS - Numeric scalar or vector specifying which columns in the file</span>
<span class="comments">;               to read.    For example, if COLUMNS = [3,7,11] then the first</span>
<span class="comments">;               output variable (v1) would contain column 3, the second would</span>
<span class="comments">;               contain column 7 and the third would contain column 11.   If</span>
<span class="comments">;               the number of elements in the COLUMNS vector is less than the</span>
<span class="comments">;               number of output parameters, then consecutive columns are </span>
<span class="comments">;               implied.    For example, if 3 output parameters are supplied</span>
<span class="comments">;               (v1,v2,v3) and COLUMNS = 3, then columns 3,4, and 5 will be</span>
<span class="comments">;               read.   </span>
<span class="comments">;      SKIPLINE - Integer scalar specifying number of lines to skip at the top</span>
<span class="comments">;              of file before reading.   Default is to start at the first line.</span>
<span class="comments">;      NUMLINE - Integer scalar specifying number of lines in the file to read.  </span>
<span class="comments">;             Default is to read the entire file</span>
<span class="comments">;      /DOUBLE - If this keyword is set, then all variables are read in as</span>
<span class="comments">;              double precision.</span>
<span class="comments">;      /SILENT - Set this keyword to suppress any informative messages</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;      V1,V2,V3,...V19 - IDL vectors to contain columns of data.</span>
<span class="comments">;               Up to 19 columns may be read.  All output vectors are of type</span>
<span class="comments">;               float, unless the /DOUBLE keyword is set, </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;      Each row in a file 'position.dat' contains a star number and 6 columns</span>
<span class="comments">;      of data giving an RA and Dec in sexagesimal format.   Read into IDL </span>
<span class="comments">;      variables.     </span>
<span class="comments">;</span>
<span class="comments">;       IDL> rdfloat,'position.dat',ID,hr,min,sec,deg,dmin,dsec  </span>
<span class="comments">;</span>
<span class="comments">;       All output vectors will be floating point.    To only read the </span>
<span class="comments">;       declination vectors (Deg,dmin,dsec)</span>
<span class="comments">;</span>
<span class="comments">;       IDL> rdfloat,'position.dat',deg,dmin,dsec,col=4</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;      (1) All rows in the file must be formatted identically (except for </span>
<span class="comments">;          those skipped by SKIPLINE).    RDFLOAT reads the first line of </span>
<span class="comments">;          the data (after SKIPLINE) to determine the number of columns of </span>
<span class="comments">;          data.</span>
<span class="comments">;      (2) Cannot be used to read strings</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;      None.</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;      Written         W. Landsman                 September 1995</span>
<span class="comments">;      Call NUMLINES() function                    February 1996</span>
<span class="comments">;      Read up to 19 columns                       August 1997</span>
<span class="comments">;      Converted to IDL V5.0   W. Landsman         September 1997</span>
<span class="comments">;      Allow to skip more than 32767 lines  W. Landsman  June 2001</span>
<span class="comments">;      Added /SILENT keyword   W. Landsman         March 2002</span>
<span class="comments">;      Added COLUMNS keyword, use STRSPLIT    W. Landsman May 2002</span>
<span class="comments">;      Use SKIP_LUN if V5.6 or later          W. Landsman Nov 2002</span>
<span class="comments">;      V5.6 version, use FILE_LINES()         W. Landsman Dec 2002</span>
<span class="comments">;-</span>
  On_error,2                           <span class="comments">;Return to caller</span>

  if N_params() lt 2 then begin
     print,'Syntax - RDFLOAT, name, v1, [ v2, v3,...v19 '
     print,'                    COLUMNS = ,/DOUBLE, SKIPLINE =, NUMLINE = ]'
     return
  endif

<span class="comments">; Get number of lines in file</span>

   nlines = FILE_LINES( name )
   if nlines LE 0 then begin
        message,'ERROR - File ' + name+' contains no data',/CON
	return
   endif     

 
   if ~keyword_set( SKIPLINE ) then skipline = 0
   nlines = nlines - skipline
   if keyword_set( NUMLINE) then nlines = numline &lt<span class="comments">; nlines</span>

<span class="comments">;Read first line, and determine number of columns of data</span>

   openr, lun, name, /GET_LUN
   temp = ''
   if skipline GT 0 then $
        skip_lun, lun, skipline, /lines
   readf,lun,temp
   
   
   colval = strsplit(temp, count=ncol)         <span class="comments">;Determine number of columns</span>
 
<span class="comments">;Create big output array and read entire file into the array</span>

   bigarr = keyword_set(DOUBLE) ? dblarr(ncol, nlines, /NOZERO):  $
                                  fltarr(ncol, nlines, /NOZERO) 

   close,lun
   openr, lun, name
   if skipline GT 0 then skip_lun, lun, skipline, /lines 

   readf, lun, bigarr
   free_lun, lun

   if ~keyword_set(SILENT) then $
       message, strtrim(nlines,2) + ' lines of data read',/INF

   Nvector = (N_params()-1) &lt<span class="comments">; ncol</span>
   if N_elements(columns) EQ 0 then c = indgen(nvector) else c = columns - 1
   Nc = N_elements(c)
   if Nc LT nvector then c = [c,indgen(nvector-nc) + c[nc-1] +1 ] 
   v1 = reform( bigarr[c[0],*])
 
   if Nvector GT 1 then v2 = reform( bigarr[c[1],*]) else return
   if Nvector GT 2 then v3 = reform( bigarr[c[2],*]) else return
   if Nvector GT 3 then v4 = reform( bigarr[c[3],*]) else return
   if Nvector GT 4 then v5 = reform( bigarr[c[4],*]) else return
   if Nvector GT 5 then v6 = reform( bigarr[c[5],*]) else return
   if Nvector GT 6 then v7 = reform( bigarr[c[6],*]) else return
   if Nvector GT 7 then v8 = reform( bigarr[c[7],*]) else return
   if Nvector GT 8 then v9 = reform( bigarr[c[8],*]) else return
   if Nvector GT 9 then v10 = reform( bigarr[c[9],*]) else return
   if Nvector GT 10 then v11 = reform( bigarr[c[10],*]) else return
   if Nvector GT 11 then v12 = reform( bigarr[c[11],*]) else return
   if Nvector GT 12 then v13 = reform( bigarr[c[12],*]) else return
   if Nvector GT 13 then v14 = reform( bigarr[c[13],*]) else return
   if Nvector GT 14 then v15 = reform( bigarr[c[14],*]) else return
   if Nvector GT 15 then v16 = reform( bigarr[c[15],*]) else return
   if Nvector GT 16 then v17 = reform( bigarr[c[16],*]) else return
   if Nvector GT 17 then v18 = reform( bigarr[c[17],*]) else return
   if Nvector GT 18 then v19 = reform( bigarr[c[18],*]) 

  return
  end
</code>
    </div>
  </body>
</html>