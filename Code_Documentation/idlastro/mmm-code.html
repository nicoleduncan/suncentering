<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mmm.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mmm.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="mmm:source"></a>pro mmm, sky_vector, skymod, sigma , skew, HIGHBAD = highbad, DEBUG = debug, $
           ReadNoise = readnoise, Nsky = nsky, INTEGER = discrete, $
	   MAXITER = mxiter, SILENT = silent, MINSKY = minsky
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MMM</span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;       Estimate the sky background in a stellar contaminated field.</span>
<span class="comments">; EXPLANATION:  </span>
<span class="comments">;       MMM assumes that contaminated sky pixel values overwhelmingly display </span>
<span class="comments">;       POSITIVE departures from the true value.  Adapted from DAOPHOT </span>
<span class="comments">;       routine of the same name.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       MMM, sky, [ skymod, sigma, skew, HIGHBAD = , READNOISE=, /DEBUG, </span>
<span class="comments">;                  NSKY=, /INTEGER,/SILENT]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       SKY - Array or Vector containing sky values.  This version of</span>
<span class="comments">;               MMM does not require SKY to be sorted beforehand.  SKY</span>
<span class="comments">;               is unaltered by this program.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;       skymod - Scalar giving estimated mode of the sky values</span>
<span class="comments">;       SIGMA -  Scalar giving standard deviation of the peak in the sky</span>
<span class="comments">;               histogram.  If for some reason it is impossible to derive</span>
<span class="comments">;               skymod, then SIGMA = -1.0</span>
<span class="comments">;       SKEW -   Scalar giving skewness of the peak in the sky histogram</span>
<span class="comments">;</span>
<span class="comments">;               If no output variables are supplied or if /DEBUG is set</span>
<span class="comments">;               then the values of skymod, SIGMA and SKEW will be printed.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;       HIGHBAD - scalar value of the (lowest) "bad" pixel level (e.g. cosmic </span>
<span class="comments">;                rays or saturated pixels) If not supplied, then there is </span>
<span class="comments">;                assumed to be no high bad pixels.</span>
<span class="comments">;       MINSKY - Integer giving mininum number of sky values to be used.   MMM</span>
<span class="comments">;                will return an error if fewer sky elements are supplied.</span>
<span class="comments">;                Default = 20.</span>
<span class="comments">;       MAXITER - integer giving maximum number of iterations allowed,default=50</span>
<span class="comments">;       READNOISE - Scalar giving the read noise (or minimum noise for any </span>
<span class="comments">;                pixel).     Normally, MMM determines the (robust) median by </span>
<span class="comments">;                averaging the central 20% of the sky values.     In some cases</span>
<span class="comments">;                where the noise is low, and pixel values are quantized a</span>
<span class="comments">;                larger fraction may be needed.    By supplying the optional</span>
<span class="comments">;                read noise parameter, MMM is better able to adjust the</span>
<span class="comments">;                fraction of pixels used to determine the median.                </span>
<span class="comments">;       /INTEGER - Set this keyword if the  input SKY vector only contains</span>
<span class="comments">;                discrete integer values.    This keyword is only needed if the</span>
<span class="comments">;                SKY vector is of type float or double precision, but contains </span>
<span class="comments">;                only discrete integer values.     (Prior to July 2004, the</span>
<span class="comments">;                equivalent of /INTEGER was set for all data types)</span>
<span class="comments">;       /DEBUG - If this keyword is set and non-zero, then additional </span>
<span class="comments">;               information is displayed at the terminal.</span>
<span class="comments">;       /SILENT - If set, then error messages will be suppressed when MMM</span>
<span class="comments">;                cannot compute a background.    Sigma will still be set to -1</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;      NSKY - Integer scalar giving the number of pixels actually used for the</span>
<span class="comments">;             sky computation (after outliers have been removed).</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       (1) Program assumes that low "bad" pixels (e.g. bad CCD columns) have</span>
<span class="comments">;       already been deleted from the SKY vector.</span>
<span class="comments">;       (2) MMM was updated in June 2004 to better match more recent versions</span>
<span class="comments">;       of DAOPHOT.</span>
<span class="comments">;       (3) Does not work well in the limit of low Poisson integer counts</span>
<span class="comments">;       (4) MMM may fail for strongly skewed distributions.</span>
<span class="comments">; METHOD:</span>
<span class="comments">;       The algorithm used by MMM consists of roughly two parts:</span>
<span class="comments">;       (1) The average and sigma of the sky pixels is computed.   These values</span>
<span class="comments">;       are used to eliminate outliers, i.e. values with a low probability</span>
<span class="comments">;       given a Gaussian with specified average and sigma.   The average</span>
<span class="comments">;       and sigma are then recomputed and the process repeated up to 20</span>
<span class="comments">;       iterations:</span>
<span class="comments">;       (2) The amount of contamination by stars is estimated by comparing the </span>
<span class="comments">;       mean and median of the remaining sky pixels.   If the mean is larger</span>
<span class="comments">;       than the median then the true sky value is estimated by</span>
<span class="comments">;       3*median - 2*mean</span>
<span class="comments">;         </span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Adapted to IDL from 1986 version of DAOPHOT in STSDAS, </span>
<span class="comments">;       W. Landsman, STX Feb 1987</span>
<span class="comments">;       Added HIGHBAD keyword, W. Landsman January, 1991</span>
<span class="comments">;       Fixed occasional problem with integer inputs    W. Landsman  Feb, 1994</span>
<span class="comments">;       Avoid possible 16 bit integer overflow   W. Landsman  November 2001</span>
<span class="comments">;       Added READNOISE, NSKY keywords,  new median computation   </span>
<span class="comments">;                          W. Landsman   June 2004</span>
<span class="comments">;       Added INTEGER keyword W. Landsman July 2004</span>
<span class="comments">;       Improve numerical precision  W. Landsman  October 2004</span>
<span class="comments">;       Fewer aborts on strange input sky histograms W. Landsman October 2005</span>
<span class="comments">;       Added /SILENT keyword  November 2005</span>
<span class="comments">;       Fix too many /CON keywords to MESSAGE  W.L. December 2005</span>
<span class="comments">;       Fix bug introduced June 2004 removing outliers when READNOISE not set</span>
<span class="comments">;         N. Cunningham/W. Landsman  January 2006</span>
<span class="comments">;       Make sure that MESSAGE never aborts  W. Landsman   January 2008</span>
<span class="comments">;       Add mxiter keyword and change default to 50  W. Landsman August 2011</span>
<span class="comments">;       Added MINSKY keyword W.L. December 2011</span>
<span class="comments">;-</span>
 compile_opt idl2
 On_error,2               <span class="comments">;Return to caller</span>
 if N_params() EQ 0 then begin          
        print,'Syntax:  MMM, sky, skymod, sigma, skew, [/INTEGER, /SILENT' 
        print,'              [HIGHBAD = , READNOISE =, /DEBUG, MXITER=, NSKY=] '
        return
 endif

 silent = keyword_set(SILENT)
              <span class="comments">;Maximum number of iterations allowed</span>
 if N_elements(mxiter) EQ 0 then mxiter = 50
 if N_elements(minsky) Eq 0 then minsky = 20   <span class="comments">;Minimum number of legal sky elements</span>
 nsky = N_elements( sky_vector )            <span class="comments">;Get number of sky elements </span>
 
  if nsky LT minsky then begin
      sigma=-1.0 &  skew = 0.0
      message,/CON, NoPrint= Silent, $
    'ERROR -Input vector must contain at least '+strtrim(minsky,2)+' elements'
      return
 endif
 
 nlast = nsky-1                        <span class="comments">;Subscript of last pixel in SKY array</span>
 if keyword_set(DEBUG) then $
     message,'Processing '+strtrim(nsky,2) + ' element array',/INF
 sz_sky = size(sky_vector,/structure)
 integer = keyword_set(discrete)
 if ~integer then integer = (sz_sky.type LT 4) or (sz_sky.type GT 11) 
 sky = sky_vector[ sort( sky_vector ) ]    <span class="comments">;Sort SKY in ascending values</span>

 skymid = 0.5*sky[(nsky-1)/2] + 0.5*sky[nsky/2] <span class="comments">;Median value of all sky values  </span>
       
 cut1 = min( [skymid-sky[0],sky[nsky-1] - skymid] ) 
 if N_elements(highbad) EQ 1 then cut1 = cut1 &lt<span class="comments">; (highbad - skymid)</span>
 cut2 = skymid + cut1
 cut1 = skymid - cut1
         
<span class="comments">; Select the pixels between Cut1 and Cut2</span>

 good = where( (sky LE cut2) and (sky GE cut1), Ngood ) 
 if ( Ngood EQ 0 ) then begin
      sigma=-1.0 &  skew = 0.0   
      message,/CON, NoPrint=Silent, $ 
           'ERROR - No sky values fall within ' + strtrim(cut1,2) + $
	   ' and ' + strtrim(cut2,2)           
      return
   endif
  
 delta = sky[good] - skymid  <span class="comments">;Subtract median to improve arithmetic accuracy</span>
 sum = total(delta,/double)                     
 sumsq = total(delta^2,/double)

 maximm = max( good,MIN=minimm )  <span class="comments">;Highest value accepted at upper end of vector</span>
 minimm = minimm -1               <span class="comments">;Highest value reject at lower end of vector</span>

<span class="comments">; Compute mean and sigma (from the first pass).</span>

 skymed = 0.5*sky[(minimm+maximm+1)/2] + 0.5*sky[(minimm+maximm)/2 + 1] <span class="comments">;median </span>
 skymn = sum/(maximm-minimm)                            <span class="comments">;mean       </span>
 sigma = sqrt(sumsq/(maximm-minimm)-skymn^2)             <span class="comments">;sigma          </span>
 skymn = skymn + skymid         <span class="comments">;Add median which was subtracted off earlier </span>


<span class="comments">;    If mean is less than the mode, then the contamination is slight, and the</span>
<span class="comments">;    mean value is what we really want.</span>
skymod =  (skymed LT skymn) ? 3.*skymed - 2.*skymn : skymn

<span class="comments">; Rejection and recomputation loop:</span>

 niter = 0
 clamp = 1
 old = 0                            
START_LOOP:
   niter = niter + 1                     
   if ( niter GT mxiter ) then begin
      sigma=-1.0 &  skew = 0.0   
      message,/CON, NoPrint=Silent, $ 
           'ERROR - Too many ('+strtrim(mxiter,2) + ') iterations,' + $
           ' unable to compute sky'
      return
   endif

   if ( maximm-minimm LT minsky ) then begin    <span class="comments">;Error? </span>

      sigma = -1.0 &  skew = 0.0   
      message,/CON,NoPrint=Silent, $
            'ERROR - Too few ('+strtrim(maximm-minimm,2) +  $
           ') valid sky elements, unable to compute sky'
      return
   endif 

<span class="comments">; Compute Chauvenet rejection criterion.</span>

    r = alog10( float( maximm-minimm ) )      
    r = max( [ 2., ( -0.1042*r + 1.1695)*r + 0.8895 ] )

<span class="comments">; Compute rejection limits (symmetric about the current mode).</span>

    cut = r*sigma + 0.5*abs(skymn-skymod)   
    if integer then cut = cut > 1.5 
    cut1 = skymod - cut   &    cut2 = skymod + cut
<span class="comments">; </span>
<span class="comments">; Recompute mean and sigma by adding and/or subtracting sky values</span>
<span class="comments">; at both ends of the interval of acceptable values.</span>
      
    redo = 0B
    newmin = minimm             
    tst_min = sky[newmin+1] GE cut1      <span class="comments">;Is minimm+1 above current CUT?</span>
    done = (newmin EQ -1) and tst_min    <span class="comments">;Are we at first pixel of SKY?</span>
    if ~done then  $
        done =  (sky[newmin>0] LT cut1) and tst_min
    if ~done then begin
        istep = 1 - 2*fix(tst_min)
        repeat begin
                newmin = newmin + istep
                done = (newmin EQ -1) || (newmin EQ nlast)
                if ~done then $
                    done = (sky[newmin] LE cut1) and (sky[newmin+1] GE cut1)
        endrep until done
        if tst_min then delta = sky[newmin+1:minimm] - skymid $
                   else delta = sky[minimm+1:newmin] - skymid
        sum = sum - istep*total(delta,/double)
        sumsq = sumsq - istep*total(delta^2,/double)
        redo = 1b
        minimm = newmin
     endif
<span class="comments">;       </span>
   newmax = maximm
   tst_max = sky[maximm] LE cut2           <span class="comments">;Is current maximum below upper cut?</span>
   done = (maximm EQ nlast) and tst_max    <span class="comments">;Are we at last pixel of SKY array?</span>
   if ~done then $   
       done = ( tst_max ) && (sky[(maximm+1)&lt<span class="comments">;nlast] GT cut2) </span>
    if ~done then begin                 <span class="comments">;Keep incrementing NEWMAX</span>
       istep = -1 + 2*fix(tst_max)         <span class="comments">;Increment up or down?</span>
       Repeat begin
          newmax = newmax + istep
          done = (newmax EQ nlast) or (newmax EQ -1)
          if ~done then $
                done = ( sky[newmax] LE cut2 ) and ( sky[newmax+1] GE cut2 )
       endrep until done
       if tst_max then delta = sky[maximm+1:newmax] - skymid $
               else delta = sky[newmax+1:maximm] - skymid
       sum = sum + istep*total(delta,/double)
       sumsq = sumsq + istep*total(delta^2,/double)
       redo = 1b
       maximm = newmax
    endif
<span class="comments">;       </span>
<span class="comments">; Compute mean and sigma (from this pass).</span>
<span class="comments">;</span>
   nsky = maximm - minimm
   if ( nsky LT minsky ) then begin    <span class="comments">;Error? </span>
       sigma = -1.0 &  skew = 0.0   
       message,NoPrint=Silent, /CON, $ 
               'ERROR - Outlier rejection left too few sky elements'
       return		 		 
   endif 

   skymn = sum/nsky       
   sigma = float( sqrt( (sumsq/nsky - skymn^2)>0 ))
    skymn = skymn + skymid 
                

<span class="comments">;  Determine a more robust median by averaging the central 20% of pixels.</span>
<span class="comments">;  Estimate the median using the mean of the central 20 percent of sky</span>
<span class="comments">;  values.   Be careful to include a perfectly symmetric sample of pixels about</span>
<span class="comments">;  the median, whether the total number is even or odd within the acceptance</span>
<span class="comments">;  interval</span>
    
        center = (minimm + 1 + maximm)/2.
        side = round(0.2*(maximm-minimm))/2.  + 0.25
        J = round(CENTER-SIDE)
        K = round(CENTER+SIDE)

<span class="comments">;  In case  the data has a large number of of the same (quantized) </span>
<span class="comments">;  intensity, expand the range until both limiting values differ from the </span>
<span class="comments">;  central value by at least 0.25 times the read noise.</span>

        if keyword_set(readnoise) then begin        
          L = round(CENTER-0.25)
          M = round(CENTER+0.25)
          R = 0.25*readnoise
          while ((J GT 0) && (K LT Nsky-1) && $
            ( ((sky[L] - sky[J]) LT R) || ((sky[K] - sky[M]) LT R))) do begin
             J--
             K++
        endwhile
        endif 
   skymed = total(sky[j:k])/(k-j+1)
   
<span class="comments">;  If the mean is less than the median, then the problem of contamination</span>
<span class="comments">;  is slight, and the mean is what we really want.</span>

   dmod = skymed LT skymn ?  3.*skymed-2.*skymn-skymod : skymn - skymod

<span class="comments">; prevent oscillations by clamping down if sky adjustments are changing sign</span>
   if dmod*old LT 0 then clamp = 0.5*clamp
   skymod = skymod + clamp*dmod 
   old = dmod     
   if redo then goto, START_LOOP

<span class="comments">;       </span>
 skew = float( (skymn-skymod)/max([1.,sigma]) )
 nsky = maximm - minimm 

 if keyword_set(DEBUG) or ( N_params() EQ 1 ) then begin
        print, '% MMM: Number of unrejected sky elements: ', strtrim(nsky,2), $
              '    Number of iterations: ',  strtrim(niter,2)
        print, '% MMM: Mode, Sigma, Skew of sky vector:', skymod, sigma, skew   
 endif

 return
 end
</code>
    </div>
  </body>
</html>