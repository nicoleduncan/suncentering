<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:56 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>polyleg.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="polyleg.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="polyleg:source"></a>function polyleg,x,coeff
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       POLYLEG</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Evaluate a Legendre polynomial with specified coefficients.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Meant to be used analogously to the POLY function in the IDL User's</span>
<span class="comments">;       Library distribution.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       Result = POLYLEG( X, C )        </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       X - input variable, scalar or vector    </span>
<span class="comments">;       C - vector of Legendre polynomial coefficients. </span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       POLYLEG returns a result equal to:</span>
<span class="comments">;               C[0] + C[1]*P_1(x) + C[2]*P_2(x) + ...</span>
<span class="comments">;</span>
<span class="comments">;       where P_j(x) is the jth Legendre polynomial.   The output will have</span>
<span class="comments">;       the same dimensions as the input X variable.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       If x = [0.5, 1.0] and C = [2.4, 1.3, 2.5] then</span>
<span class="comments">;       print, polyleg(x, c)    ====> [2.7375, 6.20]</span>
<span class="comments">;</span>
<span class="comments">;       The result can be checked using the first 3 Legendre polynomial terms</span>
<span class="comments">;       C[0] + C[1]*x + C[2]*(0.5*(3*x^2-1))</span>
<span class="comments">; METHOD:</span>
<span class="comments">;       Uses the recurrence relation of Legendre polynomials</span>
<span class="comments">;               (n+1)*P_n+1(x) = (2n+1)*x*P_n(x) - n*P_n-1(x)</span>
<span class="comments">;       evaluated with the Clenshaw recurrence formula, see Numerical Recipes</span>
<span class="comments">;       by Press et al. (1992), Section 5.5</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written W. Landsman   Hughes STX Co.        April, 1995    </span>
<span class="comments">;       Fixed for double precision  W. Landsman     May, 1997</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
 On_error,2
 
 if N_params() LT 2 then begin
        print,'Syntax - result = POLYLEG( X, Coeff)'
        return, -1
 endif

 N= N_elements(coeff) -1
 M = N_elements(x)

 case N of 
 0: return, replicate( coeff, M)
 1: return, x* coeff[1] + coeff[0]
 else:
 endcase

<span class="comments">; If X is double then compute in double; otherwise compute in real</span>

 if size(x,/TNAME) EQ 'DOUBLE'  then begin      
        y = dblarr( M, N+2)
        jj = dindgen(N) + 2.0d
 endif else begin
        y = fltarr( M, N+2 )
        jj = findgen(N) + 2.
 endelse

 beta1 =  -jj / (jj+1)
 for j = N,1,-1 do begin

        alpha = (2*j + 1.)*x/float(j + 1.) 
        y[0,j-1] = alpha*y[*,j] + beta1[j-1]*y[*,j+1] + coeff[j]
 endfor

 return, -0.5*y[*,1] + x*y[*,0] + coeff[0]
 end
</code>
    </div>
  </body>
</html>