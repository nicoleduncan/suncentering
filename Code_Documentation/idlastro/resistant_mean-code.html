<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>resistant_mean.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="resistant_mean.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO RESISTANT_Mean,Y,CUT,Mean,Sigma,Num_Rej,goodvec = goodvec, $
                  dimension=dimension, double=double,sumdim=sumdim, wused=wused
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    RESISTANT_Mean  </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Outlier-resistant determination of the mean and standard deviation. </span>
<span class="comments">; </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;    RESISTANT_Mean trims away outliers using the median and the median </span>
<span class="comments">;    absolute deviation.    An approximation formula is used to correct for</span>
<span class="comments">;    the truncation caused by trimming away outliers</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    RESISTANT_Mean, ARRAY, Sigma_CUT, Mean, Sigma_Mean, Num_RejECTED</span>
<span class="comments">;                         [/DOUBLE, DIMENSION= , GOODVEC = ]</span>
<span class="comments">; INPUT ARGUMENT:</span>
<span class="comments">;       ARRAY    = Vector or array to average</span>
<span class="comments">;       Sigma_CUT = Data more than this number of standard deviations from the</span>
<span class="comments">;               median is ignored. Suggested values: 2.0 and up.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT ARGUMENT:</span>
<span class="comments">;       Mean  = the mean of the input array, numeric scalar,    If the </span>
<span class="comments">;            DIMENSION keyword is set, then MEAN will be an array with one</span>
<span class="comments">;            less dimension than the input.</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;	Sigma_Mean = the approximate standard deviation of the mean, numeric </span>
<span class="comments">;            scalar.  This is the Sigma of the distribution divided by sqrt(N-1)</span>
<span class="comments">;            where N is the number of unrejected points. The larger</span>
<span class="comments">;            SIGMA_CUT, the more accurate. It will tend to underestimate the </span>
<span class="comments">;            true uncertainty of the mean, and this may become significant for </span>
<span class="comments">;            cuts of 2.0 or less. </span>
<span class="comments">;       Num_RejECTED = the number of points trimmed, integer scalar</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;      /DOUBLE - If set, then all calculations are performed internally </span>
<span class="comments">;            in double precision.  </span>
<span class="comments">;      DIMENSION - for a multi-dimensional array, the dimension over which to</span>
<span class="comments">;            take the mean, starting at 1. If not set, then the scalar mean</span>
<span class="comments">;            over all elements is used. If this argument is present, the result</span>
<span class="comments">;            is an array with one less dimension than Array. For example, if </span>
<span class="comments">;            the dimensions of Array are N1, N2, N3, and Dimension is 2, then </span>
<span class="comments">;            the dimensions of the result are (N1, N3)    </span>
<span class="comments">;      SUMDIM - Obsolete synonym for DIMENSION</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       Goodvec -  Indices of non-trimmed elements of the input vector</span>
<span class="comments">;       Wused - synonym for Goodvec (for solarsoft compatibility)</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       IDL> a = randomn(seed, 10000)    ;Normal distribution with 10000 pts</span>
<span class="comments">;       IDL> RESISTANT_Mean,a, 3, mean, meansig, num    ;3 Sigma clipping    </span>
<span class="comments">;       IDL> print, mean, meansig,num</span>
<span class="comments">; </span>
<span class="comments">;       The mean should be near 0, and meansig should be near 0.01 ( =</span>
<span class="comments">;        1/sqrt(10000) ).     </span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       MEAN() - compute simple mean, in Exelis library</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written, H. Freudenreich, STX, 1989; Second iteration added 5/91.</span>
<span class="comments">;       Use MEDIAN(/EVEN)    W. Landsman   April 2002</span>
<span class="comments">;       Correct conditional test, higher order truncation correction formula</span>
<span class="comments">;                R. Arendt/W. Landsman   June 2002</span>
<span class="comments">;       New truncation formula for sigma H. Freudenriech  July 2002</span>
<span class="comments">;       Divide Sigma_mean by Num_good rather than Npts W. Landsman/A. Conley</span>
<span class="comments">;                          January 2006</span>
<span class="comments">;       Use of double precision S. Bianchi February 2008</span>
<span class="comments">;       More double precision B. Carcich December 2009</span>
<span class="comments">;       Added DIMENSION keyword (from M. Desnoyer) B. Carcich December 2009</span>
<span class="comments">;       Use IDL's MEAN() function instead of AVG() W. Landsman Jan 2012</span>
<span class="comments">;       Use of Dimension keyword yielded transpose of correct value</span>
<span class="comments">;                     W. Landsman  July 2012</span>
<span class="comments">;-</span>

 On_Error,2
 compile_opt idl2
 if N_params() LT 3 then begin
     print,'Syntax - Resistant_Mean, Vector, Sigma_cut, Mean, [ Sigma_mean, ' 
     print,'                                  Num_Rejected,  GOODVEC=,'
     print,'                                  DIMEN=, /DOUBLE]'
     return
 endif

 sz = size(Y)
 indouble = size(Y,/tname) EQ 'DOUBLE'          <span class="comments">;Is input double precision?</span>
 
<span class="comments">; Average over a single dimension?</span>
   if N_elements(DIMENSION)  then DIM = long(DIMENSION[0]) $
   else if n_elements(SUMDIM) then DIM = long(SUMDIM[0]) 
 if (sz[0] gt 1L) && (sz[0] lt 5L) && (N_elements(DIM) EQ 1) then begin
   if (DIM lt 1L) || (dim gt sz[0]) then begin
     message,/continue, 'Invalid dimension number'
     print,'Syntax - Resistant_Mean, Vector, Sigma_cut, Mean'
     print,'        , [ Sigma_mean, Num_Rejected, Dimension={1|2} ]'
     return
   endif
   <span class="comments">;;;</span>
   od=[ sz[0:dim-1], sz[dim+1:sz[0]+1] ]  <span class="comments">;;; [buffer, i,j,k,m, buffer]</span>
   od=[ od[1:sz[0]-1], 1, 1, 1]         <span class="comments">;;; [i,j,k,m]</span>
   rowlen = sz[dim]
   colhgt = sz[sz[0]+2]/rowlen
   sd = size([0d0])
   Num_Rej = make_array(od[0],od[1],od[2],od[3],val=0L)
   if keyword_set(double) || indouble then v=0d0 else v=0.
   Mean = make_array(od[0],od[1],od[2],od[3],val=v)
   Sigma = Mean
   <span class="comments">;;;</span>
   if n_elements(CUT) eq colhgt then iwCUT = lindgen(colhgt) $
   else iwCUT = make_array(colhgt,val=0L)
   <span class="comments">;;;</span>
   ijkL=0L
  
   for i=0L,od[0]-1L do begin
   for j=0L,od[1]-1L do begin
   for k=0L,od[2]-1L do begin
   for L=0L,od[3]-1L do begin
     thisCut = CUT[iwCUT[ijkL]]
     case dim of
     1: RESISTANT_Mean,Y[*,i,j,k,L],thisCUT,M,S,N,double=double
     2: RESISTANT_Mean,Y[i,*,j,k,L],thisCUT,M,S,N,double=double
     3: RESISTANT_Mean,Y[i,j,*,k,L],thisCUT,M,S,N,double=double
     4: RESISTANT_Mean,Y[i,j,k,*,L],thisCUT,M,S,N,double=double
     5: RESISTANT_Mean,Y[i,j,k,L,*],thisCUT,M,S,N,double=double
     endcase
     
     <span class="comments">;;;</span>
     Mean[ijkL] = M
     Sigma[ijkL] = S
     Num_Rej[ijkL] = N
     ijkL++
   endfor
   endfor
   endfor
   endfor
   mean  = transpose(mean)
   sigma = transpose(sigma)
   num_rej = transpose(num_rej)
   return
 endif

 MADscale = 0.6745d0
 MADscale2 = 0.8d0
 MADlim = 1d-24
 Sigcoeff = [ -0.15405d0, +0.90723d0, -0.23584d0, +0.020142d0 ]
 One = 1d0
 if ~keyword_set(double) && ~indouble then begin
   MADscale = float(MADscale)
   MADscale2 = float(MADscale2)
   MADlim = float(MADlim)
   SIGcoeff = float(SIGcoeff)
   One = float(One)
 endif

 Npts    = N_Elements(Y)
 YMed    = MEDIAN(Y,/EVEN, DOUBLE=double)
 AbsDev  = ABS(Y-YMED)
 MedAbsDev = MEDIAN(AbsDev,/EVEN, DOUBLE=double)/MADscale
 IF MedAbsDev LT MADlim THEN MedAbsDev = MEAN(AbsDev, DOUBLE=double)/MADscale2

 Cutoff    = Cut*MedAbsDev

 goodvec = where( AbsDev LE Cutoff, Num_Good) 
 GoodPts = Y[ goodvec]
 Mean    = mean( GoodPts, DOUBLE=double)
 Sigma   = SQRT( TOTAL((GoodPts-Mean)^2, DOUBLE=double)/Num_Good )
 Num_Rej = Npts - Num_Good

<span class="comments">; Compensate Sigma for truncation (formula by HF):</span>
 SC = Cut > 1.0
 IF SC LE 4.50 THEN SIGMA=SIGMA/poly(SC, SIGcoeff)

 Cutoff = Cut*Sigma 

 goodvec = where( AbsDev LE Cutoff, Num_Good) 
 Num_Rej = Npts - Num_Good
 GoodPts = Y[ goodvec ]
 if arg_present(wused) then wused = goodvec
 Mean    = mean( GoodPts, DOUBLE= double)
 if N_params() LT 4 then return     <span class="comments">;Skip sigma calculation?</span>
 

 Sigma   = SQRT( TOTAL((GoodPts-Mean)^2)/Num_Good )

<span class="comments">; Fixed bug (should check for SC not Sigma) & add higher order correction</span>
 SC = Cut > 1.0
 IF SC LE 4.50 THEN SIGMA=SIGMA/poly(SC, SIGcoeff)

<span class="comments">; Now the standard deviation of the mean:</span>
 Sigma = Sigma/SQRT(Num_Good-One)

 RETURN
 END
</code>
    </div>
  </body>
</html>