<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:02 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>st_diskread.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="st_diskread.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="st_diskread:source"></a>pro st_diskread, infiles, DUMP = dump
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;       ST_DISKREAD</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:  </span>
<span class="comments">;       Read HST FITS formatted disk files and reconstruct GEIS (STSDAS) files.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:  </span>
<span class="comments">;       ST_DISKREAD, infiles</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETER:</span>
<span class="comments">;       infiles - (scalar string) input disk files to be converted into GEIS</span>
<span class="comments">;                       files. Wildcards are allowed.</span>
<span class="comments">; FILES CREATED:</span>
<span class="comments">;</span>
<span class="comments">;   GEIS files:</span>
<span class="comments">;         The GEIS file is reconstructed from each input Fits file. The </span>
<span class="comments">;       output filename is composed from the rootname of the observation</span>
<span class="comments">;       and the appropriate GEIS file extension (i.e. d0h/d, c0h/d, etc.).</span>
<span class="comments">;   Tables:</span>
<span class="comments">;         If input file is a fits table, the output is an SDAS table.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       a) Reconstruct the GEIS file for disk FITS file z29i020ct*.fits.</span>
<span class="comments">;               st_diskread,'z29i020ct*.fits'</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       ST_DISK_DATA, ST_DISK_TABLE, ST_DISK_GEIS</span>
<span class="comments">;       FTSIZE,SXPAR(),TAB_CREATE, TAB_WRITE</span>
<span class="comments">; HISTORY: </span>
<span class="comments">;       10/17/94        JKF/ACC - taken from ST_TAPEREAD.</span>
<span class="comments">;       11/02/94        JKF/ACC - added /block on open statement to</span>
<span class="comments">;                                 handle files with 512 bytes/record.</span>
<span class="comments">;       12/6/95         JKF/ACC - include new jitter files...replaces</span>
<span class="comments">;                                               st_read_jitter.pro.</span>
<span class="comments">;       03/5/96         W. Landsman, change FORRD to READU, remove Version 1</span>
<span class="comments">;                               type codes, add message facility</span>
<span class="comments">;       05/20/00        W. Landsman, remove obsolete !ERR calls, new calling</span>
<span class="comments">;                               sequence to FTINFO</span>
<span class="comments">;       09/2006        W. Landsman, remove obsolete keywords to OPEN</span>
<span class="comments">;</span>
<span class="comments">;****************************************************************************</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>

 On_error,2

 if n_params() lt 1 then begin
        print,'Syntax - ST_DISKREAD, infiles'
        return
 endif
 !ERROR = 0
 if not keyword_set(DUMP) then dump = 0
<span class="comments">;</span>
<span class="comments">; Search for names of input disk FITS files.</span>
<span class="comments">;</span>
   file_list = file_search(infiles,count=count)
   if count le 0 then $                                              
        message,' No files found: '+ infiles $
   else message,/INF, $
        'Number of files to process: ' + strtrim(count,2)
<span class="comments">;</span>
<span class="comments">; Loop on files</span>
<span class="comments">;</span>
   for file = 0,count-1 do begin
        openr,unit,file_list[file],/get_lun
<span class="comments">;</span>
<span class="comments">; read data header and data</span>
<span class="comments">;</span>
        st_disk_data,unit,h,data,fname,gcount,dimen,opsize,nbytes,itype
        if !ERROR NE 0 then return
<span class="comments">;</span>
<span class="comments">; read optional table extension</span>
<span class="comments">;</span>
        st_disk_table,unit,htab,tab,table_available
        if !ERROR NE 0 then return
<span class="comments">;</span>
<span class="comments">; Finished reading the input dataset at this point. Now process the information</span>
<span class="comments">; and create the output datasets.</span>
<span class="comments">;</span>
<span class="comments">;       GEIS file or trailer text file</span>
<span class="comments">;</span>

        if sxpar(h,'naxis') gt 0 then begin
                st_disk_geis,h,data,htab,tab,table_available, $
                        fname,gcount,dimen,opsize,nbytes,itype  <span class="comments">;GEIS file</span>
                if !ERROR NE 0 then return
                if dump gt 0 then $
                        print,format='(t5,i4,t15,a)',file+1,strlowcase(fname)
        end else begin                  <span class="comments">;either a text trailer or jitter table</span>

           outname = strtrim(sxpar(htab,'extname'),2)
           if outname eq strtrim(0,2) then $
                outname= strtrim(sxpar(h,'filename')) 

           if  table_available then begin               

                outname = strtrim(sxpar(htab,'extname'))
                s=size(tab) & nl=s[2]                           
                name=strtrim(sxpar(htab,'extname'))             <span class="comments">;file name</span>
                <span class="comments">;</span>
                <span class="comments">;  What type of table?</span>
                <span class="comments">;     - trailer file - ascii table</span>
                <span class="comments">;     - jitter data  - sdas table</span>
                <span class="comments">;</span>
                if strpos(strlowcase(name),'jit') eq -1 then begin<span class="comments">; text trailer</span>
                  <span class="comments">;</span>
                  <span class="comments">;     Special case NAME: PODPS/IRAF uses j7 as special </span>
                  <span class="comments">;     character, so that a file with z0j7&lt;...> will be </span>
                  <span class="comments">;     created as z0.&lt;...> ( . is substituted for j7 ).</span>
                  <span class="comments">;     To avoid: Check file name for ., if found replace</span>
                  <span class="comments">;     with j7.</span>
                  <span class="comments">;</span>
                  invalid_char = strpos(name,'.')
                  if invalid_char lt 5 then begin
                        message,' Warning: Invalid filename found: '+name ,/cont
                        name = strmid(name,0,invalid_char) + 'j7' + $
                                 strmid(name,invalid_char+1,strlen(name)) 
                        message,'   Filename will be changed to: '+ name,/cont
                  end       
                 
                  openw,ounit,name,/get_lun
                  for i = 0,nl-1 do printf,ounit,strtrim(string(tab[*,i]))
                  free_lun,ounit
                  if dump gt 0 then $
                        print,format='(t5,i4,t15,a)',file+1,strlowcase(name)
                end else begin                                  <span class="comments">; jitter table</span>
                  <span class="comments">;</span>
                  <span class="comments">; Convert from FITS to SDAS table</span>
                  <span class="comments">;</span>
                  ftsize,htab,tab,ncols,nrows,tfields
                  tab_create,tcb,otab,tfields,nrows,ncols/2
                  ftinfo,htab,ft_str
                  fname = ft_str.ttype
                  for j= 0, tfields-1 do begin
                        val=ftget(ft_str,tab,j+1)     <span class="comments">; extract column</span>
                        tab_put,strtrim(fname[i]),val,tcb,otab
                  end
                  tab_write,outname,tcb,otab,htab
                  if dump gt 0 then $
                        print,format='(t5,i4,t15,a,a)',file+1, $
                                strlowcase(outname)," jitter table "
                end
           end else $
                if dump gt 0 then $
                        print,format='(t5,i4,t15,a,a)',file+1, $
                                strlowcase(outname)," (No data found)
        end     
        free_lun,unit
   endfor
return
end
<span class="comments">;</span>
<a id="st_disk_data:source"></a>pro st_disk_data,unit,h,data,name,gcount,dimen,opsize,nbytes,itype
<span class="comments">;**************************************************************************</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ST_DISK_DATA </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Routine to read next header and data array from an HST FITS disk file.</span>
<span class="comments">;       This is a subroutine of ST_DISKREAD and not intended for stand alone </span>
<span class="comments">;       use.</span>
<span class="comments">;</span>
<span class="comments">;CALLING SEQUENCE:</span>
<span class="comments">;       st_disk_data,unit,h,data,name,gcount,dimen,opsize,nbytes,itype</span>
<span class="comments">;</span>
<span class="comments">;INPUTS:</span>
<span class="comments">;       unit - logical unit number.</span>
<span class="comments">;</span>
<span class="comments">;OUTPUTS:</span>
<span class="comments">;       h - FITS header</span>
<span class="comments">;       data - data array</span>
<span class="comments">;       name - file name</span>
<span class="comments">;       gcount - number of groups</span>
<span class="comments">;       dimen - data dimensions</span>
<span class="comments">;       opsize - parameter blocks size</span>
<span class="comments">;       nbytes - bytes per data group</span>
<span class="comments">;       itype - idl data type</span>
<span class="comments">;</span>
<span class="comments">; Notes:</span>
<span class="comments">;       This is not a standalone program. Use ST_DISKREAD.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       GETTOK(), SXPAR()</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       10/17/94        JKF/ACC         - taken from ST_TAPE_DATA.</span>
<span class="comments">;</span>
<span class="comments">;***************************************************************************</span>
<span class="comments">;-</span>
        On_error,2
<span class="comments">;</span>
<span class="comments">; read fits header</span>
<span class="comments">;</span>
        h = strarr(500)
        nhead = 0
        while 1 do begin
            buf=bytarr(2880)
            readu,unit,buf
        
            for i=0,35 do begin
                st = string(buf[i*80:i*80+79])
                h[nhead]=st
                if strtrim(strmid(st,0,8)) eq 'END' then goto,fini
                nhead=nhead+1
            endfor
        endwhile
fini:
<span class="comments">;</span>
<span class="comments">; get keywords from header needed to read data</span>
<span class="comments">;</span>
        bitpix = sxpar(h,'bitpix', Count = N_bitpix)

        if N_bitpix EQ 0 then begin
            message,/CON,'ERROR - BITPIX missing from FITS header'
            return
        endif

        naxis = sxpar(h,'naxis', Count = N_naxis)
        if N_naxis EQ 0 then begin
            message,/CON,'ERROR- NAXIS missing from FITS header'
            return
        endif
        if naxis eq 0 then return               <span class="comments">;NO data to read</span>
<span class="comments">;</span>
<span class="comments">; get scale factors</span>
<span class="comments">;</span>
        bscale = sxpar(h,'bscale', Count = N_bscale)
        if N_bscale EQ 0 then bscale=1.
        bzero = sxpar(h,'bzero', Count = N_bzero)
        if N_bzero EQ 0 then bzero=0.
        iraf_bp = sxpar(h,'IRAF-B/P')           <span class="comments">;Geis file bitpix</span>
        if iraf_bp ne 64 then begin
                bscale = float(bscale)
                bzero = float(bzero)
            end else begin
                bscale = double(bscale)
                bzero = double(bzero)
        end
<span class="comments">;</span>
<span class="comments">; determine output bitpix</span>
<span class="comments">;</span>
        obitpix = abs(bitpix)
        if (bscale ne 1.0) or (bzero ne 0.0) then obitpix = 32
        if iraf_bp eq 64 then obitpix = 64 
<span class="comments">;</span>
<span class="comments">; get dimensions</span>
<span class="comments">;</span>
        dimen = lonarr(naxis)
        npoints = 1L
        for i=0,naxis-1 do begin
            dimen[i]=sxpar(h,'naxis'+strtrim(i+1,2))
            if dimen[i] le 0 then begin
                message,/CON,'ERROR- Invalid data dimension'
                return
            endif
            npoints = npoints*dimen[i]
        endfor
<span class="comments">;</span>
<span class="comments">; determine group count</span>
<span class="comments">;</span>
        gcount = sxpar(h,'sdasmgnu')>1
        if gcount gt 1 then begin
                naxis = naxis-1
                dimen = dimen[0:naxis-1]     
                if n_elements(dimen) eq 1 then dimen = lonarr(1)+dimen
                npoints = npoints/gcount
        endif
<span class="comments">;</span>
<span class="comments">; determine orignal psize in bytes</span>
<span class="comments">;</span>
        opsize = sxpar(h,'opsize', Count = N_opsize)
        if N_opsize EQ 0 then opsize = 0
        opsize = opsize/8
<span class="comments">;</span>
<span class="comments">; set up data array</span>
<span class="comments">;</span>
        case bitpix of
           8: data = make_array(dimen=dimen,/byte)
          16: data = make_array(dimen=dimen,/int)
          32: data = make_array(dimen=dimen,/long)
          64: data = make_array(dimen=dimen,/double)
         -32: data = make_array(dimen=dimen,/float)
         -64: data = make_array(dimen=dimen,/double)

          else: begin
                message,/CON,'ERROR - Invalid BITPIX value'
                return
                end
        endcase
<span class="comments">;</span>
<span class="comments">; determine file name</span>
<span class="comments">;</span>
        <span class="comments">;</span>
        <span class="comments">; Keyword IRAFNAME has been changed to FILENAME in new style </span>
        <span class="comments">;       PODPS keywords (JHB 11-2-91)</span>
        <span class="comments">;</span>
        name = sxpar(h,'FILENAME', Count = N_filename)
        if N_filename EQ 0 then begin
                name = sxpar(h,'IRAFNAME', Count = N_irafname)
                if N_irafname EQ 0 then $
                        message,' Keyword(IRAFNAME) missing from data header'+ $
                        '...ABORTING '
        endif

        <span class="comments">;</span>
        <span class="comments">; Special case NAME: PODPS/IRAF uses j7 as special</span>
        <span class="comments">; character, so that a file with z0j7&lt;...> will be</span>
        <span class="comments">; created as z0.&lt;...> ( . is substituted for j7 ).</span>
        <span class="comments">; To avoid: Check file name for ., if found replace</span>
        <span class="comments">; with j7.</span>
        <span class="comments">; Special case code added by JKF/ACC 12/30/91</span>
        <span class="comments">;</span>
        invalid_char = strpos(name,'.')
        if invalid_char lt 5 then begin
            message,' Warning: Invalid filename found: '+name ,/cont
            name = strmid(name,0,invalid_char) + 'j7' + $
                    strmid(name,invalid_char+1,strlen(name))
            message,'   Filename will be changed to: '+ name,/cont
            end

        name = strtrim(gettok(name,'.') +'.'+ gettok(name,'.'),2)
        pos = strpos(name,'_cvt')               <span class="comments">;take out _cvt</span>
        if pos gt 4 then name = strmid(name,0,pos) + $
                                strmid(name,pos+4,strlen(name)-pos-4)
        dname = name
        strput,dname,'d',strlen(name)-1 <span class="comments">;change last character to a d</span>
<span class="comments">;</span>
<span class="comments">; determine number of blocks in the file</span>
<span class="comments">;</span>
        bytes_per_point = obitpix/8
        in_bytes_per_point = abs(bitpix)/8
        nbytes = bytes_per_point * npoints
        nblocks = ((nbytes + opsize)*gcount + 511)/512
<span class="comments">;</span>
<span class="comments">; open output data file</span>
<span class="comments">;</span>
        close,1
        openw,1,dname
<span class="comments">;</span>
<span class="comments">; create output assoc variable</span>
<span class="comments">;</span>
        if (bzero eq 0) and (bscale eq 1) and (bitpix gt 0) then begin
                s = size(data) & itype = s[s[0]+1] <span class="comments">; idl data type</span>
                tmp_data = make_array( dimen=dimen, type= itype )

           end else begin   

                if obitpix eq 32 then begin
                        tmp_data =  make_array(dimen=dimen,/float)
                        itype = 4
                   end else begin
                        tmp_data =  make_array(dimen=dimen,/double)
                        itype = 5
                end
        end 
<span class="comments">;</span>
<span class="comments">; read data</span>
<span class="comments">;</span>

        pointer = 2880          <span class="comments">;byte pointer in current 2880 byte disk record</span>
              
        for group=0,gcount-1 do begin           <span class="comments">;loop on groups</span>
            pos = 0                             <span class="comments">;current pointer in data array</span>
            while pos lt npoints do begin
                if pointer ge 2880 then begin
                   readu,unit,buf
                   case bitpix of
                        16: byteorder,buf,/NtoHS
                        32: byteorder,buf,/NtoHL
                        -32: byteorder,buf,/XDRTOF
                        -64: byteorder,buf,/XDRTOD
                        ELSE:
                   endcase
                   pointer = 0
                endif
                words_needed = (npoints-pos)
                bytes_needed = words_needed*in_bytes_per_point
                bytes_to_take = (2880-pointer) &lt<span class="comments">; bytes_needed</span>
                words_to_take = bytes_to_take/in_bytes_per_point

                case bitpix of
                        8: data[pos]=buf[pointer:bytes_to_take-1]
                        16: data[pos]=fix(buf,pointer,words_to_take)
                        32: data[pos]=long(buf,pointer,words_to_take)
                        64: data[pos]=double(buf,pointer,words_to_take)
                       -32: data[pos]=float(buf,pointer,words_to_take)   <span class="comments">;IEEE</span>
                       -64: data[pos]=double(buf,pointer,words_to_take)  <span class="comments">;IEEE</span>
                endcase
                pos = pos + words_to_take
                pointer = pointer + bytes_to_take
            endwhile
<span class="comments">;</span>
<span class="comments">; write data</span>
<span class="comments">;</span>
            if (bscale ne 1.0) or (bzero ne 0.0) then begin
        
                    out_rec = assoc(1,tmp_data,(nbytes+opsize)*group)
                    out_rec[0] = data * bscale + bzero  
                end else begin
                    out_rec = assoc(1,tmp_data,(nbytes+opsize)*group)
                    out_rec[0] = data
            end
        endfor
return               
end
<span class="comments">;</span>
<a id="st_disk_table:source"></a>pro st_disk_table,unit,h,data,table_available
<span class="comments">;+</span>
<span class="comments">;NAME:</span>
<span class="comments">;       ST_DISK_TABLE </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Routine to read FITS table from an ST fits on disk.</span>
<span class="comments">;       This is a subroutine of st_diskread and not intended for stand alone </span>
<span class="comments">;       use.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       st_disk_table,unit,h,data</span>
<span class="comments">;</span>
<span class="comments">; INPUTS PARAMETER:</span>
<span class="comments">;       unit - disk unit number</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       h - FITS header</span>
<span class="comments">;       data - table array</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       This is not a standalone program. Use ST_DISKREAD.</span>
<span class="comments">;          </span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       10/17/94        JKF/ACC - taken from ST_TAPE_TABLE.</span>
<span class="comments">;       12/7/95         JKF/ACC - handle tables for jitter data.</span>
<span class="comments">;                                            </span>
<span class="comments">;****************************************************************************</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">; read fits header</span>
<span class="comments">;</span>
   h = strarr(500)
   nhead = 0
   while 1 do begin

        buf  = bytarr(2880)
           
on_ioerror, no_table_found
        readu,unit,buf
        
        for i=0,35 do begin
                st = string(buf[i*80:i*80+79])
                h[nhead]=st
                if strtrim(strmid(st,0,8)) eq 'END' then goto,fini
                nhead=nhead+1
        endfor
   endwhile
fini:

<span class="comments">;</span>
<span class="comments">; get keywords from header needed to read data</span>
<span class="comments">;</span>
   bitpix = sxpar(h,'bitpix', Count = N_bitpix)
   if N_bitpix EQ 0 then begin
        message,/CON,'ERROR- BITPIX missing from FITS header'
        return
   endif
   if bitpix ne 8 then begin
        message,/CON,'Invalid BITPIX for FITS table'
        return
    endif
    naxis = sxpar(h,'naxis', Count = N_naxis)
    if N_naxis EQ 0 then begin
            message,/CON,'ERROR- NAXIS missing from FITS table header'
            return
    endif
    if naxis ne 2 then begin
        message,/CON,'Invalid NAXIS for FITS table '
        return
    endif

    dimen = lonarr(2)
    npoints = 1L
    for i=0,1 do begin
            dimen[i]=sxpar(h,'naxis'+strtrim(i+1,2))
            if dimen[i] le 0 then begin
                if dump gt 1 then message,/cont,"No data found in table"
                goto, no_table_found
            endif
            npoints = npoints*dimen[i]
    endfor
    data = make_array(dimen=dimen,/byte)
<span class="comments">;</span>
<span class="comments">; read data array</span>
<span class="comments">;</span>
    nrecs = (npoints + 2879)/2880
    nleft = npoints      

    for i=0L,nrecs-1 do begin
                readu,unit,buf
                case bitpix of
                        16: byteorder,buf,/NtoHS
                        32: byteorder,buf,/NtoHL
                        -32: byteorder,buf,/XDRTOF
                        -64: byteorder,buf,/XDRTOD
                        ELSE:
                endcase

                if nleft lt 2880 then max_nleft = nleft-1 $
                         else max_nleft= 2880L-1
                data[i*2880L] = buf[0 : max_nleft ]
                nleft   = (npoints-1) - ((i+1)*2880L)
    endfor

table_available=1
return

no_table_found:
table_available=0

return
end

<a id="st_disk_geis:source"></a>pro st_disk_geis,h,data,htab,tab,table_available,name,gcount,dimen,opsize, $
                nbytes_g,itype
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ST_DISK_GEIS </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;        Routine to construct GEIS files from ST FITS disk files.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       ST_DISK_GEIS, h, data, htab, tab, table_available, name, gcount, </span>
<span class="comments">;               dimen,opsize, nbytes_g,itype</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;       h - header for data</span>
<span class="comments">;       data - data array</span>
<span class="comments">;       htab - header for the table</span>
<span class="comments">;       tab - fits table</span>
<span class="comments">;       table_available - logical variable (1 if table was found)</span>
<span class="comments">;       name - data set name</span>
<span class="comments">;       gcount - number of groups</span>
<span class="comments">;       dimen - data dimensions</span>
<span class="comments">;       opsize - original parameter block size</span>
<span class="comments">;       nbytes_g - number of bytes per group</span>
<span class="comments">;       itype - idl integer data type value for the output data groups</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;</span>
<span class="comments">;       GEIS file updated with group parameters in unit 1 (already open)</span>
<span class="comments">;       and header file created</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       This is not a standalone program. Use st_diskread.</span>
<span class="comments">;</span>
<span class="comments">;       During the creation of the header, this routine performs the </span>
<span class="comments">;       following steps:</span>
<span class="comments">;       1) create a basic fits header (7 keywords)</span>
<span class="comments">;       2) adjust basic fits header for the number of axis present (i.e. >1)</span>
<span class="comments">;       3) adjust basic fits header for parameter keywords (i.e. ptype,etc)</span>
<span class="comments">;       4) from this point, sequentially copies keywords until it hits one of</span>
<span class="comments">;               the following keywords 'INSTRUME','INSTRUID', or 'CONFG'.</span>
<span class="comments">;       5) append 'END' statement</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       FTSIZE, SXADDPAR, SXHWRITE</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       10/17/94        JKF/ACC         - taken from ST_DISK_GEIS</span>
<span class="comments">;</span>
<span class="comments">;****************************************************************************</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">; convert table to parameter block </span>
<span class="comments">;</span>
        hpar = strarr(200)              <span class="comments">;parameter header</span>
        hpar[0]='END'
        sxaddpar,hpar,'PCOUNT',0
        sxaddpar,hpar,'PSIZE',opsize*8
        npar = 0
        if table_available then begin
                ftsize,htab,tab,ncols,ngroups,npar
                if ngroups ne gcount then begin
                    print,'ST_DISK_GEIS - number of rows in table does '+ $
                        'not match GCOUNT'
                    retall
                endif
                sxaddpar,hpar,'PCOUNT',npar
<span class="comments">;</span>
<span class="comments">; get parameter descriptions</span>
<span class="comments">;</span>

                ptype = sxpar(htab,'ttype*')    <span class="comments">;parameter name</span>
                tform = sxpar(htab,'tform*')    <span class="comments">;formats in table</span>
                tbcol = sxpar(htab,'tbcol*')-1  <span class="comments">;starting byte in table</span>
                twidth = intarr(npar)           <span class="comments">;width of table columns</span>
                pdtype = strarr(16,npar)        <span class="comments">;data type</span>
                nbytes = intarr(npar)           <span class="comments">;size in bytes of the par.</span>
                sbyte = intarr(npar)            <span class="comments">;starting byte in par. block</span>
                idltypes = intarr(npar)         <span class="comments">;idl data type</span>
                for i=0,npar-1 do begin
                    type=strmid(tform[i],0,1)
                    case strupcase(type) of
                                'A' : idltype = 1
                                'I' : idltype = 16
                                'E' : idltype = 8
                                'F' : idltype = 8
                                'D' : idltype = 32
                    endcase
                    idltypes[i]=idltype
<span class="comments">;</span>
<span class="comments">; get field width in characters</span>
<span class="comments">;</span>
                    twidth[i]=fix(strtrim(gettok( $
                                strmid(tform[i],1,strlen(tform[i])-1),'.'),2))

                    case idltype of
                        1: begin                        <span class="comments">;string</span>
                                if ((twidth[i] mod 4) gt 0) then $
                                        twidth[i]= (fix(twidth[i]/4)*4 + 4) 
                                nbytes[i] = twidth[i]
                                pdtype[i] = 'CHARACTER*'+strtrim(twidth[i],2)
                           end
                        8: begin
                                nbytes[i] = 4
                                pdtype[i] = 'REAL*4'
                           end
                        16: begin
                                nbytes[i] = 4          
                                pdtype[i] = 'INTEGER*4'
                            end
                        32: begin
                                nbytes[i] = 8
                                pdtype[i] = 'REAL*8'
                            end
                    endcase

                    if i gt 0 then sbyte[i] = nbytes[i-1]+sbyte[i-1]

                endfor
<span class="comments">;</span>
<span class="comments">; complete parameter block portion of the header</span>
<span class="comments">;</span>
                if total(nbytes) ne opsize then begin
                    print,'ST_DISK_GEIS - mismatch of computed and ' + $
                          'original group par. block sizes'
                    retall
                endif
                blank = string(replicate(32b,80))
                strput,blank,'=',8
                nhpar = 2
                for i=0,npar-1 do begin
                        st=strtrim(i+1,2)

                        line=blank                      <span class="comments">;PTYPEn</span>
                        strput,line,'PTYPE'+st
                        strput,line,"'"+ptype[i]+"'",10
<span class="comments">;</span>
<span class="comments">;       Add comments to group parameters (PTYPEn field)...JKF/ACC 1/22/92</span>
<span class="comments">;               </span>
                        strput,line,'/',31
                        strput,line, strtrim(sxpar(htab,ptype[i]),2), 33
                        hpar[nhpar]=line

                        line=blank                      <span class="comments">;PDTYPEn</span>
                        strput,line,'PDTYPE'+st
                        strput,line,"'"+pdtype[i]+"'",10
                        strput,line,'/',31
                        hpar[nhpar+1]=line

                        line=blank                      <span class="comments">;PSIZEn</span>
                        strput,line,'PSIZE'+st
                        strput,line,string(nbytes[i]*8,'(I5)'),25
                        strput,line,'/',31
                        hpar[nhpar+2]=line
                        nhpar=nhpar+3
                endfor
                hpar[nhpar]='END'
<span class="comments">;</span>
<span class="comments">; read table columns and insert into 2-d parameter block</span>
<span class="comments">;</span>
                pblock=bytarr(total(nbytes),ngroups)
                for i=0,npar-1 do begin
                        width = twidth[i]
                        width1 = width-1
                        column = tab[tbcol[i]:tbcol[i]+width1,*]
                        if idltypes[i] ne 1 then begin
                                case idltypes[i] of
                                        8: val = fltarr(ngroups)
                                        16: val = lonarr(ngroups)
                                        32: val = dblarr(ngroups)
                                endcase
                                for j=0L,ngroups-1 do begin
                                    start = width*j
                                    <span class="comments">;</span>
                                    <span class="comments">; If the field is blank, force atleast</span>
                                    <span class="comments">;  a character 0. (DJL 10/92)</span>
                                    <span class="comments">;</span>
                                    tmp = string(column[start:start+width1])
                                    if strtrim(tmp) eq '' then tmp ='0'
                                    val[j]=tmp
                                endfor
                                column = byte(val,0,nbytes[i],ngroups)
                        endif
                        pblock[sbyte[i],0]=column
                endfor
        endif
<span class="comments">;</span>
<span class="comments">; Create output header        ---------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; determine type and size of data</span>
<span class="comments">;</span>
        case itype of
                1:  begin & datatype='BYTE'      & bitpix=8  & end
                2:  begin & datatype='INTEGER*2' & bitpix=16 & end
                3: begin & datatype='INTEGER*4' & bitpix=32 & end
                4:  begin & datatype='REAL*4'    & bitpix=32 & end
                5: begin & datatype='REAL*8'    & bitpix=64 & end
        endcase
<span class="comments">;</span>
<span class="comments">; create output header for GEIS file</span>
<span class="comments">;</span>

        hout = strarr(500) & hout[0]='END'      <span class="comments">;standard keywords</span>
        sxaddpar,hout,'SIMPLE','F'              <span class="comments">;not standard fits</span>
        sxaddpar,hout,'BITPIX',bitpix
        sxaddpar,hout,'DATATYPE',datatype
        sxaddpar,hout,'NAXIS',n_elements(dimen)
        ndim = n_elements(dimen)
        for i=1,ndim do sxaddpar,hout,'NAXIS'+strtrim(i,2),dimen[i-1]
        sxaddpar,hout,'GROUPS','T'              <span class="comments">;group format data</span>
        sxaddpar,hout,'GCOUNT',gcount
<span class="comments">;</span>
<span class="comments">; combine information from hpar, hs and h headers to form output header</span>
<span class="comments">;</span>
        nout = 7
        while strtrim(strmid(hout[nout],0,8)) ne 'END' do nout=nout+1
<span class="comments">;</span>
<span class="comments">; add parameter block information</span>
<span class="comments">;</span>
        pos = 0
        while strtrim(strmid(hpar[pos],0,8)) ne 'END' do begin
                hout[nout]=hpar[pos]
                nout=nout+1
                pos=pos+1
        endwhile
<span class="comments">;</span>
<span class="comments">; skip junk at first part of h header</span>
<span class="comments">;</span>
        pos = 0
        while (strmid(h[pos],0,8) ne 'INSTRUME') and $
              (strmid(h[pos],0,8) ne 'INSTRUID') and $
              (strtrim(strmid(h[pos],0,8),2) ne 'CONFIG') do begin
            pos = pos + 1
            if strtrim(strmid(h[pos],0,8)) eq 'END' then begin
                print,'ST_DISK_GEIS- INSTRUME keyword missing from header'
                retall
            endif
        endwhile
<span class="comments">;</span>
<span class="comments">; copy rest of header to hout</span>
<span class="comments">;</span>
        while strtrim(strmid(h[pos],0,8)) ne 'END' do begin
                hout[nout] = h[pos]
                nout=nout+1
                pos=pos+1
        endwhile
        hout[nout]='END'
<span class="comments">;</span>
<span class="comments">; Create output GEIS file --------------------------------------------------</span>
<span class="comments">;</span>
        sxhwrite,name,hout                      <span class="comments">;output header file</span>
        if npar gt 0 then begin
                out_rec = assoc(1,bytarr(1))    <span class="comments">;put in group parameters</span>
                for i=0,gcount-1 do $
                        out_rec[i*(nbytes_g+opsize)+nbytes_g] = pblock[*,i]
        end
close,1
return
end
</code>
    </div>
  </body>
</html>