<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:34 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbcreate.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbcreate.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXBCREATE, UNIT, FILENAME, HEADER, EXTENSION, ERRMSG=ERRMSG
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXBCREATE</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;	Open a new binary table at the end of a FITS file.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;	Write a binary table extension header to the end of a disk FITS file,</span>
<span class="comments">;	and leave it open to receive the data.</span>
<span class="comments">;</span>
<span class="comments">;	The FITS file is opened, and the pointer is positioned just after the</span>
<span class="comments">;	last 2880 byte record.  Then the binary header is appended.  Calls to</span>
<span class="comments">;	FXBWRITE will append the binary data to this file, and then FXBFINISH</span>
<span class="comments">;	will close the file.</span>
<span class="comments">;</span>
<span class="comments">; Use         : </span>
<span class="comments">;	FXBCREATE, UNIT, FILENAME, HEADER</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;	FILENAME = Name of FITS file to be opened.</span>
<span class="comments">;	HEADER	 = String array containing the FITS binary table extension</span>
<span class="comments">;		   header.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	None.</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	UNIT	 = Logical unit number of the opened file.</span>
<span class="comments">;       EXTENSION= Extension number of newly created extension.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;	ERRMSG	  = If defined and passed, then any error messages will be</span>
<span class="comments">;		    returned to the user in this parameter rather than</span>
<span class="comments">;		    depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		    encountered, then a null string is returned.  In order to</span>
<span class="comments">;		    use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXBCREATE, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	FXADDPAR, FXBFINDLUN, FXBPARSE, FXFINDEND</span>
<span class="comments">; Common      : </span>
<span class="comments">;	Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;	information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	The primary FITS data unit must already be written to a file.  The</span>
<span class="comments">;	binary table extension header must already be defined (FXBHMAKE), and</span>
<span class="comments">;	must match the data that will be written to the file.</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	None.</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	W. Thompson, Jan 1992, based on WRITEFITS by J. Woffard and W. Landsman.</span>
<span class="comments">;	W. Thompson, Feb 1992, changed from function to procedure.</span>
<span class="comments">;	W. Thompson, Feb 1992, removed all references to temporary files.</span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, January 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 21 July 1993.</span>
<span class="comments">;		Fixed bug with variable length arrays.</span>
<span class="comments">;	Version 3, William Thompson, GSFC, 21 June 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;	Version 4, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;	Version 5, Antony Bird, Southampton, 25 June 1997</span>
<span class="comments">;		Modified to allow very long tables </span>
<span class="comments">; Version     :</span>
<span class="comments">;	Version 5, 25 June 1997</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Added EXTENSION parameter, C. Markwardt 1999 Jul 15</span>
<span class="comments">;       More efficient zeroing of file, C. Markwardt, 26 Feb 2001</span>
<span class="comments">;       Recompute header size if updating THEAP keyword B. Roukema April 2010</span>
<span class="comments">;-</span>
<span class="comments">;</span>
@fxbintable
	ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
	IF N_PARAMS() LT 3 THEN BEGIN
		MESSAGE = 'Syntax:  FXBCREATE, UNIT, FILENAME, HEADER'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Get a logical unit number, open the file, and find the end.</span>
<span class="comments">;</span>
	GET_LUN,UNIT
       	OPENU, UNIT, FILENAME, /BLOCK
	FXFINDEND, UNIT, EXTENSION
<span class="comments">;</span>
<span class="comments">;  Store the UNIT number in the common block, and leave space for the other</span>
<span class="comments">;  parameters.  Initialize the common block if need be.  ILUN is an index into</span>
<span class="comments">;  the arrays.</span>
<span class="comments">;</span>
	ILUN = FXBFINDLUN(UNIT)
<span class="comments">;</span>
<span class="comments">;  Store the current position as the start of the header.  Mark the file as</span>
<span class="comments">;  open for write.</span>
<span class="comments">;</span>
	POINT_LUN,-UNIT,POINTER
	MHEADER[ILUN] = POINTER
	STATE[ILUN] = 2
<span class="comments">;</span>
<span class="comments">;  Determine if an END line occurs, and add one if necessary</span>
<span class="comments">;</span>
CHECK_END:
	ENDLINE = WHERE(STRMID(HEADER,0,8) EQ 'END     ', NEND)
	ENDLINE = ENDLINE[0]
	IF NEND EQ 0 THEN BEGIN
		MESSAGE,/INF,'WARNING - An END statement has been appended ' +$
			'to the FITS header'
		HEADER = [HEADER, 'END' + STRING(REPLICATE(32B,77))]
		ENDLINE = N_ELEMENTS(HEADER) - 1 
	ENDIF
	NMAX = ENDLINE + 1		<span class="comments">;Number of 80 byte records</span>
	NHEAD = FIX((NMAX+35)/36)	<span class="comments">;Number of 2880 byte records</span>
<span class="comments">;</span>
<span class="comments">;  Convert the header to byte and force into 80 character lines.</span>
<span class="comments">;</span>
WRITE_HEADER:
	BHDR = REPLICATE(32B, 80, 36*NHEAD)
	FOR N = 0,ENDLINE DO BHDR[0,N] = BYTE( STRMID(HEADER[N],0,80) )
	WRITEU, UNIT, BHDR
<span class="comments">;</span>
<span class="comments">;  Get the rest of the information, and store it in the common block.</span>
<span class="comments">;</span>
	IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
		FXBPARSE,ILUN,HEADER,ERRMSG=ERRMSG
		IF ERRMSG NE '' THEN RETURN
	END ELSE FXBPARSE,ILUN,HEADER
<span class="comments">;</span>
<span class="comments">;  Check the size of the heap offset.  If the heap offset is smaller than the</span>
<span class="comments">;  table, then reset it to the size of the table.</span>
<span class="comments">;</span>
	DDHEAP = HEAP[ILUN] - NAXIS1[ILUN]*NAXIS2[ILUN]
	IF DDHEAP LT 0 THEN BEGIN
		MESSAGE,'Heap offset smaller than table size--resetting', $
			/CONTINUE
		HEAP[ILUN] = NAXIS1[ILUN]*NAXIS2[ILUN]
		FXADDPAR,HEADER,'THEAP',HEAP[ILUN]
		POINT_LUN, UNIT, MHEADER[ILUN]
	
<span class="comments">; Have we changed position of the END keyword?</span>
		GOTO, CHECK_END
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Fill out the file to size it properly.</span>
<span class="comments">;</span>
        <span class="comments">;; This segment is now optimized to write out more than one</span>
        <span class="comments">;; row at a time, which is crucial for tables with many small</span>
        <span class="comments">;; rows.  The code heuristically chooses a buffer size which</span>
        <span class="comments">;; is 1% of the file, but no bigger than 512k, and always a</span>
        <span class="comments">;; multiple of the row size.</span>


        BUFSIZE = LONG(NAXIS1[ILUN]*NAXIS2[ILUN]/100) > NAXIS1[ILUN] &lt<span class="comments">; 524288L</span>
        BUFSIZE = (FLOOR(BUFSIZE/NAXIS1[ILUN])>1) * NAXIS1[ILUN]
        BUFFER = BYTARR(BUFSIZE)
        TOTBYTES = NAXIS1[ILUN]*NAXIS2[ILUN]

        <span class="comments">;; TOTBYTES keeps count of bytes left to write</span>
        WHILE TOTBYTES GT 0 DO BEGIN
            <span class="comments">;; Case of final rows which might not be EQ BUFSIZE</span>
            IF TOTBYTES LT BUFSIZE THEN BUFFER = BYTARR(TOTBYTES)
            WRITEU,UNIT,BUFFER
            TOTBYTES = TOTBYTES - BUFSIZE
        ENDWHILE
<span class="comments">;</span>
<span class="comments">;  If there's any extra space before the start of the heap, then write that out</span>
<span class="comments">;  as well.</span>
<span class="comments">;</span>
	IF DDHEAP GT 0 THEN BEGIN
		BUFFER = BYTARR(DDHEAP)
		WRITEU,UNIT,BUFFER
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Initialize DHEAP, and return.</span>
<span class="comments">;</span>
	DHEAP[ILUN] = 0
<span class="comments">;</span>
	IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
	RETURN
	END

</code>
    </div>
  </body>
</html>