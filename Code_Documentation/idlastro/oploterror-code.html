<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:54 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>oploterror.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="oploterror.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO  oploterror, x, y, xerr, yerr, NOHAT=nohat, HATLENGTH=hln, ERRTHICK=eth, $
      ERRSTYLE=est, THICK = thick, NOCLIP=noclip, ERRCOLOR = ecol, Nsum = nsum,$
      NSKIP=nskip, LOBAR=lobar, HIBAR=hibar, ADDCMD=addcmd, _EXTRA = pkey
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      OPLOTERROR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Over-plot data points with accompanying X or Y error bars.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;      For use instead of PLOTERROR when the plotting system has already been</span>
<span class="comments">;      defined. </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      oploterror, [ x,]  y, [xerr], yerr,   </span>
<span class="comments">;            [ /NOHAT, HATLENGTH= , ERRTHICK =, ERRSTYLE=, ERRCOLOR =, </span>
<span class="comments">;              /LOBAR, /HIBAR, NSKIP = , NSUM = , /ADDCMD, ... OPLOT keywords ]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      X = array of abcissae, any datatype except string</span>
<span class="comments">;      Y = array of Y values, any datatype except string</span>
<span class="comments">;      XERR = array of error bar values (along X)</span>
<span class="comments">;      YERR = array of error bar values (along Y)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD PARAMETERS:</span>
<span class="comments">; </span>
<span class="comments">;      /ADDCMD    = Set this keyword if you want to add this command to </span>
<span class="comments">;                   a cgWindow.</span>
<span class="comments">;      /NOHAT     = if specified and non-zero, the error bars are drawn</span>
<span class="comments">;                  without hats.</span>
<span class="comments">;      HATLENGTH = the length of the hat lines used to cap the error bars.</span>
<span class="comments">;                  Defaults to !D.X_VSIZE / 100).</span>
<span class="comments">;      ERRTHICK  = the thickness of the error bar lines.  Defaults to the</span>
<span class="comments">;                  THICK plotting keyword.</span>
<span class="comments">;      ERRSTYLE  = the line style to use when drawing the error bars.  Uses</span>
<span class="comments">;                  the same codes as LINESTYLE.</span>
<span class="comments">;     ERRCOLOR =  String (e.g. 'red') or scalar integer (0 - !D.N_TABLE)</span>
<span class="comments">;              specifying the color to use for the error bars.   See CGCOLOR()</span>
<span class="comments">;              for a list of possible color names.  See </span>
<span class="comments">;              http://www.idlcoyote.com/cg_tips/legcolor.php</span>
<span class="comments">;              for a warning about the use of indexed color</span>
<span class="comments">;      NSKIP = Positive Integer specifying the error bars to be plotted.   </span>
<span class="comments">;            For example, if NSKIP = 2 then every other error bar is </span>
<span class="comments">;            plotted; if NSKIP=3 then every third error bar is plotted.   </span>
<span class="comments">;            Default is to plot every error bar (NSKIP = 1)</span>
<span class="comments">;      NSUM =  Number of points to average over before plotting, default = </span>
<span class="comments">;             !P.NSUM  The errors are also averaged, and then divided by </span>
<span class="comments">;             sqrt(NSUM).   This approximation is meaningful only when the </span>
<span class="comments">;             neighboring error bars have similar sizes.</span>
<span class="comments">; </span>
<span class="comments">;      /LOBAR = if specified and non-zero, will draw only the -ERR error bars.</span>
<span class="comments">;      /HIBAR = if specified and non-zero, will draw only the +ERR error bars.</span>
<span class="comments">;                  If neither LOBAR or HIBAR are set _or_ if both are set,</span>
<span class="comments">;                  you will get both error bars.  Just specify one if you</span>
<span class="comments">;                  only want one set.</span>
<span class="comments">;     Any valid keywords to the OPLOT command (e.g. PSYM, YRANGE) are also </span>
<span class="comments">;     accepted by OPLOTERROR via the _EXTRA facility.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;     If only two parameters are input, they are taken as Y and YERR.  If only</span>
<span class="comments">;     three parameters are input, they will be taken as X, Y and YERR, </span>
<span class="comments">;     respectively.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;      Suppose one has X and Y vectors with associated errors XERR and YERR</span>
<span class="comments">;      and that a plotting system has already been defined:</span>
<span class="comments">;</span>
<span class="comments">;       (1) Overplot Y vs. X with both X and Y errors and no lines connecting</span>
<span class="comments">;           the points</span>
<span class="comments">;                  IDL> oploterror, x, y, xerr, yerr, psym=3</span>
<span class="comments">;</span>
<span class="comments">;       (2) Like (1) but overplot only the Y errors bars and omits "hats"</span>
<span class="comments">;                  IDL> oploterror, x, y, yerr, psym=3, /NOHAT</span>
<span class="comments">;</span>
<span class="comments">;       (3) Like (2) but suppose one has a positive error vector YERR1, and </span>
<span class="comments">;               a negative error vector YERR2 (asymmetric error bars)</span>
<span class="comments">;                  IDL> oploterror, x, y, yerr1, psym=3, /NOHAT,/HIBAR</span>
<span class="comments">;                  IDL> oploterror, x, y, yerr2, psym=3, /NOHAT,/LOBAR</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;      A plot of X versus Y with error bars drawn from Y - YERR to Y + YERR</span>
<span class="comments">;      and optionally from X - XERR to X + XERR is written to the output device</span>
<span class="comments">;</span>
<span class="comments">; WARNING:</span>
<span class="comments">;      This an enhanced version of the procedure OPLOTERR in the standard RSI</span>
<span class="comments">;      library.    It was renamed to OPLOTERROR in June 1998 in the IDL </span>
<span class="comments">;      Astronomy library.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;      Adapted from the most recent version of PLOTERR.  M. R. Greason,</span>
<span class="comments">;            Hughes STX, 11 August 1992.</span>
<span class="comments">;      Added COLOR keyword option to error bars W. Landsman   November 1993</span>
<span class="comments">;      Add ERRCOLOR, use _EXTRA keyword,           W. Landsman, July 1995</span>
<span class="comments">;      Remove spurious call to PLOT_KEYWORDS     W. Landsman, August 1995</span>
<span class="comments">;      OPLOT more than 32767 error bars          W. Landsman, Feb 1996</span>
<span class="comments">;      Added NSKIP keyword                       W. Landsman, Dec 1996</span>
<span class="comments">;      Added HIBAR and LOBAR keywords, M. Buie, Lowell Obs., Feb 1998</span>
<span class="comments">;      Rename to OPLOTERROR    W. Landsman    June 1998</span>
<span class="comments">;      Ignore !P.PSYM when drawing error bars   W. Landsman   Jan 1999</span>
<span class="comments">;      Handle NSUM keyword correctly           W. Landsman    Aug 1999</span>
<span class="comments">;      Check limits for logarithmic axes       W. Landsman    Nov. 1999</span>
<span class="comments">;      Work in the presence of  NAN values     W. Landsman    Dec 2000</span>
<span class="comments">;      Improve logic when NSUM or !P.NSUM is set  W. Landsman      Jan 2001</span>
<span class="comments">;      Remove NSUM keyword from PLOTS call    W. Landsman      March 2001</span>
<span class="comments">;      Only draw error bars with in XRANGE (for speed)  W. Landsman Jan 2002</span>
<span class="comments">;      Fix Jan 2002 update to work with log plots  W. Landsman Jun 2002</span>
<span class="comments">;      Added STRICT_EXTRA keyword   W. Landsman     July 2005</span>
<span class="comments">;      W. Landsman Fixed case of logarithmic axes reversed Mar 2009</span>
<span class="comments">;      Update for Coyote Graphics  W. Landsman     Feb. 2011 </span>
<span class="comments">;      Hats were not being plotted by default  W. Landsman Apr 2011  </span>
<span class="comments">;-</span>
<span class="comments">;                  Check the parameters.</span>
<span class="comments">;</span>
 On_error, 2
 compile_opt idl2
 np = N_params()
 IF (np LT 2) THEN BEGIN
      print, "OPLOTERR must be called with at least two parameters."
      print, "Syntax: oploterr, [x,] y, [xerr], yerr, [..oplot keywords... "
      print,'     /NOHAT, HATLENGTH = , ERRTHICK=, ERRSTLYE=, ERRCOLOR='
      print,'     /LOBAR, /HIBAR, /ADDCMD, NSKIP= ]'
      RETURN
 ENDIF

 <span class="comments">; Add it to a cgWindow, if required.</span>
 IF (Keyword_Set(addcmd)) && ((!D.Flags AND 256) NE 0) THEN BEGIN
    
      void = cgQuery(Count=count)
      IF count EQ 0 THEN Message, 'No cgWindow currently exists to add this command to.'
      cgWindow, 'oploterror', x, y, xerr, yerr, NOHAT=nohat, HATLENGTH=hln, ERRTHICK=eth, $
          ERRSTYLE=est, THICK = thick, NOCLIP=noclip, ERRCOLOR = ecol, Nsum = nsum,$
          NSKIP=nskip, LOBAR=lobar, HIBAR=hibar, ADDCMD=1, _EXTRA = pkey
            
      RETURN
 ENDIF
 
 
<span class="comments">; Error bar keywords (except for HATLENGTH; this one will be taken care of </span>
<span class="comments">; later, when it is time to deal with the error bar hats).</span>

  setdefaultvalue, thick, !P.THICK
  setdefaultvalue, eth, thick
  setdefaultvalue, est, 0        <span class="comments">;Error line style</span>
  setdefaultvalue, noclip, 0
 if ~keyword_set(NSKIP) then nskip = 1
  setdefaultvalue, nsum , !P.NSUM
 if (N_elements(ecol) EQ 0) && (N_elements(pkey) GT 0) then $
    if tag_exist(pkey,'COLOR') then  ecol = pkey.color
 if ~keyword_set(lobar) && ~keyword_set(hibar) then begin
      lobar=1
      hibar=1
 endif else if keyword_set(lobar) && keyword_set(hibar) then begin
      lobar=1
      hibar=1
 endif else if keyword_set(lobar) then begin
      lobar=1
      hibar=0
 endif else begin
      lobar=0
      hibar=1
 endelse
<span class="comments">;</span>
<span class="comments">; If no X array has been supplied, create one.  Make sure the rest of the </span>
<span class="comments">; procedure can know which parameter is which.</span>
<span class="comments">;</span>
 IF np EQ 2 THEN BEGIN                  <span class="comments">; Only Y and YERR passed.</span>
      yerr = y
      yy = x
      xx = indgen(n_elements(yy))
      xerr = make_array(size=size(xx))

 ENDIF ELSE IF np EQ 3 THEN BEGIN       <span class="comments">; X, Y, and YERR passed.</span>
        yerr = xerr
        yy = y
        xx = x

 ENDIF ELSE BEGIN                        <span class="comments">; X, Y, XERR and YERR passed.</span>
      yy = y
      g = where(finite(xerr))
      xerr[g] = abs(xerr[g])
      xx = x
 ENDELSE

 g = where(finite(yerr))
 yerr[g] = abs(yerr[g])

<span class="comments">;</span>
<span class="comments">;                  Determine the number of points being plotted.  This</span>
<span class="comments">;                  is the size of the smallest of the three arrays</span>
<span class="comments">;                  passed to the procedure.  Truncate any overlong arrays.</span>
<span class="comments">;</span>

 n = N_elements(xx) &lt<span class="comments">; N_elements(yy)</span>

 IF np GT 2 then n = n &lt<span class="comments">; N_elements(yerr)   </span>
 IF np EQ 4 then n = n &lt<span class="comments">; N_elements(xerr)</span>

 xx = xx[0:n-1]
 yy = yy[0:n-1]
 yerr = yerr[0:n-1]
 IF np EQ 4 then xerr = xerr[0:n-1]

<span class="comments">; If NSUM is greater than one, then we need to smooth ourselves (using FREBIN)</span>

 if NSum GT 1 then begin
      n1 = float(n) / nsum
      n  = long(n1)
      xx = frebin(xx, n1)
      yy = frebin(yy, n1)
      yerror = frebin(yerr,n1)/sqrt(nsum)
      if NP EQ 4 then xerror = frebin(xerr,n1)/sqrt(nsum)
  endif else begin
      yerror = yerr
      if NP EQ 4 then xerror = xerr
  endelse

 ylo = yy - yerror*lobar
 yhi = yy + yerror*hibar

 if Np EQ 4 then begin
     xlo = xx - xerror*lobar
     xhi = xx + xerror*hibar
 endif
 
<span class="comments">;</span>
<span class="comments">;                  Plot the positions.</span>
<span class="comments">;</span>
  window = cgquery(/current) GE 0
 if n NE 1 then begin
     cgPlot, xx, yy, NOCLIP=noclip,THICK = thick,_STRICT_EXTRA = pkey,/over
 endif else begin 
     cgPlots, xx, yy, NOCLIP=noclip,THICK = thick,_STRICT_EXTRA = pkey
 endelse
<span class="comments">;;</span>
<span class="comments">;; Plot the error bars.   Compute the hat length in device coordinates</span>
<span class="comments">;; so that it remains fixed even when doing logarithmic plots.</span>
<span class="comments">;;</span>
     if window then  begin 
          cgcontrol, execute = 0
          wset,cgquery(/current)
     endif	  

 data_low = convert_coord(xx,ylo,/TO_DEVICE)
 data_hi = convert_coord(xx,yhi,/TO_DEVICE)
 if NP EQ 4 then begin
    x_low = convert_coord(xlo,yy,/TO_DEVICE)
    x_hi = convert_coord(xhi,yy,/TO_DEVICE)
 endif
 
 ycrange = !Y.CRANGE   &  xcrange = !X.CRANGE
   if !Y.type EQ 1 then ylo = ylo > 10^min(ycrange)    
	                    
    if (!X.type EQ 1) && (np EQ 4) then xlo = xlo > 10^min(xcrange) 

 sv_psym = !P.PSYM & !P.PSYM = 0     <span class="comments">;Turn off !P.PSYM for error bars</span>
<span class="comments">; Only draw error bars for X values within XCRANGE</span>
    if !X.TYPE EQ 1 then xcrange = 10^xcrange
    g = where((xx GT xcrange[0]) and (xx LE xcrange[1]), Ng)
    if (Ng GT 0) && (Ng NE n) then begin  
          istart = min(g, max = iend)  
    endif else begin
          istart = 0L & iend = n-1
    endelse
    
    <span class="comments">; Set plotting color.</span>
    ecol = cgDefaultColor(ecol, Default='opposite')
    IF Size(ecol, /TNAME) EQ 'STRING' THEN ecol = cgColor(ecol)
    
 FOR i = istart, iend, Nskip DO BEGIN

    Plots, [xx[i],xx[i]], [ylo[i],yhi[i]], LINESTYLE=est,THICK=eth,  $
           NOCLIP = noclip, COLOR = ecol

    <span class="comments">; Plot X-error bars </span>
    <span class="comments">;</span>
    if np EQ 4 then $
       Plots, [xlo[i],xhi[i]],[yy[i],yy[i]],LINESTYLE=est, $
              THICK=eth, COLOR = ecol, NOCLIP = noclip

    IF ~keyword_set(nohat) THEN BEGIN
       IF (N_elements(hln) EQ 0) THEN hln = !D.X_VSIZE/100. 
       exx1 = data_low[0,i] - hln/2.
       exx2 = exx1 + hln
       if lobar then $
          Plots, [exx1,exx2], [data_low[1,i],data_low[1,i]],COLOR=ecol, $
                 LINESTYLE=est,THICK=eth,/DEVICE, noclip = noclip
       if hibar then $
          Plots, [exx1,exx2], [data_hi[1,i],data_hi[1,i]], COLOR = ecol,$
                 LINESTYLE=est,THICK=eth,/DEVICE, noclip = noclip
<span class="comments">;                                          </span>
       IF np EQ 4 THEN BEGIN
          IF (N_elements(hln) EQ 0) THEN hln = !D.Y_VSIZE/100.
             eyy1 = x_low[1,i] - hln/2.
             eyy2 = eyy1 + hln
             if lobar then $
                Plots, [x_low[0,i],x_low[0,i]], [eyy1,eyy2],COLOR = ecol, $
                       LINESTYLE=est,THICK=eth,/DEVICE, NOCLIP = noclip
             if hibar then $
                Plots, [x_hi[0,i],x_hi[0,i]], [eyy1,eyy2],COLOR = ecol, $
                       LINESTYLE=est,THICK=eth,/DEVICE, NOCLIP = noclip
          ENDIF
       ENDIF
    NOPLOT:
ENDFOR
 !P.PSYM = sv_psym 

<span class="comments">;</span>
RETURN
END
</code>
    </div>
  </body>
</html>