<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:36 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbwrite.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbwrite.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXBWRITE, UNIT, DATA, COL, ROW, BIT=BIT, NANVALUE=NANVALUE,	$
		ERRMSG=ERRMSG
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXBWRITE</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;	Write a binary data array to a disk FITS binary table file.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;	Each call to FXBWRITE will write to the data file, which should already</span>
<span class="comments">;	have been created and opened by FXBCREATE.  One needs to call this</span>
<span class="comments">;	routine for every column and every row in the binary table.  FXBFINISH</span>
<span class="comments">;	will then close the file.</span>
<span class="comments">; Use         : </span>
<span class="comments">;	FXBWRITE, UNIT, DATA, COL, ROW</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;	UNIT	= Logical unit number corresponding to the file containing the</span>
<span class="comments">;		  binary table.</span>
<span class="comments">;	DATA	= IDL data array to be written to the file.</span>
<span class="comments">;	COL	= Column in the binary table to place data in, starting from</span>
<span class="comments">;		  column one.</span>
<span class="comments">;	ROW	= Row in the binary table to place data in, starting from row</span>
<span class="comments">;		  one.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	None.</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	None.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;	BIT	= Number of bits in bit mask arrays (type "X").  Only used if</span>
<span class="comments">;		  the column is of variable size.</span>
<span class="comments">;	NANVALUE= Value signalling data dropout.  All points corresponding to</span>
<span class="comments">;		  this value are set to be IEEE NaN (not-a-number).  Ignored</span>
<span class="comments">;		  unless DATA is of type float, double-precision or complex.</span>
<span class="comments">;	ERRMSG	= If defined and passed, then any error messages will be</span>
<span class="comments">;		  returned to the user in this parameter rather than</span>
<span class="comments">;		  depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		  encountered, then a null string is returned.  In order to</span>
<span class="comments">;		  use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXBWRITE, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	HOST_TO_IEEE</span>
<span class="comments">; Common      : </span>
<span class="comments">;	Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;	information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	The binary table file must have been opened with FXBCREATE.</span>
<span class="comments">;</span>
<span class="comments">;	The data must be consistent with the column definition in the binary</span>
<span class="comments">;	table header.</span>
<span class="comments">;</span>
<span class="comments">;	The row number must be consistent with the number of rows stored in the</span>
<span class="comments">;	binary table header.</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	None.</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	W. Thompson, Jan 1992, based on WRITEFITS by J. Woffard and W. Landsman.</span>
<span class="comments">;	W. Thompson, Feb 1992, modified to support variable length arrays.</span>
<span class="comments">;	W. Thompson, Feb 1992, removed all references to temporary files.</span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, January 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 21 July 1993.</span>
<span class="comments">;		Fixed bug with variable length arrays.</span>
<span class="comments">;	Version 3, William Thompson, GSFC, 31 May 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;       Version 4, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;	Version 5, Wayne Landsman, GSFC, 12 Aug 1997</span>
<span class="comments">;		Recognize IDL double complex data type</span>
<span class="comments">; Version     :</span>
<span class="comments">;       Version 5, 12 August 1997</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
<span class="comments">;</span>
@fxbintable
	ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
	IF N_PARAMS() LT 4 THEN BEGIN
		MESSAGE = 'Syntax:  FXBWRITE, UNIT, DATA, COL, ROW'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Find the logical unit number in the FXBINTABLE common block.</span>
<span class="comments">;</span>
	ILUN = WHERE(LUN EQ UNIT,NLUN)
	ILUN = ILUN[0]
	IF NLUN EQ 0 THEN BEGIN
		MESSAGE,'Unit ' + STRTRIM(UNIT,2) +	$
			' not opened properly'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Check the row and column parameters against the header.</span>
<span class="comments">;</span>
	IF (COL LT 1) OR (COL GT TFIELDS[ILUN]) THEN BEGIN
		MESSAGE = 'COL must be between 1 and ' +	$
			STRTRIM(TFIELDS[ILUN],2)
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	END ELSE IF (ROW LT 1) OR (ROW GT NAXIS2[ILUN]) THEN BEGIN
		MESSAGE = 'ROW must be between 1 and ' +	$
			STRTRIM(NAXIS2[ILUN],2)
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Calculate the row and column parameters using IDL zero-based indexing.</span>
<span class="comments">;</span>
	IROW = LONG(ROW) - 1
	ICOL = LONG(COL) - 1
<span class="comments">;</span>
<span class="comments">;  Check the type of the data against that defined for this column.</span>
<span class="comments">;</span>
	SZ = SIZE(DATA)
	TYPE = SZ[SZ[0]+1]
	IF TYPE NE IDLTYPE[ICOL,ILUN] THEN BEGIN
		CASE IDLTYPE[ICOL,ILUN] OF
			1: STYPE = 'byte'
			2: STYPE = 'short integer'
			3: STYPE = 'long integer'
			4: STYPE = 'floating point'
			5: STYPE = 'double precison'
			6: STYPE = 'complex'
			7: STYPE = 'string'
			9: STYPE = 'double complex'
		ENDCASE
		MESSAGE = 'Data type should be ' + STYPE
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Check the number of elements, depending on whether or not the column</span>
<span class="comments">;  contains variable length arrays.</span>
<span class="comments">;</span>
	IF MAXVAL[ICOL,ILUN] GT 0 THEN BEGIN
		IF N_ELEMENTS(DATA) GT MAXVAL[ICOL,ILUN] THEN BEGIN
			MESSAGE = 'Data array should have no more than ' + $
				STRTRIM(N_ELEM[ICOL,ILUN],2) + ' elements'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
	END ELSE BEGIN
		IF N_ELEMENTS(DATA) NE N_ELEM[ICOL,ILUN] THEN BEGIN
			MESSAGE = 'Data array should have ' +	$
				STRTRIM(N_ELEM[ICOL,ILUN],2) + ' elements'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
	ENDELSE
<span class="comments">;</span>
<span class="comments">;  Find the position of the first byte of the data array in the file.</span>
<span class="comments">;</span>
	OFFSET = NHEADER[ILUN] + NAXIS1[ILUN]*IROW + BYTOFF[ICOL,ILUN]
	POINT_LUN,UNIT,OFFSET
<span class="comments">;</span>
<span class="comments">;  If a variable length array, then test to see if the array is of type</span>
<span class="comments">;  double-precision complex (M) or bit (X).</span>
<span class="comments">;</span>
	IF MAXVAL[ICOL,ILUN] GT 0 THEN BEGIN
		N_ELEM0 = N_ELEMENTS(DATA)
		IF FORMAT[ICOL,ILUN] EQ "X" THEN BEGIN
			IF N_ELEMENTS(BIT) EQ 0 THEN BEGIN
				MESSAGE = 'Number of bits not defined'
				IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
					ERRMSG = MESSAGE
					RETURN
				END ELSE MESSAGE, MESSAGE
			END ELSE IF N_ELEMENTS(BIT) NE 1 THEN BEGIN
				MESSAGE = 'Number of bits must be a scalar'
				IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
					ERRMSG = MESSAGE
					RETURN
				END ELSE MESSAGE, MESSAGE
			END ELSE IF LONG((BIT+7)/8) NE N_ELEM0 THEN BEGIN
				MESSAGE = 'Number of bits does not match ' + $
					'array size'
				IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
					ERRMSG = MESSAGE
					RETURN
				END ELSE MESSAGE, MESSAGE
			ENDIF
			N_ELEM0 = BIT
		ENDIF
<span class="comments">;</span>
<span class="comments">;  Write out the number of elements, and the pointer to the variable length</span>
<span class="comments">;  array.</span>
<span class="comments">;</span>
		POINTER = LONARR(2)
		POINTER[0] = N_ELEM0
		POINTER[1] = DHEAP[ILUN]
		HOST_TO_IEEE,POINTER
		WRITEU,UNIT,POINTER
		POINT_LUN,UNIT,NHEADER[ILUN] + HEAP[ILUN] + DHEAP[ILUN]
<span class="comments">;</span>
<span class="comments">;  Update the HEAP pointer.</span>
<span class="comments">;</span>
		CASE TYPE OF
			1:  DDHEAP = N_ELEMENTS(DATA)		<span class="comments">;Byte</span>
			2:  DDHEAP = N_ELEMENTS(DATA) * 2	<span class="comments">;Short integer</span>
			3:  DDHEAP = N_ELEMENTS(DATA) * 4	<span class="comments">;Long integer</span>
			4:  DDHEAP = N_ELEMENTS(DATA) * 4	<span class="comments">;Float</span>
			5:  DDHEAP = N_ELEMENTS(DATA) * 8	<span class="comments">;Double</span>
			6:  DDHEAP = N_ELEMENTS(DATA) * 8	<span class="comments">;Complex</span>
			7:  DDHEAP = N_ELEMENTS(DATA)		<span class="comments">;String</span>
			9:  DDHEAP = N_ELEMENTS(DATA) * 16      <span class="comments">;Dble Complex</span>
		ENDCASE
		DHEAP[ILUN] = DHEAP[ILUN] + DDHEAP
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If a byte array, then simply write out the data.</span>
<span class="comments">;</span>
        IF TYPE EQ 1 THEN BEGIN
		WRITEU,UNIT,DATA
<span class="comments">;</span>
<span class="comments">;  Otherwise, if a character string array, then write out the character strings</span>
<span class="comments">;  with the correct width, truncating or padding with blanks as necessary.</span>
<span class="comments">;  However, if a variable length string array, then simply write it out.</span>
<span class="comments">;</span>
	END ELSE IF TYPE EQ 7 THEN BEGIN
		IF MAXVAL[ICOL,ILUN] GT 0 THEN BEGIN
			WRITEU,UNIT,DATA
		END ELSE BEGIN
			N_CHAR = N_DIMS[1,ICOL,ILUN]
			NEWDATA = REPLICATE(32B,N_CHAR,N_ELEMENTS(DATA))
			FOR I=0,N_ELEMENTS(DATA)-1 DO	$
				NEWDATA[0,I] = BYTE(STRMID(DATA[I],0,N_CHAR))
			WRITEU,UNIT,NEWDATA
		ENDELSE
<span class="comments">;</span>
<span class="comments">;  Otherwise, if necessary, then byte-swap the data before writing it out.</span>
<span class="comments">;  Also, replace any values corresponding data dropout with IEEE NaN.</span>
<span class="comments">;</span>
	END ELSE BEGIN
		IF (N_ELEMENTS(NANVALUE) EQ 1) AND (TYPE GE 4) AND	$
				((TYPE LE 6) OR (TYPE EQ 9)) THEN BEGIN
			W = WHERE(DATA EQ NANVALUE, COUNT)
			CASE TYPE OF
				4:  NAN = FLOAT(  REPLICATE('FF'XB,4),0,1)
				5:  NAN = DOUBLE( REPLICATE('FF'XB,8),0,1)
				6:  NAN = COMPLEX(REPLICATE('FF'XB,8),0,1)
				9:  NAN = DCOMPLEX(REPLICATE('FF'XB,16),0,1)
			ENDCASE
		END ELSE COUNT = 0
<span class="comments">;</span>
		NEWDATA = DATA
		HOST_TO_IEEE, NEWDATA
		IF COUNT GT 0 THEN NEWDATA[W] = NAN
		WRITEU,UNIT,NEWDATA 
	ENDELSE
<span class="comments">;</span>
	IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
	RETURN
	END
</code>
    </div>
  </body>
</html>