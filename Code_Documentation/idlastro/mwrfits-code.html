<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:52 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mwrfits.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mwrfits.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MWRFITS</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Write all standard FITS data types from input arrays or structures.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Must be used with a post-October 2009 version of FXADDPAR.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       MWRFITS, Input, Filename, [Header],</span>
<span class="comments">;                       /LSCALE , /ISCALE, /BSCALE, </span>
<span class="comments">;                       /USE_COLNUM, /Silent, /Create, /No_comment, /Version, $</span>
<span class="comments">;                       Alias=, /ASCII, Separator=, Terminator=, Null=,</span>
<span class="comments">;                       /Logical_cols, /Bit_cols, /Nbit_cols, </span>
<span class="comments">;                       Group=, Pscale=, Pzero=, Status=</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Input = Array or structure to be written to FITS file.</span>
<span class="comments">;</span>
<span class="comments">;               -When writing FITS primary data or image extensions</span>
<span class="comments">;                input should be an array.</span>
<span class="comments">;               --If data is to be grouped</span>
<span class="comments">;                 the Group keyword should be specified to point to</span>
<span class="comments">;                 a two dimensional array.  The first dimension of the</span>
<span class="comments">;                 Group array will be PCOUNT while the second dimension</span>
<span class="comments">;                 should be the same as the last dimension of Input.</span>
<span class="comments">;               --If Input is undefined, then a dummy primary dataset</span>
<span class="comments">;                 or Image extension is created [This might be done, e.g.,</span>
<span class="comments">;                 to put appropriate keywords in a dummy primary</span>
<span class="comments">;                 HDU].</span>
<span class="comments">;</span>
<span class="comments">;               -When writing an ASCII table extension, Input should</span>
<span class="comments">;                be a structure array where no element of the structure</span>
<span class="comments">;                is a structure or array (except see below).</span>
<span class="comments">;               --A byte array will be written as A field.  No checking</span>
<span class="comments">;                 is done to ensure that the values in the byte field</span>
<span class="comments">;                 are valid ASCII.</span>
<span class="comments">;               --Complex numbers are written to two columns with '_R' and</span>
<span class="comments">;                 '_I' appended to the TTYPE fields (if present).  The</span>
<span class="comments">;                 complex number is enclosed in square brackets in the output.</span>
<span class="comments">;               --Strings are written to fields with the length adjusted</span>
<span class="comments">;                 to accommodate the largest string.  Shorter strings are</span>
<span class="comments">;                 blank padded to the right.</span>
<span class="comments">;</span>
<span class="comments">;               -When writing a binary table extension, the input should</span>
<span class="comments">;                be a structure array with no element of the structure</span>
<span class="comments">;                being a substructure.</span>
<span class="comments">;</span>
<span class="comments">;               If a structure is specified on input and the output</span>
<span class="comments">;               file does not exist or the /CREATE keyword is specified</span>
<span class="comments">;               a dummy primary HDU is created.</span>
<span class="comments">;</span>
<span class="comments">;       Filename = String containing the name of the file to be written.</span>
<span class="comments">;                By default MWRFITS appends a new extension to existing</span>
<span class="comments">;                files which are assumed to be valid FITS.  The /CREATE</span>
<span class="comments">;                keyword can be used to ensure that a new FITS file</span>
<span class="comments">;                is created even if the file already exists.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       Header = Header should be a string array.  Each element of the</span>
<span class="comments">;                array is added as a row in the FITS  header.  No</span>
<span class="comments">;                parsing is done of this data.  MWRFITS will prepend</span>
<span class="comments">;                required structural (and, if specified, scaling)</span>
<span class="comments">;                keywords before the rows specified in Header.</span>
<span class="comments">;                Rows describing columns in the table will be appended</span>
<span class="comments">;                to the contents of Header.</span>
<span class="comments">;                Header lines will be extended or truncated to</span>
<span class="comments">;                80 characters as necessary.</span>
<span class="comments">;                If Header is specified then on return Header will have</span>
<span class="comments">;                the header generated for the specified extension.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       ALias=   Set up aliases to convert from the IDL structure</span>
<span class="comments">;                to the FITS column name.  The value should be</span>
<span class="comments">;                a STRARR(2,*) value where the first element of</span>
<span class="comments">;                each pair of values corresponds to a column</span>
<span class="comments">;                in the structure and the second is the name</span>
<span class="comments">;                to be used in the FITS file.</span>
<span class="comments">;                The order of the alias keyword is compatible with</span>
<span class="comments">;                use in MRDFITS.</span>
<span class="comments">;       ASCII  - Creates an ASCII table rather than a binary table.</span>
<span class="comments">;                This keyword may be specified as:</span>
<span class="comments">;                /ASCII - Use default formats for columns.</span>
<span class="comments">;                ASCII='format_string' allows the user to specify</span>
<span class="comments">;                  the format of various data types such using the following</span>
<span class="comments">;                  syntax 'column_type:format, column_type:format'.  E.g.,</span>
<span class="comments">;                ASCII='A:A1,I:I6,L:I10,B:I4,F:G15.9,D:G23.17,C:G15.9,M:G23.17'</span>
<span class="comments">;                gives the default formats used for each type.  The TFORM</span>
<span class="comments">;                fields for the real and complex types indicate will use corresponding</span>
<span class="comments">;                E and D formats when a G format is specified.</span>
<span class="comments">;                Note that the length of the field for ASCII strings and</span>
<span class="comments">;                byte arrays is automatically determined for each column.</span>
<span class="comments">;       BIT_COLS=   An array of indices of the bit columns.   The data should</span>
<span class="comments">;                comprise a byte array with the appropriate dimensions.</span>
<span class="comments">;                If the number of bits per row (see NBIT_COLS)</span>
<span class="comments">;                is greater than 8, then the first dimension of the array </span>
<span class="comments">;                should match the number of input bytes per row.</span>
<span class="comments">;       BSCALE   Scale floats, longs, or shorts to unsigned bytes (see LSCALE)</span>
<span class="comments">;       /CREATE   If this keyword is non-zero, then a new FITS file will</span>
<span class="comments">;                be created regardless of whether the file currently</span>
<span class="comments">;                exists.  Otherwise when the file already exists,</span>
<span class="comments">;                a FITS extension will be appended to the existing file</span>
<span class="comments">;                which is assumed to be a valid FITS file.</span>
<span class="comments">;       GROUP=   This keyword indicates that GROUPed FITS data is to</span>
<span class="comments">;                be generated.</span>
<span class="comments">;                Group should be a 2-D array of the appropriate output type.</span>
<span class="comments">;                The first dimension will set the number of group parameters.</span>
<span class="comments">;                The second dimension must agree with the last dimension</span>
<span class="comments">;                of the Input array.</span>
<span class="comments">;       ISCALE   Scale floats or longs to short integer (see LSCALE)</span>
<span class="comments">;       LOGICAL_COLS=  An array of indices of the logical column numbers.</span>
<span class="comments">;                These should start with the first column having index *1*.</span>
<span class="comments">;                The structure element should either be an array of characters</span>
<span class="comments">;                with the values 'T' or 'F', or an array of bytes having the </span>
<span class="comments">;                values byte('T')=84b, byte('F')=70b or 0b.     The use of bytes</span>
<span class="comments">;                allows the specification of undefined values (0b).</span>
<span class="comments">;       LSCALE   Scale floating point numbers to long integers.</span>
<span class="comments">;                This keyword may be specified in three ways.</span>
<span class="comments">;                /LSCALE (or LSCALE=1) asks for scaling to be automatically</span>
<span class="comments">;                determined. LSCALE=value divides the input by value.</span>
<span class="comments">;                I.e., BSCALE=value, BZERO=0.  Numbers out of range are </span>
<span class="comments">;                given the value of NULL if specified, otherwise they are given</span>
<span class="comments">;                the appropriate extremum value.  LSCALE=(value,value)</span>
<span class="comments">;                uses the first value as BSCALE and the second as BZERO</span>
<span class="comments">;                (or TSCALE and TZERO for tables).</span>
<span class="comments">;       NBIT_COLS=  The number of bits actually used in the bit array.</span>
<span class="comments">;                This argument must point to an array of the same dimension</span>
<span class="comments">;                as BIT_COLS.</span>
<span class="comments">;       NO_TYPES  If the NO_TYPES keyword is specified, then no TTYPE</span>
<span class="comments">;                keywords will be created for ASCII and BINARY tables.</span>
<span class="comments">;       No_comment Do not write comment keywords in the header</span>
<span class="comments">;       NULL=    Value to be written for integers/strings which are</span>
<span class="comments">;                undefined or unwritable.</span>
<span class="comments">;       PSCALE=  An array giving scaling parameters for the group keywords.</span>
<span class="comments">;                It should have the same dimension as the first dimension</span>
<span class="comments">;                of Group.</span>
<span class="comments">;       PZERO=   An array giving offset parameters for the group keywords.</span>
<span class="comments">;                It should have the same dimension as the first dimension</span>
<span class="comments">;                of Group.</span>
<span class="comments">;       Separator= This keyword can be specified as a string which will</span>
<span class="comments">;                be used to separate fields in ASCII tables.  By default</span>
<span class="comments">;                fields are separated by a blank.</span>
<span class="comments">;       /SILENT   Suppress informative messages.  Errors will still</span>
<span class="comments">;                be reported.</span>
<span class="comments">;       Terminator= This keyword can be specified to provide a string which</span>
<span class="comments">;                will be placed at the end of each row of an ASCII table.</span>
<span class="comments">;                No terminator is used when not specified.</span>
<span class="comments">;                If a non-string terminator is specified (including</span>
<span class="comments">;                when the /terminator form is used), a new line terminator</span>
<span class="comments">;                is appended.</span>
<span class="comments">;       USE_COLNUM  When creating column names for binary and ASCII tables</span>
<span class="comments">;                MWRFITS attempts to use structure field name</span>
<span class="comments">;                values.  If USE_COLNUM is specified and non-zero then</span>
<span class="comments">;                column names will be generated as 'C1, C2, ... 'Cn'</span>
<span class="comments">;                for the number of columns in the table.</span>
<span class="comments">;       Version   Print the version number of MWRFITS.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       Status - 0 if FITS file is successfully written, -1 if there is a</span>
<span class="comments">;                a problem (e.g. nonexistent directory, or no write permission)</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Write a simple array:</span>
<span class="comments">;            a=fltarr(20,20)</span>
<span class="comments">;            mwrfits,a,'test.fits'</span>
<span class="comments">;</span>
<span class="comments">;       Append a 3 column, 2 row, binary table extension to file just created.</span>
<span class="comments">;            a={name:'M31', coords:(30., 20.), distance:2}</span>
<span class="comments">;            a=replicate(a, 2);</span>
<span class="comments">;            mwrfits,a,'test.fits'</span>
<span class="comments">;</span>
<span class="comments">;       Now add on an image extension:</span>
<span class="comments">;            a=lonarr(10,10,10)</span>
<span class="comments">;            hdr=("COMMENT  This is a comment line to put in the header", $</span>
<span class="comments">;                 "MYKEY    = "Some desired keyword value")</span>
<span class="comments">;            mwrfits,a,'test.fits',hdr</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1)     Variable length columns are not supported for anything</span>
<span class="comments">;               other than simple types (byte, int, long, float, double).</span>
<span class="comments">;       (2)     Empty strings are converted to 1 element blank strings (because</span>
<span class="comments">;               IDL refuses to write an empty string (0b) from a structure)</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       This multiple format FITS writer is designed to provide a</span>
<span class="comments">;       single, simple interface to writing all common types of FITS data.</span>
<span class="comments">;       Given the number of options within the program and the</span>
<span class="comments">;       variety of IDL systems available it is likely that a number</span>
<span class="comments">;       of bugs are yet to be uncovered. </span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       FXPAR(), FXADDPAR</span>
<span class="comments">; MODIfICATION HISTORY:</span>
<span class="comments">;       Version 0.9: By T. McGlynn   1997-07-23</span>
<span class="comments">;              Initial beta release.</span>
<span class="comments">;       Dec 1, 1997, Lindler, Modified to work under VMS.</span>
<span class="comments">;       Version 0.91: T. McGlynn  1998-03-09</span>
<span class="comments">;               Fixed problem in handling null primary arrays.</span>
<span class="comments">;       Version 0.92: T. McGlynn 1998-09-09</span>
<span class="comments">;               Add no_comment flag and keep user comments on fields.</span>
<span class="comments">;               Fix handling of bit fields.</span>
<span class="comments">;       Version 0.93: T. McGlynn 1999-03-10</span>
<span class="comments">;               Fix table appends on VMS.</span>
<span class="comments">;       Version 0.93a  W. Landsman/D. Schlegel</span>
<span class="comments">;               Update keyword values in chk_and_upd if data type has changed </span>
<span class="comments">;       Version 0.94: T. McGlynn 2000-02-02</span>
<span class="comments">;               Efficient processing of ASCII tables.</span>
<span class="comments">;               Use G rather than E formats as defaults for ASCII tables</span>
<span class="comments">;                and make the default precision long enough that transformations</span>
<span class="comments">;                binary to/from ASCII are invertible.</span>
<span class="comments">;               Some loop indices made long.</span>
<span class="comments">;               Fixed some ends to match block beginnings.</span>
<span class="comments">;       Version 0.95: T. McGlynn 2000-11-06</span>
<span class="comments">;               Several fixes to scaling.  Thanks to David Sahnow for</span>
<span class="comments">;               documenting the problems.</span>
<span class="comments">;               Added PCOUNT,GCOUNT keywords to Image extensions.</span>
<span class="comments">;               Version numbers shown in SIMPLE/XTENSION comments</span>
<span class="comments">;       Version 0.96: T. McGlynn 2001-04-06</span>
<span class="comments">;               Changed how files are opened to handle ~ consistently</span>
<span class="comments">;       Version 1.0: T. McGlynn 2001-12-04</span>
<span class="comments">;               Unsigned integers,</span>
<span class="comments">;               64 bit integers.</span>
<span class="comments">;               Aliases</span>
<span class="comments">;               Variable length arrays</span>
<span class="comments">;               Some code cleanup</span>
<span class="comments">;       Version 1.1: T. McGlynn 2002-2-18</span>
<span class="comments">;               Fixed major bug in processing of unsigned integers.</span>
<span class="comments">;               (Thanks to Stephane Beland)</span>
<span class="comments">;       Version 1.2: Stephane Beland 2003-03-17</span>
<span class="comments">;               Fixed problem in creating dummy dataset when passing undefined</span>
<span class="comments">;               data, caused by an update to FXADDPAR routine.</span>
<span class="comments">;       Version 1.2.1 Stephane Beland 2003-09-10</span>
<span class="comments">;               Exit gracefully if write priveleges unavailable</span>
<span class="comments">;       Version 1.3 Wayne Landsman 2003-10-24</span>
<span class="comments">;               Don't use EXECUTE() statement if on a virtual machine</span>
<span class="comments">;       Version 1.3a Wayne Landsman 2004-5-21</span>
<span class="comments">;               Fix for variable type arrays</span>
<span class="comments">;       Version 1.4 Wayne Landsman 2004-07-16</span>
<span class="comments">;               Use STRUCT_ASSIGN when modifying structure with pointer tags</span>
<span class="comments">;       Version 1.4a Wayne Landsman 2005-01-03</span>
<span class="comments">;               Fix writing of empty strings in binary tables </span>
<span class="comments">;       Version 1.4b Wayne Landsman 2006-02-23</span>
<span class="comments">;               Propagate /SILENT keyword to mwr_tablehdr</span>
<span class="comments">;       Version 1.5 Wayne Landsman  2006-05-24</span>
<span class="comments">;               Open file using /SWAP_IF_LITTLE_ENDIAN keyword </span>
<span class="comments">;               Convert empty strings to 1 element blank strings before writing            </span>
<span class="comments">;       Version 1.5a Wayne Landsman 2006-06-29</span>
<span class="comments">;               Fix problem introduced 2006-05-24 with multidimensional strings</span>
<span class="comments">;       Version 1.5b K. Tolbert 2006-06-29</span>
<span class="comments">;               Make V1.5a fix work pre-V6.0</span>
<span class="comments">;       Version 1.5c I.Evans/W.Landsman 2006-08-08</span>
<span class="comments">;               Allow logical columns to be specified as bytes </span>
<span class="comments">;       Version 1,5d K. Tolbert 2006-08-11 </span>
<span class="comments">;               Make V1.5a fix work for scalar empty string</span>
<span class="comments">;       Version 1.6  W. Landsman  2006-09-22</span>
<span class="comments">;               Assume since V5.5, remove VMS support</span>
<span class="comments">;       Version 1.6a  W. Landsman  2006-09-22</span>
<span class="comments">;               Don't right-justify strings </span>
<span class="comments">;       Version 1.7  W. Landsman  2009-01-12</span>
<span class="comments">;               Added STATUS output keyword</span>
<span class="comments">;       Version 1.7a W. Landsman 2009-04-10</span>
<span class="comments">;               Since V6.4 strings are no longer limited to 1024</span>
<span class="comments">;               elements </span>
<span class="comments">;       Version 1.8 Pierre Chanial 2009-06-23</span>
<span class="comments">;               trim alias, implement logical TFORM 'L', don't</span>
<span class="comments">;               add space after tform key.</span>
<span class="comments">;       Version 1.9 W. Landsman 2009-07-20</span>
<span class="comments">;               Suppress compilation messages of supporting routines</span>
<span class="comments">;       Version 1.10 W. Landsman 2009-09-30</span>
<span class="comments">;               Allow TTYPE values of 'T' and 'F', fix USE_COLNUM for bin tables</span>
<span class="comments">;       Version 1.11 W. Landsman 2010-11-18</span>
<span class="comments">;               Allow LONG64 number of bytes, use V6.0 notation </span>
<span class="comments">;       Version 1.11a W. Landsman 2012-08-12</span>
<span class="comments">;               Better documentation, error checking for logical columns</span>
<span class="comments">;       Version 1.11b M. Haffner/W.L. 2012-10-12</span>
<span class="comments">;     </span>
<span class="comments">;-</span>

<span class="comments">; What is the current version of this program?</span>
<a id="mwr_version:source"></a>function mwr_version
     compile_opt idl2,hidden
    return, '1.11b'
end
    

<span class="comments">; Find the appropriate offset for a given unsigned type</span>
<span class="comments">; or just return 0 if the type is not unsigned.</span>

<a id="mwr_unsigned_offset:source"></a>function mwr_unsigned_offset, type
     compile_opt idl2,hidden
     
    case type of            
    12: return, 32768US
    13: return, 2147483648UL
    15: return, 9223372036854775808ULL
    else: return,0
    endcase
end


<span class="comments">; Add a keyword as non-destructively as possible to a FITS header</span>
<a id="chk_and_upd:source"></a>pro chk_and_upd, header, key, value, comment, nological=nological
     compile_opt idl2,hidden


    xcomm = ""
    if n_elements(comment) gt 0 then xcomm = comment
    if n_elements(header) eq 0 then begin
      
        fxaddpar, header, key, value, xcomm
       
    endif else begin
       
        oldvalue = fxpar(header, key, count=count, comment=oldcomment)
        if (count eq 1) then begin

           qchange = 0 <span class="comments">; Set to 1 if either the type of variable or its</span>
                       <span class="comments">; value changes.</span>
            size1 = size(oldvalue,/type) & size2 = size(value,/type)
            if size1 NE size2 then qchange = 1 $
            else if (oldvalue ne value) then qchange = 1

            if (qchange) then begin

               if n_elements(oldcomment) gt 0 then xcomm = oldcomment[0]
               fxaddpar, header, key, value, xcomm,nological=nological
              
           endif
           
       endif else begin
           
            fxaddpar, header, key, value, xcomm,nological=nological
        endelse
       
    endelse
end

<span class="comments">; Get the column name appropriate for a given tag</span>
<a id="mwr_checktype:source"></a>function mwr_checktype, tag, alias=alias
     compile_opt idl2,hidden

    if ~keyword_set(alias) then return, tag

    sz = size(alias,/struc)
    <span class="comments">; 1 or 2 D string array with first dimension of 2</span>
    if (sz.type_name EQ 'STRING') && (sz.dimensions[0] EQ 2) && $
       (sz.N_dimensions LE 2)  then begin 
       w = where(tag eq strtrim(alias[0,*],2),N_alias)
       if N_alias EQ 0 then return,tag else return,alias[1,w[0]]
    endif else begin
       print,'MWRFITS: Warning: Alias values not strarr(2) or strarr(2,*)'
    endelse
    return, tag
end

<span class="comments">; Create an ASCII table</span>
<a id="mwr_ascii:source"></a>pro mwr_ascii, input, siz, lun, bof, header,     $
        ascii=ascii,                             $
       null=null,                               $
       use_colnum = use_colnum,                 $
       lscale=lscale, iscale=iscale,               $
       bscale=bscale,                           $
       no_types=no_types,                      $
       separator=separator,                     $
       terminator=terminator,                   $
        no_comment=no_comment,                   $
       silent=silent,                           $
       alias=alias
     compile_opt idl2,hidden
       
    <span class="comments">; Write the header and data for a FITS ASCII table extension.</span>
  
    types=  ['A',   'I',   'L',   'B',   'F',    'D',      'C',     'M',     'K']
    formats=['A1',  'I6',  'I10', 'I4',  'G15.9','G23.17', 'G15.9', 'G23.17','I20']
    lengths=[1,     6,     10,     4,    15,     23,       15,      23,      20]

    <span class="comments">; Check if the user is overriding any default formats.</span>
    sz = size(ascii)

    if sz[0] eq 0 and sz[1] eq 7 then begin
        ascii = strupcase(strcompress(ascii,/remo))
        for i=0, n_elements(types)-1  do begin
            p = strpos(ascii,types[i]+':')
            if p ge 0 then begin

               q = strpos(ascii, ',', p+1)
               if q lt p then q = strlen(ascii)+1
               formats[i] = strmid(ascii, p+2, (q-p)-2)
               len = 0
           
               reads, formats[i], len, format='(1X,I)'
               lengths[i] = len
            endif
        endfor
    endif

    i0      = input[0]
    ntag    = n_tags(i0)
    tags    = tag_names(i0)
    ctypes  = lonarr(ntag)
    strmaxs = lonarr(ntag)

    if ~keyword_set(separator) then separator=' '
    slen = strlen(separator)

    offsets = 0
    tforms = ''
    ttypes = ''
    offset = 0

    totalFormat = ""
    xsep = ""<span class="comments">;</span>

    for i=0, ntag-1 do begin

        totalFormat = totalFormat + xsep<span class="comments">;</span>
    
        sz = size(i0.(i))
        if (sz[0] ne 0) && (sz[sz[0]+1] ne 1) then begin
            print, 'MWRFITS Error: ASCII table cannot contain arrays'
           return
        endif

        ctypes[i] = sz[1]

        xtype = mwr_checktype(tags[i], alias=alias)
    
        ttypes = [ttypes, xtype+' ']

        if sz[0] gt 0 then begin
            <span class="comments">; Byte array to be handled as a string.</span>
           nelem = sz[sz[0]+2]
           ctypes[i] = sz[sz[0]+1]
            tf = 'A'+strcompress(string(nelem))
            tforms = [tforms, tf]
           offsets = [offsets, offset]
            totalFormat = totalFormat + tf
           offset = offset + nelem
       
        endif else if sz[1] eq 7 then begin
            <span class="comments">; Use longest string to get appropriate size.</span>
           strmax = max(strlen(input.(i)))
           strmaxs[i] = strmax
           tf = 'A'+strcompress(string(strmax), /remo)
           tforms = [tforms, tf]
           offsets = [offsets, offset]
            totalFormat = totalFormat + tf
           ctypes[i] = 7
           offset = offset + strmax
       
        endif else if (sz[1] eq 6 ) || (sz[1] eq 9) then begin
            <span class="comments">; Complexes handled as two floats.</span>
           offset++
       
           if sz[1] eq 6 then indx = where(types eq 'C')
           if sz[1] eq 9 then indx = where(types eq 'M')
           indx = indx[0]
           fx = formats[indx]
           if strcmp(fx,'g',1,/fold) then begin
               if (sz[1] eq 6) then begin
                   fx = "E"+strmid(fx,1 )
               endif else begin
                  fx = "D"+strmid(fx,1 )
               endelse
           endif
           tforms = [tforms, fx, fx]
            offsets = [offsets, offset, offset+lengths[indx]+1]
           nel = n_elements(ttypes)
           ttypes = [ttypes[0:nel-2], xtype+'_R', xtype+'_I']
           offset = offset + 2*lengths[indx] + 1

            totalFormat = totalFormat + '"[",'+formats[indx]+',1x,'+formats[indx]+',"]"'
            offset = offset+1
       
        endif else begin
         
            if sz[1] eq 1 then indx = where(types eq 'B')                      $
           else if (sz[1] eq 2) || (sz[1] eq 12) then indx = where(types eq 'I')  $
           else if (sz[1] eq 3) || (sz[1] eq 13) then indx = where(types eq 'L')  $
           else if sz[1] eq 4 then indx = where(types eq 'F')                 $
           else if sz[1] eq 5 then indx = where(types eq 'D')                 $
           else if (sz[1] eq 14) || (sz[1] eq 15) then indx = where(types eq 'K') $
           else begin
               print, 'MWRFITS Error: Invalid type in ASCII table'
               return
           endelse
       
           indx = indx[0]
           fx = formats[indx]
           if (strmid(fx, 0, 1) eq 'G' || strmid(fx, 0, 1) eq 'g') then begin
               if sz[1] eq 4 then begin
                   fx = 'E'+strmid(fx, 1, 99)
               endif else begin
                   fx = 'D'+strmid(fx, 1, 99)
               endelse
           endif
       
           tforms = [tforms, fx]
           offsets = [offsets, offset]
            totalFormat = totalFormat + formats[indx]
           offset = offset + lengths[indx]
        endelse
        if i ne ntag-1 then begin
            offset = offset + slen
        endif

        xsep = ", '"+separator+"', "
    
    endfor

    if  keyword_set(terminator) then begin
        sz = size(terminator)<span class="comments">;</span>
        if sz[0] ne 0 || sz[1] ne 7 then begin
            terminator= string(10B)
        endif
    endif


    if keyword_set(terminator) then offset = offset+strlen(terminator)
    <span class="comments">; Write required FITS keywords.</span>

    chk_and_upd, header, 'XTENSION', 'TABLE', 'ASCII table extension written by MWRFITS '+mwr_version()
    chk_and_upd, header, 'BITPIX', 8,'Required Value: ASCII characters'
    chk_and_upd, header, 'NAXIS', 2,'Required Value'
    chk_and_upd, header, 'NAXIS1', offset, 'Number of characters in a row'
    chk_and_upd, header, 'NAXIS2', n_elements(input), 'Number of rows'
    chk_and_upd, header, 'PCOUNT', 0, 'Required value'
    chk_and_upd, header, 'GCOUNT', 1, 'Required value'
    chk_and_upd, header, 'TFIELDS', n_elements(ttypes)-1, 'Number of fields'

    <span class="comments">; Recall that the TTYPES, TFORMS, and OFFSETS arrays have an</span>
    <span class="comments">; initial dummy element.</span>


    <span class="comments">; Write the TTYPE keywords.</span>
    if ~keyword_set(no_types) then begin
        for i=1, n_elements(ttypes)-1 do begin
            key = 'TTYPE'+ strcompress(string(i),/remo)
            if keyword_set(use_colnum) then begin
               value = 'C'+strcompress(string(i),/remo)
           endif else begin
               value = ttypes[i]+' '
           endelse
           chk_and_upd, header, key, value
        endfor

        if (~keyword_set(no_comment)) then $
	    sxaddhist, [' ',' *** Column names ***',' '],header, $
	        /comment,location='TTYPE1'
     
    endif

    <span class="comments">; Write the TBCOL keywords.</span>

    for i=1, n_elements(ttypes)-1 do begin
        key= 'TBCOL'+strcompress(string(i),/remo)
        chk_and_upd, header, key, offsets[i]+1
    endfor

    if ~keyword_set(no_comment) then $
        sxaddhist,[' ',' *** Column offsets ***',' '],header,/comm, $
	           location = 'TBCOL1'

    <span class="comments">; Write the TFORM keywords</span>

    for i=1, n_elements(ttypes)-1 do begin
        key= 'TFORM'+strcompress(string(i),/remo)
        chk_and_upd, header, key, tforms[i]
    endfor

    if ~keyword_set(no_comment) then $
        sxaddhist,[' ',' *** Column formats ***',' '],header, $
	    /COMMENT, location = 'TFORM1'
 
    <span class="comments">; Write the header.</span>

    mwr_header, lun, header

    <span class="comments">;  Write out the data applying the field formats</span>

    totalFormat = "("+totalFormat+")"<span class="comments">;</span>
    
     strings = string(input, format=totalFormat)
     if keyword_set(terminator) then strings = strings+terminator
     writeu, lun, strings
 
    <span class="comments">; Check to see if any padding is required.</span>

    nbytes = long64(n_elements(input))*offset
    padding = 2880 - nbytes mod 2880
    if padding ne 0 then writeu, lun, replicate(32b, padding)
    
   return
end

<span class="comments">; Write a dummy primary header-data unit.</span>
<a id="mwr_dummy:source"></a>pro mwr_dummy, lun
     compile_opt idl2,hidden

    fxaddpar, header, 'SIMPLE', 'T','Dummy Created by MWRFITS v'+mwr_version()
    fxaddpar, header, 'BITPIX', 8, 'Dummy primary header created by MWRFITS'
    fxaddpar, header, 'NAXIS', 0, 'No data is associated with this header'
    fxaddpar, header, 'EXTEND', 'T', 'Extensions may (will!) be present'

    mwr_header, lun, header
end

<span class="comments">; Check if this is a valid pointer array for variable length data.</span>
<a id="mwr_validptr:source"></a>function mwr_validptr, vtypes, nfld, index, array
     compile_opt idl2,hidden
    
    type = -1
    offset = 0L
    for i=0, n_elements(array)-1 do begin
       if ptr_valid(array[i]) then begin
           
           sz = size(*array[i])
           if sz[0] gt 1 then begin
              print,'MWRFITS: Error: Multidimensional Pointer array'
              return, 0
           endif
           if type eq -1 then begin
              type = sz[sz[0] + 1]
           endif else begin
              if sz[sz[0] + 1] ne type then begin
                  print,'MWRFITS: Error: Inconsistent type in pointer array'
                  return, 0
              endif
           endelse
           xsz = sz[1]
           if sz[0] eq 0 then xsz = 1
           offset = offset + xsz
       endif
    endfor
    if type eq -1 then begin
        <span class="comments">; If there is no data assume an I*2 type</span>
       type = 2
    endif

    if  (type lt 1 || type gt 5) &&(type lt 12 || type gt 15) then begin
       print,'MWRFITS: Error: Unsupported type for variable length array'
    endif

    types = 'BIJED      IJKK'
    sizes = [1,2,4,4,8,0,0,0,0,0,0,2,4,8,8]
    
    if n_elements(vtypes) eq 0 then begin
       
        vtype = {status:0, data:array,           $
            type: strmid(types, type-1, 1),            $
            itype: type, ilen: sizes[type-1],          $
            offset:offset }
    
       vtypes = replicate(vtype, nfld)

    endif else begin
       <span class="comments">; This ensures compatible structures without</span>
       <span class="comments">; having to used named structures.</span>
       
       vtype = vtypes[0]
       vtype.status = 0
       vtype.data   = array
       vtype.type   = strmid(types, type-1, 1)
       vtype.itype  = type
       vtype.ilen   = sizes[type-1]
       vtype.offset = offset
       vtypes[index] = vtype
       
       
    endelse
    vtypes[index].status = 1<span class="comments">;</span>

    return, 1
end
       
<span class="comments">; Handle the header for a binary table.</span>
<a id="mwr_tablehdr:source"></a>pro mwr_tablehdr, lun, input, header, vtypes,     $
              no_types=no_types,                $
              logical_cols = logical_cols,         $
              bit_cols = bit_cols,                $
              nbit_cols= nbit_cols,             $
                no_comment=no_comment,            $
              alias=alias,                      $
              silent=silent,                     $
	      use_colnum = use_colnum
     compile_opt idl2,hidden

    if ~keyword_set(no_types) then no_types = 0

    nfld = n_tags(input[0])
    if nfld le 0 then begin
       print, 'MWRFITS Error: Input contains no structure fields.'
       return
    endif

    tags = tag_names(input)

    <span class="comments">; Get the number of rows in the table.</span>

    nrow = n_elements(input)

    dims    = lonarr(nfld)
    tdims   = strarr(nfld)
    types   = strarr(nfld)
    pointers= lonarr(nfld)

    <span class="comments">; offsets = null...  Don't want to define this</span>
    <span class="comments">; in advance since reference to ulon64 won't word with IDL &lt; 5.2</span>
    <span class="comments">;</span>
    <span class="comments">; Get the type and length of each column.  We do this</span>
    <span class="comments">; by examining the contents of the first row of the structure.</span>
    <span class="comments">;</span>

    nbyte = 0ULL

    islogical = bytarr(nfld)
    if keyword_set(logical_cols) then islogical[logical_cols-1] = 1b
   
    for i=0, nfld-1 do begin

       a = input[0].(i)

       sz = size(a)
       
       nelem    = sz[sz[0]+2]
       type_ele = sz[sz[0]+1]
       if type_ele EQ 7 then maxstr = max(strlen(input.(i)) > 1)
       
       if islogical[i]  then begin        
          if (type_ele EQ 1) then begin
          gg = (input.(i) EQ 0b) or (input.(i) EQ 84b) or (input.(i) EQ 0b) 
	       if ~array_equal(gg,1b) then begin 
	       islogical[i] = 0b
	       message,/CON, 'Warning - ' + $ 
	  "Allowed Logical Column byte values are byte('T'),byte('F'), or 0b"
	   endif
	endif else if (type_ele EQ 7) then begin   	  	 
           gg =  (input.(i) eq 'T') or (input.(i) eq 'F')
	       if ~array_equal(gg,1b) then begin
	       islogical[i] = 0b
	       message,/CON, 'Warning - ' + $ 
	  'Allowed Logical column string values are "T" and "F"'
	   endif
	endif else begin 
	    message,/CON, $
	    'Warning - Logical Columns must be of type string or byte'
	    islogical[i] = 0b
	 endelse   	  
       endif               
       dims[i] = nelem
       
        if (sz[0] lt 1) || (sz[0] eq 1 && type_ele ne 7) then begin
           tdims[i] = ''
       endif else begin
           tdims[i] = '('
           
           if type_ele eq 7 then begin
               tdims[i] = tdims[i] + strcompress(string(maxstr), /remo) + ','
           endif
           
           for j=1, sz[0] do begin
               tdims[i] = tdims[i] + strcompress(sz[j])
               if j ne sz[0] then tdims[i] = tdims[i] + ','
           endfor
           
           tdims[i] = tdims[i] + ')'
       endelse
             
       case type_ele of
          1:        begin
                     types[i] = 'B'
                     nbyte = nbyte + nelem
              end
          2:       begin
                         types[i] = 'I'
                     nbyte = nbyte + 2*nelem
              end
          3:       begin
                     types[i] = 'J'
                     nbyte = nbyte + 4*nelem
              end
          4:       begin
                        types[i] = 'E'
                     nbyte = nbyte + 4*nelem
               end
          5:       begin
                     types[i] = 'D'
                     nbyte = nbyte + 8*nelem
              end
          6:       begin
                        types[i] = 'C'
                     nbyte = nbyte + 8*nelem
              end
          7:       begin
                     maxstr = max(strlen(input.(i)) > 1 )
                     types[i] = 'A'
                     nbyte = nbyte + maxstr*nelem
                     dims[i] = maxstr*nelem		    
              end
          9:   begin
                       types[i] = 'M'
                     nbyte = nbyte + 16*nelem
              end

         10:   begin
                       if ~mwr_validptr(vtypes, nfld, i, input.(i)) then begin
                         return
                     endif
                     
                       types[i] = 'P'+vtypes[i].type
                     nbyte = nbyte + 8
                     dims[i] = 1

                     test = mwr_unsigned_offset(vtypes[i].itype)
                     if test gt 0 then begin
                         if (n_elements(offsets) lt 1) then begin
                             offsets = ulon64arr(nfld)
                         endif
                         offsets[i] = test
                     endif
                     
               end

         12:   begin
                      types[i] = 'I'
                     if (n_elements(offsets) lt 1) then begin
                         offsets = ulon64arr(nfld)
                     endif
                     offsets[i] = mwr_unsigned_offset(12)<span class="comments">;</span>
                     nbyte = nbyte + 2*nelem
              end

         13:   begin
                      types[i] = 'J'
                     if (n_elements(offsets) lt 1) then begin
                         offsets = ulon64arr(nfld)
                     endif
                     offsets[i] = mwr_unsigned_offset(13)<span class="comments">;</span>
                     nbyte = nbyte + 4*nelem
              end
              
                <span class="comments">; 8 byte integers became standard FITS in December 2005</span>
         14:   begin
                     types[i] = 'K'
                     nbyte = nbyte + 8*nelem
               end

         15:   begin
                      types[i] = 'K'
                     nbyte = nbyte + 8*nelem
                     if (n_elements(offsets) lt 1) then begin
                         offsets = ulon64arr(nfld)
                     endif
                     offsets[i] = mwr_unsigned_offset(15)
               end
                  
          0:   begin
                        print,'MWRFITS Error: Undefined structure element??'
                     return
              end
              
          8:   begin
                        print, 'MWRFITS Error: Nested structures'
                     return
              end
              
          else:begin
                        print, 'MWRFITS Error: Cannot parse structure'
                     return
              end
       endcase
    endfor

    <span class="comments">; Put in the required FITS keywords.</span>
    chk_and_upd, header, 'XTENSION', 'BINTABLE', 'Binary table written by MWRFITS v'+mwr_version()
    chk_and_upd, header, 'BITPIX', 8, 'Required value'
    chk_and_upd, header, 'NAXIS', 2, 'Required value'
    chk_and_upd, header, 'NAXIS1', nbyte, 'Number of bytes per row'
    chk_and_upd, header, 'NAXIS2', n_elements(input), 'Number of rows'
    chk_and_upd, header, 'PCOUNT', 0, 'Normally 0 (no varying arrays)'
    chk_and_upd, header, 'GCOUNT', 1, 'Required value'
    chk_and_upd, header, 'TFIELDS', nfld, 'Number of columns in table'

    <span class="comments">;</span>
    <span class="comments">; Handle the special cases.</span>
    <span class="comments">;</span>
    g = where(islogical,Nlogic)
    if Nlogic GT 0 then types[g] = 'L'
       
    if keyword_set(bit_cols) then begin
       nb = n_elements(bit_cols)
       if nb ne n_elements(nbit_cols) then begin
           print,'WARNING: Bit_cols and Nbit_cols not same size'
           print,'         No bit columns generated.'
          goto, after_bits
       endif
       for i = 0, nb-1 do begin
           nbyte = (nbit_cols[i]+7)/8
           icol = bit_cols[i]
           if types[icol-1] ne 'B'  || (dims[icol-1] ne nbyte) then begin
              print,'WARNING: Invalid attempt to create bit column:',icol
                    goto, next_bit
           endif
           types[icol-1] = 'X'
           tdims[icol-1] = ''
           dims[icol-1] = nbit_cols[i]
  next_bit:
       endfor
  after_bits:
    endif



    <span class="comments">; Write scaling info as needed.</span>
    if n_elements(offsets) gt 0 then begin
        w = where(offsets gt 0)

        for i=0, n_elements(w) - 1 do begin
            key = 'TSCAL'+strcompress(string(w[i])+1,/remo)
           chk_and_upd, header, key, 1
        endfor
    
        for i=0, n_elements(w) - 1 do begin
           key = 'TZERO'+strcompress(string(w[i]+1),/remo)
           chk_and_upd, header, key, offsets[w[i]]
        endfor
    
        if ~keyword_set(no_comment) then begin
            key = 'TSCAL'+strcompress(string(w[0])+1,/remo)
	   sxaddhist,[' ',' *** Unsigned integer column scalings *',' '], $
	        header,/COMMENT,location = key
    endif
    endif
  
    <span class="comments">; Now add in the TFORM keywords</span>
    for i=0, nfld-1 do begin
       if dims[i] eq 1 then begin
           form = types[i]
       endif else begin
           form=strcompress(string(dims[i]),/remove) + types[i]
        endelse
       
       tfld = 'TFORM'+strcompress(string(i+1),/remove)
       
       <span class="comments">; Check to see if there is an existing value for this keyword.</span>
       <span class="comments">; If it has the proper value we will not modify it.</span>
       <span class="comments">; This can matter if there is optional information coded</span>
       <span class="comments">; beyond required TFORM information.</span>
              
       oval = fxpar(header, tfld)
       oval = strcompress(string(oval),/remove_all)
       if (oval eq '0')  ||  (strmid(oval, 0, strlen(form)) ne form) then begin
           chk_and_upd, header, tfld, form
       endif
    endfor

    if ~keyword_set(no_comment) then $
        sxaddhist,[' ',' *** Column formats ***',' '],header, $
	    /COMMENT, location='TFORM1'
 
    <span class="comments">; Now write TDIM info as needed.</span>
    for i=nfld-1, 0,-1 do begin
        if tdims[i] ne '' then begin
            fxaddpar, header, 'TDIM'+strcompress(string(i+1),/remo), tdims[i],after=tfld
        endif
    endfor

    w=where(tdims ne '',N_tdims)
    if (N_tdims GT 0) && ~keyword_set(no_comment) then begin
        fxaddpar, header, 'COMMENT', ' ', after=tfld
        fxaddpar, header, 'COMMENT', ' *** Column dimensions (2 D or greater) ***', after=tfld
        fxaddpar, header, 'COMMENT', ' ', after=tfld
    endif

    for i=0, nfld-1 do begin
        if tdims[i] ne '' then begin
            chk_and_upd, header, 'TDIM'+strcompress(string(i+1),/remo), tdims[i]
        endif
    endfor

    if n_elements(vtypes) gt 0 then begin
        fxaddpar, header, 'THEAP', nbyte*n_elements(input), 'Offset of start of heap'
        offset = 0L
        for i=0,n_elements(vtypes)-1 do begin
           if vtypes[i].status then offset = offset + vtypes[i].offset*vtypes[i].ilen
        endfor
        fxaddpar, header, 'PCOUNT', offset, 'Size of heap'
    endif

    <span class="comments">;</span>
    <span class="comments">; Last add in the TTYPE keywords if desired.</span>
    <span class="comments">;</span>
    if ~no_types then begin
       for i=0, nfld - 1 do begin
           key = 'TTYPE'+strcompress(string(i+1),/remove)
           if ~keyword_set(use_colnum) then begin
               value= mwr_checktype(tags[i],alias=alias)
           endif else begin
               value = 'C'+strmid(key,5,2) + ' '
           endelse
          chk_and_upd, header, key, value, /nological
       endfor
       
        if ~keyword_set(no_comment) then $
	   sxaddhist,[' ',' *** Column names *** ',' '],header,/comment, $
	        location = 'TTYPE1'
     endif

    if ~keyword_set(no_comment) then begin
        fxaddpar, header, 'COMMENT', ' ', after='TFIELDS'
        fxaddpar, header, 'COMMENT', ' *** End of mandatory fields ***', after='TFIELDS'
        fxaddpar, header, 'COMMENT', ' ', after='TFIELDS'
    endif

    <span class="comments">; Write to the output device.</span>
    mwr_header, lun, header

end

<span class="comments">; Modify the structure to put the pointer column in.</span>
<a id="mwr_retable:source"></a>function mwr_retable, input, vtypes

     compile_opt idl2,hidden

    offset = 0L
    tags = tag_names(input)<span class="comments">;</span>
<span class="comments">;Create an output structure identical to the input structure but with pointers replaced</span>
<span class="comments">; by a 2 word lonarr to point to the heap area</span>

      if vtypes[0].status then begin
        output = CREATE_STRUCT(tags[0],lonarr(2))
      endif else begin
         output = CREATE_STRUCT(tags[0],input[0].(0))
      endelse
      for i=1, n_elements(tags) -1 do begin
         if vtypes[i].status then begin
           output = CREATE_STRUCT(temporary(output), tags[i], lonarr(2))
         endif else begin
           output = CREATE_STRUCT(temporary(output), tags[i], input[0].(i))
         endelse
      endfor
      output = replicate(temporary(output), N_elements(input) )
      struct_assign, input, output      <span class="comments">;Available since V5.1</span>

    for i=0, n_elements(tags)-1 do begin
       if vtypes[i].status then begin
           for j=0, n_elements(input)-1 do begin
              ptr = input[j].(i)
              if ptr_valid(ptr) then begin
                  sz = size(*ptr)
                  if sz[0] eq 0 then xsz = 1 else xsz= sz[1]

                  output[j].(i)[0] = xsz
                  output[j].(i)[1] = offset
                  
                  offset = offset + vtypes[i].ilen*xsz
              endif
           endfor
       endif
    endfor
    return,output
end

<span class="comments">; Write the heap data.</span>
<a id="mwr_writeheap:source"></a>function mwr_writeheap, lun, vtypes

    offset = 0L
    
    for i=0, n_elements(vtypes)-1 do begin
       if vtypes[i].status then begin
           
           itype = vtypes[i].itype
           unsigned = mwr_unsigned_offset(itype)
           
           ptrs = vtypes[i].data
           
           for j=0,n_elements(ptrs)-1 do begin
              if ptr_valid(ptrs[j]) then begin
                  if (unsigned gt 0) then begin
                     *ptrs[j] = *ptrs[j] + unsigned
                  endif

                      writeu, lun, *ptrs[j]
                  
                  sz = size(*ptrs[j])
                  xsz = 1 > sz[1]
                  offset = offset + xsz * vtypes[i].ilen
              endif
           endfor
       endif
    endfor

    return, offset
    
end

<span class="comments">; Write the brinary table.</span>
<a id="mwr_tabledat:source"></a>pro mwr_tabledat, lun, input, header, vtypes
     compile_opt idl2,hidden
    <span class="comments">;</span>
    <span class="comments">; file              -- unit to which data is to be written.</span>
    <span class="comments">; Input              -- IDL structure</span>
    <span class="comments">; Header       -- Filled header</span>

    nfld = n_tags(input)

    <span class="comments">; Any special processing?</span>

    typ = intarr(nfld)
    for i=0, nfld-1 do begin
        
        typ[i] = size(input.(i),/type)
	    if (typ[i] eq 7) then begin

             dim = size(input.(i),/dimen) >1
             siz = max(strlen(input.(i))) > 1
	     input.(i) = $
	        strmid( input.(i) + string(replicate(32b, siz)), 0, siz)

       endif
 
       unsigned = mwr_unsigned_offset(typ[i])
       if (unsigned gt 0) then begin
           input.(i) = input.(i) + unsigned
       endif
       
    endfor

    if n_elements(vtypes) gt 0 then begin
          
      
        input = mwr_retable(input, vtypes)
    endif

    <span class="comments">; Write the data segment.</span>
    <span class="comments">;</span>
    writeu, lun, input

    nbyte = long64(fxpar(header, 'NAXIS1'))
    nrow  = n_elements(input)

    heap = 0
    if n_elements(vtypes) gt 0 then $
        heap = mwr_writeheap(lun, vtypes)

    siz   = nbyte*nrow + heap
    padding = 2880 - (siz mod 2880)
    if padding eq 2880 then padding = 0

    <span class="comments">;</span>
    <span class="comments">; If necessary write the padding.</span>
    <span class="comments">;</span>
    if padding gt 0 then begin
        pad = bytarr(padding)  <span class="comments">; Should be null-filled by default.</span>
        writeu, lun, pad
    endif

end


<span class="comments">; Scale parameters for GROUPed data.</span>
<a id="mwr_pscale:source"></a>pro mwr_pscale, grp, header, pscale=pscale, pzero=pzero
     compile_opt idl2,hidden
    

<span class="comments">; This function assumes group is a 2-d array.</span>

    if ~keyword_set(pscale) && ~keyword_set(pzero) then return

    if ~keyword_set(pscale) then begin
        pscale = dblarr(sizg[1])
        pscale[*] = 1.
    endif

    w = where(pzero eq 0.d0)

    if w[0] ne 0 then begin
        print, 'MWRFITS  Warning: PSCALE value of 0 found, set to 1.'
        pscale[w] = 1.d0
    endif

    if keyword_set(pscale) then begin
        for i=0L, sizg[1]-1 do begin
            key= 'PSCAL' + strcompress(string(i+1),/remo)
            chk_and_upd, header, key, pscale[i]
        endfor
    endif

    if ~keyword_set(pzero) then begin
        pzero = dblarr(sizg[1])
        pzero[*] = 0.
    endif else begin
        for i=0L, sizg[1]-1 do begin
            key= 'PZERO' + strcompress(string(i+1),/remo)
            chk_and_upd, header, key, pscale[i]
        endfor
    endelse

    for i=0L, sizg[1]-1 do begin
        grp[i,*] = grp[i,*]/pscale[i] - pzero[i]
    endfor

end


<span class="comments">; Find the appropriate scaling parameters.</span>
<a id="mwr_findscale:source"></a>pro mwr_findscale, flag, array, nbits, scale, offset, error

     compile_opt idl2,hidden

    error = 0
    if n_elements(flag) eq 2 then begin
         scale  = double(flag[0])
        offset = double(flag[1])
    endif else if n_elements(flag) eq 1 and flag[0] ne 1 then begin
         minmum = min(array, max=maxmum)
        offset = 0.d0
        scale  = double(flag[0])
    endif else if n_elements(flag) ne 1 then begin
         print, 'MWRFITS Error: Invalid scaling parameters.'
        error  = 1
        return
    endif else begin
        
         minmum = min(array, max=maxmum)
        scale  = (maxmum-minmum)/(2.d0^nbits)
        amin   = -(2.d0^(nbits-1))
        if (amin gt -130) then amin = 0  <span class="comments">; looking for -128</span>
        offset = minmum - scale*amin
        
    endelse
    return
end

<span class="comments">; Scale and possibly convert array according to information</span>
<span class="comments">; in flags.</span>
<a id="mwr_scale:source"></a>pro mwr_scale, array, scale, offset, lscale=lscale, iscale=iscale,  $
   bscale=bscale, null=null

     compile_opt idl2,hidden

    <span class="comments">; First deallocate scale and offset</span>
    if n_elements(scale)  gt 0 then xx = temporary(scale)
    if n_elements(offset) gt 0 then xx = temporary(offset)

    if ~keyword_set(lscale) && ~keyword_set(iscale) &&  $
       ~keyword_set(bscale) then return

    siz = size(array)
    if keyword_set(lscale) then begin

        <span class="comments">; Doesn't make sense to scale data that can be stored exactly.</span>
        if siz[siz[0]+1] lt 4 then return
        amin = -2.d0^31
        amax = -(amin + 1)
    
        mwr_findscale, lscale, array, 32, scale, offset, error

    endif else if keyword_set(iscale) then begin
        if siz[siz[0]+1] lt 3 then return
        amin = -2.d0^15
        amax = -(amin + 1)
    
        mwr_findscale, iscale, array, 16, scale, offset, error

    endif else begin
        if siz[siz[0]+1] lt 2 then return
    
        amin = 0
        amax = 255
    
        mwr_findscale, bscale, array, 8, scale, offset, error
    endelse

    <span class="comments">; Check that there was no error in mwr_findscale</span>
    if error gt 0 then return

    if scale le 0.d0 then begin
        print, 'MWRFITS Error: BSCALE/TSCAL=0'
        return
    endif

    array = round((array-offset)/scale)

    w = where(array gt amax)
    if w[0] ne -1 then $
        array[w] = keyword_set(null) ? null : amax
 
    w = where(array lt amin)
    if w[0] ne -1 then $
        array[w] = keyword_set(null) ? null : amin
 
    if keyword_set(lscale) then      array = long(array) $
    else if keyword_set(iscale) then array = fix(array)  $
    else                             array = byte(array)
    
end

<span class="comments">; Write a header</span>
<a id="mwr_header:source"></a>pro mwr_header, lun, header

     compile_opt idl2,hidden
    <span class="comments">; Fill strings to at least 80 characters and then truncate.</span>

    space = string(replicate(32b, 80))
    header = strmid(header+space, 0, 80)

    w = where(strcmp(header,"END     ",8), Nw)

    if Nw eq 0 then begin

       header = [header, strmid("END"+space,0,80)]
       
    endif else begin
        if (Nw gt 1) then begin 
           <span class="comments">; Get rid of extra end keywords;</span>
           print,"MWRFITS Warning: multiple END keywords found."
           for irec=0L, n_elements(w)-2 do begin
              header[w[irec]] = strmid('COMMENT INVALID END REPLACED'+  $
                space, 0, 80)
           endfor
       endif

       <span class="comments">; Truncate header array at END keyword.</span>
       header = header[0:w[n_elements(w)-1]]
    endelse

    nrec = n_elements(header)
    if nrec mod 36 ne 0 then header = [header, replicate(space,36 - nrec mod 36)]

    writeu, lun, byte(header)
end


<span class="comments">; Move the group information within the data.</span>
<a id="mwr_groupinfix:source"></a>pro mwr_groupinfix, data, group, hdr
     compile_opt idl2,hidden

    siz = size(data)
    sizg = size(group)

    <span class="comments">; Check if group info is same type as data </span>

    if siz[siz[0]+1] ne sizg[3] then begin
        case siz[siz[0]+1] of
         1: begin
               mwr_groupscale, 127.d0, group, hdr
               group = byte(group)
           end
         2: begin
               mwr_groupscale, 32767.d0, group, hdr
               group = fix(group)
           end
         3: begin
               mwr_groupscale, 2147483647.d0, group, hdr
               group = long(group)
           end
         4: group = float(group)
         5: group = double(group)
      else: begin
                print,'MWRFITS Internal error: Conversion of group data'
               return
            end
        endcase
    endif

    nrow = 1
    for i=1, siz[0]-1 do begin
        nrow = nrow*siz[i]
    endfor

    data = reform(data, siz[siz[0]+2])
    for i=0L, siz[siz[0]] - 1 do begin
        if i eq 0 then begin
            gdata = group[*,0]
           gdata = reform(gdata)
            tdata = [ gdata , data[0:nrow-1]]
        endif else begin
            start = nrow*i
           fin = start+nrow-1
           gdata = group[*,i]
            tdata = [tdata, gdata ,data[start:fin]]
       endelse
    endfor

    data = temporary(tdata)
end

<span class="comments">; If an array is being scaled to integer type, then</span>
<span class="comments">; check to see if the group parameters will exceed the maximum</span>
<span class="comments">; values allowed.  If so scale them and update the header.</span>
<a id="mwr_groupscale:source"></a>pro mwr_groupscale, maxval, group, hdr
     compile_opt idl2,hidden

    sz = size(group)
    for i=0L, sz[1]-1 do begin
         pmax = max(abs(group[i,*]))
         if (pmax gt maxval) then begin
             ratio = pmax/maxval
            psc = 'PSCAL'+strcompress(string(i+1),/remo)
            currat = fxpar(hdr, psc)
            if (currat ne 0) then begin
                fxaddpar, hdr, psc, currat*ratio, 'Scaling overriden by MWRFITS'
            endif else begin
                fxaddpar, hdr, psc, ratio, ' Scaling added by MWRFITS'
            endelse
             group[i,*] = group[i,*]/ratio
         endif
    endfor
end
        
        
<span class="comments">; Write out header and image for IMAGE extensions and primary arrays.</span>
<a id="mwr_image:source"></a>pro mwr_image, input, siz, lun, bof, hdr,       $
       null=null,                              $
       group=group,                            $
       pscale=pscale, pzero=pzero,             $
       lscale=lscale, iscale=iscale,              $
       bscale=bscale,                          $
        no_comment=no_comment,                  $
       silent=silent


    compile_opt idl2,hidden
    type = siz[siz[0] + 1]

    bitpixes=[8,8,16,32,-32,-64,-32,0,0,-64,0,0,16,32,64,64]

    <span class="comments">; Convert complexes to two element real array.</span>

    if type eq 6 || type eq 9 then begin
 
        if ~keyword_set(silent) then begin
            print, "MWRFITS Note: Complex numbers treated as arrays"
        endif
    
        array_dimen=(2)
        if siz[0] gt 0 then array_dimen=[array_dimen, siz[1:siz[0]]] 
        if siz[siz[0]+1] eq 6 then data = float(input,0,array_dimen)  $
        else data = double(input,0,array_dimen)

    <span class="comments">; Convert strings to bytes.</span>
    endif else if type eq 7 then begin
        data = input
        len = max(strlen(input))
        if len eq 0 then begin
            print, 'MWRFITS Error: strings all have zero length'
           return
        endif

        for i=0L, n_elements(input)-1 do begin
            t = len - strlen(input[i])
           if t gt 0 then input[i] = input[i] + string(replicate(32B, len))
        endfor
    
        <span class="comments">; Note that byte operation works on strings in a special way</span>
        <span class="comments">; so we don't go through the subterfuge we tried above.</span>
    
        data = byte(data)
    
    endif else if n_elements(input) gt 0 then data = input


    <span class="comments">; Do any scaling of the data.</span>
    mwr_scale, data, scalval, offsetval, lscale=lscale, $
      iscale=iscale, bscale=bscale, null=null

    <span class="comments">; This may have changed the type.</span>
    siz  = size(data)
    type = siz[siz[0]+1]


    <span class="comments">; If grouped data scale the group parameters.</span>
    if keyword_set(group) then mwr_pscale, group, hdr, pscale=pscale, pzero=pzero

    if bof then begin
        chk_and_upd, hdr, 'SIMPLE', 'T','Primary Header created by MWRFITS v'+mwr_version()
        chk_and_upd, hdr, 'BITPIX', bitpixes[type]
        chk_and_upd, hdr, 'NAXIS', siz[0]
        chk_and_upd, hdr, 'EXTEND', 'T', 'Extensions may be present'
    endif else begin
        chk_and_upd, hdr, 'XTENSION', 'IMAGE','Image Extension created by MWRFITS v'+mwr_version()
        chk_and_upd, hdr, 'BITPIX', bitpixes[type]
        chk_and_upd, hdr, 'NAXIS', siz[0]
        chk_and_upd, hdr, 'PCOUNT', 0
        chk_and_upd, hdr, 'GCOUNT', 1
    endelse


    if keyword_set(group) then begin
        group_offset = 1
    endif else group_offset = 0

    if keyword_set(group) then begin
       chk_and_upd, hdr, 'NAXIS1', 0
    endif

    for i=1L, siz[0]-group_offset do begin
        chk_and_upd, hdr, 'NAXIS'+strcompress(string(i+group_offset),/remo), siz[i]
    endfor


    if keyword_set(group) then begin
        chk_and_upd, hdr, 'GROUPS', 'T'
        sizg = size(group)
        if sizg[0] ne 2 then begin
            print,'MWRFITS Error: Group data is not 2-d array'
           return
        endif
        if sizg[2] ne siz[siz[0]] then begin
            print,'MWRFITS Error: Group data has wrong number of rows'
           return
        endif
        chk_and_upd,hdr,  'PCOUNT', sizg[1]
        chk_and_upd, hdr, 'GCOUNT', siz[siz[0]]
    endif
    
    if n_elements(scalval) gt 0 then begin
    
        chk_and_upd, hdr, 'BSCALE', scalval
        chk_and_upd, hdr, 'BZERO', offsetval
    
    endif else begin
       
       <span class="comments">; Handle unsigned offsets</span>
       bzero = mwr_unsigned_offset(type)
       if bzero gt 0 then begin
           chk_and_upd,hdr,'BSCALE', 1
           chk_and_upd, hdr, 'BZERO', bzero
           data += bzero
        endif
       
    endelse

    if keyword_set(group) then begin
        if keyword_set(pscale) then begin
            if n_elements(pscale) ne sizg[1] then begin
               print, 'MWRFITS Warning: wrong number of PSCALE values'
           endif else begin
                for i=1L, sizg[1] do begin
                    chk_and_upd, hdr, 'PSCALE'+strcompress(string(i),/remo)
               endfor
           endelse
        endif
        if keyword_set(pzero) then begin
            if n_elements(pscale) ne sizg[1] then begin
               print, 'MWRFITS Warning: Wrong number of PSCALE values'
           endif else begin
                for i=1L, sizg[1] do begin
                    chk_and_upd, hdr, 'PZERO'+strcompress(string(i),/remo)
               endfor
           endelse
        endif
    endif

    bytpix=abs(bitpixes[siz[siz[0]+1]])/8             <span class="comments">; Number of bytes per pixel.</span>
    npixel = n_elements(data) + n_elements(group)     <span class="comments">; Number of pixels.</span>

    if keyword_set(group) then mwr_groupinfix, data, group, hdr

    <span class="comments">; Write the FITS header</span>
    mwr_header, lun, hdr

    <span class="comments">; This is all we need to do if input is undefined.</span>
    if (n_elements(input) eq 0) || (siz[0] eq 0) then return

    <span class="comments">; Write the data.</span>
    writeu, lun, data

    nbytes = bytpix*npixel
    filler = 2880 - nbytes mod 2880
    if filler eq 2880 then filler = 0
  
    <span class="comments">; Write any needed filler.</span>
    if filler gt 0 then writeu, lun, replicate(0B,filler)
end


<span class="comments">; Main routine -- see documentation at start</span>
<a id="mwrfits:source"></a>pro mwrfits, xinput, file, header,              $
        ascii=ascii,                            $
       separator=separator,                    $
       terminator=terminator,                  $
       create=create,                          $
       null=null,                              $
       group=group,                            $
       pscale=pscale, pzero=pzero,             $
       alias=alias,                            $
       use_colnum = use_colnum,                $
       lscale=lscale, iscale=iscale,              $
       bscale=bscale,                          $
       no_types=no_types,                      $
       silent=silent,                          $
       no_comment=no_comment,                  $
       logical_cols=logical_cols,              $
       bit_cols=bit_cols,                      $
       nbit_cols=nbit_cols,                    $
       status = status,                        $
       version=version


    <span class="comments">; Check required keywords.</span>
    compile_opt idl2
    status = -1                     <span class="comments">;Status changes to 0 upon completion</span>
    if (keyword_set(Version)) then begin
        print, "MWRFITS V"+mwr_version()+":  October 12, 2012"
    endif

    if n_elements(file) eq 0 then begin
        if ~keyword_set(Version) then begin
            print, 'MWRFITS: Usage:'
            print, '    MWRFITS, struct_name, file, [header,] '
            print, '             /CREATE, /SILENT, /NO_TYPES, /NO_COMMENT, '
            print, '             GROUP=, PSCALE=, PZERO=,'
            print, '             LSCALE=, ISCALE=, BSCALE=,'
            print, '             LOGICAL_COLS=, BIT_COLS=, NBIT_COLS=,'
            print, '             ASCII=, SEPARATOR=, TERMINATOR=, NULL='
           print, '             /USE_COLNUM, ALIAS=, STATUS='
        endif
        return
    endif


    <span class="comments">; Save the data into an array/structure that we can modify.</span>
 
    if n_elements(xinput) gt 0 then input = xinput

    on_ioerror, open_error

    <span class="comments">; Open the input file.    If it exists, and the /CREATE keyword is not </span>
    <span class="comments">; specified, then we append to to the existing file.</span>
     <span class="comments">;</span>

    if  ~keyword_set(create) && file_test(file) then begin
        openu, lun, file, /get_lun, /append,/swap_if_little
        if ~keyword_set(silent) then $
	    message,/inf,'Appending FITS extension to file ' + file
        bof = 0
    endif else begin 
        openw, lun, file, /get_lun, /swap_if_little
         bof = 1
    endelse 	 
    on_ioerror, null


    siz = size(input) 
     if siz[siz[0]+1] ne 8 then begin

        <span class="comments">; If input is not a structure then call image writing utilities.</span>
        mwr_image, input, siz, lun, bof, header,    $
         null=null,                              $
         group=group,                            $
         pscale=pscale, pzero=pzero,             $
         lscale=lscale, iscale=iscale,              $
         bscale=bscale,                          $
         no_comment=no_comment,                  $
         silent=silent

    endif else if keyword_set(ascii) then begin

        if bof then mwr_dummy, lun
        <span class="comments">; Create an ASCII table.</span>
	mwr_ascii, input, siz, lun, bof, header,     $
         ascii=ascii,                             $
         null=null,                               $
         use_colnum = use_colnum,                 $
         lscale=lscale, iscale=iscale,               $
         bscale=bscale,                           $
         no_types=no_types,                      $
         separator=separator,                     $
         terminator=terminator,                   $
         no_comment=no_comment,                   $
         alias=alias,                             $
         silent=silent

    endif else begin

        if bof then mwr_dummy, lun

        <span class="comments">; Create a binary table.</span>
        mwr_tablehdr, lun, input, header, vtypes,    $
          no_types=no_types,                        $
          logical_cols = logical_cols,                    $
          bit_cols = bit_cols,                           $
          nbit_cols= nbit_cols,                     $
          alias=alias,                              $
          no_comment=no_comment,                    $
	  silent=silent,                             $
	  use_colnum = use_colnum
       
        mwr_tabledat, lun, input, header, vtypes

    endelse

    free_lun, lun
    status=0
    return
    
    <span class="comments">; Handle error in opening file.</span>
  open_error:
    on_ioerror, null
    print, 'MWRFITS Error: Cannot open output: ', file
	 print,!ERROR_STATE.SYS_MSG
    if n_elements(lun) gt 0 then free_lun, lun
    
    return
end
</code>
    </div>
  </body>
</html>