<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:38 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gaussian.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gaussian.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="gaussian:source"></a>function gaussian, xi, parms, pderiv, DOUBLE=double
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       GAUSSIAN</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Compute the 1-d Gaussian function and optionally the derivative</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Compute the 1-D Gaussian function and optionally the derivative </span>
<span class="comments">;       at an array of points.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       y = gaussian( xi, parms,[ pderiv ])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       xi = array, independent variable of Gaussian function.</span>
<span class="comments">;</span>
<span class="comments">;       parms = parameters of Gaussian, 2, 3 or 4 element array:</span>
<span class="comments">;               parms[0] = maximum value (factor) of Gaussian,</span>
<span class="comments">;               parms[1] = mean value (center) of Gaussian,</span>
<span class="comments">;               parms[2] = standard deviation (sigma) of Gaussian.</span>
<span class="comments">;               (if parms has only 2 elements then sigma taken from previous</span>
<span class="comments">;               call to gaussian(), which is stored in a  common block).</span>
<span class="comments">;               parms[3] = optional, constant offset added to Gaussian.</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       y -  Function returns array of Gaussian evaluated at xi.    Values will</span>
<span class="comments">;            be floating pt. (even if xi is double) unless the /DOUBLE keyword</span>
<span class="comments">;            is set.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       /DOUBLE - set this keyword to return double precision for both</span>
<span class="comments">;             the function values and (optionally) the partial derivatives.</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       pderiv = [N,3] or [N,4] output array of partial derivatives,</span>
<span class="comments">;               computed only if parameter is present in call.</span>
<span class="comments">;</span>
<span class="comments">;               pderiv[*,i] = partial derivative at all xi absisca values</span>
<span class="comments">;               with respect to parms[i], i=0,1,2,[3].</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Evaulate a Gaussian centered at x=0, with sigma=1, and a peak value</span>
<span class="comments">;       of 10 at the points 0.5 and 1.5.   Also compute the derivative</span>
<span class="comments">;</span>
<span class="comments">;       IDL> f = gaussian( [0.5,1.5], [10,0,1], DERIV )</span>
<span class="comments">;       ==> f= [8.825,3.25].   DERIV will be a 2 x 3 array containing the</span>
<span class="comments">;       numerical derivative at the two points with respect to the 3 parameters.</span>
<span class="comments">; </span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       None</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1992.</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Use machar() for machine precision, added /DOUBLE keyword,</span>
<span class="comments">;       add optional constant 4th parameter    W. Landsman   November 2001</span>
<span class="comments">;-</span>
  On_error,2
  common gaussian, sigma

  if N_params() LT 2 then begin
        print,'Syntax - y = GAUSSIAN( xi, parms,[ pderiv, /DOUBLE ])'
        print,'         parms[0] = maximum value (factor) of Gaussian'
        print,'         parms[1] = mean value (center) of Gaussian'
        print,'         parms[2] = standard deviation (sigma) of Gaussian'
        print,'         parms[3] = optional constant to be added to Gaussian'
        return, -1
  endif

  common gaussian, sigma

        Nparmg = N_elements( parms )
        npts = N_elements(xi) 
        ptype = size(parms,/type)
        if (ptype LE 3) or (ptype GE 12) then parms = float(parms)
        if (Nparmg GE 3) then sigma = parms[2]

        double = keyword_set(DOUBLE)
        if double then $       <span class="comments">;Double precision?</span>
            gauss = dblarr( npts ) else $
            gauss = fltarr( npts )
 
        z = ( xi - parms[1] )/sigma
        zz = z*z

<span class="comments">; Get smallest value expressible on computer.   Set lower values to 0 to avoid</span>
<span class="comments">; floating underflow</span>
        minexp = alog((machar(DOUBLE=double)).xmin)     
 
        w = where( zz LT -2*minexp, nw )
        if (nw GT 0) then gauss[w] = exp( -zz[w] / 2 )

        if N_params() GE 3 then begin

                if double then $ 
                pderiv = dblarr( npts, Nparmg ) else $
                pderiv = fltarr( npts, Nparmg )
                fsig = parms[0] / sigma

                pderiv[0,0] = gauss
                pderiv[0,1] = gauss * z * fsig

                if (Nparmg GE 3) then  pderiv[0,2] = gauss * zz * fsig
                if (Nparmg GE 4) then  pderiv[0,3] = replicate(1, npts)
           endif

 if Nparmg LT 4 then return, parms[0] * gauss else $
                     return, parms[0] * gauss + parms[3]
 end
</code>
    </div>
  </body>
</html>