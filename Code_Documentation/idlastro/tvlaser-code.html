<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:10 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tvlaser.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tvlaser.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO TVLASER, hdr, Image, BARPOS=BarPos, CARROWS=CArrows, CLABELS=CLabels, $
	COLORPS=ColorPS, COMMENTS=Comments, CSIZE=CSize, CTITLE=CTitle, $
 	DX=dX, DY=dY, ENCAP=encap, FILENAME=filename, HEADER=Header, HELP=Help,$
	IMAGEOut=ImageOut, INTERP=Interp, MAGNIFY=Magnify, NoClose=noclose, $
        NODELETE=NoDelete, NO_PERS_INFO=No_Pers_Info, NOEIGHT=NoEight, $ 
        NOPRINT=NoPrint, NORETAIN = NoRetain, PORTRAIT=Portrait, $
        PRINTER = Printer, REVERSE=Reverse, SCALE=Scale, TITLE=Title, $
        XSTART=XStart, YSTART=YStart, XDIM=XDim, YDIM=YDim, $
        TrueColor=TrueColor, BOTTOMDW=bottomdw, NCOLORSDW=ncolorsdw
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      TVLASER</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Prints screen or image array onto a Postscript file or printer.</span>
<span class="comments">;      Information from FITS header is optionally used for labeling.  </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:     </span>
<span class="comments">;      TVLASER, [header, Image, BARPOS = ,CARROWS =, CLABELS = ,/COLORPS, </span>
<span class="comments">;             COMMENTS = ,CSIZE = ,CTITLE = , DX = , DY =, /ENCAP, FILENAME =</span>
<span class="comments">;             HEADER = ,/HELP, IMAGEOUT = ,/INTERP, /MAGNIFY, /NoCLOSE, </span>
<span class="comments">;             /NoDELETE, /NO_PERS_INFO, /NoEIGHT, /NoPRINT, /NoRETAIN, </span>
<span class="comments">;             /PORTRAIT, PRINTER = , /REVERSE, /SCALE, TITLE = , /TrueColor, </span>
<span class="comments">;             XDIM=, XSTART=, YDIM=, YSTART=, BOTTOMDW=, NCOLORSDW= ]	</span>
<span class="comments">;</span>
<span class="comments">;       Note that the calling sequence was changed in May 1997</span>
<span class="comments">; OPTIONAL INPUTS: </span>
<span class="comments">;       HEADER - FITS header string array.   Object and astrometric info from</span>
<span class="comments">;               the FITS header will be used for labeling, if available</span>
<span class="comments">;       IMAGE - if an array is passed through this parameter, then this image</span>
<span class="comments">;               will be used rather than reading off the current window.  This</span>
<span class="comments">;		allows easy use of large images.     It is usually preferable</span>
<span class="comments">;               to optimally byte scale IMAGE before supplying it to TVLASER   </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT PARAMETERS: </span>
<span class="comments">;       BARPOS - A four- or five-element vector giving the position and</span>
<span class="comments">;            orientation of the color bar.  The first four elements</span>
<span class="comments">;            [X0,Y0,XSize,YSize] indicate the position and size of the color</span>
<span class="comments">;            bar in INCHES, relative to origin of the displayed image.</span>
<span class="comments">;            (X0,Y0) are the position of the lower left corner and </span>
<span class="comments">;            (XSize,YSize) are the width and height.  The fifth element is</span>
<span class="comments">;            optional, and if present, the color bar will be printed</span>
<span class="comments">;            horizontally rather than vertically.  If BARPOS is set to</span>
<span class="comments">;            anything but a four- or five-element vector, the bar is NOT</span>
<span class="comments">;            printed.  The default value is BARPOS = [-0.25, 0.0, 0.2, 2.0] </span>
<span class="comments">;       BOTTOMDW - The lowest value to use in building the density</span>
<span class="comments">;            wedge.  Used with NCOLORSDW.  Compatible with BOTTOM and</span>
<span class="comments">;            NCOLORS keywords of XLOADCT.</span>
<span class="comments">;       CARROWS - The color to print the North-East arrows.  Default is dark.</span>
<span class="comments">;            Three types of values can be passed:</span>
<span class="comments">;                 SCALAR: that value's color in the current color table</span>
<span class="comments">;                 3-ELEMENT VECTOR: the color will be [R,G,B]</span>
<span class="comments">;                 STRING: A letter indicating the color.  Valid names are:  </span>
<span class="comments">;                 'W' (white), 'D' (dark/black), 'R' (red),    'G' (green), </span>
<span class="comments">;                 'B' (blue),  'T' (turquoise),  'V' (violet), 'Y' (yellow), </span>
<span class="comments">;             If the keyword is set to a value of -1, the arrows are</span>
<span class="comments">;             NOT printed.</span>
<span class="comments">;       COLORPS - If present and non-zero, the idl.ps file is written using</span>
<span class="comments">;             color postscript.</span>
<span class="comments">;       COMMENTS - A string that will be included in the comment line below the</span>
<span class="comments">;                image.  For multi-line comments you can either use "!C" in the</span>
<span class="comments">;                string as a carriage return {although the vertical spacing</span>
<span class="comments">;                might be a little off} or, preferably, make the COMMENTS a</span>
<span class="comments">;                string array with each line as a separate element. </span>
<span class="comments">;       CLABELS - Color to print the labels, same format as for CARROWS.</span>
<span class="comments">;       CSIZE - Color to print the size-scale bar and label, same format as for</span>
<span class="comments">;                CARROWS.</span>
<span class="comments">;       CTITLE - Color to print the title, same format as for CARROWS.</span>
<span class="comments">;       DX,DY - offsets in INCHES added to the position of the figure on the</span>
<span class="comments">;               paper.  As is the case for the device keywords XOFFSET and</span>
<span class="comments">;               YOFFSET, when in landscape mode DX and DY are the same</span>
<span class="comments">;               *relative to the paper*, not relative to the plot (e.g., DX is</span>
<span class="comments">;               the horizontal offset in portrait mode, but the *vertical*</span>
<span class="comments">;               offset in landscape mode).</span>
<span class="comments">;       ENCAP - If present and non-zero, the IDL.PS file is written in</span>
<span class="comments">;               encapsulated postscript for import into LaTeX documents</span>
<span class="comments">;       FILENAME - scalar string giving name of output postscript file.</span>
<span class="comments">;               Default is idl.ps.   Automatically sets /NODELETE</span>
<span class="comments">;       HEADER = FITS header.   This is an alternative to supplying the FITS</span>
<span class="comments">;                header in the first parameter.</span>
<span class="comments">;       HELP - print out the sytax for this procedure.</span>
<span class="comments">;       INTERP - If present and non-zero, current color table will be</span>
<span class="comments">;                interpolated to fill the full range of the PostScript color</span>
<span class="comments">;                table (256 colors).  Otherwise, the current color table will be</span>
<span class="comments">;                directly copied.   You probably will want to use this if you</span>
<span class="comments">;                are using IMAGE keyword and a shared color table.</span>
<span class="comments">;       MAGNIFY - The net magnification of the entire figure.  At this point,</span>
<span class="comments">;                the figure is not automatically centered on the paper if the</span>
<span class="comments">;                value of MAGNIFY is not equal to 1, but the DX and DY keywords</span>
<span class="comments">;                can be used to shift location.  For example, to fit a full plot</span>
<span class="comments">;                on the printable area (8.5x8.5 inches) of the Tek PhaserIISD</span>
<span class="comments">;                color printer use:  MAGNIFY=0.8, DX=0.5, DY=0.5.;       </span>
<span class="comments">;       NCOLORSDW - The number of values to include in the density</span>
<span class="comments">;                wedge.  Used with BOTTOMDW.  Compatible with</span>
<span class="comments">;                BOTTOM/NCOLORS keywords of XLOADCT.</span>
<span class="comments">;       NoCLOSE - If present and non-zero, then the postscript file is not</span>
<span class="comments">;             closed (or printed), the device is set to 'PS', and the data </span>
<span class="comments">;             coordinate system is set to match the image size.  This allows the</span>
<span class="comments">;             user to add additional plotting commands before printing.  For </span>
<span class="comments">;             example, to include a 15 pixel circle around a source at </span>
<span class="comments">;             coordinates (150,160), around an image, im, with FITS header </span>
<span class="comments">;             array, h</span>
<span class="comments">;</span>
<span class="comments">;                IDL> tvlaser,h,im,/NoClose      ;Write image & annotation</span>
<span class="comments">;                IDL> tvcircle,15,150,160,/data  ;Draw circle</span>
<span class="comments">;                IDL> device,/close              ;Close postscript file & print</span>
<span class="comments">;</span>
<span class="comments">;       NoDELETE - If present and non-zero, the postscript file is kept AND is </span>
<span class="comments">;                 also sent to the printer</span>
<span class="comments">;       NoEIGHT - if set then only four bits sent to printer (saves space)</span>
<span class="comments">;       NO_PERS_INFO - if present and non-zero, output notation will NOT</span>
<span class="comments">;                 include date/user block of information.</span>
<span class="comments">;       NoPRINT - If present and non-zero, the output is sent to a file (default</span>
<span class="comments">;                name 'idl.ps'), which is NOT deleted and is NOT sent to the </span>
<span class="comments">;                printer.</span>
<span class="comments">;       NoRETAIN - In order to avoid possible problems when using TVRD with</span>
<span class="comments">;                 an obscured window, TVLASER will first copy the current window</span>
<span class="comments">;                 to a temporary RETAIN=2 window.    Set /NORETAIN to skip this</span>
<span class="comments">;                 step and improve performance</span>
<span class="comments">;       PORTRAIT - if present and non-zero, the printer results will be in</span>
<span class="comments">;                 portrait format; otherwise, they will be in landscape format.</span>
<span class="comments">;                 If labels are requested, image will be in portrait mode,</span>
<span class="comments">;                 regardless</span>
<span class="comments">;       PRINTER - scalar string giving the OS command to send a the postscript</span>
<span class="comments">;               file to the printer.   Under Unix, the default value of PRINTER</span>
<span class="comments">;               is 'lpr ' while for other OS it is 'print ' </span>
<span class="comments">;       REVERSE - if present and non-zero, color table will be fliped, so black</span>
<span class="comments">;               and white are reversed.</span>
<span class="comments">;       SCALE - if present and non-zero, image will be bytscaled before being</span>
<span class="comments">;               sent to postscript file.      </span>
<span class="comments">;       TITLE - if present and non-zero, the string entered here will be the</span>
<span class="comments">;               title of the picture.  Default is the OBJECT field in the</span>
<span class="comments">;               header (if present).</span>
<span class="comments">;       TRUECOLOR - if present and non-zero, the postscript file is created</span>
<span class="comments">;               using the truecolor switch (i.e. true=3). The colorbar is</span>
<span class="comments">;               not displayed in this mode.  </span>
<span class="comments">;       XDIM,YDIM - Number of pixels.  Default is from !d.x_size and !d.y_size,</span>
<span class="comments">;               or size of image if passed with IMAGE keyword.</span>
<span class="comments">;       XSTART,YSTART - lower left corner (default of (0,0))</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD OUTPUT PARAMETER</span>
<span class="comments">;        IMAGEOUT = the image byte array actually sent to the postscript file.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS: </span>
<span class="comments">;        A postscript file is created in the current directory.  User must have </span>
<span class="comments">;        write privileges in the current directory.  The file is named idl.ps</span>
<span class="comments">;        unless the FILENAME keyword is given.   The file is directed to the</span>
<span class="comments">;        printer unless the /ENCAP, /NoCLOSE, or /NOPRINT keywords are given.</span>
<span class="comments">;        After printing, the file is deleted unless the /NODELETE or FILENAME </span>
<span class="comments">;        keywords are given. </span>
<span class="comments">; PROCEDURE:  </span>
<span class="comments">;       Read display or take IMAGE and then redisplay into a postscript file.</span>
<span class="comments">;       If a header exists, printout header information.  If header has</span>
<span class="comments">;       astrometry, then print out orientation and scale information.</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;        ARROWS, EXTAST, FDECOMP, GETROT, PIXCOLOR, SXPAR(), XYAD, ZPARCHECK</span>
<span class="comments">;</span>
<span class="comments">;*EXAMPLE:</span>
<span class="comments">;       1) Send a true color image (xsize,ysize,3) to a printer (i.e. print23l),</span>
<span class="comments">;                tvlaser,huv,cpic,/colorps,/truecolor,printer="print23l"</span>
<span class="comments">;                % TVLASER: Now printing image: $print23l idl.ps</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:     </span>
<span class="comments">;       Major rewrite from UIT version   W. Landsman   Dec 94</span>
<span class="comments">;       Massive rewrite.  Added North-East arrows, pixel scale bar, color bar,</span>
<span class="comments">;       and keywords DX, DY, MAGNIFY, INTERP, HELP, and COMMENTS.</span>
<span class="comments">;       Created ablility to define colors for annotation and</span>
<span class="comments">;       text.  Repositioned text labels.     J.Wm.Parker, HITC, 5/95</span>
<span class="comments">;       Make Header and Image parameters instead of keywords.   Add PRINTER</span>
<span class="comments">;       keyword.   Include alternate FITS keywords.   W. Landsman May 97      </span>
<span class="comments">;       Copy to a RETAIN=2 window, work without FITS header W. Landsman June 97</span>
<span class="comments">;       Cleaner output when no astrometry in header  W. Landsman  June 97</span>
<span class="comments">;       Added /INFO to final MESSAGE  W. Landsman   July 1997</span>
<span class="comments">;       12/4/97	jkf/acc	- added TrueColor optional keyword.</span>
<span class="comments">;       Added /NoClose keyword, trim Equinox format  W. Landsman 9-Jul-1998</span>
<span class="comments">;       Don't display coordinate labels if no astrometry, more flexible</span>
<span class="comments">;       formatting of exposure time W. Landsman 30-Aug-1998</span>
<span class="comments">;       BottomDW and NColorsDW added.  R. S. Hill, 1-Mar-1999</span>
<span class="comments">;       Apply func tab to color bar if not colorps.  RSH, 21 Mar 2000</span>
<span class="comments">;       Fix problem with /NOCLOSE and unequal X,Y sizes  W. Landsman Feb 2001</span>
<span class="comments">;       Use TVRD(True=3) if /TRUECOLOR set    W. Landsman   November 2001</span>
<span class="comments">;       More synonyms, check for header supplied W. Landsman November 2007</span>
<span class="comments">;-</span>
 compile_opt idl2
 on_error,2

 if keyword_set(Help) then begin
   print, 'Syntax:  TVLASER, [ Header, Image ]'
   print, 'Keywords:  BARPOS= ,CARROWS= , CLABELS= ,/COLOPS, COMMENTS= ,'
   print, '           CSIZE= , CTITLE= , DX= , DY= , /ENCAP, FILENAME= ,'
   print, '           HEADER= ,/HELP, IMAGEOUT= , /INTERP, /MAGNIFY,/NoCLOSE ,'
   print, '           /NoDELETE, NO_PERS_INFO, /NoEIGHT, /NoPRINT, /NORETAIN,'
   print, '           /PORTRAIT,PRINTER=,/REVERSE, /SCALE, TITLE= , /TRUECOLOR,' 
   print, '           XDIM= ,XSTART=, YDIM= , YSTART= ] '
   print, '   '        
   return
 endif

<span class="comments">;----------------------------;</span>
<span class="comments">;  SECTION:  INITIALIZATION  ;</span>
<span class="comments">;----------------------------;</span>

<span class="comments">;;;</span>
<span class="comments">;   Save some info and set some variables.  LogoDir may need to be changed</span>
<span class="comments">; depending on where the GIF logos are.</span>
<span class="comments">;</span>
 sv_device = !D.NAME
 sv_color = !P.Color
 if !D.NAME EQ 'PS' then set_plot,'X'     <span class="comments">;Return to X terminal</span>
 tvlct,sv_rr,sv_gg,sv_bb,/get

 if keyword_set(NoEight)  THEN NBits = 4 ELSE NBits = 8
 if keyword_set(Portrait) THEN Lands = 0 ELSE Lands = 1
 ColorPS  = keyword_set(ColorPS)
 Encap    = keyword_set(Encap)
 NoPrint  = keyword_set(NoPrint)
 NoDelete = keyword_set(NoDelete)
 TrueColor= keyword_set(TrueColor)
 if TrueColor then TrueValue =3 else TrueValue =0
 
 if N_elements(hdr) EQ 0 then $
	if N_elements(header) NE 0 then hdr = header
 if (N_params() GE 1) and (N_elements(hdr) EQ 0) then message,/INF, $
        'Warning - No valid FITS header supplied'	
 if N_elements(hdr) NE 0 then zparcheck,'TVLASER',hdr,1,7,1,'FITS image header'
<span class="comments">;;;</span>
<span class="comments">;   If no image was passed in the IMAGE keyword, then we will be reading the</span>
<span class="comments">; image from the screen.  Default values are to start at 0,0 and read the</span>
<span class="comments">; entire window.</span>
<span class="comments">;</span>
 FromTV = N_elements(Image) eq 0
 if FromTV then begin
   if !D.WINDOW EQ -1 then begin
	tvlaser,/help
	return
   endif
   message,'Reading image from window ' + strtrim(!D.WINDOW,2) + $
        ' ... Please be patient', /INF
   if not keyword_set(XStart) then XStart = 0
   if not keyword_set(YStart) then YStart = 0
   if not keyword_set(XDim) then XDim = !d.x_size
   if not keyword_set(YDim) then YDim = !d.y_size
   if not keyword_set(noretain) then begin
	chan = !D.WINDOW
	xsize = !D.X_SIZE & ysize = !D.Y_SIZE
	window,/free,xsize=xsize,ysize=ysize
	wset,!D.WINDOW
	device,copy=[0,0,xsize,ysize,0,0,chan]
   endif
   ImageOut = tvrd(XStart,YStart,XDim,YDim,true = truevalue)
   if not keyword_set(noretain) then begin
	wdelete,!D.WINDOW
	wset,chan
   endif
 endif else begin
   XStart = 0
   YStart = 0
   XDim   = (size(Image))[1]
   YDim   = (size(Image))[2]
   ImageOut = Image
 endelse
<span class="comments">;;;</span>
<span class="comments">;   YSpace is used to scale the vertical spacing of text and the title.</span>
<span class="comments">;</span>
 YSpace  = (float(Xdim) / Ydim) > 1.              <span class="comments">;Modified December 1994 WBL</span>
 XSpace  = (float(Ydim) / Xdim) > 1.

<span class="comments">;;;</span>
<span class="comments">;   If using B/W PostScript, use NTSC color -> B/W formula, J Brinkmann</span>
<span class="comments">;   Scale and/or reverse if desired.</span>
<span class="comments">;</span>
 if not(ColorPS) then ImageOut = $
   0.299 * sv_rr[ImageOut] + 0.587 * sv_gg[ImageOut] + 0.114 * sv_bb[ImageOut]
 if keyword_set(Scale)   then ImageOut = bytscl(ImageOut)
 if keyword_set(Reverse) then ImageOut = 255b - temporary(ImageOut)

<span class="comments">;;;</span>
<span class="comments">;   If a header is given, put in portrait mode regardless. </span>
<span class="comments">;</span>
 if N_elements(hdr) NE 0 then Lands = 0

<span class="comments">;;;</span>
<span class="comments">;   Set up colors for density wedge.</span>
<span class="comments">;</span>
 if N_elements(BottomDW) LE 0 then BottomDW = 0
 nc = !D.table_size - BottomDW
 if n_elements(NColors) GT 0 then nc = nc &lt<span class="comments">; ncolors</span>
 if nc LE 0 then begin
   message, /INFO, 'Bad color spec; using default'
   BottomDW = 0
   nc = !D.table_size
 endif


<span class="comments">;------------------------------;</span>
<span class="comments">;  SECTION:  POSTSCRIPT SETUP  ;</span>
<span class="comments">;------------------------------;</span>

<span class="comments">;;;</span>
<span class="comments">;   Redirect output to Postscript printer file, which may be printed.</span>
<span class="comments">;   Size of image is restricted to 7.5 inches in the paper's narrow direction</span>
<span class="comments">; for MAGNIFY=1.  If we will be printing out header info, then restrict the</span>
<span class="comments">; Y size to be no more than 7.5 also.</span>
<span class="comments">;</span>
if (Lands eq 1) then begin
   inx = 10.0
   iny = float(YDim)/float(XDim)*float(inx)
   if (iny gt 7.5) then begin
     iny = 7.5
     inx = (float(XDim)/float(YDim))*float(iny)
   endif
 endif

 if (Lands eq 0) then begin
   if N_elements(hdr) NE 0 then iny = 7.5 else iny = 10.0
   inx = float(XDim)/float(YDim)*float(iny)
   if (inx gt 7.5) then begin
     inx = 7.5
     iny = (float(YDim)/float(XDim))*float(inx)
   endif
 endif

<span class="comments">;;;</span>
<span class="comments">;   Some info for the user, and setting the filename.</span>
<span class="comments">;</span>
 pstype = ' '
 if Encap then pstype = pstype + 'encapsulated '
 if ColorPS then pstype = pstype + 'color '
 if not keyword_set(filename) then fname = 'idl.ps' else begin
   fdecomp,filename,disk,dir,name,ext
   if ext EQ '' then ext = 'ps'
   fname = disk + dir + name + '.' + ext
   NoDelete = 1
 endelse 
 if keyword_set(NoDelete) or keyword_set(EnCap) or keyword_set(NoPrint) then $ 
 message,'Writing image to' + pstype + 'postscript file ' + fname, /INF

<span class="comments">;;;</span>
<span class="comments">;   Set plot to the PostScript printer.  Set all the device keywords.</span>
<span class="comments">;</span>
set_plot, 'ps', INTERPOLATE=keyword_set(Interp)
sv_font = !P.FONT
!p.font = 0

 if not keyword_set(dX) then dX = 0
 if not keyword_set(dY) then dY = 0

 XOff =  0.75 + dX
 YOff = 10.25 + dY
 if Lands then begin
   device, /landscape
   YOff = inx + ((11 - inx) / 2.0) + dY   <span class="comments">; centered</span>
 endif else begin
   device, /portrait
   YOff = Yoff - iny
 endelse

 device, xsize=inx, ysize=iny, xoffset=XOff, yoffset=YOff, /inches, $
   bits=NBits, filename=fname, /helvetica, encapsulated=Encap, color=ColorPS

 if keyword_set(Magnify) then device, scale=Magnify else device, scale=1


<span class="comments">;-----------------------;</span>
<span class="comments">;  SECTION:  TV OUTPUT  ;</span>
<span class="comments">;-----------------------;</span>

 tv, ImageOut,true=TrueValue

<span class="comments">;   If the BarPos keyword has four or five elements, then show the color bar.</span>

 if (not(TrueValue)) then begin 
   if (N_elements(BarPos) eq 0) then BarPos = [-0.25, 0.0, 0.2, 2.0]
   NumEls = N_elements(BarPos)
   if ( (NumEls eq 4) or (NumEls eq 5) ) then begin
    ColorBar = byte(round(congrid(findgen(nc)+BottomDW, 256))) $
       # make_array(20,val=1b)
    if not(ColorPS) then $
       ColorBar = 0.299 * sv_rr[ColorBar] + 0.587 * sv_gg[ColorBar] $
                  + 0.114 * sv_bb[ColorBar]
    ColorBar[0:*,[0,19]]  = 0
    ColorBar[[0,255],0:*] = 0
    if (NumEls eq 4) then ColorBar = transpose(ColorBar)
    tv, ColorBar, BarPos[0],BarPos[1], xsize=BarPos[2],ysize=BarPos[3], /INCHES
   endif
 endif

<span class="comments">;;;</span>
<span class="comments">;   Now that the image has been displayed with the desired color table, we will </span>
<span class="comments">; play with the color table a bit to get the appropriate colors for the text,</span>
<span class="comments">; arrows, and scale bar.  The three RGB values for each one will be loaded into</span>
<span class="comments">; vectors called things like 'CArrowsRGBN', 'CSizeRGBN', etc.  The last value</span>
<span class="comments">; in this vector will be the location of that color in the color table.</span>
<span class="comments">;   "Colors" is a string array of the keyword names, then via the EXECUTE</span>
<span class="comments">; function, we determine what the content of each variable is: a string to be</span>
<span class="comments">; used inthe pixcolor procedure, a single number indicating the location in the</span>
<span class="comments">; current color table, or a 3-element vector with RGB values.  One reason for</span>
<span class="comments">; doing it this way, is that if more objects to be colored are added to the</span>
<span class="comments">; keywords, only the variable COLORS need be changed here by adding those</span>
<span class="comments">; keyword names.</span>
<span class="comments">;   "Val" is where we will be temporarily putting the new colors (usually in</span>
<span class="comments">; the bottom bin).</span>
<span class="comments">;</span>
 Colors = ['CArrows','CSize','CTitle','CLabels']
 r_new = bytarr(n_elements(Colors))
 g_new = r_new
 b_new = r_new

 for N=0,(n_elements(Colors) -1) do begin
  tvlct, sv_rr, sv_gg, sv_bb
  Val = 0

  dummy = execute( 'NumEls = n_elements(' + Colors[N] + ')' )
  if (NumEls eq 0) then begin
    dummy = execute( Colors[N] + ' = "D"' )
    NumEls = 1
  endif
  dummy = execute( 'C = ' + Colors[N] )
  if (NumEls eq 1) then begin  <span class="comments">; string or color value</span>
    if ((size(C))[1] eq 7) then pixcolor, Val, C else Val = C
  endif else begin
    if (NumEls eq 3) then tvlct,transpose(C) else pixcolor, Val, 'D'
  endelse

  tvlct, r, g, b, /get
  if (Val[0] ne -1) then begin
     r_new[N] = r[Val]
     g_new[N] = g[Val]
     b_new[N] = b[Val]
     dummy = execute(Colors[N]+'RGBN = [r[Val],g[Val],b[Val],N]')
  endif
endfor

 tvlct, r_new, g_new, b_new


<span class="comments">;-------------------------------;</span>
<span class="comments">;  SECTION:  HEADER and LABELS  ;</span>
<span class="comments">;-------------------------------;</span>

<span class="comments">;;;</span>
<span class="comments">;   If a FITS header was given then include whatever of the following FITS</span>
<span class="comments">; keywords that are present as annotation:  OBJECT (becomes the title if none</span>
<span class="comments">; given), TELESCOP, IMAGE, EXPTIME, EQUINOX, CRVAL1 (Right Ascension), CRVAL2</span>
<span class="comments">; (Declination), NAXIS1, NAXIS2, CD (Rotation angle and pixel size), PDSDATIM</span>
<span class="comments">; (Date of Microdensitometry).  Also will include the name of the user and the</span>
<span class="comments">; current date.  Some blocks can be suppressed...see description of keywords</span>
<span class="comments">; above.  Also prints directional arrows and scale.</span>
<span class="comments">;  </span>
if (N_elements(Hdr) NE 0) then begin
 

<span class="comments">;;;</span>
<span class="comments">;   Does the header have astrometry?</span>
<span class="comments">;</span>
  extast, hdr, astr, NoAstrom
  if NoAstrom GT 0 then begin
    ast_type = strmid( strupcase( strtrim(astr.ctype[0],2) ), 0 ,4)
    if  ((ast_type NE 'RA--') and (ast_type NE 'GLON') and $ <span class="comments">;Valid projection?</span>
         (ast_type NE 'ELAT') ) then NoAstrom = -1
  endif
	
  if (NoAstrom LT 0) then begin
    rga      = 'N/A'
    decl     = 'N/A'
    equi     = ''
    ROTATE   = 'N/A'
    CDELT    = [0.0,0.0]
    CDELTAS  = 'N/A'
  endif else begin
    xcen = (XDim-XStart-1)/2.
    ycen = (YDim-YStart-1)/2.
    if FromTV then zoom_xy,xcen,ycen <span class="comments">;In case TV image has non-zero zoom or roam</span>
    xyad,hdr, xcen, ycen, ra_cen, dec_cen
    str = adstring(ra_cen,dec_cen,1)
    rga = strmid( str, 1, 11)
    decl = strmid( str, 14, 11)
    equi = sxpar( hdr, 'EQUINOX', Count = N_equi)
    if N_equi EQ 0 then equi = '' else $ 
              equi = '(' + strmid(strtrim(equi,2),0,7) + ')'
    getrot, hdr ,ROTATE, CDELT
    ROTATE  = strtrim(string(ROTATE,  format='(f7.2)'),2) + ' degrees'
    CDELT   = abs(CDELT*60.*60.)
    if CDELT[0] LT 0.1 then fmt = '(f7.3)' else fmt = '(f7.2)'
    CDELTAS = strtrim(string(CDELT[0],format=fmt ),2)
    if (abs(CDELT[0] - CDELT[1]) GT 0.05*CDELT[0]) THEN $
       CDELTAS = CDELTAS + ' by ' + strtrim(string(CDELT[1],format=fmt),2)
    CDELTAS = CDELTAS + ' arcsec/pixel'
  endelse

<span class="comments">;;;</span>
<span class="comments">;   Printout the image information?  YSpace is used to scale the spacing of the</span>
<span class="comments">; linformation lines in NORMAL units.  dY is one line height.  LabXs and LabYs</span>
<span class="comments">; are arrays that define the placement of Label/Value pairs in the NORMAL</span>
<span class="comments">; coordinates.  So to increment to the next line, simply use:</span>
<span class="comments">;   LabYs = LabYs + dY</span>
<span class="comments">;</span>
if (strtrim(CLabels[0],2) ne '-1') then begin
    dY     = -0.025 * YSpace
    LabYs  = [-0.05, -0.05] * YSpace
    LabX1s = [ 0.01,  0.21] * XSpace
    LabX2s = [ 0.64,  0.74] * XSpace

<span class="comments">;;;</span>
<span class="comments">;  Set the label color and print out each label/value.</span>
<span class="comments">;</span>
  !P.Color = CLabelsRGBN[3]

<span class="comments">;OBJECT</span>
    OBJ = strtrim( sxpar(hdr,'OBJECT', Count = N_Obj),2 )
    if N_Obj EQ 0 then begin 
    OBJ = strtrim( sxpar( hdr,'TARGNAME', Count = N_Obj),2)
    if N_Obj EQ 0 then OBJ = 'N/A'
    endif
    XYOUTS, LabX1s, LabYs, ['OBJECT:',OBJ],/ NORMAL
    LabYs = LabYs + dY

<span class="comments">;TITLE (set here, but print out later in case no header was given)</span>
    if NOT keyword_set(TITLE) then begin
      if (N_Obj NE 0) then TITLE=OBJ else TITLE = ''
    endif 

<span class="comments">;IMAGE ID</span>
    imname = 'N/A'
    imname = sxpar(hdr,'IMAGE', Count = N_image)
    if N_image EQ 0 then imname = sxpar(hdr,'EXPNAME', Count = N_image)
    if N_image EQ 0 then imname = sxpar(hdr,'OBS_ID', Count = N_image)
    if N_image EQ 0 then imname = sxpar(hdr,'ROOTNAME', Count = N_image)
    imname = strtrim(imname,2)
 
  
    XYOUTS,LabX1s,LabYs,['IMAGE:',IMNAME],/NORMAL
    LabYs = LabYs + dY

  LabYs = LabYs + dY

<span class="comments">;TELESCOPE</span>
    scop = sxpar( hdr,'INSTRUME', Count = N_Scop)
    if N_Scop EQ 0 then scop = sxpar( hdr,'TELESCOP', Count = N_Scop)
    if N_Scop EQ 0 then scop = sxpar( hdr,'OBSERVAT', Count = N_Scop)
    if N_Scop EQ 0 then scop = '' else scop = strtrim(scop,2)
    detector = sxpar( hdr,'DETECTOR', Count = N_det)
    if N_det EQ 0 then detector = '' else detector = strtrim(detector,2)
    if scop EQ '' then scop = detector else $
    if detector NE '' then scop = scop + '/' + detector
    XYOUTS,LabX1s,LabYs,['INSTRUMENT:',scop],/NORMAL

<span class="comments">;SIZE</span>
    SIZ = strtrim(XDim,2) +' by ' + strtrim(YDim,2) + ' pixels'
    XYOUTS,LabX2s,LabYs,['SIZE:',SIZ],/NORMAL
    LabYs = LabYs + dY

<span class="comments">;FILTER</span>
    filter = sxpar(hdr, 'FILTER', Count= N_filter)
    if N_filter EQ 0 then filter = sxpar(hdr, 'FILTNAM1', Count= N_filter)
    if N_filter EQ 0 then filter = sxpar(hdr, 'FILTER1', Count= N_filter)
    if N_filter EQ 0 then FILTER = 'N/A' else filter = strtrim(filter,2)
    XYOUTS,LabX1s,LabYs,['CAMERA/FILTER:',FILTER],/NORMAL

<span class="comments">;SCALE</span>
    if NoAstrom GE 0 then XYOUTS,LabX2s,LabYs,['SCALE:',CDELTAS],/NORMAL
    LabYs = LabYs + dY

<span class="comments">;EXPOSURE TIME   First try 'EXPTIME' then 'EXPOSURE' then 'INTEG'</span>
    exptime = sxpar(hdr, 'EXPTIME', Count = N_time)
    if N_time EQ 0 then exptime = sxpar(hdr, 'EXPOSURE', Count = N_time)
    if N_time EQ 0 then exptime = sxpar(hdr, 'INTEG', Count = N_time)
    if N_time EQ 0 then exptime = 'N/A' else $
	exptime = strmid( strtrim(exptime,2),0,6) + ' seconds'
    XYOUTS,LabX1s,LabYs,['EXPOSURE TIME:',EXPTIME],/NORMAL	
    LabYs = LabYs + dY

    LabYs = LabYs + dY

    if noastrom GE 0 then begin
<span class="comments">;CENTER COORDINATES</span>
    XYOUTS, LabX1s, LabYs,['CENTER '+ equi + ':', $
     'RA = ' + RGA + '    DEC = ' + DECL], /NORMAL
    LabYs = LabYs + dY

<span class="comments">;ROTATION</span>
    XYOUTS,LabX1s,LabYs,['ROTATION:',strtrim(ROTATE,2)],/NORMAL
    LabYs = LabYs + dY
    endif



<span class="comments">;COMMENTS</span>
    if keyword_set(Comments) then begin
      XYOUTS,LabX1s[0],LabYs[0],'COMMENTS:',/NORMAL
      for N=0,(n_elements(Comments)-1) do $
        XYOUTS,LabX1s[1],(LabYs[1] + (dY * N)),Comments[N],/NORMAL
    endif
    LabYs = LabYs + dY

<span class="comments">;USER and DATE/TIME</span>
    if not keyword_set(No_pers_info) then begin
      XYOUTS, LabX2s[0],LabYs[0], GetEnv('USER') + '  (' + $
      STRMID(systime(),4,20) + ')' ,SIZE=0.9, /NORMAL
    endif

  endif


<span class="comments">;ARROWS</span>
<span class="comments">;   The calculations AX and XY allow the smallest use of space for the arrows</span>
<span class="comments">; for all possible rotation angles.  To test the extent of the circle, add</span>
<span class="comments">; code like the following in before the "R = float(..." line:</span>
<span class="comments">;   hextract,ImageOut,h,i1,h1,0,5,0,5 & for N=0,18 do begin</span>
<span class="comments">;   hrot,i1,h1,i2,h2,N*20,-1,-1,0  & getrot, h2 ,Rotate</span>
<span class="comments">;</span>
  if ((strtrim(CArrows[0],2) ne '-1') and (NoAstrom ne -1)) then begin
    R = float(rotate) * !pi / 180
    AX = ( 0.50 + (0.05 * (cos(R) + sin(R)))) * XSpace
    AY = (-0.10 - (0.05 * (cos(R) - sin(R)))) * YSpace

    !P.Font  = -1
    !P.Color = CArrowsRGBN[3]
    arrows, hdr, AX, AY, /NORMAL, FONT=13, COLOR=!P.Color, arrowlen=3, charsize=2
    !P.Font  = 0
  endif 


<span class="comments">;SIZE SCALE BAR</span>
<span class="comments">;   This is probably more complicated than necessary, but the idea is to find</span>
<span class="comments">; the best size scale bar for any image, where the scale may be a few arcsec</span>
<span class="comments">; or a few degrees.</span>
<span class="comments">;   "BarLength" is the length of a 1 arcsecond bar in normal coordinates</span>
<span class="comments">;   "BarScale" is the list of standard sizes for the bar in arcsec or arcmin.</span>
<span class="comments">;   "BarLength" is the length in normal coordiates of the "best" scale bar.</span>
<span class="comments">;</span>
  if ((strtrim(CSize[0],2) ne '-1') and (NoAstrom ne -1)) then begin
    BarLength = 1.0 / (CDelt[0] * XDim)
    BarScale = [1,2,3,5,10,15,20,25,30,40]
    MinBar   = 0.1 * XSpace

    BS = where((BarLength * BarScale) gt MinBar)        <span class="comments">; bar scale in arcsec?</span>
    if (BS[0] ne -1) then begin
      BarLength = BarLength * BarScale[BS[0]]
      BarLabel  = strtrim(BarScale[BS[0]], 2) + '"'
    endif else begin
      BS = where((BarLength * BarScale * 60) gt MinBar) <span class="comments">; bar scale in arcmin?</span>
      if (BS[0] ne -1) then begin
        BarLength = BarLength * BarScale[BS[0]] * 60
        BarLabel  = strtrim(BarScale[BS[0]], 2) + "'"
      endif else begin
        BarLength = BarLength * 3600
        BarLabel  = '1 degree'
      endelse
    endelse

<span class="comments">;    Barlength = BarLength * XSpace</span>
    BarX      =   0.7 * XSpace             <span class="comments">; left end of bar</span>
    BarY      = -0.03 * YSpace             <span class="comments">; Y position of bar</span>
    BarDY     = 0.01 * [-1,1] * YSpace     <span class="comments">; height of bar's endpoints</span>
    LabY      = BarY - (0.025 * YSpace)    <span class="comments">; position of label</span>

    !P.Color = CSizeRGBN[3]
    plots, BarX+[0,BarLength], [BarY,BarY], /NORMAL
    plots, [BarX,BarX], BarY+BarDY, /NORMAL
    plots, BarLength+[BarX,BarX], BarY+BarDY,/NORMAL
    xyouts, ((BarX + (BarX + BarLength)) / 2.0), LabY, /NORMAL, ALIGN=0.5, $
      '!6'+BarLabel+'!X', FONT=-1

  endif

endif 

<span class="comments">;;;</span>
<span class="comments">; TITLE  (handle here in case no header was given but TITLE keyword was used.)</span>
<span class="comments">;</span>
 if (keyword_set(TITLE) and (strtrim(CTitle[0],2) ne '-1')) then begin
   !P.Color = CTitleRGBN[3]
   XYOUTS, 0.50*XSpace, 1+(0.01*YSpace), TITLE,SIZE=2.0, /NORMAL, ALIGN=0.5
 endif

 if keyword_set(NoClose) then begin
       plot,[0,xdim-1],[0,ydim-1],/noerase,xsty=5,ysty=5,/nodata, $
       pos = [0,0,1,1]
       return
 endif 

 Device,/close

<span class="comments">;-------------------------------;</span>
<span class="comments">;  SECTION:  PRINTING THE FILE  ;</span>
<span class="comments">;-------------------------------;</span>

 if not(NoPrint or Encap) then begin        <span class="comments">;Should the file be printed out?</span>
 if not keyword_set(PRINTER) then begin
	 case !VERSION.OS_FAMILY of
	 'unix': printer = 'lpr'
	 else: printer = 'print'
	 endcase
 endif
 spawn,printer + ' ' + fname
 message,/INFO,'Now printing image: $' + printer + ' ' + fname
 endif

<span class="comments">;  Reset output direction to X-windows, and restore some variables.</span>

 tvlct,sv_rr,sv_gg,sv_bb
 set_plot, sv_device
 !P.font = sv_font
 !P.Color = sv_color

 return
 end
</code>
    </div>
  </body>
</html>