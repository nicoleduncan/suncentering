<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:12 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>wcsxy2sph.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="wcsxy2sph.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      WCSXY2SPH</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Convert x and y (map) coordinates to spherical coordinates</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;      To convert x and y (map) coordinates to spherical (longitude and</span>
<span class="comments">;      latitude or sky) coordinates.    This procedure is the inverse of</span>
<span class="comments">;      WCSSPH2XY.</span>
<span class="comments">;</span>
<span class="comments">;     This is a lower level procedure -- given a FITS header, the user will</span>
<span class="comments">;     usually use XYAD which will then call WCSXY2SPH with the appropriate</span>
<span class="comments">;     parameters.</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;      Mapping and Auxilary FITS Routine</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;      wcsxy2sph, x, y, longitude, latitude, [map_type], [ CTYPE = ,$</span>
<span class="comments">;             FACE = ,PV2 = ,CRVAL =, CRXY =, LONGPOLE=, LATPOLE=]</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       x - x coordinate of data, scalar or vector, in degrees, NOTE: x</span>
<span class="comments">;               increases to the left, not the right</span>
<span class="comments">;       y - y coordinate of data, same number of elements as x, in degrees</span>
<span class="comments">;       map_type - optional positional parameter, scalar corresponding to a</span>
<span class="comments">;               particular map projection.  This is not a FITS standard, it is</span>
<span class="comments">;               simply put in to allow function similar to that of less general</span>
<span class="comments">;               map projection procedures (eg AITOFF).  The following list gives</span>
<span class="comments">;               the map projection types and their respective numbers.</span>
<span class="comments">;</span>
<span class="comments">;  FITS  Number  Name                       Comments</span>
<span class="comments">;  code   code</span>
<span class="comments">;  ----  ------  -----------------------    -----------------------------------</span>
<span class="comments">;   DEF     0    Default = Cartesian</span>
<span class="comments">;   AZP     1    Zenithal perspective       pv2_1 required</span>
<span class="comments">;   TAN     2    Gnomic                     AZP w/ pv2_1 = 0</span>
<span class="comments">;   SIN     3    Orthographic               pv2_1, pv2_2 optional</span>
<span class="comments">;   STG     4    Stereographic              AZP w/ pv2_1 = 1</span>
<span class="comments">;   ARC     5    Zenithal Equidistant</span>
<span class="comments">;   ZPN     6    Zenithal polynomial        PV2_0, PV2_1....PV2_20 possible</span>
<span class="comments">;   ZEA     7    Zenithal equal area</span>
<span class="comments">;   AIR     8    Airy                       pv2_1 required</span>
<span class="comments">;   CYP     9    Cylindrical perspective    pv2_1 and pv2_2 required</span>
<span class="comments">;   CAR    10    Cartesian</span>
<span class="comments">;   MER    11    Mercator</span>
<span class="comments">;   CEA    12    Cylindrical equal area     pv2_1 required</span>
<span class="comments">;   COP    13    Conical perspective        pv2_1 and pv2_2 required</span>
<span class="comments">;   COD    14    Conical equidistant        pv2_1 and pv2_2 required</span>
<span class="comments">;   COE    15    Conical equal area         pv2_1 and pv2_2 required</span>
<span class="comments">;   COO    16    Conical orthomorphic       pv2_1 and pv2_2 required</span>
<span class="comments">;   BON    17    Bonne's equal area         pv2_1 required</span>
<span class="comments">;   PCO    18    Polyconic</span>
<span class="comments">;   SFL    19    Sanson-Flamsteed</span>
<span class="comments">;   PAR    20    Parabolic</span>
<span class="comments">;   AIT    21    Hammer-Aitoff</span>
<span class="comments">;   MOL    22    Mollweide</span>
<span class="comments">;   CSC    23    Cobe Quadrilateralized     inverse converges poorly</span>
<span class="comments">;                Spherical Cube</span>
<span class="comments">;   QCS    24    Quadrilateralized</span>
<span class="comments">;                Spherical Cube</span>
<span class="comments">;   TSC    25    Tangential Spherical Cube</span>
<span class="comments">;   SZP    26    Slant Zenithal perspective  PV2_1,PV2_2, PV2_3 optional</span>
<span class="comments">;   HPX    27    HealPix</span>
<span class="comments">;   HCT    28    HealCart (Cartesian approximation of Healpix)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       CTYPE - One, two, or three element vector containing 8 character</span>
<span class="comments">;               strings corresponding to the CTYPE1, CTYPE2, and CTYPE3</span>
<span class="comments">;               FITS keywords:</span>
<span class="comments">;</span>
<span class="comments">;               CTYPE[0] - first four characters specify standard system</span>
<span class="comments">;               ('RA--','GLON' or 'ELON' for right ascension, galactic</span>
<span class="comments">;               longitude or ecliptic longitude respectively), second four</span>
<span class="comments">;               letters specify the type of map projection (eg '-AIT' for</span>
<span class="comments">;               Aitoff projection)</span>
<span class="comments">;               CTYPE[1] - first four characters specify standard system</span>
<span class="comments">;               ('DEC-','GLAT' or 'ELAT' for declination, galactic latitude</span>
<span class="comments">;               or ecliptic latitude respectively; these must match</span>
<span class="comments">;               the appropriate system of ctype1), second four letters of</span>
<span class="comments">;               ctype2 must match second four letters of ctype1.</span>
<span class="comments">;               CTYPE[2] - if present must be the 8 character string,'CUBEFACE',</span>
<span class="comments">;                only used for spherical cube projections to identify an axis</span>
<span class="comments">;               as containing the face on which each x and y pair of</span>
<span class="comments">;               coordinates lie.</span>
<span class="comments">;       FACE - a input variable used for spherical cube projections to</span>
<span class="comments">;               designate the face of the cube on which the x and y</span>
<span class="comments">;               coordinates lie.   Must contain the same number of elements</span>
<span class="comments">;               as X and Y.</span>
<span class="comments">;       CRVAL - 2 element vector containing standard system coordinates (the</span>
<span class="comments">;               longitude and latitude) of the reference point</span>
<span class="comments">;       CRXY - 2 element vector giving the x and y coordinates of the</span>
<span class="comments">;               reference point, if this is not set the offset of the x</span>
<span class="comments">;               coordinate is assumed to be 0.</span>
<span class="comments">;       LATPOLE -  native latitude of the standard system's North Pole</span>
<span class="comments">;       LONGPOLE - native longitude of standard system's North Pole, default</span>
<span class="comments">;               is 180 degrees, numeric scalar</span>
<span class="comments">;       PV2  - Vector of projection parameter associated with latitude axis</span>
<span class="comments">;             PV2 will have up to 21 elements for the ZPN projection, up to 3</span>
<span class="comments">;             for the SIN projection and no more than 2 for any other</span>
<span class="comments">;             projection.   The first element corresponds to PV2_1, the</span>
<span class="comments">;             second to PV2_2, etc.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       longitude - longitude of data, same number of elements as x, in degrees</span>
<span class="comments">;       latitude - latitude of data, same number of elements as x, in degrees</span>
<span class="comments">;</span>
<span class="comments">;       Longitude and latitude will be set to NaN, wherever elements of X,Y</span>
<span class="comments">;       have no corresponding longitude, latitude values.</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The conventions followed here are described in more detail in the paper</span>
<span class="comments">;      "Representations of Celestial Coordinates in FITS" by Calabretta &</span>
<span class="comments">;       Greisen (2002, A&A, 395, 1077, also see</span>
<span class="comments">;       http://fits.gsfc.nasa.gov/fits_wcs.html).   The general scheme</span>
<span class="comments">;       outlined in that article is to convert x and y coordinates into a</span>
<span class="comments">;       "native" longitude and latitude and then rotate the system into one of</span>
<span class="comments">;       three generally recognized systems (celestial, galactic or ecliptic).</span>
<span class="comments">;</span>
<span class="comments">;       This procedure necessitates two basic sections.  The first converts</span>
<span class="comments">;       x and y coordinates to "native" coordinates while the second converts</span>
<span class="comments">;       "native" to "standard" coordinates.  The first section contains the</span>
<span class="comments">;       guts of the code in which all of the map projection is done.  The</span>
<span class="comments">;       second step is performed by WCS_ROTATE and only involves rotation of</span>
<span class="comments">;       coordinate systems.  WCSXY2SPH can be called in a form similar to</span>
<span class="comments">;       AITOFF, EQPOLE, or QDCB by calling wcsxy2sph with a fifth parameter</span>
<span class="comments">;       specifying the map projection by number and by not using any of the</span>
<span class="comments">;       keywords related to the map projection type (eg ctype1 and ctyp2).</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       The first task of the procedure is to do general error-checking to</span>
<span class="comments">;       make sure the procedure was called correctly and none of the</span>
<span class="comments">;       parameters or keywords conflict.  This is particularly important</span>
<span class="comments">;       because the procedure can be called in two ways (either using</span>
<span class="comments">;       FITS-type keywords or using a number corresponding a map projection</span>
<span class="comments">;       type).  All variables are converted into double precision values.</span>
<span class="comments">;</span>
<span class="comments">;       The second task of the procedure is to take x and y coordinates and</span>
<span class="comments">;       convert them into "native" latitude and longitude coordinates.</span>
<span class="comments">;       Map-specific error-checking is done at this time.  All of the</span>
<span class="comments">;       equations were obtained from "Representations of Celestial</span>
<span class="comments">;       Coordinates in FITS" and cases needing special attention are handled</span>
<span class="comments">;       appropriately (see the comments with individual map projections for</span>
<span class="comments">;       more information on special cases).     WCS_ROTATE is then called to</span>
<span class="comments">;       convert the "native" coordinates to "standard" coordinates by rotating</span>
<span class="comments">;       the coordinate system.  This rotation is governed by the keywords</span>
<span class="comments">;       CRVAL, and LONGPOLE.  The transformation is a straightforward</span>
<span class="comments">;       application of euler angles.  Finally, longitude values are converted</span>
<span class="comments">;       into the range from 0 to 360 degrees.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       none</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       WCS_ROTATE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;</span>
<span class="comments">;       Rick Balsano</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATIONS/REVISION LEVEL:</span>
<span class="comments">;</span>
<span class="comments">; 1.1    8/31/93</span>
<span class="comments">; 1.2    9/12/93   W. Landsman Vectorized CRXY, CRVAL, CTYPE</span>
<span class="comments">; 1.3    29/12/93  I. Freedman Eliminated LU decomposition</span>
<span class="comments">; 1.4    22/09/94  W. Landsman If scalar input, then scalar output</span>
<span class="comments">; 1.5    02/03/05  W. Landsman Change variable name BETA for V4.0 compatibility</span>
<span class="comments">; 1.6    06/07/05  W. Landsman Change loop index from integer to long</span>
<span class="comments">; 1.7    02/18/99  W. Landsman Fixed implementation of ARC algorithm</span>
<span class="comments">; 1.8    June 2003 W. Landsman Update conic projections, add LATPOLE keyword</span>
<span class="comments">; 1.81   Sep 2003 W. Landsman Avoid divide by zero</span>
<span class="comments">; 1.82   Sep 2003 W. Landsman CTYPE keywords need not be 8 characters</span>
<span class="comments">; 1.83   Sep 2003 W. Landsman Preserve input array sizes</span>
<span class="comments">; 1.9    Jan 2004 W. Landsman don't modify scalars, fix PARabolic code</span>
<span class="comments">; 2.0    Feb 2004 W. Landsman Fix AIR and AZP projections</span>
<span class="comments">; 2.1    Feb 2004 W. Landsman Fix tangent projection for matrix input</span>
<span class="comments">; 3.0    May 2004  W. Landsman Support extended SIN (=NCP), slant zenithal</span>
<span class="comments">;                  (SZP), and zenithal polynomial (ZPN) projections, use</span>
<span class="comments">;                   PV2 keyword vector instead of PROJP1, PROJP2</span>
<span class="comments">; 3.1    May 2004 W. Landsman/J. Ballet Handle NaN values, flag invalid output</span>
<span class="comments">;                   for AITOFF projection</span>
<span class="comments">; 3.1.1  Dec 2005 W. Landsman/W. Thompson Fixed problem with Airy projection</span>
<span class="comments">;                   centered on 90 degree latitude</span>
<span class="comments">; 3.1.2  May 2006 W. Landsman/Y.Sato Fix problem selecting the correct root</span>
<span class="comments">;                    for the ZPN projection</span>
<span class="comments">; 3.2    Aug 2007  W. Landsman Correct treatment of PVi_j parameters</span>
<span class="comments">; 3.3    Oct 2007  Sergey Koposov Support HEALPIX projection</span>
<span class="comments">; 3.4    May 2012  Benjamin Alan Weaver, Add nonstandard HEALCART </span>
<span class="comments">;                        projection, Allow map_index to be > 25</span>
<span class="comments">;-</span>

PRO wcsxy2sph, x, y, longitude, latitude, map_type, ctype=ctype, $
              face=face,pv2 = pv2,$
              crval=crval,crxy = crxy,longpole=longpole, Latpole = latpole

<span class="comments">; Define angle constants</span>

 compile_opt idl2
 pi = !DPI
 radeg = 57.295779513082323d0
 pi2 = pi/2.0d
 map_types=['DEF','AZP','TAN','SIN','STG','ARC','ZPN','ZEA','AIR','CYP',$
            'CAR','MER','CEA','COP','COD','COE','COO','BON','PCO','SFL',$
            'PAR','AIT','MOL','CSC','QSC','TSC','SZP','HPX','HCT']

<span class="comments">; check to see that enough parameters (at least 4) were sent</span>
 if ( N_params() lt 4 ) then begin
    print,'Syntax - WCSXY2SPH, x, y, longitude, latitude,[ map_type,  '
    print,'             CTYPE= , FACE=, PV2= , CRVAL= , CRXY= , '
    print,'             LATPOLE = , LONGPOLE = ]'
    return
 endif else if (n_params() eq 5) then begin
    if keyword_set(ctype) then message,$
  'Use either the MAP_TYPE positional parameter or set the projection type' + $
    'with CTYPE, but not both.'

<span class="comments">; set projection_type string using map_type parameter (a number)</span>
  if (n_elements(map_type) ne 0) then begin
         projection_type = map_types[map_type]
  endif else message,'MAP_TYPE must be >= 0 and &lt; '+$
            strtrim(string(n_elements(map_types)),2)+'; it was set to '+$
            strtrim(string(map_type),2)

endif else if (n_params() eq 4) then begin

<span class="comments">; check to see that CTYPE is set correctly</span>

  if N_elements( ctype ) GE 1 then begin
        ctype1 = strtrim(ctype[0],2)
        if strlen(ctype1) LT 8 then message,'ERROR - ' + strupcase(ctype1) + $
               ' is not a valid spherical projection type.'
        projection_type = strupcase(strmid(ctype1,5,3))
  endif

  if N_elements( ctype ) GE 2  then begin
        ctype2 = ctype[1]
         if (projection_type ne strupcase(strmid(ctype2,5,3))) then begin
      message,'The same map projection type must be in characters',/continue
      message,'     5-8 of both CTYPE1 and CTYPE2.',/con
      return
    endif
    if (((strupcase(strmid(ctype1,1,2)) eq 'RA') and $
         (strupcase(strmid(ctype2,1,3)) ne 'DEC')) or $
        ((strupcase(strmid(ctype1,1,4)) eq 'GLON') and $
         (strupcase(strmid(ctype2,1,4)) ne 'GLAT')) or $
        ((strupcase(strmid(ctype1,1,4)) eq 'ELON') and $
         (strupcase(strmid(ctype2,1,4)) ne 'ELAT'))) $
    then begin message,'The same standard system must be in the first 4',$
                       /continue
      print,'characters of both CTYPE1 and CTYPE2.'
      return
    endif
  endif else projection_type = 'DEF'

endif

<span class="comments">; GENERAL ERROR CHECKING</span>

<span class="comments">; find the number of elements in each of the data arrays</span>
 n_x = n_elements(x)
 n_y = n_elements(y)
 sz_x = size(x)
 sz_y = size(y)

<span class="comments">; check to see that the data arrays have the same size</span>
 if (n_x ne n_y) then $
        message,'The arrays X and Y must have the same number of elements.'

<span class="comments">; this sets the default map projection type for the cases when map_type or</span>
<span class="comments">; projection_type is set to 'DEF' or if projection_type is not set at this</span>
<span class="comments">; point.  As suggested in 'Representations of Celestial Coordinates in FITS'</span>
<span class="comments">; the default type is set to CAR (Cartesian) the simplest of all projections.</span>
if ((n_elements(projection_type) eq 0) or (projection_type eq 'DEF')) then $
   projection_type='CAR'

<span class="comments">; Check to make sure all the correct parameters and keywords are set for</span>
<span class="comments">; spherical projections.</span>
 if ((N_elements(ctype) EQ 3) or keyword_set(face) or  $
    (projection_type eq 'CSC') or $
    (projection_type eq 'QSC') or (projection_type eq 'TSC')) then begin

  noface =  ~keyword_set(face)

endif

<span class="comments">; check to see if the x and y offsets are set properly.  If not, break out</span>
<span class="comments">; of program.  If so, apply offsets.  If the x and y offsets are not set,</span>
<span class="comments">; then assume they are zero.</span>

 if ( (keyword_set(crxy)) and N_elements(crxy) NE 2) then $
     message,'Offset keyword CRXY must contain 2 elements'

 if keyword_set(crxy) then begin
        xx = double(x - crxy[0] )
        yy = double(y - crxy[1] )
 endif else begin
        xx = double(x)
        yy = double(y)
 endelse

 if  ( N_elements(crval) eq 1 ) then $
        message,'CRVAL keyword must be a 2 element vector'


<span class="comments">; BRANCH BY MAP PROJECTION TYPE</span>
case strupcase(projection_type) of
  'AZP':begin
  PV2_1 = N_elements(PV2) GE 1 ? PV2[0] : 0.0  <span class="comments">;PV2_1 =mu (spherical radii)</span>
  PV2_2 = N_elements(PV2) GE 2 ? PV2[1] : 0.0   <span class="comments">; PV2_2 = gamma (degrees)</span>

    if (pv2_1 lt 0) then message,$
      'AZP map projection requires the keyword pv2_1 >= 0'
    gamma = pv2_2/radeg
    mu = pv2_1
    r = sqrt(xx^2 + yy^2*cos(gamma)^2)
    rho = r/(radeg*(mu+1) + yy*sin(gamma) )
    omega = asin( rho*mu/ sqrt( rho^2 + 1.d0) )
    xsi = atan(1.d0, rho)
    phi = atan(xx, -yy*cos(gamma) )
    theta1 = xsi - omega
    theta2 = xsi + omega + !dpi
    theta = theta1*0.0
    if abs(mu) LT 1 then begin
          g = where(abs(theta1) LT pi2, Ng)
          if Ng GT 0 then theta[g] = theta1[g]
          g = where(abs(theta2) LT pi2, Ng)
          if Ng GT 0 then theta[g] = theta2[g]
    endif else begin
          diff1 = abs(pi2 - theta1)
          diff2 = abs(pi2 - theta2)
          g = where((diff1 le diff2), Ng)
          if Ng GT 0 then theta[g] = theta1[g]
          g = where( (diff2 LT diff1) , Ng)
          if Ng GT 0 then theta[g] = theta2[g]
    endelse

  end
  'SZP': begin

       mu = N_elements(PV2) GT 0 ? PV2[0] : 0
       phi_c = N_elements(PV2) GT 1 ? PV2[1] : 0
       theta_c = N_elements(PV2) GT 2 ? PV2[2] : 90.0

       phi_c = phi_c/radeg & theta_c = theta_c/radeg
       xp = -mu*cos(theta_c)*sin(phi_c)
       yp =  mu*cos(theta_c)*cos(phi_c)
       zp =  mu*sin(theta_c) + 1.

       xx = xx/radeg  &  yy = yy/radeg
       xb = (xx - xp)/zp & yb = (yy - yp)/zp
       a = xb^2 + yb^2 + 1
       b = xb*(xx - xb) + yb*(yy - yb)
       c = (xx - xb)^2 + (yy - yb)^2 - 1.
       rad = sqrt(b^2 - a*c)
       rad1 = (-b + rad)/a
       rad2 = (-b - rad)/a
       arad1 = abs(rad1)
       arad2 = abs(rad2)
       rad = rad*0.
       g = where((arad1 LE pi2) and (arad2 GT pi2), Ng )
       if Ng GT 0 then rad[g] = rad1[g]
       g = where((arad2 LE pi2) and (arad1 GT pi2), Ng )
       if Ng GT 0 then rad[g] = rad2[g]
       g = where((arad2 LE pi2) and (arad1 LE pi2), Ng )
       if Ng GT 0 then rad[g] = rad2[g] > rad1[g]
       theta = asin(rad)
       phi = atan( xx - xb*(1-sin(theta)), -(yy - yb*(1-sin(theta))) )
        end

  'TAN':begin
    sz_x = size(xx,/dimen)
    if sz_x[0] EQ 0 then theta = pi2 else $
        theta = make_array(value=pi2,dimen = sz_x)     <span class="comments">;Default is 90 degrees</span>
    r = sqrt(xx^2 + yy^2)
    g = where(r GT 0, Ng)
    if Ng GT 0 then theta[g] = atan(radeg/r[g])
    phi = atan(xx,-yy)
  end

  'SIN':begin

    PV2_1 = N_elements(PV2) GE 1 ? PV2[0] : 0.0
    PV2_2 = N_elements(PV2) GE 2 ? PV2[1] : 0.0

    if (pv2_1 EQ 0) and (pv2_2 EQ 0) then begin
       theta = acos(sqrt(xx^2 + yy^2)/radeg)
       phi = atan(xx,-yy)
    endif else begin
       x = xx/radeg & y = yy/radeg
       a = pv2_1^2 + pv2_2^2 + 1
       b = pv2_1*(x - pv2_1) + pv2_2*(y - pv2_2)
       c = (x - pv2_1)^2 + (y - pv2_2)^2 - 1.
       rad = sqrt(b^2 - a*c)
       rad1 = (-b + rad)/a
       rad2 = (-b - rad)/a
       arad1 = abs(rad1)
       arad2 = abs(rad2)
       rad = rad*0.
       g = where((arad1 LE pi2) and (arad2 GT pi2), Ng )
       if Ng GT 0 then rad[g] = rad1[g]
       g = where((arad2 LE pi2) and (arad1 GT pi2), Ng )
       if Ng GT 0 then rad[g] = rad2[g]
       g = where((arad2 LE pi2) and (arad1 LE pi2), Ng )
       if Ng GT 0 then rad[g] = rad2[g] > rad1[g]
       theta = asin(rad)
       phi = atan( x - pv2_1*(1-sin(theta)), -(y - pv2_2*(1-sin(theta))) )
   endelse
  end

  'STG':begin
    theta = pi2 - 2*atan(sqrt(xx^2 + yy^2)/(2.d0*radeg))
    phi = atan(xx, -yy)
  end

  'ARC':begin
    theta = pi2 - sqrt(xx^2 + yy^2)/radeg
    phi = atan(xx, -yy)
  end

  'ZPN':  begin
   rtheta = sqrt(xx^2 + yy^2)/radeg
   phi = atan(xx, -yy)
   g = where(pv2 NE 0, Ng)
   if Ng GT 0 then np = max(g) else np =0
   pv2 = pv2[0:np]
   n = N_elements(xx)
   theta = dblarr(n)
   for i=0, n-1 do begin
      pv = pv2
      pv[0] = pv[0] - rtheta[i]
      gamma = fz_roots(pv)
<span class="comments">; Want only the real roots</span>
   good = where( imaginary(gamma) EQ 0, Ng)
   if Ng EQ 0 then message,'ERROR in ZPN computation: no real roots found'
   gamma = double( gamma[good])

<span class="comments">; If multiple real roots are found, then we seek the value closest to the</span>
<span class="comments">; approximate linear solution</span>

   if Ng GT 1 then begin
        gamma1 = -pv[0]/pv[1]
        dgmin = min(abs(gamma - gamma1), dgmin_index)
        gamma = gamma[dgmin_index]
      good = where( (gamma GE -pi2) and (gamma LE pi2), Ng)
      if Ng EQ 0 then gamma = gamma[0] else gamma = gamma[good[0]]
   endif
   theta[i] = pi2 - gamma
   endfor
  end


  'ZEA':begin
    theta = pi2 - 2.d0*asin(sqrt(xx^2 + yy^2)/(2.d0*radeg))
    phi = atan(xx,-yy)
  end

  'AIR':begin

    if N_elements(PV2) LT 1 then begin
      message,/informational,$
          'pv2_1 not set, using default of pv2_1 = 90 for AIR map projection'
      pv2_1 = 9.d1
    endif else pv2_1 = pv2[0]

<span class="comments">; Numerically solve the equation for xi, by iterating the equation for xi.</span>
<span class="comments">; The default initial value for xi is 30 degrees, but for some values of</span>
<span class="comments">; x and y, this causes an imaginary angle to result for the next iteration of</span>
<span class="comments">; xi.  Unfortunately, this causes the value of xi to converge to an incorrect</span>
<span class="comments">; value, so the initial xi is adjusted to avoid this problem.</span>
    theta_b = pv2_1/radeg
    xi = theta_b
    zeta_b = (pi2-theta_b)/2.d0
    if (cos(zeta_b) NE 1) then $
      a = alog(cos(zeta_b))/(tan(zeta_b))^2 $
    else a = -0.5d0
    rtheta = sqrt(xx^2 + yy^2)/(2.0d*radeg)

    repeat begin
      bad=where( abs(exp((-rtheta - a*tan(xi))*tan(xi))) gt 1)
      if (bad[0] ne -1) then xi[bad] = xi[bad]/2.d0
    endrep until (bad[0] eq -1)

    tolerance = 1.d-12
    repeat begin

      xi_old = xi
      xi = acos(exp( (-rtheta - a*tan(xi) )*tan(xi)))

    endrep until (max(abs(xi_old - xi)) lt tolerance)

<span class="comments">;    print,rtheta,alog(cos(xi))/tan(xi) + a*tan(xi)</span>
    theta = pi2 - 2.d0*xi
    phi = atan(xx,-yy)
  end

  'CYP':begin
    if n_elements(pv2 eq 0) then begin
      message,/informational,$
            'PV2_1 not set, using default of pv2_1 = 0 for CYP map projection'
      pv2_1 = 0.d0
    endif else pv2_1 = pv2[0]
    if N_elements(pv2) LT 2 then begin
      message,/informational,$
            'PV2_2 not set, using default of pv2_2 = 1 for CYP map projection'
      pv2_2 = 1.d0
    endif else pv2_2 = pv2[1]
    if (pv2_1 eq -pv2_2) then message,$
      'PV2_1 = -PV2_2 is not allowed for CYP map projection.'

    eta = yy/((pv2_1 + pv2_2)*radeg)
    theta = atan(eta,1) + asin(eta*pv2_1/sqrt(eta^2 + 1.d0))
    phi = xx/(pv2_2*radeg)
  end

  'CAR':begin
    phi = xx/radeg
    theta = yy/radeg
  end

  'MER':begin
    phi = xx/radeg
    theta = 2*atan(exp(yy/radeg)) - pi2
  end

  'CEA':begin
    if N_elements(PV2) LT 1 then message,$
      'CEA map projection requires that PV2_1 keyword be set.'
    pv2_1 = pv2[0]
    if ((pv2_1 le 0) or (pv2_1 gt 1)) then message,$
      'CEA map projection requires 0 &lt; PV2_1 &lt;= 1'
    phi = xx/radeg
    theta = asin(yy*pv2_1/radeg)
  end

  'COP':begin
    if N_elements(PV2) LT 1 then message,$
      'COP map projection requires that PV2_1 keyword be set.'
    pv2_1 =  pv2[0]
    if N_elements(PV2) LT 2 then begin
      message,/informational,$
      'PV2_2 not set, using default of PV2_2 = 0 for COP map projection'
      pv2_2=0
    endif else pv2_2 = pv2[1]
    if ((pv2_1 lt -90) or (pv2_2 gt 90) or (pv2_1 gt 90)) then message,$
 'pv2_1 and pv2_2 must satisfy -90&lt;=PV2_1&lt;=90, PV2_2&lt;=90 for COP projection'
    if (pv2_1 eq -pv2_2) then message,$
 'COP projection with PV2_1=-PV2_2 is better done as a cylindrical projection'

    theta_a = pv2_1/radeg
    alpha = pv2_2/radeg
    y_0 = radeg*cos(alpha)/tan(theta_a)
    R_theta = sqrt(xx^2+(y_0-yy)^2)
    if pv2_1 LT 0 then R_theta = -R_theta
    theta = theta_a + atan(1.d0/tan(theta_a) - R_theta/$
          (radeg*cos(alpha)))
     phi = atan( xx/R_theta,(y_0-yy)/R_theta )/sin(theta_a)
  end

  'COD':begin
    if N_elements(pv2) LT 1 then message,$
      'COD map projection requires that PV2_1 keyword be set.'
    pv2_1 = pv2[0]
    if N_elements(pv2) LT 2 then begin
      message,/informational,$
     'PV2_2 not set, using default of PV2_2 = 0 for COD map projection'
      pv2_2 = 0
    endif else pv2_2 = pv2[1]
    if ((pv2_1 lt -90) or (pv2_2 gt 90) or (pv2_1 gt 90)) then message,$
 'pv2_1 and pv2_2 must satisfy -90&lt;=pv2_1&lt;=90,pv2_2&lt;=90 for COD projection'

<span class="comments">; use general set of equations for pv2_1 not = pv2_2</span>
    theta_a = pv2_1/radeg

    if (pv2_2 NE 0) then begin
      alpha = pv2_2/radeg
      C = sin(theta_a)*sin(alpha)/alpha
      Y_0 = radeg*alpha/tan(alpha)/tan(theta_a)
      R_theta = sqrt(xx^2+(y_0-yy)^2)
      if pv2_1 LT 0 then R_theta = -R_theta
       theta = theta_a + alpha/(tan(alpha)*tan(theta_a))-  R_theta/radeg
<span class="comments">; use special set of equations for pv2_1 = pv2_2</span>
    endif else begin
      C = sin(theta_a)
      y_0 = radeg/tan(theta_a)
     R_theta = sqrt(xx^2+(y_0-yy)^2)
     if pv2_1 LT 0 then R_theta = -R_theta
      theta = theta_a + 1.0d/tan(theta_a) - R_theta/radeg
   endelse
    phi = atan( xx/R_theta,(y_0-yy)/R_theta )/C
   end

  'COE':begin
    if N_elements(pv2) LT 1 then message,$
      'COE map projection requires that pv2_1 keyword be set.'
    pv2_1 = pv2[0]
    if N_elements(pv2) LT 2 then begin
      message,/informational,$
      'pv2_2 not set, using default of pv2_2 = 0 for COE map projection'
      pv2_2 = 0
    endif else pv2_2 = pv2[1]
    if ((pv2_1 lt -90) or (pv2_2 gt 90) or (pv2_1 gt 90)) then message,$
 'pv2_1 and pv2_2 must satisfy -90&lt;=pv2_1&lt;=90,pv2_2&lt;=90 for COE projection'
    theta_a = pv2_1/radeg
    eta = pv2_2/radeg
    theta1 = (theta_a - eta)
     theta2 = (theta_a + eta)
    s_1 = sin( theta1)
    s_2 = sin( theta2)
    stheta_a = sin(theta_a)
    gamma = s_1 + s_2
    C = gamma/2
    y_0 = radeg*2.d0*sqrt(1.d0 + s_1*s_2 - gamma*stheta_a)/gamma
    R_theta = (xx^2+(y_0-yy)^2)
    if pv2_1 LT 0 then R_theta = -R_theta
    phi = 2*atan(xx/R_theta,(y_0 - yy)/R_theta)/gamma
    theta = asin((1.d0 + s_1*s_2-(xx^2+(y_0-yy)^2)*(gamma/(2.d0*radeg))^2)/gamma)

  end

  'COO':begin
    if N_elements(pv2) LT 1 then message,$
      'COO map projection requires that pv2_1 keyword be set.'
    pv2_1 = pv2[0]
    if N_elements(pv2) LT 2 then begin
      message,/informational,$
      'pv2_2 not set, using default of pv2_2 = 0 for COO map projection'
      pv2_2 = 0
    endif else  pv2_2 = pv2[1]
    if ((pv2_1 lt -90) or (pv2_2 gt 90) or (pv2_1 gt 90)) then message,$
 'pv2_1 and pv2_2 must satisfy -90&lt;=pv2_1&lt;=90,pv2_2&lt;=90 for COO projection'
    theta_1 = (pv2_1 - pv2_2)/radeg
    theta_2 = (pv2_1 + pv2_2)/radeg
    theta_a = pv2_1/radeg


<span class="comments">; calculate value of c in simpler fashion if pv2_1 = pv2_2</span>
    if (theta_1 eq theta_2) then c = sin(theta_1) else $
    c = alog(cos(theta_2)/cos(theta_1))/alog(tan((pi2-theta_2)/2.d0)/$
    tan((pi2-theta_1)/2.d0))

    alpha = radeg*cos(theta_1)/(c*(tan((pi2-theta_1)/2.d0))^c)
    Y_0 = alpha*(tan((pi2-theta_a)/2.d0)^c)
    R_theta = sqrt(xx^2+(y_0-yy)^2)
    if pv2_1 LT 0 then R_theta = -R_theta
     phi = atan( xx/R_theta,(y_0-yy)/R_theta )/C
    theta = pi2 - 2*atan((R_theta/alpha)^(1.d0/c))
  end

  'BON':begin
    if (N_elements(pv2) LT 1) then message,$
      'BON map projection requires that PV2_1 keyword be set.'
    pv2_1 = pv2[0]
    if ((pv2_1 lt -90) or (pv2_1 gt 90)) then message,$
      'pv2_1 must satisfy -90 &lt;= pv2_1 &lt;= 90 for BON map projection'
    if (pv2_1 eq 0) then message,$
      'pv2_1 = 0 for BON map projection is better done with SFL map projection'
    theta_1 = pv2_1/radeg
    y_0 = 1.d0/tan(theta_1) + theta_1
    s = theta_1/abs(theta_1)
    theta = y_0 - s*sqrt(xx^2 + (y_0*radeg - yy)^2)/radeg
    phi = s*(y_0 - theta)*atan(s*xx/(y_0*radeg - theta),$
                               (y_0*radeg - yy)/(y_0*radeg - theta))/cos(theta)
  end

  'PCO':begin
<span class="comments">; Determine where y = 0 and assign theta to 0 for these points.  The reason</span>
<span class="comments">; for doing this separately is that the intial condition for theta in the</span>
<span class="comments">; numerical solution is sign(y)*45 which only works for y not = 0.</span>
    bad = where(yy eq 0)
    good = where(yy ne 0)
    theta = double(xx - xx)
    if (bad[0] ne -1) then theta[bad] = 0.d0

<span class="comments">; Find theta numerically.</span>
    tolerance = 1.d-11
    tolerance_2 = 1.d-11
    if (good[0] ne -1) then begin
      theta_p = double(xx - xx)
      theta_p[good] = pi2*yy[good]/abs(yy[good])
      theta_n = double(xx - xx)
      f_p = double(xx - xx)
      f_p[good] = xx[good]^2 - 2.d0*radeg*(yy[good] - radeg*theta_p[good])/$
                  tan(theta_p[good]) + (yy[good] - radeg*theta_p[good])^2
      f_n = double(xx - xx) - 999.d0
      lambda = double(xx - xx)
      f = double(xx - xx)
      repeat begin
        case_1 = where((yy ne 0.d0) and (f_n lt (-1.d2)))
        case_2 = where((yy ne 0.d0) and (f_n ge (-1.d2)))
        if (case_1[0] ne -1) then lambda[case_1] = 0.5d0
        if (case_2[0] ne -1) then $
          lambda[case_2] = f_p[case_2]/(f_p[case_2] - f_n[case_2])
        lambda[good] = 1.d-1 > (9.d-1 &lt<span class="comments">; lambda[good])</span>
        theta[good] = (1.d0 - lambda[good])*theta_p[good] + $
                      lambda[good]*theta_n[good]
        f[good] = xx[good]^2 - 2.d0*radeg*(yy[good] - radeg*theta[good])/$
                  tan(theta[good]) + (yy[good] - radeg*theta[good])^2
        neg = where((yy ne 0.d0) and (f lt 0.d0))
        pos = where((yy ne 0.d0) and (f gt 0.d0))
        if (neg[0] ne -1) then begin
          f_n[neg] = f[neg]
          theta_n[neg] = theta[neg]
        end
        if (pos[0] ne -1) then begin
          f_p[pos] = f[pos]
          theta_p[pos] = theta[pos]
        end
      endrep until ((max(abs(theta_p - theta_n)) lt tolerance) or $
                    (max(abs(f)) lt tolerance_2))
    endif

<span class="comments">; Determine phi differently depending on whether theta = 0 or not.</span>
    bad = where(theta eq 0.d0)
    good = where(theta ne 0.d0)
    phi = double(x - x)
    if (bad[0] ne -1) then phi[bad] = xx[bad]/radeg
    phi[good] = atan(xx[good]/radeg*tan(theta[good]),$
       1.d0 - (yy[good]/radeg - theta[good])*tan(theta[good]))/sin(theta[good])
  end

  'SFL':begin
    phi = xx/(radeg*cos(yy/radeg))
    theta = yy/radeg
  end

  'PAR':begin

    theta = 3.d0*asin(yy/pi/radeg)
    phi = xx/(1.d0 - 4.d0*(yy/pi/radeg)^2)/radeg
  end

  'AIT':begin
  z2 = 1.d0 - (xx/(4.d0*radeg))^2 - (yy/(2.d0*radeg))^2
  bad = where(z2 lt 0.5d0,nbad)
  z = sqrt(z2)
  phi = 2.d0*atan(z*xx/(2.d0*radeg),2.d0*z^2 - 1.d0)
  theta = asin(yy*z/radeg)
  if nbad gt 0 then begin
       phi[bad] = !values.d_nan
      theta[bad] = !values.d_nan
   endif

  end

  'MOL':begin
    phi = pi*xx/(radeg*2.d0*sqrt(2.d0 - (yy/radeg)^2))
    arg = 2.d0*asin(yy/(sqrt(2.d0)*radeg))/pi + $
                 yy*sqrt(2.d0 - (yy/radeg)^2)/1.8d2

   theta = asin(2.d0*asin(yy/(sqrt(2.d0)*radeg))/pi + $
                 yy*sqrt(2.d0 - (yy/radeg)^2)/1.8d2)

  end

  'CSC':begin
    xx = xx/4.5d1
    yy = yy/4.5d1

<span class="comments">;</span>
<span class="comments">;   If the faces are not defined, assume that the faces need to be defined</span>
<span class="comments">;   and the whole sky is displayed as a "sideways T".</span>
<span class="comments">;</span>
        if noface eq 1 then begin

                face=intarr(n_elements(xx))

                face1 = where((xx le 1.0) and (yy le 1.0) and (yy ge -1.0),nf1)
                if nf1 gt 0 then begin
                        face[face1]=1
                endif

                face4 = where((xx gt 5.0),nf4)
                if nf4 gt 0 then begin
                        face[face4]=4
                        xx[face4]=xx[face4]-6.0d0
                endif

                face3 = where((xx le 5.0) and (xx gt 3.0),nf3)
                if nf3 gt 0 then begin
                        face[face3]=3
                        xx[face3]=xx[face3]-4.0d0
                endif

                face2 = where((xx le 3.0) and (xx gt 1.0),nf2)
                if nf2 gt 0 then begin
                        face[face2]=2
                        xx[face2]=xx[face2]-2.0d0
                endif

                face0 = where((xx le 1.0) and (yy gt 1.0),nf0)
                if nf0 gt 0 then begin
                        face[face0]=0
                        yy[face0]=yy[face0] - 2.0
                endif

                face5 = where((xx le 1.0) and (yy lt -1.0),nf5)
                if nf5 gt 0 then begin
                        face[face5]=5
                        yy[face5]=yy[face5] + 2.0
                endif

        endif

<span class="comments">; Define array of numerical constants used in determining alpha and beta1.</span>
    p = dblarr(7,7)
    p[0,0] = -0.27292696d0
    p[1,0] = -0.07629969d0
    p[0,1] = -0.02819452d0
    p[2,0] = -0.22797056d0
    p[1,1] = -0.01471565d0
    p[0,2] = 0.27058160d0
    p[3,0] = 0.54852384d0
    p[2,1] = 0.48051509d0
    p[1,2] = -0.56800938d0
    p[0,3] = -0.60441560d0
    p[4,0] = -0.62930065d0
    p[3,1] = -1.74114454d0
    p[2,2] = 0.30803317d0
    p[1,3] = 1.50880086d0
    p[0,4] = 0.93412077d0
    p[5,0] = 0.25795794d0
    p[4,1] = 1.71547508d0
    p[3,2] = 0.98938102d0
    p[2,3] = -0.93678576d0
    p[1,4] = -1.41601920d0
    p[0,5] = -0.63915306d0
    p[6,0] = 0.02584375d0
    p[5,1] = -0.53022337d0
    p[4,2] = -0.83180469d0
    p[3,3] = 0.08693841d0
    p[2,4] = 0.33887446d0
    p[1,5] = 0.52032238d0
    p[0,6] = 0.14381585d0

<span class="comments">; Calculate alpha and beta1 using numerical constants</span>
    sum = double(x - x)
    for j = 0,6 do for i = 0,6 - j do sum = sum + p[i,j]*xx^(2*i)*yy^(2*j)
    alpha = xx + xx*(1 - xx^2)*sum

    sum = double(x - x)
    for j = 0,6 do for i = 0,6 - j do sum = sum + p[i,j]*yy^(2*i)*xx^(2*j)
    beta1 = yy + yy*(1 - yy^2)*sum

<span class="comments">; Calculate theta and phi from alpha and beta1; the method depends on which</span>
<span class="comments">; face the point lies on</span>
    phi = double(x - x)
    theta = double(x - x)
    for i = 0l, n_x - 1 do begin
      case face[i] of
        0:begin
          if (beta1[i] eq 0.d0) then begin
            if (alpha[i] eq 0.d0) then begin
              theta[i] = pi2
<span class="comments">; uh-oh lost information if this happens</span>
              phi[i] = 0.d0
            endif else begin
              phi[i] = alpha[i]/abs(alpha[i])*pi2
              theta[i] = atan(abs(1.d0/alpha[i]))
            endelse
          endif else begin
            phi[i] = atan(alpha[i],-beta1[i])
            theta[i] = atan(-cos(phi[i])/beta1[i])
          endelse
<span class="comments">; ensure that the latitudes are positive</span>
          theta[i] = abs(theta[i])
        end
        1:begin
          phi[i] = atan(alpha[i])
          theta[i] = atan(beta1[i]*cos(phi[i]))
        end
        2:begin
          if (alpha[i] eq 0.d0) then phi[i] = pi2 else $
            phi[i] = atan(-1.d0/alpha[i])
          if (phi[i] lt 0.d0) then phi[i] = phi[i] + pi
          theta[i] = atan(beta1[i]*sin(phi[i]))
        end
        3:begin
          phi[i] = atan(alpha[i])
          if (phi[i] gt 0.d0) then phi[i] = phi[i] - pi else $
          if (phi[i] lt 0.d0) then phi[i] = phi[i] + pi
          theta[i] = atan(-beta1[i]*cos(phi[i]))
        end
        4:begin
          if (alpha[i] eq 0.d0) then phi[i] = -pi2 else $
            phi[i] = atan(-1.d0/alpha[i])
          if (phi[i] gt 0.d0) then phi[i] = phi[i] - pi
          theta[i] = atan(-beta1[i]*sin(phi[i]))
        end
        5:begin
          if (beta1[i] eq 0.d0) then begin
            if (alpha[i] eq 0.d0) then begin
              theta[i] = -pi2
<span class="comments">; uh-oh lost information if this happens</span>
              phi[i] = 0.d0
            endif else begin
              phi[i] = -alpha[i]/abs(alpha[i])*pi2
              theta[i] = -atan(abs(1.d0/alpha[i]))
            endelse
          endif else begin
            phi[i] = atan(alpha[i],beta1[i])
            theta[i] = atan(-cos(phi[i])/beta1[i])
          endelse
<span class="comments">; ensure that the latitudes are negative</span>
          theta[i] = -abs(theta[i])
        end

      endcase
    endfor
  end

  'QSC':begin

    xx=xx/45.0d0
    yy=yy/45.0d0
<span class="comments">;</span>
<span class="comments">;   If the faces are not defined, assume that the faces need to be defined</span>
<span class="comments">;   and the whole sky is displayed as a "sideways T".</span>
<span class="comments">;</span>
        if noface eq 1 then begin

                face=intarr(n_elements(xx))

                face1 = where((xx le 1.0) and (yy le 1.0) and (yy ge -1.0),nf1)
                if nf1 gt 0 then begin
                        face[face1]=1
                endif

                face4 = where((xx gt 5.0),nf4)
                if nf4 gt 0 then begin
                        face[face4]=4
                        xx[face4]=xx[face4]-6.0d0
                endif

                face3 = where((xx le 5.0) and (xx gt 3.0),nf3)
                if nf3 gt 0 then begin
                        face[face3]=3
                        xx[face3]=xx[face3]-4.0d0
                endif

                face2 = where((xx le 3.0) and (xx gt 1.0),nf2)
                if nf2 gt 0 then begin
                        face[face2]=2
                        xx[face2]=xx[face2]-2.0d0
                endif

                face0 = where((xx le 1.0) and (yy gt 1.0),nf0)
                if nf0 gt 0 then begin
                        face[face0]=0
                        yy[face0]=yy[face0] - 2.0
                endif

                face5 = where((xx le 1.0) and (yy lt -1.0),nf5)
                if nf5 gt 0 then begin
                        face[face5]=5
                        yy[face5]=yy[face5] + 2.0
                endif

        endif


<span class="comments">; First determine the quadrant in which each points lies.  Calculate the</span>
<span class="comments">; ratio (alpha/beta1) for each point depending on the quadrant.  Finally,</span>
<span class="comments">; use this information and the face on which the point lies to calculate</span>
<span class="comments">; phi and theta.</span>
    theta = double(x - x)
    phi = double(x - x)
    rho = double(x - x)
    ratio = double(x - x)
    larger = double(x - x)
    smaller = double(x - x)

    temp = where(abs(yy) ge abs(xx), Ntemp)
    if Ntemp GT 0 then larger[temp] = yy[temp]
    temp = where(abs(xx) gt abs(yy), Ntemp )
    if Ntemp GT 0 then larger[temp] = xx[temp]
    temp = where(abs(yy) lt abs(xx), Ntemp )
    if Ntemp GT 0 then smaller[temp] = yy[temp]
    temp = where(abs(xx) le abs(yy), Ntemp)
    if Ntemp GT 0 then smaller[temp] = xx[temp]

    temp = where(larger ne 0.d0, Ntemp)
    if Ntemp GT 0 then ratio[temp] = sin(pi/1.2d1*smaller[temp]/larger[temp])/$
                      (cos(pi/1.2d1*smaller[temp]/larger[temp]) - sqrt(0.5d0))

    temp = where(larger eq 0.d0, Ntemp)
    if Ntemp GT 0 then ratio[temp] = 1.d0
    rho = 1.d0 - (larger)^2*(1.d0 - 1.d0/sqrt(2.d0 + ratio^2))

    temp = where((abs(xx) gt abs(yy)) and (ratio ne 0.d0), Ntemp)
    if Ntemp GT 0 then ratio[temp] = 1.d0/ratio[temp]

    temp = where((abs(xx) gt abs(yy)) and (ratio eq 0.d0), Ntemp)
<span class="comments">; use a kludge to produce the correct value for 1/0 without generating an error</span>
    if Ntemp GT 0 then ratio[temp] = tan(pi2)

    for i = 0l, n_x-1 do begin
      case face[i] of
        0:begin
          if (xx[i] ne 0.d0) then phi[i] = atan(-ratio[i]) else $
          if (yy[i] le 0.d0) then phi[i] = 0.d0 else $
          if (yy[i] gt 0.d0) then phi[i] = pi

          if (yy[i] ne 0.d0) then theta[i] = asin(rho[i]) else $
          if (xx[i] le 0.d0) then theta[i] = -pi2 else $
          if (xx[i] gt 0.d0) then theta[i] = pi2

          if (yy[i] gt 0.d0) then begin
            if (xx[i] lt 0.d0) then phi[i] = phi[i] - pi $
            else if (xx[i] gt 0.d0) then phi[i] = phi[i] + pi
          endif
        end
        1:begin
          if (xx[i] ne 0.d0) then begin
            if (yy[i] ne 0.d0) then $
             phi[i] = xx[i]/abs(xx[i])*acos(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                             (ratio[i]^2 + rho[i]^2))) $
            else phi[i] = xx[i]/abs(xx[i])*acos(rho[i])
          endif else phi[i] = 0.d0
          if (yy[i] ne 0.d0) then theta[i] = yy[i]/abs(yy[i])*acos(rho[i]/$
                                            cos(phi[i])) else theta[i] = 0.d0
        end
        2:begin
          if (yy[i] ne 0.d0) then begin
            if (xx[i] gt 0.d0) then $
               phi[i] = pi - asin(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                             (ratio[i]^2 + rho[i]^2))) $
            else if (xx[i] lt 0.d0) then $
               phi[i] = asin(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                             (ratio[i]^2 + rho[i]^2))) $
            else phi[i] = pi2
            theta[i] = yy[i]/abs(yy[i])*acos(rho[i]/abs(sin(phi[i])))
          endif else begin
            theta[i] = 0.d0
            if (xx[i] gt 0.d0) then phi[i] = pi - asin(rho[i]) $
            else if (xx[i] lt 0.d0) then phi[i] = asin(rho[i]) $
            else phi[i] = pi2
          endelse
        end
        3:begin
          if (yy[i] ne 0.d0) then begin
            if (xx[i] gt 0.d0) then $
              phi[i] = acos(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                            (ratio[i]^2 + rho[i]^2))) - pi $
            else if (xx[i] lt 0.d0) then $
              phi[i] = -acos(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                       (ratio[i]^2 + rho[i]^2))) + pi $
            else phi[i] = pi
            theta[i] = yy[i]/abs(yy[i])*acos(-rho[i]/cos(phi[i]))
          endif else begin
            theta[i] = 0.d0
            if (xx[i] gt 0.d0) then phi[i] = acos(rho[i]) - pi $
            else if (xx[i] lt 0.d0) then phi[i] = -acos(rho[i]) + pi $
            else phi[i] = pi
          endelse
        end
        4:begin
          if (yy[i] ne 0.d0) then begin
            if (xx[i] gt 0.d0) then $
               phi[i] = -asin(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                             (ratio[i]^2 + rho[i]^2))) $
            else if (xx[i] lt 0.d0) then $
               phi[i] = asin(sqrt(rho[i]^2*(1.d0 + ratio[i]^2)/$
                             (ratio[i]^2 + rho[i]^2))) - pi $
            else phi[i] = -pi2
            theta[i] = yy[i]/abs(yy[i])*acos(-rho[i]/sin(phi[i]))
          endif else begin
            theta[i] = 0.d0
            if (xx[i] gt 0.d0) then phi[i] = -asin(rho[i]) $
            else if (xx[i] lt 0.d0) then phi[i] = asin(rho[i]) - pi $
            else phi[i] = -pi2
          endelse
        end
        5:begin
          if (xx[i] ne 0.d0) then phi[i] = atan(ratio[i]) $
          else if (yy[i] le 0.d0) then phi[i] = pi $
          else if (yy[i] gt 0.d0) then phi[i] = 0.d0

          if (yy[i] ne 0.d0) then theta[i] = asin(-rho[i]) $
          else if (xx[i] le 0.d0) then theta[i] = -pi2 $
          else if (xx[i] gt 0.d0) then theta[i] = pi2

          if (yy[i] lt 0.d0) then begin
            if (xx[i] lt 0.d0) then phi[i] = phi[i] - pi $
            else if (xx[i] gt 0.d0) then phi[i] = phi[i] + pi
          endif
        end
      endcase
    endfor
  end

  'TSC':begin

    xx=xx/45.0d0
    yy=yy/45.0d0
<span class="comments">;</span>
<span class="comments">;   If the faces are not defined, assume that the faces need to be defined</span>
<span class="comments">;   and the whole sky is displayed as a "sideways T".</span>
<span class="comments">;</span>
        if noface eq 1 then begin

                face=intarr(n_elements(xx))

                face1 = where((xx le 1.0) and (yy le 1.0) and (yy ge -1.0),nf1)
                if nf1 gt 0 then begin
                        face[face1]=1
                endif

                face4 = where((xx gt 5.0),nf4)
                if nf4 gt 0 then begin
                        face[face4]=4
                        xx[face4]=xx[face4]-6.0d0
                endif

                face3 = where((xx le 5.0) and (xx gt 3.0),nf3)
                if nf3 gt 0 then begin
                        face[face3]=3
                        xx[face3]=xx[face3]-4.0d0
                endif

                face2 = where((xx le 3.0) and (xx gt 1.0),nf2)
                if nf2 gt 0 then begin
                        face[face2]=2
                        xx[face2]=xx[face2]-2.0d0
                endif

                face0 = where((xx le 1.0) and (yy gt 1.0),nf0)
                if nf0 gt 0 then begin
                        face[face0]=0
                        yy[face0]=yy[face0] - 2.0
                endif

                face5 = where((xx le 1.0) and (yy lt -1.0),nf5)
                if nf5 gt 0 then begin
                        face[face5]=5
                        yy[face5]=yy[face5] + 2.0
                endif

        endif

    rho = sin(atan(1.0d0/sqrt(xx^2 + yy^2)))
    phi = double(x - x)
    theta = double(x - x)
    for i = 0l, n_x - 1 do begin
      case face[i] of
        0:begin
          phi[i] = atan(xx[i],-yy[i])
          theta[i] = asin(rho[i])
        end
        1:begin
          if (xx[i] ne 0.d0) then begin
            if (xx[i] ge 0.d0) then $
             phi[i] = atan(sqrt((1.d0/rho[i]^2- 1.d0)/(1 + (yy[i]/xx[i])^2))) $
            else phi[i] =atan(-sqrt((1.d0/rho[i]^2 - 1.d0)/$
                               (1 + (yy[i]/xx[i])^2)))
            theta[i] = atan(yy[i]/xx[i]*sin(phi[i]))
          endif else begin
            phi[i] = 0.d0
            if (yy[i] ge 0.d0) then theta[i] = acos(rho[i]) $
            else theta[i] = -acos(rho[i])
          endelse
        end
        2:begin
<span class="comments">; The point theta = 0, phi = Pi/2 lies in this region, allowing</span>
<span class="comments">; rho = Cos[theta]*Sin[phi] to be 1, causing an infinite quantity in the</span>
<span class="comments">; equation for phi</span>
          if (rho[i] eq 1.d0) then begin
            phi[i] = pi2
            theta[i] = 0.d0
          endif else if (xx[i] gt 1.d-14) then begin
           phi[i] = atan(-sqrt((1.d0 + (yy[i]/xx[i])^2)/$
                                (1.d0/rho[i]^2 - 1.d0)))+pi
            theta[i] = atan(-yy[i]/xx[i]*cos(phi[i]))
          endif else if (xx[i] lt -1.d-14) then begin
            phi[i]=atan(sqrt((1.d0+(yy[i]/xx[i])^2)/(1.d0/rho[i]^2 - 1.d0)))
            theta[i] = atan(-yy[i]/xx[i]*cos(phi[i]))
          endif else begin
             phi[i] = pi2
            if (yy[i] ge 0) then theta[i] = acos(rho[i]/sin(phi[i])) $
            else theta[i] = -acos(rho[i]/sin(phi[i]))
          endelse
        end
        3:begin
          if (abs(xx[i]) ge 1.d-5) then begin
            if (xx[i] gt 0.d0) then $
           phi[i] = atan(sqrt((1.d0/rho[i]^2 - 1.d0)/$
                          (1 + (yy[i]/xx[i])^2)))-pi $
        else phi[i] = atan(-sqrt((1.d0/rho[i]^2 - 1.d0)/$
                            (1 + (yy[i]/xx[i])^2)))+pi
            theta[i] = atan(-yy[i]/xx[i]*sin(phi[i]))
          endif else begin
            if (xx[i] ge 0.d0) then phi[i] = -pi $
            else phi[i] = pi
            if (yy[i] ge 0) then theta[i] = acos(rho[i]) $
            else theta[i] = -acos(rho[i])
          endelse
        end
        4:begin
          if (rho[i] eq 1.d0) then begin
            phi[i] = -pi2
            theta[i] = atan(yy[i]/xx[i])
          endif else if (xx[i] gt 1.d-14) then begin
           phi[i]=atan(-sqrt((1.d0 + (yy[i]/xx[i])^2)/(1.d0/rho[i]^2 - 1.d0)))
            theta[i] = atan(yy[i]/xx[i]*cos(phi[i]))
          endif else if (xx[i] lt -1.d-14) then begin
            phi[i]=atan(sqrt((1.d0+(yy[i]/xx[i])^2)/(1.d0/rho[i]^2 - 1.d0)))-pi
            theta[i] = atan(yy[i]/xx[i]*cos(phi[i]))
          endif else begin
             phi[i] = 1.5d0*!pi
            if (yy[i] ge 0) then theta[i] = acos(rho[i]) $
            else theta[i] = -acos(rho[i])
          endelse
        end
        5:begin
          phi[i] = atan(xx[i],yy[i])
          theta[i] = asin(-rho[i])
        end

      endcase
    endfor
  end

  'HPX':begin
    hpx_k = 3.D <span class="comments">; The main HEALPIX parameters (see Calabretta 2007, MNRAS)</span>
    hpx_h = 4.D <span class="comments">;</span>
    ylim = 90D *(hpx_k-1)/hpx_h
    phi=xx*1.D
    theta=yy*1.D

    eqfaces = where( abs(yy) le ylim, complement=polfaces)

    <span class="comments">; equatorial region</span>
    if eqfaces[0] ne -1 then begin
        phi[eqfaces]=xx[eqfaces]/radeg
        theta[eqfaces]=asin(yy[eqfaces]*hpx_h/90.D/hpx_k)
	hpx_bad = where(xx[eqfaces] lt -180 or xx[eqfaces] gt 180)
	if hpx_bad[0] ne -1 then begin
		phi[eqfaces[hpx_bad]]=!VALUES.F_NAN
		theta[eqfaces[hpx_bad]]=!VALUES.F_NAN
	end

    endif

    <span class="comments">;polar regions</span>
    if polfaces[0] ne -1 then begin
        hpx_sig = (hpx_k+1)/2.D -abs(yy[polfaces]*hpx_h)/180.D
        hpx_omega = ((hpx_k mod 2 eq 1) or yy[polfaces] gt 0)*1.D
        hpx_xc=-180+(2*floor((xx[polfaces]+180)*hpx_h/360+(1-hpx_omega)/2)+hpx_omega)*180.D/hpx_h
        phi[polfaces] = (hpx_xc + (xx[polfaces]-hpx_xc)/hpx_sig)/radeg
        theta[polfaces] = ((yy[polfaces] gt 0)*2-1)*asin(1-hpx_sig^2/hpx_k)

	<span class="comments">; points outside reasonable area</span>
	hpx_bad = where( ((abs(((xx[polfaces]-hpx_xc)*hpx_h) mod 180)+(abs(yy[polfaces])-ylim)*hpx_h) gt 45*(3+hpx_h-hpx_k)) or (xx[polfaces] lt -180) or (xx[polfaces] gt 180))
	if hpx_bad[0] ne -1 then begin
		phi[polfaces[hpx_bad]]=!VALUES.F_NAN
		theta[polfaces[hpx_bad]]=!VALUES.F_NAN
	end
    endif
  end

  'HCT':begin
    phi = xx/radeg
    theta = dblarr(n_elements(yy))
    ylim = 90*(3-1)/4
    w_np = where(yy ge ylim, n_np)
    w_eq = where((yy lt ylim) and (yy gt -ylim), n_eq)
    w_sp = where(yy le -ylim, n_sp)

    if n_np gt 0 then theta[w_np] =  asin(1-(2-yy[w_np]/ylim)^2/3.d)
    if n_eq gt 0 then theta[w_eq] =  asin((yy[w_eq]/ylim)*2./3.d)
    if n_sp gt 0 then theta[w_sp] = -asin(1-(2+yy[w_sp]/ylim)^2/3.d)
  end

  else:message,strupcase(projection_type) + $
               ' is not a valid projection type.  Reset CTYPE1 and CTYPE2'

endcase

<span class="comments">; Convert from "native" coordinate system to "standard" coordinate system</span>
<span class="comments">; if the CRVAL keyword is set.  Otherwise, assume the map projection is</span>
<span class="comments">; complete</span>

 phi = phi*radeg
 theta = theta*radeg

 if ( N_elements(crval) GE 2 ) then begin



  if (n_elements(longpole) eq 0) then longpole = 1.8d2

  if N_elements(map_type) EQ 0 then $
           map_type = where(projection_type EQ map_types)
   map_type = map_type[0]
   conic = (map_type GE 13) and (map_type LE 16)
   zenithal =  ((map_type GE 1) and (map_type LE 8)) or (map_type EQ 26)
   if conic then theta0 = pv2_1 else if zenithal then theta0 = 90 $
            else theta0 = 0
   wcs_rotate, longitude, latitude, phi, theta, crval, longpole=longpole, $
           theta0 = theta0, latpole = latpole, /REVERSE
 endif else begin    <span class="comments">;no rotation from standard to native coordinates</span>

  latitude = theta
  longitude = phi

endelse

<span class="comments">; CONVERT LONGITUDE FROM -180 TO 180 TO 0 TO 360</span>

 temp = where(longitude lt 0.d0, Nneg)
 if (Nneg GT 0) then longitude[temp] = longitude[temp] + 3.6d2
 temp = where(longitude ge 3.6d2-1.d-2, Nneg)
 if (Nneg GT 0) then longitude[temp] = longitude[temp] - 3.6d2


 return
 end
</code>
    </div>
  </body>
</html>