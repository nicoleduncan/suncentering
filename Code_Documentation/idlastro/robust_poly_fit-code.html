<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:01 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>robust_poly_fit.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="robust_poly_fit.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION ROBUST_POLY_FIT,X,Y,NDEG,YFIT,SIG, NUMIT=THIS_MANY, DOUBLE=DOUBLE
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	ROBUST_POLY_FIT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	An outlier-resistant polynomial fit.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	COEFF = ROBUST_POLY_FIT(X,Y,NDEGREE  ,[ YFIT,SIG, /DOULBE, NUMIT=] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	X = Independent variable vector, floating-point or double-precision</span>
<span class="comments">;	Y = Dependent variable vector</span>
<span class="comments">;       NDEGREE - integer giving degree of polynomial to fit, maximum = 6</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	Function result = coefficient vector, length NDEGREE+1. </span>
<span class="comments">;	IF COEFF=0.0, NO FIT! If N_ELEMENTS(COEFF) > degree+1, the fit is poor</span>
<span class="comments">;	(in this case the last element of COEFF=0.)</span>
<span class="comments">;	Either floating point or double precision.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT PARAMETERS:</span>
<span class="comments">;	YFIT = Vector of calculated y's</span>
<span class="comments">;	SIG  = the "standard deviation" of the residuals</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       /DOUBLE - If set, then force all computations to double precision.</span>
<span class="comments">;       NUMIT - Maximum number of iterations to perform, default = 25</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;	Large values of NDEGREE should be avoided. This routine works best</span>
<span class="comments">;	when the number of points >> NDEGREE.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	For the initial estimate, the data is sorted by X and broken into </span>
<span class="comments">;	NDEGREE+2 sets. The X,Y medians of each set are fitted to a polynomial</span>
<span class="comments">;	 via POLY_FIT.   Bisquare ("Tukey's Biweight") weights are then </span>
<span class="comments">;	calculated, using a limit  of 6 outlier-resistant standard deviations.</span>
<span class="comments">;	The fit is repeated iteratively until the robust standard deviation of </span>
<span class="comments">;	the residuals changes by less than .03xSQRT(.5/(N-1)).</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;        POLY(), POLY_FIT()</span>
<span class="comments">;       ROB_CHECKFIT()</span>
<span class="comments">; REVISION HISTORY</span>
<span class="comments">;	Written, H. Freudenreich, STX, 8/90. Revised 4/91.</span>
<span class="comments">;	2/94 -- changed convergence criterion</span>
<span class="comments">;        Added /DOUBLE keyword, remove POLYFITW call  W. Landsman  Jan 2009</span>
<span class="comments">;-</span>

ON_ERROR,2
COMPILE_OPT IDL2

EPS   = 1.0E-20
DEL   = 5.0E-07
DEGMAX= 6

IF N_ELEMENTS(THIS_MANY) GT 0 THEN ITMAX=THIS_MANY ELSE ITMAX=25

BADFIT=0

NPTS = N_ELEMENTS(X)
MINPTS=NDEG+1
IF (NPTS/4*4) EQ NPTS THEN NEED2 = 1 ELSE NEED2 = 0
N3 = 3*NPTS/4  &  N1 = NPTS/4

<span class="comments">; If convenient, move X and Y to their centers of gravity:</span>
IF NDEG LT DEGMAX THEN BEGIN
   X0=TOTAL(X)/NPTS  &  Y0=TOTAL(Y)/NPTS
   U=X-X0            &  V=Y-Y0
ENDIF ELSE BEGIN
   U=X               &  V=Y
ENDELSE

<span class="comments">; The initial estimate.</span>

<span class="comments">; Choose an odd number of segments:</span>
NUM_SEG = NDEG+2
IF (NUM_SEG/2*2) EQ NUM_SEG THEN NUM_SEG =NUM_SEG+1
MIN_PTS = NUM_SEG*3
IF NPTS LT 10000 THEN BEGIN <span class="comments">;MIN_PTS THEN BEGIN</span>
<span class="comments">;  Settle for least-squares:</span>
   LSQFIT = 1
   CC = POLY_FIT( U, V, NDEG, YFIT , DOUBLE=DOUBLE)
ENDIF ELSE BEGIN
<span class="comments">;  Break up the data into segments:</span>
   LSQFIT = 0
   Q = SORT(U)
   U = U[Q]  &  V = V[Q]
   N_PER_SEG = REPLICATE( NPTS/NUM_SEG, NUM_SEG)

<span class="comments">;  Put the leftover points in the middle segment:</span>
   N_LEFT = NPTS - N_PER_SEG[0]*NUM_SEG
   N_PER_SEG[NUM_SEG/2] = N_PER_SEG[NUM_SEG/2] + N_LEFT
   R = DBLARR(NUM_SEG)  &  S = DBLARR(NUM_SEG)
   R[0]=MEDIAN( U[0:N_PER_SEG[0]-1],/EVEN ) 
   S[0]=MEDIAN( V[0:N_PER_SEG[0]-1],/EVEN )
   I2 = N_PER_SEG[0]-1
   FOR I=1,NUM_SEG-1 DO BEGIN
     I1 = I2 + 1
     I2 = I1 + N_PER_SEG[I] - 1
     R[I] = MEDIAN( U[I1:I2], /EVEN)      &  S[I] = MEDIAN( V[I1:I2],/EVEN )
   ENDFOR
<span class="comments">;  Now fit:</span>
   CC = POLY_FIT( R,S, NDEG, DOUBLE=DOUBLE )
   YFIT = POLY(U,CC)  
ENDELSE

ISTAT = ROB_CHECKFIT(V,YFIT,EPS,DEL,  SIG,FRACDEV,NGOOD,W,S)

IF ISTAT EQ 0 THEN GOTO,AFTERFIT

IF NGOOD LT MINPTS THEN BEGIN
   IF LSQFIT EQ 0 THEN BEGIN
      <span class="comments">;  Try a least-squares:</span>
      CC = POLY_FIT( U, V, NDEG, YFIT, DOUBLE=DOUBLE )
      ISTAT = ROB_CHECKFIT(V,YFIT,EPS,DEL,  SIG,FRACDEV,NGOOD,W,S)
      IF ISTAT EQ 0 THEN GOTO,AFTERFIT
      NGOOD = NPTS-COUNT
   ENDIF
   IF NGOOD LT MINPTS THEN BEGIN
      PRINT,'ROBUST_POLY_FIT: No Fit Possible!'
      RETURN,0.
   ENDIF
ENDIF

<span class="comments">; Now iterate until the solution converges:</span>
CLOSE_ENOUGH = .03*SQRT(.5/(NPTS-1)) > DEL 
DIFF= 1.0E10
SIG_1= (100.*SIG) &lt<span class="comments">; 1.0E20</span>
NIT = 0
WHILE( (DIFF GT CLOSE_ENOUGH) AND (NIT LT ITMAX) ) DO BEGIN
  NIT=NIT+1
  SIG_2=SIG_1
  SIG_1=SIG
<span class="comments">; We use the "obsolete" POLYFITW routine because it allows us to input weights</span>
<span class="comments">; rather than measure errors</span>
  g = where(W gt 0, Ng)
  if Ng LT N_elements(w) then begin    <span class="comments">;Throw out points with zero weight</span>
    u = u[g]
    v = v[g]
    w = w[g]
  endif  
  CC = POLY_FIT( U, V, NDEG, YFIT, MEASURE_ERRORS = 1/W^2, DOUBLE=DOUBLE )
  ISTAT = ROB_CHECKFIT(V,YFIT,EPS,DEL,  SIG,FRACDEV,NGOOD,W,S)
  IF ISTAT EQ 0 THEN GOTO,AFTERFIT
  IF NGOOD LT MINPTS THEN BEGIN
     PRINT,'ROBUST_POLY_FIT: Questionable Fit!'
     BADFIT=1
     GOTO,AFTERFIT
  ENDIF
  DIFF = (ABS(SIG_1-SIG)/SIG) &lt<span class="comments">; (ABS(SIG_2-SIG)/SIG)</span>
ENDWHILE

<span class="comments">;IF NIT GE ITMAX THEN PRINT,'ROBUST_POLY_FIT: Did not converge in',ITMAX,$</span>
<span class="comments">;' iterations!'</span>

AFTERFIT:
CC=REFORM(CC)

IF NDEG LT DEGMAX THEN BEGIN
CASE NDEG OF
 1: CC[0] = CC[0]-CC[1]*X0 + Y0
 2: BEGIN   
   CC[0] = CC[0]-CC[1]*X0+CC[2]*X0^2 + Y0
   CC[1] = CC[1]-2.*CC[2]*X0
    END
 3: BEGIN
   CC[0] = CC[0]-CC[1]*X0+CC[2]*X0^2-CC[3]*X0^3 + Y0
   CC[1] = CC[1]-2.*CC[2]*X0+3.*CC[3]*X0^2
   CC[2] = CC[2]-3.*CC[3]*X0
    END
 4: BEGIN
   CC[0] = CC[0]-   CC[1]*X0+CC[2]*X0^2-CC[3]*X0^3+CC[4]*X0^4+ Y0
   CC[1] = CC[1]-2.*CC[2]*X0+3.*CC[3]*X0^2-4.*CC[4]*X0^3
   CC[2] = CC[2]-3.*CC[3]*X0+6.*CC[4]*X0^2
   CC[3] = CC[3]-4.*CC[4]*X0
    END
 5: BEGIN
   CC[0] = CC[0]-  CC[1]*X0+CC[2]*X0^2-CC[3]*X0^3+CC[4]*X0^4-CC[5]*X0^5+ Y0
   CC[1] = CC[1]-2.*CC[2]*X0+ 3.*CC[3]*X0^2- 4.*CC[4]*X0^3+5.*CC[5]*X0^4
   CC[2] = CC[2]-3.*CC[3]*X0+ 6.*CC[4]*X0^2-10.*CC[5]*X0^3
   CC[3] = CC[3]-4.*CC[4]*X0+10.*CC[5]*X0^2
   CC[4] = CC[4]-5.*CC[5]*X0
    END
 ENDCASE
ENDIF

<span class="comments">; Calculate the fit at points X:</span>
IF( N_PARAMS(0) GT 3 )THEN YFIT=POLY(X,CC)

IF BADFIT EQ 1 THEN CC=[CC,0.]

RETURN,CC
END
</code>
    </div>
  </body>
</html>