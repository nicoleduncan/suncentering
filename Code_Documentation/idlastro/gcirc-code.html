<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:38 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gcirc.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gcirc.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO gcirc,u,ra1,dc1,ra2,dc2,dis                         
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     GCIRC</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Computes rigorous great circle arc distances.  </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     Input position can either be either radians, sexagesimal RA, Dec or</span>
<span class="comments">;     degrees.   All computations are double precision. </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      GCIRC, U, RA1, DC1, RA2, DC2, DIS</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      U    -- integer = 0,1, or 2: Describes units of inputs and output:</span>
<span class="comments">;              0:  everything radians</span>
<span class="comments">;              1:  RAx in decimal hours, DCx in decimal</span>
<span class="comments">;                       degrees, DIS in arc seconds </span>
<span class="comments">;              2:  RAx and DCx in degrees, DIS in arc seconds</span>
<span class="comments">;      RA1  -- Right ascension or longitude of point 1</span>
<span class="comments">;      DC1  -- Declination or latitude of point 1</span>
<span class="comments">;      RA2  -- Right ascension or longitude of point 2</span>
<span class="comments">;      DC2  -- Declination or latitude of point 2</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;      DIS  -- Angular distance on the sky between points 1 and 2</span>
<span class="comments">;              See U above for units;  double precision  </span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;      "Haversine formula" see </span>
<span class="comments">;      http://en.wikipedia.org/wiki/Great-circle_distance</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       (1) If RA1,DC1 are scalars, and RA2,DC2 are vectors, then DIS is a</span>
<span class="comments">;       vector giving the distance of each element of RA2,DC2 to RA1,DC1.</span>
<span class="comments">;       Similarly, if RA1,DC1 are vectors, and RA2, DC2 are scalars, then DIS</span>
<span class="comments">;       is a vector giving the distance of each element of RA1, DC1 to </span>
<span class="comments">;       RA2, DC2.    If both RA1,DC1 and RA2,DC2 are vectors then DIS is a</span>
<span class="comments">;       vector giving the distance of each element of RA1,DC1 to the </span>
<span class="comments">;       corresponding element of RA2,DC2.    If the input vectors are not the </span>
<span class="comments">;       same length, then excess elements of the longer ones will be ignored.</span>
<span class="comments">;</span>
<span class="comments">;       (2) The function SPHDIST provides an alternate method of computing</span>
<span class="comments">;        a spherical distance.</span>
<span class="comments">;</span>
<span class="comments">;       (3) The haversine formula can give rounding errors for antipodal</span>
<span class="comments">;       points.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;      None</span>
<span class="comments">;</span>
<span class="comments">;   MODIFICATION HISTORY:</span>
<span class="comments">;      Written in Fortran by R. Hill -- SASC Technologies -- January 3, 1986</span>
<span class="comments">;      Translated from FORTRAN to IDL, RSH, STX, 2/6/87</span>
<span class="comments">;      Vector arguments allowed    W. Landsman    April 1989</span>
<span class="comments">;      Prints result if last argument not given.  RSH, RSTX, 3 Apr. 1998</span>
<span class="comments">;      Remove ISARRAY(), V5.1 version        W. Landsman   August 2000</span>
<span class="comments">;      Added option U=2                      W. Landsman   October 2006</span>
<span class="comments">;      Use double precision for U=0 as advertised R. McMahon/W.L.  April 2007</span>
<span class="comments">;      Use havesine formula, which has less roundoff error in the </span>
<span class="comments">;             milliarcsecond regime      W.L. Mar 2009</span>
<span class="comments">;-</span>
 compile_opt idl2
 On_error,2                            <span class="comments">;Return to caller</span>

 npar = N_params()
 IF (npar ne 6) and (npar ne 5) THEN BEGIN
   print,'Calling sequence:  GCIRC,U,RA1,DC1,RA2,DC2[,DIS]'
   print,'   U = 0  ==> Everything in radians'
   print, $
   '   U = 1  ==> RAx decimal hours, DCx decimal degrees, DIS arc sec'
   print,'   U = 2  ==> RAx, DCx decimal degrees, DIS arc sec'
   RETURN
 ENDIF


 d2r    = !DPI/180.0d0
 as2r   = !DPI/648000.0d0
 h2r    = !DPI/12.0d0

<span class="comments">; Convert input to double precision radians</span>
 CASE u OF
   0:  BEGIN
          rarad1 = double(ra1)
          rarad2 = double(ra2)
          dcrad1 = double(dc1)
          dcrad2 = double(dc2)
       END
   1:  BEGIN
          rarad1 = ra1*h2r
          rarad2 = ra2*h2r
          dcrad1 = dc1*d2r
          dcrad2 = dc2*d2r
       END
   2:  BEGIN  
          rarad1 = ra1*d2r
          rarad2 = ra2*d2r
          dcrad1 = dc1*d2r
          dcrad2 = dc2*d2r
        END
   ELSE:  MESSAGE, $
                'U must be 0 (radians), 1 ( hours, degrees) or 2 (degrees)'
 ENDCASE

 deldec2 = (dcrad2-dcrad1)/2.0d
 delra2 =  (rarad2-rarad1)/2.0d
 sindis = sqrt( sin(deldec2)*sin(deldec2) + $
	  cos(dcrad1)*cos(dcrad2)*sin(delra2)*sin(delra2) )
 dis = 2.0d*asin(sindis) 

 IF (u ne 0) THEN dis = dis/as2r

 IF (npar eq 5) && (N_elements(dis) EQ 1) THEN BEGIN
    IF (u ne 0) && (dis ge 0.1) && (dis le 1000)  $
       THEN fmt = '(F10.4)' $
       ELSE fmt = '(E15.8)'
    IF (u ne 0) THEN units = ' arcsec' ELSE units = ' radians'
    print,'Angular separation is ' + string(dis,format=fmt) + units
 ENDIF

 RETURN
 END

</code>
    </div>
  </body>
</html>