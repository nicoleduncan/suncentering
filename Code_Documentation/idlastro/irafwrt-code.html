<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:43 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>irafwrt.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="irafwrt.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="irafwrt:source"></a>pro irafwrt, image, hd, filename, PIXDIR = pixdir
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     IRAFWRT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Write IDL data in IRAF (OIF) format (.imh and .pix files).</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     Does the reverse of IRAFRD.    IRAFWRT writes the "old" IRAF format</span>
<span class="comments">;     used prior to v2.11.   However, this "old" format is still readable by</span>
<span class="comments">;     the current version of IRAF.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: </span>
<span class="comments">;    IRAFWRT, image, hdr, filename, [ PIXDIR = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     image - array containing data</span>
<span class="comments">;     hdr   - The  corresponding FITS header.   Use MKHDR to create a minimal</span>
<span class="comments">;             FITS header if one does not already exist.</span>
<span class="comments">;     filename - Scalar string giving the name of the file to be written </span>
<span class="comments">;             Should not include the extension name, which will be supplied </span>
<span class="comments">;             by IRAFWRT.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     None</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;      PIXDIR - scalar string specifying the directory into which to write</span>
<span class="comments">;              the IRAF pixel (.pix) file.   The default is to write the pixel</span>
<span class="comments">;              file to the same directory as the header (.imh) file</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;      Image array and  FITS header are written to IRAF pixel file </span>
<span class="comments">;               'filename'.pix and header file 'filename'.imh</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Write an empty 50 x 50 array of all zeros to an IRAF file named 'EMPTY'</span>
<span class="comments">;</span>
<span class="comments">;       IDL> im = intarr( 50, 50)         ;Create empty array</span>
<span class="comments">;       IDL> mkhdr, hdr, im               ;Create a minimal FITS header</span>
<span class="comments">;       IDL> irafwrt, im, hdr, 'empty'    ;Write to a IRAF file named 'empty'</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       IRAFWRT gets information about the data - image dimensions, size, </span>
<span class="comments">;       datatype, maximum and minimum pixel values - and writes it into</span>
<span class="comments">;       the binary part of the header. The ASCII part of the header</span>
<span class="comments">;       is directly copied after deleting records with certain keywords </span>
<span class="comments">;       A pixel file is created, with a header in the first 1024 bytes</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1) The files are not created by IRAFWRT are not identical to those </span>
<span class="comments">;               created by the IRAF routine rfits.    However, the files </span>
<span class="comments">;               created by IRAFWRT appear to be compatible with all the IRAF </span>
<span class="comments">;               routines tested so far.</span>
<span class="comments">;       (2)  IRAFWRT has been tested on a limited number of data types</span>
<span class="comments">;       (3)  IRAFWRT has only been tested on Unix and VMS systems.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       FDECOMP, IS_IEEE_BIG(), ISARRAY(), REPCHR(), STRN(), SXDELPAR, SXPAR()</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written K. Venkatakrishna, STX February 1992</span>
<span class="comments">;       VMS compatibility    W. Landsman      April 1992</span>
<span class="comments">;       Work with headers without DATE-OBS or ORIGIN           August 1992</span>
<span class="comments">;       Preserve HISTORY records with other FITS records       March 1995    </span>
<span class="comments">;       Fix case where a minimal FITS header supplied          August 1995</span>
<span class="comments">;       Work under Alpha/OSF and Linux                         Dec.   1995</span>
<span class="comments">;       Make sureheader has 80 char lines, use IS_IEEE_BIG()   May    1997</span>
<span class="comments">;       Don't apply strlowcase to .pix name   W. Landsman      April 1999</span>
<span class="comments">;       Work with double precision            W. Landsman      May 1999</span>
<span class="comments">;       Minimize use of obsolete !ERR         W. Landsman      Feb. 2000</span>
<span class="comments">;       Assume since V5.5, remove VMS support W. Landsman       Sep. 2006</span>
<span class="comments">;-     </span>
 On_error,2

 if N_params() LT 3 then begin
        print,'Syntax - IRAFWRT, image, header, filename, [PIXDIR = ]'
        return
  endif
<span class="comments">;</span>
<span class="comments">; Get the dimensions, vector of dimensions and the data type</span>

  imsize  =  size(image) 
  naxis = imsize[0]
  imdim = imsize[1:naxis]
  type = imsize[naxis+1]
  im_max = max(image,min=im_min)  <span class="comments">; find the minimum and maximum pixel values</span>

  case type of
  1: datatype = 1
  2: datatype = 3
  3: datatype = 4
  4: datatype = 6
  5: datatype = 7
  else: message,'ERROR - Input data type is currently unsupported'
  endcase

  fname = filename

  big_endian = is_ieee_big()

 header = fname+'.imh'
 openw, lun1, header, /GET_LUN

 object = sxpar( hd, 'OBJECT',Count = N_object)
 if ( N_object EQ 0 ) or ( object EQ '' ) then object = ' '
 origin = sxpar( hd, 'ORIGIN', Count = N_origin)
 if ( N_origin EQ 0 ) or ( origin EQ '') then origin = ' '
 date_obs = sxpar( hd, 'DATE-OBS', Count = N_date ) 
 if ( N_date EQ 0 ) or ( date_obs EQ '')  then date_obs = ' '

 hist_rec = where(strpos(hd,'HISTORY') EQ 0, Nhist)        <span class="comments">; Get history records</span>
 if Nhist GT 0 then history = hd[hist_rec] else $
                    history = ' '

<span class="comments">;Copy header to new variable and leave original variable unmodified</span>
 xhdr = hd                   

 delete_rec = ['SIMPLE', 'BITPIX', 'NAXIS ', 'NAXIS1', 'NAXIS2', 'DATATYPE', $
            'OBJECT', 'ORIGIN', 'BSCALE', 'BZERO', 'GROUPS', $
            'IRAFNAME', 'END']

 sxdelpar, xhdr, delete_rec

 nmax = N_elements(xhdr)
 bhdr = replicate(32b, 80, nmax)         <span class="comments">;Make sure it is 80 bytes</span>
 for i = 0l,nmax-1 do bhdr[0,i] = byte(xhdr[i])

 if isarray(xhdr) then $
         hdrlen = (nmax*162 + 2056)/4 $
    else hdrlen = 514

 hdr = bytarr(hdrlen*4)             <span class="comments">; Create header array</span>

 inp = [ fix(hdrlen), fix(datatype), fix(naxis)]

 buf = bytarr(1024)
 hdr[12] = byte(inp,0,2)            <span class="comments">; write header length, data type</span>
 hdr[16] = byte(inp,2,2)            <span class="comments">; and number of dimensions into</span>
 hdr[20] = byte(inp,4,2)            <span class="comments">; header</span>
 buf[20] = byte(inp,4,2)
<span class="comments">;</span>
<span class="comments">; find current time in seconds wrt Jan-01-80 00:00:00</span>
<span class="comments">;</span>
 time_creat = systime(2)-315550800.
 if big_endian then byteorder, hdr, /LSWAP   

 min = strn(im_min,format = '(E13.6)')
 max = strn(im_max,format = '(E13.6)') 
 max_rec_pos = where(strpos(xhdr,'IRAF-MAX = ') EQ 0)
 min_rec_pos = where(strpos(xhdr,'IRAF-MIN = ') EQ 0)
 if (max_rec_pos[0] GE 0) then begin
            max_rec = xhdr[max_rec_pos[0]]   <span class="comments">; write maximum</span>
            min_rec = xhdr[min_rec_pos[0]]   <span class="comments">; and minimum pixel</span>
            strput,max_rec,max,18        <span class="comments">; values</span>
            strput,min_rec,min,18
            xhdr[max_rec_pos[0]] = max_rec
            xhdr[min_rec_pos[0]] = min_rec
 end
<span class="comments">;</span>
<span class="comments">; write the ascii part of the header</span>
<span class="comments">;</span>
  if hdrlen GT 514 then $
        for i = 0, nmax-1 do begin
            hdr[ 2052 + 162L*i + lindgen(80)*2]  =  bhdr[*,i]
            hdr[2052+162L*i+160] = 10B
        endfor

  if big_endian then byteorder,hdr,/SSWAP
  if not big_endian then offset = 0 else offset = 1
  hdr[ 732 + indgen(strlen(object))*2+offset] = byte(object)
  hdr[indgen(5)*2 + offset] = byte('imhdr')
  hdr[24] = byte(imdim,0,4*naxis)
  buf[24] = byte(imdim,0,4*naxis)
  hdr[52] = byte(imdim,0,4*naxis)
  hdr[120] = byte(im_max,0,4)
  hdr[124] = byte(im_min[0],0,4)
  cd,current = dir

     host = getenv('HOST')
    dir  =  dir + path_sep()
 
  if keyword_set(pixdir) then dir = pixdir
  pixname = host+'!' + dir + fname + '.pix'
  len1 = strlen(pixname)
  len2 = strlen(header)
  hdr[ 412 + offset + indgen(len1[0])*2] = byte(pixname)   <span class="comments">; write pixel file location    </span>
  hdr[ 572 + offset + indgen(len2[0])*2] = byte(header)    <span class="comments">; into header</span>
<span class="comments">; Get the history records</span>
<span class="comments">;</span>
 ind = 893
 hdr[ind+indgen(strlen(origin[0]))*2] = byte(origin[0])
 ind = ind+2*strlen(origin[0])
 hdr[ind] = 10B
 ind = ind+2
 hdr[ind+indgen(strlen(date_obs[0]))*2] = byte(date_obs[0])
 ind = ind+2*strlen(date_obs[0])
 hdr[ind] = 10B
 ind = ind+2

<span class="comments">; write the history comment strings (as many as possible) in binary form</span>
<span class="comments">; into the available 1160 bytes </span>

 for i = 0, N_elements(history)-1 do begin
            hist = strtrim(strmid(history[i],8,72))
            if ( strlen(hist) EQ 0 ) then goto, SKIP    
            if (ind + 2*strlen(hist) GT 2052 ) then goto, HIST_END    
            hdr[ ind + indgen( strlen(hist) )*2 ] = byte(hist)
            ind = ind+2*strlen(hist)
            hdr[ind] = 10B
            ind = ind+2 
            SKIP:   
 end
 HIST_END:   
 hdr[88 + 2*offset] = byte(513,0,2)
 hdr[108] = byte(long(time_creat),0,4)       <span class="comments">; write time of image creation</span>
 buf[108] = byte(long(time_creat),0,4)       <span class="comments">; time of last modification</span>
 hdr[112] = byte(long(time_creat),0,4)       <span class="comments">; and time minimum and maximum </span>
 hdr[116] = byte(long(time_creat),0,4)       <span class="comments">; pixel values were computed</span>
 
         hdr[32 + indgen(5)*4 + 3*offset] = 1
         buf[32 + indgen(5)*4 + 3*offset] = 1
         if big_endian then begin
            hdr[63 + indgen(5)*4] = 1
            buf[63 + indgen(5)*4] = 1
         endif
         hdr[63 + indgen(5)*4 - 3*offset] = 128
         buf[63 + indgen(5)*4 - 3*offset] = 128

  writeu,lun1,hdr
  free_lun,lun1

<span class="comments">; Write the data into the .pix file   </span>

 buf[ offset + indgen(5)*2] = byte('impix')
 if not big_endian then buf[12] = [65b, 58b] else $
                              buf[14] = [58b, 65b]
 hdrname = repchr(pixname,'pix','imh')
 buf[ 412 + offset+ indgen(len1[0])*2 ] = byte(hdrname)
 buf[ 572 + offset + indgen(len2[0])*2] = byte(header)
 node = strpos( pixname, '!')
 pixfile = strmid( pixname, node+1,strlen(pixname)-node+1 )

 openw,lun2, pixfile, /GET_LUN

 writeu, lun2, buf
 writeu, lun2, image

 free_lun, lun2

 return
 end
</code>
    </div>
  </body>
</html>