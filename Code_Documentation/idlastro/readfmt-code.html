<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>readfmt.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="readfmt.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="readfmt:source"></a>pro readfmt,name,fmt,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15, $
                 v16,v17,v18,v19,v20,v21,v22,v23,v24,v25, $
                 SILENT = silent, DEBUG = debug, SKIPLINE = skipline, $
                 NUMLINE = numline
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     READFMT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Quickly read a fixed format ASCII data file into IDL variables. </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Lines of data not meeting the specified format (e.g. comments) are</span>
<span class="comments">;       ignored.  </span>
<span class="comments">;      </span>
<span class="comments">;       To read a free format ASCII data file use the procedures </span>
<span class="comments">;       READCOL or RDFLOAT.     To print (formatted or free) columns of data</span>
<span class="comments">;       use the procedure FORPRINT.   </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       READFMT, name, fmt, v1,[ v2, v3, v4, ..., v25 , </span>
<span class="comments">;                          /SILENT, /DEBUG, SKIPLINE= , NUMLINE =]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       NAME - Name of ASCII data file.  An extension of .DAT is assumed,</span>
<span class="comments">;               if not supplied.</span>
<span class="comments">;       FMT - scalar string containing a valid FORTRAN read format.</span>
<span class="comments">;               Must include a field length specification.   Cannot include</span>
<span class="comments">;               internal parenthesis.  A format field must be included for </span>
<span class="comments">;               each output vector.   Multiple format fields are allowed, but</span>
<span class="comments">;               the repetition factor must be less than 100, (.i.e. 19X is </span>
<span class="comments">;               allowed but 117X is illegal) </span>
<span class="comments">;</span>
<span class="comments">;       Examples of valid FMT values are</span>
<span class="comments">;               FMT = 'A7,3X,2I4'  or FMT = '1H ,5I7,2A7'</span>
<span class="comments">;       Examples of INVALID FMT values are</span>
<span class="comments">;               FMT = 'A7,B3'           ;'B' is not a valid FORTRAN format</span>
<span class="comments">;               FMT = 'A7,2(I3,F5.1)'   ;Internal parenthesis not allowed</span>
<span class="comments">;               FMT = 'A7,F,I'          ;Field length not included</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       V1,V2,V3,V4... - IDL vectors to contain columns of data.</span>
<span class="comments">;               Up to 25 output vectors may be read.  The type of the output </span>
<span class="comments">;               vectors are specified by FMT.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;       /SILENT - If this keyword is set and non-zero, then certain terminal</span>
<span class="comments">;               output is suppressed while reading the file</span>
<span class="comments">;       /DEBUG - Set this keyword to display additional information while</span>
<span class="comments">;               reading the file.</span>
<span class="comments">;       SKIPLINE - Scalar specifying number of lines to skip at the top of</span>
<span class="comments">;               file before reading. Default is to start at first line</span>
<span class="comments">;       NUMLINE - Scalar specifying number of lines in the file to read.</span>
<span class="comments">;               Default is to read the entire file </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       Each row in a fixed-format file POSITION.DAT contains a 5 character </span>
<span class="comments">;       star name  and 6 columns of data giving an RA and Dec in sexagesimal </span>
<span class="comments">;       format.   A possible format for such data might be</span>
<span class="comments">;</span>
<span class="comments">;       IDL> FMT = 'A5,2I3,F5.1,2x,3I3'    </span>
<span class="comments">;       and the file could be quickly read with</span>
<span class="comments">;</span>
<span class="comments">;       IDL> READFMT,'POSITION', fmt, name, hr, min, sec, deg, dmin, dsec </span>
<span class="comments">;    </span>
<span class="comments">;       NAME will be a string vector,SEC will be a floating point vector, and</span>
<span class="comments">;       the other vectors will be of integer type.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       This procedure is designed for generality and not for speed.</span>
<span class="comments">;       If a large ASCII file is to be read repeatedly, it may be worth</span>
<span class="comments">;       writing a specialized reader.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       When reading a field with an integer format I&lt;n>, the output vector is</span>
<span class="comments">;               byte  - if n = 1</span>
<span class="comments">;               integer*2 - if 1 &lt; n &lt; 5</span>
<span class="comments">;               integer*4  - in all other cases</span>
<span class="comments">;       Octal ('O') and hexadecimal ('Z') formats are read into longwords</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       GETTOK(), REMCHAR, ZPARCHECK</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written         W. Landsman                 November, 1988</span>
<span class="comments">;       Added SKIPLINE and NUMLINE keywords         March 92</span>
<span class="comments">;       Allow up to 25 columns to be read           June 92</span>
<span class="comments">;       Call NUMLINES() function                    Feb 1996</span>
<span class="comments">;       Recognize 'O' and 'Z' formats  W. Landsman   September 1997</span>
<span class="comments">;       Recognize 'G' format, use SKIP_LUN   W. Landsman  May 2010</span>
<span class="comments">;-</span>
  On_error,2
  compile_opt idl2

  if N_params() LT 3 then begin
      print,'Syntax - readfmt, name, fmt, v1,[ v2, v3, v4...v25, '
      print,'         /SILENT, /DEBUG, SKIPLINE =, NUMLINE = ]'
      return
  endif

  zparcheck, 'READFMT', fmt, 2, 7, 0, 'FORMAT string'

<span class="comments">; Get number of lines in file </span>

   nlines = FILE_LINES( name )
 
  if ~keyword_set( SKIPLINE ) then skipline = 0
  if keyword_set( NUMLINE) then nlines = numline &lt<span class="comments">; nlines else $</span>
               nlines = nlines - skipline
 
  if nlines LE 0 then begin
        message,'ERROR - File ' + name+' contains no valid data',/CON
	return
   endif   
  ncol = N_params() - 2           <span class="comments">;Number of columns of data expected</span>
  ii = strtrim(indgen(ncol)+1,2)
  frmt = strtrim( strupcase(fmt), 2 )      <span class="comments">;Working FORMAT string</span>

<span class="comments">; If format string is of the form "$(...)"  then remove dollar sign and</span>
<span class="comments">; parenthesis </span>

  remchar, frmt, '$'                      <span class="comments">;Remove dollar sign</span>
  if strmid(frmt,0,1) EQ '(' then $
          frmt = strmid( frmt,1,strlen(frmt)-1 )

  if strmid(frmt,strlen(frmt)-1,1) EQ ')' then $
          frmt = strmid(frmt,0,strlen(frmt)-1 )

  fmt1 = '(' + frmt + ')'              <span class="comments">;Now make a valid read format</span>


<span class="comments">; Create output arrays according to specified formats</span>

   k = 0L                             <span class="comments">;Loop over output columns</span>
  REPEAT BEGIN

    fmt_1 = gettok(frmt,',')
    vtype = strmid( fmt_1, 0, 1)
    ndup = 1
    if (strnumber(vtype,val) EQ 1) then begin   <span class="comments">;Test for multiple format</span>

        ndup = val
        vtype = strmid(fmt_1,1,1)

        if (strnumber(vtype,val) EQ 1) then begin

               ndup = 10*ndup+ val
               vtype = strmid(fmt_1,2,1)

        endif

        if vtype EQ '(' then $
           message,'Parenthesis within format string not allowed'

    endif   
  
    for j = 1L,ndup do begin
     CASE vtype OF 

     'A':  begin

        tst = strnumber(strmid(fmt_1,1, strlen(fmt_1)-1), nfield)
        if (tst EQ 0) or (strlen(fmt_1) LT 2) then $ 
             message,'String format must include a field length'
    
         nfield = fix(nfield)
         idltype = 7
         end

   'D':  idltype = 5

   'E':  idltype = 4

   'F':  idltype = 4
   
   'G':  idltype = 4

   'I':  begin                       <span class="comments">;Decide whether BYTE, INTEGER or LONG</span>

         pos = strpos(fmt_1,vtype)
         len = fix(strmid( fmt_1, pos+1, strlen(fmt_1)-pos-1))
         if len EQ 1 then idltype = 1 $
           else if len LT 5 then idltype = 2 $
                            else idltype = 3

         end

   'H':  goto, NO_VAR 
   
   'O':  idltype = 3
   
   'Z':  idltype = 3

   'X':  goto, NO_VAR               <span class="comments">;No variable declaration needed</span>

   ELSE: message,'ERROR - Illegal format '+fmt_1 +' in field ' + strtrim(k,2)

 endcase

<span class="comments">; Define output arrays</span>

   st = 'v'+ ii[k] +'= make_array(nlines, type = idltype)'  
   tst = execute(st)
   st = 'x'+ ii[k] +'= make_array(1,type = idltype)'  
   tst = execute(st)
   k = k+1
   if k EQ ncol then goto, DONE          <span class="comments">;Normal exit</span>
  endfor
NO_VAR:  

  ENDREP until frmt EQ ''

  message,'ERROR - ' + strtrim(ncol,2)+ ' output vectors supplied but only ' + $
         strtrim(k,2) + ' FORMAT fields specified'

DONE: 
  
  openr, LUN, name, /get_lun
  ngood = 0L
  skip_lun,lun,skipline,/lines

  On_IOerror, BAD_LINE  


  for j = 0L,nlines-1 do begin

   badline = 1

   case ncol of                  <span class="comments">;Can't use ON_IOERROR with EXECUTE statement</span>
<span class="comments">;                                 so have to list all the possibilities </span>
   1:   readf,LUN,f = fmt1,x1        
   2:   readf,LUN,f = fmt1,x1,x2
   3:   readf,LUN,f = fmt1,x1,x2,x3
   4:   readf,LUN,f = fmt1,x1,x2,x3,x4
   5:   readf,LUN,f = fmt1,x1,x2,x3,x4,x5
   6:   readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6
   7:   readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7
   8:   readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8
   9:   readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9
   10:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
   11:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11
   12:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12
   13:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13
   14:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14
   15:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15
   16:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,$
                      x16
   17:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,$
                      x16,x17
   18:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18
   19:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19 
   20:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20 
   21:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20,x21 
   22:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20,x21,x22 
   23:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20,x21,x22,x23
   24:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20,x21,x22,x23,x24 
   25:  readf,LUN,f = fmt1,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15, $
                   x16,x17,x18,x19,x20,x21,x22,x23,x24,x25 

  ENDCASE 

    for i = 0L, ncol-1 do begin

        st ='v' + ii[i] + '[ngood] = x'+ii[i]
        tst = execute(st)

     endfor

     ngood = ngood + 1
     badline = 0
BAD_LINE: 
     if badline then if ~keyword_set(SILENT) then $
                 message,'Error reading line ' + strtrim(skipline+ j+1,2),/CON
  endfor
  free_lun, LUN

  if ngood EQ 0L then message, $
                'ERROR - No valid lines found with specified format'
  if ~keyword_set( SILENT)  then $
          message, strtrim(ngood,2) + ' valid lines read',/INF

<span class="comments">; Compress arrays to match actual number of valid lines</span>

  for i = 0L, ncol-1 do begin 

      var ='v'+ii[i]
      tst = execute(var + '='+ var+ '[0:ngood-1]')

  endfor

  return
  end
</code>
    </div>
  </body>
</html>