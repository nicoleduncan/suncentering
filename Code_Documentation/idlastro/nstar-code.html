<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:53 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>nstar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="nstar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="nstar:source"></a>pro nstar,image,id,xc,yc,mags,sky,group,phpadu,readns,psfname,DEBUG=debug, $  
          errmag,iter,chisq,peak,PRINT=print,SILENT=silent, VARSKY = varsky
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       NSTAR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Simultaneous point spread function fitting (adapted from DAOPHOT)</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This PSF fitting algorithm is based on a very old (~1987) version of </span>
<span class="comments">;       DAOPHOT, and much better algorithms (e.g. ALLSTAR) are now available</span>
<span class="comments">;       -- though not in IDL.</span>
<span class="comments">;       </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       NSTAR, image, id, xc, yc, mags, sky, group, [ phpadu, readns, psfname,</span>
<span class="comments">;               magerr, iter, chisq, peak, /PRINT , /SILENT, /VARSKY, /DEBUG ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       image - image array</span>
<span class="comments">;       id    - vector of stellar ID numbers given by FIND</span>
<span class="comments">;       xc    - vector containing X position centroids of stars (e.g. as found</span>
<span class="comments">;               by FIND)</span>
<span class="comments">;       yc    - vector of Y position centroids</span>
<span class="comments">;       mags  - vector of aperture magnitudes (e.g. as found by APER)</span>
<span class="comments">;               If 9 or more parameters are supplied then, upon output</span>
<span class="comments">;               ID,XC,YC, and MAGS will be modified to contain the new</span>
<span class="comments">;               values of these parameters as determined by NSTAR.</span>
<span class="comments">;               Note that the number of output stars may be less than </span>
<span class="comments">;               the number of input stars since stars may converge, or </span>
<span class="comments">;               "disappear" because they are too faint.</span>
<span class="comments">;       sky   - vector of sky background values (e.g. as found by APER)</span>
<span class="comments">;       group - vector containing group id's of stars as found by GROUP</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       phpadu - numeric scalar giving number of photons per digital unit.  </span>
<span class="comments">;               Needed for computing Poisson error statistics.   </span>
<span class="comments">;       readns - readout noise per pixel, numeric scalar.   If not supplied, </span>
<span class="comments">;               NSTAR will try to read the values of READNS and PHPADU from</span>
<span class="comments">;               the PSF header.  If still not found, user will be prompted.</span>
<span class="comments">;       psfname - name of FITS image file containing the point spread</span>
<span class="comments">;               function residuals as determined by GETPSF, scalar string.  </span>
<span class="comments">;               If omitted, then NSTAR will prompt for this parameter.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;       MAGERR - vector of errors in the magnitudes found by NSTAR</span>
<span class="comments">;       ITER - vector containing the number of iterations required for</span>
<span class="comments">;               each output star.  </span>
<span class="comments">;       CHISQ- vector containing the chi square of the PSF fit for each</span>
<span class="comments">;               output star.</span>
<span class="comments">;       PEAK - vector containing the difference of the mean residual of</span>
<span class="comments">;               the pixels in the outer half of the fitting circle and</span>
<span class="comments">;               the mean residual of pixels in the inner half of the</span>
<span class="comments">;               fitting circle</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;       /SILENT - if set and non-zero, then NSTAR will not display its results</span>
<span class="comments">;               at the terminal</span>
<span class="comments">;       /PRINT - if set and non-zero then NSTAR will also write its results to</span>
<span class="comments">;               a file nstar.prt.   One also can specify the output file name</span>
<span class="comments">;               by setting PRINT = 'filename'.</span>
<span class="comments">;       /VARSKY - if this keyword is set and non-zero, then the sky level of</span>
<span class="comments">;               each group is set as a free parameter.</span>
<span class="comments">;       /DEBUG - if this keyword is set and non-zero, then the result of each</span>
<span class="comments">;               fitting iteration will be displayed.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       DAO_VALUE(), READFITS(), REMOVE, SPEC_DIR(), STRN(), SXPAR()</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCK:</span>
<span class="comments">;       RINTER - contains pre-tabulated values for cubic interpolation</span>
<span class="comments">; REVISION HISTORY</span>
<span class="comments">;       W. Landsman                 ST Systems Co.       May, 1988</span>
<span class="comments">;       Adapted for IDL Version 2, J. Isensee, September, 1990</span>
<span class="comments">;       Minor fixes so that PRINT='filename' really prints to 'filename', and</span>
<span class="comments">;       it really silent if SILENT is set.  J.Wm.Parker HSTX 1995-Oct-31</span>
<span class="comments">;       Added /VARSKY option   W. Landsman   HSTX      May 1996</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Replace DATATYPE() with size(/TNAME)  W. Landsman November 2001</span>
<span class="comments">;       Assume since V5.5, remove VMS calls W. Landsman September 2006</span>
<span class="comments">;-</span>
 compile_opt idl2
 common rinter,c1,c2,c3,init            <span class="comments">;Save time in RINTER()</span>
 npar = N_params()
 if npar LT 7 then begin
   print,'Syntax - NSTAR, image, id, xc, yc, mags, sky, group, [phpadu, '
   print, $
     '   [readns, psfname, magerr, iter, chisq, peak, /SILENT, /PRINT, /VARSKY]'
   return
 endif                                                        

 if ( N_elements(psfname) EQ 0 ) then begin
   psfname=''
   read,'Enter name of FITS file containing PSF: ',psfname
 endif else zparcheck,'PSFNAME',psfname,10,7,0,'PSF disk file name'

 psf_file = file_search( psfname, COUNT = n)
 if n EQ 0 then message, $
      'ERROR - Unable to locate PSF file ' + spec_dir(psfname)

 if npar LT 9 then begin                                                     
   ans = ''
   read, $
     'Do you want to update the input vectors with the results of NSTAR? ',ans
   if strmid(strupcase(ans),0,1) EQ 'Y' then npar = 9
 endif

 if npar LT 9 then $
    message,'Input vectors ID,XC,YC and MAGS will not be updated by NSTAR',/INF

<span class="comments">; Read in the FITS file containing the PSF</span>

 s = size(image)
 icol = s[1]-1 & irow = s[2]-1  <span class="comments">;Index of last row and column</span>
 psf = readfits(psfname, hpsf)
 if  N_elements(phpadu) EQ 0 then begin 
    par = sxpar(hpsf,'PHPADU', Count = N_phpadu)
    if N_phpadu eq 0 $
        then read, 'Enter photons per analog digital unit: ',phpadu $
        else phpadu = par
endif

 if ( N_elements(readns) EQ 0 ) then begin 
    par = sxpar(hpsf,'RONOIS', Count = N_ronois)
    if N_ronois EQ 0 $
        then read, 'Enter the readout noise per pixel: ',readns $
        else readns = par
 endif

 gauss = sxpar(hpsf,'GAUSS*')
 psfmag = sxpar(hpsf,'PSFMAG')
 psfrad = sxpar(hpsf,'PSFRAD')
 fitrad = sxpar(hpsf,'FITRAD')
 npsf = sxpar(hpsf,'NAXIS1')
<span class="comments">;                               Compute RINTER common block arrays</span>
 p_1 = shift(psf,1,0) & p1 = shift(psf,-1,0) & p2 = shift(psf,-2,0)
 c1 = 0.5*(p1 - p_1)
 c2 = 2.*p1 + p_1 - 0.5*(5.*psf + p2)
 c3 = 0.5*(3.*(psf-p1) + p2 - p_1)
 init = 1

 ronois = readns^2
 radsq = fitrad^2   &  psfrsq = psfrad^2
 sepmin = 2.773*(gauss[3]^2+gauss[4]^2)

<span class="comments">;      PKERR will be used to estimate the error due to interpolating PSF</span>
<span class="comments">;      Factor of 0.027 is estimated from good-seeing CTIO frames</span>

 pkerr = 0.027/(gauss[3]*gauss[4])^2     
 sharpnrm = 2.*gauss[3]*gauss[4]/gauss[0]
 if (N_elements(group) EQ 1) then groupid = group[0] else $
     groupid = where(histogram(group,min=0))    <span class="comments">;Vector of distinct group id's</span>

 mag = mags                        <span class="comments">;Save original magnitude vector</span>
 bad = where( mag GT 99, nbad )     <span class="comments">;Undefined magnitudes assigned 99.9</span>
 if nbad GT 0 then mag[bad] = psfmag + 7.5
 mag = 10.^(-0.4*(mag-psfmag)) <span class="comments">;Convert magnitude to brightness, scaled to PSF</span>
 fmt = '(I6,2F9.2,3F9.3,I4,F9.2,F9.3)'

 SILENT = keyword_set(SILENT)
 VARSKY = keyword_set(VARSKY)

 if keyword_set(PRINT) then begin
     if ( size(print,/TNAME) NE 'STRING' ) then file = 'nstar.prt' $
                                           else file = print
    message,'Results will be written to a file '+ file,/INF
     openw,lun,file,/GET_LUN
     printf,lun,'NSTAR:    '+ getenv('USER') + ' '+ systime()
     printf,lun,'PSF File:',psfname
 endif 
 PRINT = keyword_set(PRINT)

 hdr='   ID      X       Y       MAG     MAGERR   SKY   NITER     CHI     SHARP'
 if not(SILENT) then print,hdr
 if PRINT then printf,lun,hdr

 for igroup = 0, N_elements(groupid)-1 do begin

 index = where(group EQ groupid[igroup],nstr) 
 if not SILENT then print,'Processing group ', $
               strtrim(groupid[igroup],2),'    ',strtrim(nstr,2),' stars'
 if nstr EQ 0 then stop
 magerr = fltarr(nstr)
 chiold = 1.0
 niter = 0
 clip = 0b
 nterm = nstr*3 + varsky
 xold = dblarr(nterm)
 clamp = replicate(1.,nterm)
 xb = double(xc[index])  &   yb = double(yc[index])
 magg = double(mag[index]) & skyg = double(sky[index])
 idg = id[index]
 skybar = total(skyg)/nstr
 reset = 0b
<span class="comments">;</span>
START_IT : 
   niter = niter+1
RESTART: 
 case 1 of              <span class="comments">;Set up critical error for star rejection</span>
   niter GE 4 : wcrit = 1
   niter GE 8 : wcrit = 0.4444444
   niter GE 12: wcrit = 0.25             
   else       : wcrit = 400                                                   
 endcase

 if reset EQ 1b then begin
     xb = xg + ixmin & yb = yg + iymin
 endif

 reset = 1b
 xfitmin = fix(xb - fitrad) > 0
 xfitmax = fix(xb + fitrad)+1 &lt<span class="comments">; (icol-1)</span>
 yfitmin = fix(yb - fitrad) > 0
 yfitmax = fix(yb + fitrad)+1 &lt<span class="comments">; (irow-1)</span>
 nfitx = xfitmax - xfitmin + 1
 nfity = yfitmax - yfitmin + 1
 ixmin = min(xfitmin)& iymin = min(yfitmin)
 ixmax = max(xfitmax)& iymax = max(yfitmax)
 nx = ixmax-ixmin+1 & ny = iymax-iymin+1
 dimage = image[ixmin:ixmax,iymin:iymax]
 xfitmin = xfitmin -ixmin & yfitmin = yfitmin-iymin
 xfitmax = xfitmax -ixmin & yfitmax = yfitmax-iymin
<span class="comments">;                                        Offset to the subarray</span>
 xg = xb-ixmin & yg = yb-iymin
 j = 0

 while (j LT nstr-1) do begin
   sep = (xg[j] - xg[j+1:*])^2 + (yg[j] - yg[j+1:*])^2
   bad = where(sep LT sepmin,nbad)
   if nbad GT 0 then begin      <span class="comments">;Do any star overlap?</span>
      for l = 0,nbad-1 do begin
      k = bad[l] + j + 1
      if magg[k] LT magg[j] then imin = k else imin = j <span class="comments">;Identify fainter star</span>
      if ( sep[l] LT 0.14*sepmin) or  $
         ( magerr[imin]/magg[imin]^2 GT wcrit ) then begin
      if  imin EQ j then imerge = k else imerge = j
      nstr = nstr - 1
      if not SILENT then print, $
       'Star ',strn(idg[imin]),' has merged with star ',strn(idg[imerge])
      totmag = magg[imerge] + magg[imin]
      xg[imerge] = (xg[imerge]*magg[imerge] + xg[imin]*magg[imin])/totmag
      yg[imerge] = (yg[imerge]*magg[imerge] + yg[imin]*magg[imin])/totmag
      magg[imerge] = totmag     
      remove,imin,idg,xg,yg,magg,skyg,magerr    <span class="comments">;Remove fainter star from group</span>
      nterm = nstr*3 + varsky                   <span class="comments">;Update matrix size</span>
      xold = dblarr(nterm) 
      clamp = replicate(1.,nterm)               <span class="comments">;Release all clamps</span>
      clip = 0b
      niter = niter-1                           <span class="comments">;Back up iteration counter</span>
      goto, RESTART 
      endif
   endfor
   endif
   j = j+1
 endwhile

 xpsfmin = (fix (xg - psfrad+1)) > 0
 xpsfmax = (fix (xg + psfrad  )) &lt<span class="comments">; (nx-1)</span>
 ypsfmin = (fix (yg - psfrad+1)) > 0
 ypsfmax = (fix (yg + psfrad  )) &lt<span class="comments">; (ny-1)</span>
 npsfx = xpsfmax-xpsfmin+1 & npsfy = ypsfmax-ypsfmin+1
 wt = fltarr(nx,ny)
 mask = bytarr(nx,ny)
 nterm = 3*nstr + varsky
 chi = fltarr(nstr) & sumwt = chi & numer = chi & denom = chi
 c = fltarr(nterm,nterm) & v = fltarr(nterm)

 for j = 0,nstr-1 do begin   <span class="comments">;Mask of pixels within fitting radius of any star</span>
     x1 = xfitmin[j]  &  y1 = yfitmin[j]
     x2 = xfitmax[j]  &  y2 = yfitmax[j]
     rpixsq = fltarr(nfitx[j],nfity[j])
     xfitgen2 = (findgen(nfitx[j]) + x1 - xg[j])^2
     yfitgen2 = (findgen(nfity[j]) + y1 - yg[j])^2
     for k=0,nfity[j]-1 do rpixsq[0,k] = xfitgen2 + yfitgen2[k]
     temp = (rpixsq LE 0.999998*radsq)
     mask[x1,y1] = mask[x1:x2,y1:y2] or temp
     good = where(temp)
     rsq = rpixsq[good]/radsq
     temp1 = wt[x1:x2,y1:y2] 
     temp1[good] = temp1[good] > (5./(5.+rsq/(1.-rsq)) )
     wt[x1,y1] = temp1
 endfor

 igood = where(mask, ngoodpix)
 x = dblarr(ngoodpix,nterm)
 if varsky then x[0, nterm-1] = replicate(-1.0d, ngoodpix)

 psfmask = bytarr(ngoodpix,nstr)
 d = dimage[igood] - skybar
 for j = 0,nstr-1 do begin <span class="comments">;Masks of pixels within PSF radius of each star</span>
     x1 = xpsfmin[j]   &    y1 = ypsfmin[j]
     x2 = xpsfmax[j]   &    y2 = ypsfmax[j]
     xgen = lindgen(npsfx[j]) + x1 - xg[j]
     ygen = lindgen(npsfy[j]) + y1 - yg[j]
     xgen2 = xgen^2 & ygen2 = ygen^2
     rpxsq = fltarr( npsfx[j],npsfy[j] )
     for k = 0,npsfy[j]-1 do rpxsq[0,k] = xgen2 + ygen2[k]
     temp =  mask[x1:x2,y1:y2] and (rpxsq LT psfrsq)
     temp1 = bytarr(nx,ny)
     temp1[x1,y1] = temp 
     goodfit = where(temp1[igood])
     psfmask[goodfit+ngoodpix*j] = 1b
     good = where(temp)
     xgood = xgen[good mod npsfx[j]] & ygood = ygen[good/npsfx[j]]
     model = dao_value(xgood,ygood,gauss,psf,dvdx,dvdy)
     d[goodfit] = d[goodfit] - magg[j]*model
     x[goodfit + 3*j*ngoodpix] = -model
     x[goodfit + (3*j+1)*ngoodpix] = magg[j]*dvdx
     x[goodfit + (3*j+2)*ngoodpix] = magg[j]*dvdy
 endfor

 wt = wt[igood] & idimage = dimage[igood]
 dpos = (idimage-d) > 0
 sigsq = dpos/phpadu + ronois + (0.0075*dpos)^2 + (pkerr*(dpos-skybar))^2

 relerr = abs(d)/sqrt(sigsq)
 if clip then begin   <span class="comments">;Reject pixels with 20 sigma errors (after 1st iteration)</span>
        bigpix = where(relerr GT 20.*chiold, nbigpix)
        if ( nbigpix GT 0 ) then begin
              keep = indgen(ngoodpix)
              for i = 0,nbigpix-1 do keep = keep[ where( keep NE bigpix[i]) ]
              wt= wt[keep] & d = d[keep] & idimage = idimage[keep] 
              igood= igood[keep]  & relerr = relerr[keep]
              psfmask = psfmask[keep,*]   &  x = x[keep,*]
        endif
 endif

 sumres = total(relerr*wt)
 grpwt = total(wt)

 dpos = ((idimage-skybar) > 0) + skybar
 sig = dpos/phpadu + ronois + (0.0075*dpos)^2 + (pkerr*(dpos-skybar))^2
 for j = 0,nstr-1 do begin
     goodfit = where(psfmask[*,j])
     chi[j] = total(relerr[goodfit]*wt[goodfit])
     sumwt[j] = total(wt[goodfit])
     xgood = igood[goodfit] mod nx & ygood = igood[goodfit]/nx
     rhosq = ((xg[j] - xgood)/gauss[3])^2  +  ((yg[j] - ygood)/gauss[4])^2
     goodsig = where(rhosq LT 36)     <span class="comments">;Include in sharpness index only</span>
     rhosq = 0.5*rhosq[goodsig]       <span class="comments">;pixels within 6 sigma of centroid</span>
     dfdsig = exp(-rhosq)*(rhosq-1.)
     sigpsf = sig[goodfit[goodsig]] & dsig = d[goodfit[goodsig]]
     numer[j] = total(dfdsig*dsig/sigpsf)
     denom[j] = total(dfdsig^2/sigpsf)
 endfor

 wt = wt/sigsq
 if clip then $  <span class="comments">;After 1st iteration, reduce weight of a bad pixel</span>
   wt = wt/(1.+(0.4*relerr/chiold)^8) 

 v = d * wt # x
 c = transpose(x) # ( ( wt # replicate(1.,nterm) ) * x )

 if grpwt GT 3 then begin
        chiold = 1.2533*sumres*sqrt(1./(grpwt*(grpwt-3.)))
        chiold = ((grpwt-3.)*chiold+3.)/grpwt
 endif

 i = where(sumwt GT 3, ngood)
 if ngood GT 0 then begin 
     chi[i] = 1.2533*chi[i]*sqrt(1./((sumwt[i]-3.)*sumwt[i]))
     chi[i] = ((sumwt[i]-3.)*chi[i]+3.)/sumwt[i]
 endif

chibad = where(sumwt LE 3, ngood)
if ngood GT 0 then chi[chibad] = chiold

 c = invert(c)
 x = c # transpose(v)

 if (not clip) or (niter LE 1) then redo = 1b else redo = 0b 
 if varsky then begin
        skybar = skybar - x[nterm-1]
        if abs(x[nterm-1]) GT  0.01 then redo = 1b
 endif
 clip = 1b

 j = 3*indgen(nstr) & k = j+1 & l=j+2
 sharp = sharpnrm*numer/(magg*denom)
 if not redo then begin
   redo = max(abs(x[j]) GT ( (0.05*chi*sqrt(c[j+nterm*j])) > 0.001*magg) )
   if redo EQ 0 then redo = max( abs([x[k], x[l]]) GT 0.01)
 endif

 sgn = where( xold[j]*x[j]/magg^2 LT -1.E-37, Nclamp )  
 if Nclamp GT 0 then clamp[j[sgn]] = 0.5*clamp[j[sgn]]
 sgn = where( xold[k]*x[k]        LT -1.E-37, Nclamp )
 if Nclamp GT 0 then clamp[k[sgn]] = 0.5*clamp[k[sgn]]
 sgn = where( xold[l]*x[l]        LT -1.E-37, Nclamp )
 if Nclamp GT 0 then clamp[l[sgn]] = 0.5*clamp[l[sgn]]

 magg = magg-x[j] / (1.+ ( (x[j]/(0.84*magg)) > (-x[j]/(5.25*magg)) )/ clamp[j] )
 xg = xg - x[k]   /(1.+abs(x[k])/( clamp[k]*0.5))
 yg = yg - x[l]   /(1.+abs(x[l])/( clamp[l]*0.5))
 xold = x

 magerr = c[j+nterm*j]*(nstr*chi^2 + (nstr-1)*chiold^2)/(2.*nstr-1.)

 dx = (-xg) > ( (xg - nx) > 0.) <span class="comments">;Find stars outside subarray</span>
 dy = (-yg) > ( (yg-  ny) > 0.)
 badcen = where(    $                     <span class="comments">;Remove stars with bad centroids</span>
     (dx GT 0.001) or (dy GT 0.001) or ( (dx+1)^2 + (dy+1)^2 GE radsq ), nbad)
 if nbad GT 0 then begin
        nstr = nstr - nbad
        print,strn(nbad),' stars eliminated by centroid criteria'
        if nstr LE 0 then goto, DONE_GROUP 
        remove, badcen, idg, xg, yg, magg, skyg, magerr
        nterm = nstr*3 + varsky
        redo = 1b
 endif

 faint = 1        
 toofaint =  where (magg LE 1.e-5,nfaint) 
                              <span class="comments">;Number of stars 12.5 mags fainter than PSF star</span>
 if nfaint GT 0 then begin        
         faint = min( magg[toofaint], min_pos )
         ifaint = toofaint[ min_pos ]
         magg[toofaint] = 1.e-5
         goto, REM_FAINT                <span class="comments">;Remove faintest star</span>
 endif else begin
         faint = 0.
         ifaint = -1
         if (not redo) or (niter GE 4) then $
            faint = max(magerr/magg^2, ifaint) else $ 
            goto,START_IT 
 endelse

 if keyword_set(DEBUG) then begin 
   err = 1.085736*sqrt(magerr)/magg
    for i=0,nstr-1 do  print,format=fmt,idg[i],xg[i]+ixmin,yg[i]+iymin, $
          psfmag-1.085736*alog(magg[i]),err[i],skyg[i],niter,chi[i],sharp[i]
 endif

 if redo and (niter LE 50) and (faint LT wcrit) then goto,START_IT   
REM_FAINT: 
 if (faint GE 0.25) or (nfaint GT 0) then begin
         if not SILENT then $
               message,'Star '+ strn(idg[ifaint]) + ' is too faint',/INF
         nstr = nstr-1
         if nstr LE 0 then goto,DONE_GROUP  
         remove,ifaint,idg,xg,yg,magg,skyg,magerr
         nterm = nstr*3 + varsky
         xold = dblarr(nterm)
         clamp = replicate(1.,nterm)
         clip = 0b
         niter = niter-1
         goto,RESTART  
 endif

 err = 1.085736*sqrt(magerr)/magg
 magg = psfmag - 1.085736*alog(magg)
 sharp = sharp > (-99.999) &lt<span class="comments">; 99.999</span>
 xg = xg+ixmin & yg = yg+iymin

<span class="comments">; Print results to terminal and/or file</span>

 if not SILENT then for i = 0,nstr-1 do print,format=fmt, $
     idg[i],xg[i],yg[i],magg[i],err[i],skyg[i],niter,chi[i],sharp[i]
 if PRINT then for i = 0,nstr-1 do printf,lun,format=fmt, $
     idg[i],xg[i],yg[i],magg[i],err[i],skyg[i],niter,chi[i],sharp[i]

 if ( npar GE 9 ) then begin                  <span class="comments">;Create output vectors?</span>
   if ( N_elements(newid) EQ 0 ) then begin  <span class="comments">;Initialize output vectors?</span>
       newid = idg &  newx = xg  &  newy = yg & newmag = magg
       iter = replicate(niter,nstr) & peak = sharp & chisq = chi
       errmag = err
   endif else begin           <span class="comments">;Append current group to output vector</span>
       newid = [newid,idg] & newx = [newx ,xg] & newy = [newy,yg]
       newmag = [newmag,magg] & iter = [iter,replicate(niter,nstr)]
       peak = [peak,sharp]     & chisq = [chisq,chi] & errmag = [errmag,err]
   endelse
 endif

DONE_GROUP: 
 endfor

 if  ( npar GE 9 ) then begin
    if N_elements(newid) GT 0 then begin
       id = newid &  xc = newx &  yc = newy  & mags = newmag
    endif else $
     message,'ERROR - There are no valid stars left, variables not updated',/CON
 endif

 if PRINT then free_lun,lun

 return
 end
</code>
    </div>
  </body>
</html>