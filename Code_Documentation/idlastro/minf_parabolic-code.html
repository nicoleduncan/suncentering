<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>minf_parabolic.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="minf_parabolic.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="minF_parabolic:source"></a>pro minF_parabolic, xa,xb,xc, xmin, fmin, FUNC_NAME=func_name,    $
                                          MAX_ITERATIONS=maxit,   $
                                          TOLERANCE=TOL,          $
                                          POINT_NDIM=pn, DIRECTION=dirn
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MINF_PARABOLIC</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Minimize a function using Brent's method with parabolic interpolation</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Find a local minimum of a 1-D function up to specified tolerance.</span>
<span class="comments">;       This routine assumes that the function has a minimum nearby.</span>
<span class="comments">;       (recommend first calling minF_bracket, xa,xb,xc, to bracket minimum).</span>
<span class="comments">;       Routine can also be applied to a scalar function of many variables,</span>
<span class="comments">;       for such case the local minimum in a specified direction is found,</span>
<span class="comments">;       This routine is called by minF_conj_grad, to locate minimum in the </span>
<span class="comments">;       direction of the conjugate gradient of function of many variables.</span>
<span class="comments">;</span>
<span class="comments">; CALLING EXAMPLES:</span>
<span class="comments">;       minF_parabolic, xa,xb,xc, xmin, fmin, FUNC_NAME="name"  ;for 1-D func.</span>
<span class="comments">;  or:</span>
<span class="comments">;       minF_parabolic, xa,xb,xc, xmin, fmin, FUNC="name", $</span>
<span class="comments">;                                         POINT=[0,1,1],   $</span>
<span class="comments">;                                         DIRECTION=[2,1,1]     ;for 3-D func.</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       xa,xb,xc = scalars, 3 points which bracket location of minimum,</span>
<span class="comments">;               that is, f(xb) &lt; f(xa) and f(xb) &lt; f(xc), so minimum exists.</span>
<span class="comments">;               When working with function of N variables</span>
<span class="comments">;               (xa,xb,xc) are then relative distances from POINT_NDIM,</span>
<span class="comments">;               in the direction specified by keyword DIRECTION,</span>
<span class="comments">;               with scale factor given by magnitude of DIRECTION.</span>
<span class="comments">; INPUT KEYWORDS:</span>
<span class="comments">;      FUNC_NAME = function name (string)</span>
<span class="comments">;               Calling mechanism should be:  F = func_name( px )</span>
<span class="comments">;               where:</span>
<span class="comments">;                       px = scalar or vector of independent variables, input.</span>
<span class="comments">;                       F = scalar value of function at px.</span>
<span class="comments">;</span>
<span class="comments">;      POINT_NDIM = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the starting point in N-dim space.</span>
<span class="comments">;               Default = 0, which assumes function is 1-D.</span>
<span class="comments">;      DIRECTION = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the direction in N-dim space</span>
<span class="comments">;               along which to bracket the local minimum, (default=1 for 1-D).</span>
<span class="comments">;               (xa, xb, xc, x_min are then relative distances from POINT_NDIM)</span>
<span class="comments">;      MAX_ITER = maximum allowed number iterations, default=100.</span>
<span class="comments">;      TOLERANCE = desired accuracy of minimum location, default=sqrt(1.e-7).</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       xmin = estimated location of minimum.</span>
<span class="comments">;               When working with function of N variables,</span>
<span class="comments">;               xmin is the relative distance from POINT_NDIM,</span>
<span class="comments">;               in the direction specified by keyword DIRECTION,</span>
<span class="comments">;               with scale factor given by magnitude of DIRECTION,</span>
<span class="comments">;               so that min. Loc. Pmin = Point_Ndim + xmin * Direction.</span>
<span class="comments">;       fmin = value of function at xmin (or Pmin).</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Brent's method to minimize a function by using parabolic interpolation.</span>
<span class="comments">;       Based on function BRENT in Numerical Recipes in FORTRAN (Press et al. </span>
<span class="comments">;       1992),  sec.10.2 (p. 397).</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1992.</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
        zeps = 1.e-7                    <span class="comments">;machine epsilon, smallest addition.</span>
        goldc = 1 - (sqrt(5)-1)/2       <span class="comments">;complement of golden mean.</span>

        if N_elements( TOL ) NE 1 then TOL = sqrt( zeps )
        if N_elements( maxit ) NE 1 then maxit = 100

        if N_elements( pn ) LE 0 then begin
                pn = 0
                dirn = 1
           endif

        xLo = xa &lt<span class="comments">; xc</span>
        xHi = xa > xc
        xmin = xb
        fmin = call_function( func_name, pn + xmin * dirn )
        xv = xmin  &  xw = xmin
        fv = fmin  &  fw = fmin
        es = 0.

        for iter = 1,maxit do begin

                goldstep = 1
                xm = (xLo + xHi)/2.
                TOL1 = TOL * abs(xmin) + zeps
                TOL2 = 2*TOL1

                if ( abs( xmin - xm ) LE ( TOL2 - (xHi-xLo)/2. ) ) then return

                if (abs( es ) GT TOL1) then begin

                        r = (xmin-xw) * (fmin-fv)
                        q = (xmin-xv) * (fmin-fw)
                        p = (xmin-xv) * q + (xmin-xw) * r
                        q = 2 * (q-r)
                        if (q GT 0) then p = -p
                        q = abs( q )
                        etemp = es
                        es = ds

                        if (p GT q*(xLo-xmin)) AND $
                           (p LT q*(xHi-xmin)) AND $
                           (abs( p ) LT abs( q*etemp/2 )) then begin
                                ds = p/q
                                xu = xmin + ds
                                if (xu-xLo LT TOL2) OR (xHi-xu LT TOL2) then $
                                        ds = TOL1 * (1-2*((xm-xmin) LT 0))
                                goldstep = 0
                           endif
                   endif

                if (goldstep) then begin
                        if (xmin GE xm) then  es = xLo-xmin  else  es = xHi-xmin
                        ds = goldc * es
                   endif

                xu = xmin + (1-2*(ds LT 0)) * ( abs( ds ) > TOL1 )
                fu = call_function( func_name, pn + xu * dirn )

                if (fu LE fmin) then begin

                        if (xu GE xmin) then xLo=xmin else xHi=xmin
                        xv = xw  &  fv = fw
                        xw = xmin  &  fw = fmin
                        xmin = xu  &  fmin = fu
                
                  endif else begin

                        if (xu LT xmin) then xLo=xu else xHi=xu

                        if (fu LE fw) OR (xw EQ xmin) then begin

                                xv = xw  &  fv = fw
                                xw = xu  &  fw = fu

                          endif else if (fu LE fv) OR (xv EQ xmin) $
                                                   OR (xv EQ xw) then begin
                                xv = xu  &  fv = fu
                           endif
                   endelse
          endfor

        message,"exceeded maximum number of iterations: "+strtrim(iter,2),/INFO
return
end
</code>
    </div>
  </body>
</html>