<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:41 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hermite.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hermite.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="hermite:source"></a>function hermite,xx,ff,x, FDERIV = fderiv
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       HERMITE</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       To compute Hermite spline interpolation of a tabulated function.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Hermite interpolation computes the cubic polynomial that agrees with </span>
<span class="comments">;       the tabulated function and its derivative at the two nearest </span>
<span class="comments">;       tabulated points.   It may be preferable to Lagrangian interpolation </span>
<span class="comments">;       (QUADTERP) when either (1) the first derivatives are known, or (2)</span>
<span class="comments">;       one desires continuity of the first derivative of the interpolated</span>
<span class="comments">;       values.    HERMITE() will numerically compute the necessary</span>
<span class="comments">;       derivatives, if they are not supplied.</span>
<span class="comments">;       </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       F = HERMITE( XX, FF, X, [ FDERIV = ])</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;       XX - Vector giving tabulated X values of function to be interpolated</span>
<span class="comments">;               Must be either monotonic increasing or decreasing   </span>
<span class="comments">;       FF - Tabuluated values of function, same number of elements as X</span>
<span class="comments">;       X -  Scalar or vector giving the X values at which to interpolate</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       FDERIV - function derivative values computed at XX.    If not supplied,</span>
<span class="comments">;               then HERMITE() will compute the derivatives numerically.</span>
<span class="comments">;               The FDERIV keyword is useful either when (1) the derivative</span>
<span class="comments">;               values are (somehow) known to better accuracy than can be </span>
<span class="comments">;               computed numerically, or (2) when HERMITE() is called repeatedly</span>
<span class="comments">;               with the same tabulated function, so that the derivatives</span>
<span class="comments">;               need be computed only once.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT PARAMETER:</span>
<span class="comments">;       F - Interpolated values of function, same number of points as X</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Interpolate the function 1/x at x = 0.45 using tabulated values</span>
<span class="comments">;       with a spacing of 0.1</span>
<span class="comments">;</span>
<span class="comments">;       IDL> x = findgen(20)*0.1 + 0.1</span>
<span class="comments">;       IDL> y = 1/x</span>
<span class="comments">;       IDL> print,hermite(x,y,0.45)         </span>
<span class="comments">;               This gives 2.2188 compared to the true value 1/0.45 = 2.2222</span>
<span class="comments">;</span>
<span class="comments">;       IDL> yprime = -1/x^2      ;But in this case we know the first derivatives</span>
<span class="comments">;       IDL> print,hermite(x,y,0.45,fderiv = yprime)</span>
<span class="comments">;             == 2.2219            ;and so can get a more accurate interpolation</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The algorithm here is based on the FORTRAN code discussed by </span>
<span class="comments">;       Hill, G. 1982, Publ Dom. Astrophys. Obs., 16, 67.   The original </span>
<span class="comments">;       FORTRAN source is U.S. Airforce. Surveys in Geophysics No 272. </span>
<span class="comments">;</span>
<span class="comments">;       HERMITE() will return an error if one tries to interpolate any values </span>
<span class="comments">;       outside of the range of the input table XX</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       None</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written,    B. Dorman (GSFC) Oct 1993, revised April 1996</span>
<span class="comments">;       Added FDERIV keyword,  W. Landsman (HSTX)  April 1996</span>
<span class="comments">;       Test for out of range values  W. Landsman (HSTX) May 1996</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Use VALUE_LOCATE instead of TABINV   W. Landsman   February 2001</span>
<span class="comments">;-</span>
   On_error,2 

   if N_Params() LT 3 then begin
        print,'Syntax:  f = HERMITE( xx, ff, x, [FDERIV = ] )'
        return,0
   endif

   n = N_elements(xx)           <span class="comments">;Number of knot points</span>
   m = N_elements(x)            <span class="comments">;Number of points at which to interpolate</span>

   l = value_locate(xx,x)       <span class="comments">;Integer index of interpolation points </span>

   bad = where( (l LT 0) or (l EQ n-1), Nbad)
        if Nbad GT 0 then message, 'ERROR - Valid interpolation range is ' + $
        strtrim(xx[0],2) + ' to ' + strtrim(xx[n-1],2)

   n1 = n - 1
   n2 = n - 2

   l1  = l + 1  
   l2 = l1 + 1
   lm1 = l - 1
   h1 = double(1./(xx[l] - xx[l1]))
   h2 = - h1

<span class="comments">; If derivatives were not supplied, then compute numeric derivatives at the </span>
<span class="comments">; two closest knot points</span>

 if N_elements(fderiv) NE 0 then begin
        f2 = fderiv[l1]
        f1 = fderiv[l]

 endif else begin

   f1 = dblarr(m)
   f2 = dblarr(m)
   for i = 0,m-1 do begin
        if l[i] ne 0 then begin
           if l[i] lt n2 then begin
              f2[i] = (ff[l2[i]] - ff[l[i]])/(xx[l2[i]]-xx[l[i]])
           endif else begin
              f2[i] = (ff[n1] - ff[n2])/(xx[n1] - xx[n2])
           endelse
           f1[i] = ( ff[l1[i]] - ff[lm1[i]] )/( xx[l1[i]] - xx[lm1[i]] )
        endif else begin
           f1[i] = (ff[1] - ff[0])/(xx[1] - xx[0])
           f2[i] = (ff[2] - ff[0])/(xx[2] - xx[0])
        endelse
   endfor
 endelse
       
    xl1 = x - xx[l1]
    xl  = x - xx[l]
    s1  = xl1*h1
    s2  = xl*h2

<span class="comments">; Now finally the Hermite interpolation formula</span>

    f   = (ff[l]*(1.-2.*h1*xl) + f1*xl)*s1*s1 + $                       
                                        (ff[l1]*(1.-2.*h2*xl1) + f2*xl1)*s2*s2

    if m eq 1 then return,f[0] else return,f

    end

</code>
    </div>
  </body>
</html>