<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:30 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fits_info.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fits_info.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="fits_info:source"></a>pro fits_info, filename, SILENT=silent,TEXTOUT=textout, N_ext=n_ext, extname=extname
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     FITS_INFO</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Provide information about the contents of a FITS file</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     Information includes number of header records and size of data array.</span>
<span class="comments">;     Applies to primary header and all extensions.    Information can be </span>
<span class="comments">;     printed at the terminal and/or stored in a common block</span>
<span class="comments">;</span>
<span class="comments">;     This routine is mostly obsolete, and better results can be usually be</span>
<span class="comments">;     performed with FITS_HELP (for display) or FITS_OPEN (to read FITS </span>
<span class="comments">;     information into a structure)</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;     FITS_INFO, Filename, [ /SILENT , TEXTOUT = , N_ext =, EXTNAME= ]</span>
<span class="comments">;</span>
<span class="comments">; INPUT:</span>
<span class="comments">;     Filename - Scalar string giving the name of the FITS file(s)</span>
<span class="comments">;               Can include wildcards such as '*.fits', or regular expressions </span>
<span class="comments">;               allowed by the FILE_SEARCH() function.     One can also search </span>
<span class="comments">;               gzip compressed  FITS files, but their extension must</span>
<span class="comments">;               end in .gz or .ftz.</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;     /SILENT - If set, then the display of the file description on the </span>
<span class="comments">;                terminal will be suppressed</span>
<span class="comments">;</span>
<span class="comments">;      TEXTOUT - specifies output device.</span>
<span class="comments">;               textout=1        TERMINAL using /more option</span>
<span class="comments">;               textout=2        TERMINAL without /more option</span>
<span class="comments">;               textout=3        &lt;program>.prt</span>
<span class="comments">;               textout=4        laser.tmp</span>
<span class="comments">;               textout=5        user must open file, see TEXTOPEN</span>
<span class="comments">;               textout=7       append to existing &lt;program.prt> file</span>
<span class="comments">;               textout = filename (default extension of .prt)</span>
<span class="comments">;</span>
<span class="comments">;               If TEXTOUT is not supplied, then !TEXTOUT is used</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       The following keyowrds are for use when only one file is processed</span>
<span class="comments">;</span>
<span class="comments">;       N_ext - Returns an integer scalar giving the number of extensions in</span>
<span class="comments">;               the FITS file</span>
<span class="comments">;       extname - returns a list containing the EXTNAME keywords for each</span>
<span class="comments">;       		extension.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS</span>
<span class="comments">;       DESCRIPTOR =  File descriptor string of the form N_hdrrec Naxis IDL_type</span>
<span class="comments">;               Naxis1 Naxis2 ... Naxisn [N_hdrrec table_type Naxis</span>
<span class="comments">;               IDL_type Naxis1 ... Naxisn] (repeated for each extension) </span>
<span class="comments">;               For example, the following descriptor </span>
<span class="comments">;                    167 2 4 3839 4 55 BINTABLE 2 1 89 5</span>
<span class="comments">; </span>
<span class="comments">;               indicates that the  primary header containing 167 lines, and </span>
<span class="comments">;               the primary (2D) floating point image (IDL type 4) </span>
<span class="comments">;               is of size 3839 x 4.    The first extension header contains</span>
<span class="comments">;               55 lines, and the  byte (IDL type 1) table array is of size</span>
<span class="comments">;               89 x 5.</span>
<span class="comments">;</span>
<span class="comments">;               The DESCRIPTOR is *only* computed if /SILENT is set.</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Display info about all FITS files of the form '*.fit' in the current</span>
<span class="comments">;               directory</span>
<span class="comments">;</span>
<span class="comments">;               IDL> fits_info, '*.fit'</span>
<span class="comments">;</span>
<span class="comments">;       Any time a *.fit file is found which is *not* in FITS format, an error </span>
<span class="comments">;       message is displayed at the terminal and the program continues</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       GETTOK(), MRD_SKIP, STRN(), SXPAR(), TEXTOPEN, TEXTCLOSE </span>
<span class="comments">;</span>
<span class="comments">; SYSTEM VARIABLES:</span>
<span class="comments">;       The non-standard system variables !TEXTOUT and !TEXTUNIT will be  </span>
<span class="comments">;       created by FITS_INFO if they are not previously defined.   </span>
<span class="comments">;</span>
<span class="comments">;       DEFSYSV,'!TEXTOUT',1</span>
<span class="comments">;       DEFSYSV,'!TEXTUNIT',0</span>
<span class="comments">;</span>
<span class="comments">;       See TEXTOPEN.PRO for more info</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, K. Venkatakrishna, Hughes STX, May 1992</span>
<span class="comments">;       Added N_ext keyword, and table_name info, G. Reichert</span>
<span class="comments">;       Work on *very* large FITS files   October 92</span>
<span class="comments">;       More checks to recognize corrupted FITS files     February, 1993</span>
<span class="comments">;       Proper check for END keyword    December 1994</span>
<span class="comments">;       Correctly size variable length binary tables  WBL December 1994</span>
<span class="comments">;       EXTNAME keyword can be anywhere in extension header WBL  January 1998</span>
<span class="comments">;       Correctly skip past extensions with no data   WBL   April 1998</span>
<span class="comments">;       Converted to IDL V5.0, W. Landsman, April 1998</span>
<span class="comments">;       No need for !TEXTOUT if /SILENT D.Finkbeiner   February 2002</span>
<span class="comments">;       Define !TEXTOUT if needed.  R. Sterner, 2002 Aug 27</span>
<span class="comments">;       Work on gzip compressed files for V5.3 or later  W. Landsman 2003 Jan</span>
<span class="comments">;       Improve speed by only reading first 36 lines of header </span>
<span class="comments">;       Count headers with more than 32767 lines         W. Landsman Feb. 2003</span>
<span class="comments">;       Assume since V5.3 (OPENR,/COMPRESS)   W. Landsman Feb 2004</span>
<span class="comments">;       EXTNAME keyword can be anywhere in extension header again </span>
<span class="comments">;                         WBL/S. Bansal Dec 2004</span>
<span class="comments">;       Read more than 200 extensions  WBL   March 2005</span>
<span class="comments">;       Work for FITS files with SIMPLE=F   WBL July 2005</span>
<span class="comments">;       Assume since V5.4, fstat.compress available WBL April 2006</span>
<span class="comments">;       Added EXTNAME as an IDL keyword to return values. M. Perrin Dec 2007</span>
<span class="comments">;       make Ndata a long64 to deal with large files. E. Hivon Mar 2008</span>
<span class="comments">;       For GDL compatibility, first check if file is compressed  before using</span>
<span class="comments">;          OPENR,/COMPRESS  B. Roukema/WL    Apr 2010</span>
<span class="comments">;       Increased nmax (max number of extensions) from 400 to 2000   Sept 2012</span>
<span class="comments">;-</span>
 On_error,2
 compile_opt idl2
 COMMON descriptor,fdescript

 if N_params() lt 1 then begin
     print,'Syntax - FITS_INFO, filename, [/SILENT, TEXTOUT=, N_ext=, EXTNAME=]'
     return
 endif

  defsysv,'!TEXTOUT',exists=ex                  <span class="comments">; Check if !TEXTOUT exists.</span>
  if ex eq 0 then defsysv,'!TEXTOUT',1          <span class="comments">; If not define it.</span>

    fil = file_search( filename, COUNT = nfiles) 
    if nfiles EQ 0 then message,'No files found'
<span class="comments">; File is gzip compressed if it ends in .gz or .ftz </span>
    len = strlen(fil)
    ext = strlowcase(strmid(fil,transpose(len-3),3))
    compress = (ext EQ '.gz') or (ext EQ 'ftz')

   silent = keyword_set( SILENT )
   if ~silent then begin 
    if ~keyword_set( TEXTOUT ) then textout = !TEXTOUT    
    textopen, 'FITS_INFO', TEXTOUT=textout
   endif

 for nf = 0, nfiles-1 do begin

    file = fil[nf]

    openr, lun1, file, /GET_LUN, COMPRESS = compress[nf]
     
   N_ext = -1
    fdescript = ''
    nmax = 2000 <span class="comments">; MDP was 100, then 400</span>
    nbuf= nmax
    extname = strarr(nmax)

   ptr = 0l
   START:  
   ON_IOerror, BAD_FILE
   descript = ''
   
    test = bytarr(8)
   readu, lun1, test
 
   if N_ext EQ -1 then begin
        if string(test) NE 'SIMPLE  ' then goto, BAD_FILE
	simple = 1
   endif else begin
        if string(test) NE 'XTENSION' then goto, END_OF_FILE
	simple = 0
   endelse
   point_lun, lun1, ptr

<span class="comments">;                               Read the header</span>
   hdr = bytarr(80, 36, /NOZERO)
   N_hdrblock = 1
   readu, lun1, hdr
   ptr = ptr + 2880
   hd = string( hdr > 32b)

<span class="comments">;                               Get values of BITPIX, NAXIS etc.</span>
   bitpix = sxpar(hd, 'BITPIX', Count = N_BITPIX)
   if N_BITPIX EQ 0 then $ 
          message, 'WARNING - FITS header missing BITPIX keyword',/CON
   Naxis = sxpar( hd, 'NAXIS', Count = N_NAXIS)
   if N_NAXIS EQ 0 then message, $ 
           'WARNING - FITS header missing NAXIS keyword',/CON
   
   exten = sxpar( hd, 'XTENSION')
   Ext_type = strmid( strtrim( exten ,2), 0, 8)      <span class="comments">;Use only first 8 char</span>
   gcount = sxpar( hd, 'GCOUNT') > 1
   pcount = sxpar( hd, 'PCOUNT')

   if strn(Ext_type) NE '0' then begin
        if (gcount NE 1) or (pcount NE 0) then $
             ext_type = 'VAR_' + ext_type
        descript += ' ' + Ext_type
  endif

   descript += ' ' + strn(Naxis)

   case BITPIX of
      8:   IDL_type = 1     <span class="comments">; Byte</span>
     16:   IDL_type = 2     <span class="comments">; Integer*2</span>
     32:   IDL_type = 3     <span class="comments">; Integer*4</span>
    -32:   IDL_type = 4     <span class="comments">; Real*4 </span>
    -64:   IDL_type = 5     <span class="comments">; Real*8</span>
   ELSE: begin 
         message, ' Illegal value of BITPIX = ' + strn(bitpix) + $
         ' in header',/CON
         goto, SKIP
         end
   endcase

  if Naxis GT 0 then begin
         descript += ' ' + strn(IDL_type)
         Nax = sxpar( hd, 'NAXIS*')
         if N_elements(Nax) LT Naxis then begin 
              message, $
                 'ERROR - Missing required NAXISi keyword in FITS header',/CON
                  goto, SKIP
         endif
         for i = 1, Naxis do descript += ' '+strn(Nax[i-1])
  endif

  end_rec = where( strtrim(strmid(hd,0,8),2) EQ  'END')

  exname = sxpar(hd, 'extname', Count = N_extname)
  if N_extname GT 0 then extname[N_ext+1] = exname
  get_extname =  (N_ext GE 0) && (N_extname EQ 0) && ~keyword_set(SILENT)  

<span class="comments">;  Read header records, till end of header is reached</span>

  hdr = bytarr(80, 36, /NOZERO)
  while (end_rec[0] EQ -1) && (~eof(lun1) ) do begin
       readu,lun1,hdr
       ptr = ptr + 2880L
       hd1 = string( hdr > 32b)
       end_rec = where( strtrim(strmid(hd1,0,8),2) EQ  'END')
       n_hdrblock++ 
       if get_extname then begin
           exname = sxpar(hd1, 'extname', Count = N_extname)
           if N_extname GT 0 then begin
                extname[N_ext+1] = exname
               get_extname = 0
           endif
       endif 
  endwhile
 
 n_hdrec = 36L*(n_hdrblock-1) + end_rec[0] + 1L         <span class="comments">; size of header</span>
 descript = strn( n_hdrec ) + descript

<span class="comments">;  If there is data associated with primary header, then find out the size</span>

 if Naxis GT 0 then begin
         ndata = long64(Nax[0])
         if naxis GT 1 then for i = 2, naxis do ndata *= Nax[i-1]
 endif else ndata = 0

 nbytes = (abs(bitpix)/8) * gcount * (pcount + ndata)
 nrec = long(( nbytes +2879)/ 2880)


 
<span class="comments">; Check if all headers have been read </span>

 if ( simple EQ 0 ) && ( strlen(strn(exten)) EQ 1) then goto, END_OF_FILE  

    N_ext++ 
    if N_ext GE (nmax-1) then begin 
        extname = [extname,strarr(nbuf)]
        nmax = N_elements(extname)
    endif	

<span class="comments">; Append information concerning the current extension to descriptor</span>

    fdescript += ' ' + descript

<span class="comments">; Check for EOF</span>
<span class="comments">; Skip the headers and data records</span>

    ptr = ptr + nrec*2880L
    if compress[nf] then mrd_skip,lun1,nrec*2880L else point_lun,lun1,ptr
    if ~eof(lun1) then goto, START
<span class="comments">;</span>
 END_OF_FILE:  

 extname = extname[0:N_ext]           <span class="comments">;strip off bogus first value</span>
                                  <span class="comments">;otherwise will end up with '' at end</span>

 if ~SILENT then begin
 printf,!textunit,file,' has ',strn(N_ext),' extensions'
 printf,!textunit,'Primary header: ',gettok(fdescript,' '),' records'

 Naxis = gettok( fdescript,' ' ) 

 If Naxis NE '0' then begin

 case gettok(fdescript,' ') of

 '1': image_type = 'Byte'
 '2': image_type = 'Integer*2'    
 '3': image_type = 'Integer*4'
 '4': image_type = 'Real*4'
 '5': image_type = 'Real*8'

 endcase

 image_desc = 'Image -- ' + image_type + ' array ('
 for i = 0,fix(Naxis)-1 do image_desc = image_desc + ' '+ gettok(fdescript,' ')
 image_desc = image_desc+' )'

 endif else image_desc = 'No data'
 printf,!textunit, format='(a)',image_desc

 if N_ext GT 0 then begin
  for i = 1,N_ext do begin

  printf, !TEXTUNIT, 'Extension ' + strn(i) + ' -- '+extname[i]

  header_desc = '               Header : '+gettok(fdescript,' ')+' records'
  printf, !textunit, format = '(a)',header_desc

  table_type = gettok(fdescript,' ')

  case table_type of
   'A3DTABLE' : table_desc = 'Binary Table'
   'BINTABLE' : table_desc = 'Binary Table'
   'VAR_BINTABLE': table_desc = 'Variable length Binary Table'
   'TABLE':     table_desc = 'ASCII Table'
    ELSE:       table_desc = table_type
  endcase

  table_desc = '               ' + table_desc + ' ( '
  table_dim = fix( gettok( fdescript,' ') )
  if table_dim GT 0 then begin
          table_type = gettok(fdescript,' ')
          for j = 0, table_dim-1 do $
                table_desc = table_desc + gettok(fdescript,' ') + ' '
  endif
  table_desc = table_desc + ')'

  printf,!textunit, format='(a)',table_desc
 endfor
 endif

  printf, !TEXTUNIT, ' '
  endif 
  SKIP: free_lun, lun1
  endfor
  if ~silent then textclose, TEXTOUT=textout
  return

 BAD_FILE:
     message, 'Error reading FITS file ' + file, /CON
    goto,SKIP
 end
</code>
    </div>
  </body>
</html>