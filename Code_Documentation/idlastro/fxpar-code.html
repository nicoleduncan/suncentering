<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:37 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxpar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxpar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">        FUNCTION FXPAR, HDR, NAME, ABORT, COUNT=MATCHES, COMMENT=COMMENTS, $
                        START=START, PRECHECK=PRECHECK, POSTCHECK=POSTCHECK, $
                                          NOCONTINUE = NOCONTINUE, $
                        DATATYPE=DATATYPE
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;        FXPAR()</span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;       Obtain the value of a parameter in a FITS header.</span>
<span class="comments">; EXPLANATION: </span>
<span class="comments">;       The first 8 chacters of each element of HDR are searched for a match to</span>
<span class="comments">;       NAME.  If the keyword is one of those allowed to take multiple values</span>
<span class="comments">;       ("HISTORY", "COMMENT", or "        " (blank)), then the value is taken</span>
<span class="comments">;       as the next 72 characters.  Otherwise, it is assumed that the next</span>
<span class="comments">;       character is "=", and the value (and optional comment) is then parsed</span>
<span class="comments">;       from the last 71 characters.  An error occurs if there is no parameter</span>
<span class="comments">;       with the given name.</span>
<span class="comments">;      </span>
<span class="comments">;       If the value is too long for one line, it may be continued on to the</span>
<span class="comments">;       the next input card, using the CONTINUE Long String Keyword convention.</span>
<span class="comments">;       For more info, http://fits.gsfc.nasa.gov/registry/continue_keyword.html</span>
<span class="comments">;       </span>
<span class="comments">;</span>
<span class="comments">;       Complex numbers are recognized as two numbers separated by one or more</span>
<span class="comments">;       space characters.</span>
<span class="comments">;</span>
<span class="comments">;       If a numeric value has no decimal point (or E or D) it is returned as</span>
<span class="comments">;       type LONG.  If it contains more than 8 numerals, or contains the</span>
<span class="comments">;       character 'D', then it is returned as type DOUBLE.  Otherwise it is</span>
<span class="comments">;       returned as type FLOAT.    If an integer is too large to be stored as</span>
<span class="comments">;       type LONG, then it is returned as DOUBLE.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: </span>
<span class="comments">;       Result = FXPAR( HDR, NAME  [, ABORT, COUNT=, COMMENT=, /NOCONTINUE ] )</span>
<span class="comments">;</span>
<span class="comments">;       Result = FXPAR(HEADER,'DATE')           ;Finds the value of DATE</span>
<span class="comments">;       Result = FXPAR(HEADER,'NAXIS*')         ;Returns array dimensions as</span>
<span class="comments">;                                               ;vector</span>
<span class="comments">; REQUIRED INPUTS: </span>
<span class="comments">;       HDR     = FITS header string array (e.g. as returned by FXREAD).  Each</span>
<span class="comments">;                 element should have a length of 80 characters</span>
<span class="comments">;       NAME    = String name of the parameter to return.  If NAME is of the</span>
<span class="comments">;                 form 'keyword*' then an array is returned containing values</span>
<span class="comments">;                 of keywordN where N is an integer.  The value of keywordN</span>
<span class="comments">;                 will be placed in RESULT(N-1).  The data type of RESULT will</span>
<span class="comments">;                 be the type of the first valid match of keywordN</span>
<span class="comments">;                 found, unless DATATYPE is given.</span>
<span class="comments">; OPTIONAL INPUT: </span>
<span class="comments">;       ABORT   = String specifying that FXPAR should do a RETALL if a</span>
<span class="comments">;                 parameter is not found.  ABORT should contain a string to be</span>
<span class="comments">;                 printed if the keyword parameter is not found.  If not</span>
<span class="comments">;                 supplied, FXPAR will return with a negative !err if a keyword</span>
<span class="comments">;                 is not found.</span>
<span class="comments">;       DATATYPE = A scalar value, indicating the type of vector</span>
<span class="comments">;                  data.  All keywords will be cast to this type.</span>
<span class="comments">;                  Default: based on first keyword.</span>
<span class="comments">;                  Example: DATATYPE=0.0D (cast data to double precision)</span>
<span class="comments">;       START   = A best-guess starting position of the sought-after</span>
<span class="comments">;                 keyword in the header.  If specified, then FXPAR</span>
<span class="comments">;                 first searches for scalar keywords in the header in</span>
<span class="comments">;                 the index range bounded by START-PRECHECK and</span>
<span class="comments">;                 START+POSTCHECK.  This can speed up keyword searches</span>
<span class="comments">;                 in large headers.  If the keyword is not found, then</span>
<span class="comments">;                 FXPAR searches the entire header.  </span>
<span class="comments">;</span>
<span class="comments">;                 If not specified then the entire header is searched.</span>
<span class="comments">;                 Searches of the form 'keyword*' also search the</span>
<span class="comments">;                 entire header and ignore START.</span>
<span class="comments">;</span>
<span class="comments">;                 Upon return START is changed to be the position of</span>
<span class="comments">;                 the newly found keyword.  Thus the best way to</span>
<span class="comments">;                 search for a series of keywords is to search for</span>
<span class="comments">;                 them in the order they appear in the header like</span>
<span class="comments">;                 this:</span>
<span class="comments">;</span>
<span class="comments">;                       START = 0L</span>
<span class="comments">;                       P1 = FXPAR('P1', START=START)</span>
<span class="comments">;                       P2 = FXPAR('P2', START=START)</span>
<span class="comments">;       PRECHECK = If START is specified, then PRECHECK is the number</span>
<span class="comments">;                  of keywords preceding START to be searched.</span>
<span class="comments">;                  Default: 5</span>
<span class="comments">;       POSTCHECK = If START is specified, then POSTCHECK is the number</span>
<span class="comments">;                   of keywords after START to be searched.</span>
<span class="comments">;                   Default: 20</span>
<span class="comments">; OUTPUT: </span>
<span class="comments">;       The returned value of the function is the value(s) associated with the</span>
<span class="comments">;       requested keyword in the header array.</span>
<span class="comments">;</span>
<span class="comments">;       If the parameter is complex, double precision, floating point, long or</span>
<span class="comments">;       string, then the result is of that type.  Apostrophes are stripped from</span>
<span class="comments">;       strings.  If the parameter is logical, 1 is returned for T, and 0 is</span>
<span class="comments">;       returned for F.</span>
<span class="comments">;</span>
<span class="comments">;       If NAME was of form 'keyword*' then a vector of values are returned.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS: </span>
<span class="comments">;       /NOCONTINUE = If set, then continuation lines will not be read, even</span>
<span class="comments">;                 if present in the header</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       COUNT   = Optional keyword to return a value equal to the number of</span>
<span class="comments">;                 parameters found by FXPAR.</span>
<span class="comments">;       COMMENTS= Array of comments associated with the returned values.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE CALLS: </span>
<span class="comments">;       GETTOK(), VALID_NUM</span>
<span class="comments">; SIDE EFFECTS: </span>
<span class="comments">;</span>
<span class="comments">;       The system variable !err is set to -1 if parameter not found, 0 for a</span>
<span class="comments">;       scalar value returned.  If a vector is returned it is set to the number</span>
<span class="comments">;       of keyword matches found.</span>
<span class="comments">;</span>
<span class="comments">;       If a keyword occurs more than once in a header, a warning is given,</span>
<span class="comments">;       and the first occurence is used.  However, if the keyword is "HISTORY",</span>
<span class="comments">;       "COMMENT", or "        " (blank), then multiple values are returned.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;	The functions SXPAR() and FXPAR() are nearly identical, although</span>
<span class="comments">;	FXPAR() has slightly more sophisticated parsing.   There is no</span>
<span class="comments">;	particular reason for having two nearly identical procedures, but</span>
<span class="comments">;	both are too widely used to drop either one.</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY: </span>
<span class="comments">;       Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;               Adapted from SXPAR</span>
<span class="comments">;       Version 2, William Thompson, GSFC, 14 October 1994</span>
<span class="comments">;               Modified to use VALID_NUM instead of STRNUMBER.  Inserted</span>
<span class="comments">;               additional call to VALID_NUM to trap cases where character</span>
<span class="comments">;               strings did not contain quotation marks.</span>
<span class="comments">;       Version 3, William Thompson, GSFC, 22 December 1994</span>
<span class="comments">;               Fixed bug with blank keywords, following suggestion by Wayne</span>
<span class="comments">;               Landsman.</span>
<span class="comments">;       Version 4, Mons Morrison, LMSAL, 9-Jan-98</span>
<span class="comments">;               Made non-trailing ' for string tag just be a warning (not</span>
<span class="comments">;               a fatal error).  It was needed because "sxaddpar" had an</span>
<span class="comments">;               error which did not write tags properly for long strings</span>
<span class="comments">;               (over 68 characters)</span>
<span class="comments">;       Version 5, Wayne Landsman GSFC, 29 May 1998</span>
<span class="comments">;               Fixed potential problem with overflow of LONG values</span>
<span class="comments">;       Version 6, Craig Markwardt, GSFC, 28 Jan 1998, </span>
<span class="comments">;               Added CONTINUE parsing         </span>
<span class="comments">;       Version 7, Craig Markwardt, GSFC, 18 Nov 1999,</span>
<span class="comments">;               Added START, PRE/POSTCHECK keywords for better</span>
<span class="comments">;               performance</span>
<span class="comments">;       Version 8, Craig Markwardt, GSFC, 08 Oct 2003,</span>
<span class="comments">;               Added DATATYPE keyword to cast vector keywords type</span>
<span class="comments">;       Version 9, Paul Hick, 22 Oct 2003, Corrected bug (NHEADER-1)</span>
<span class="comments">;       Version 10, W. Landsman, GSFC  2 May 2012</span>
<span class="comments">;               Keywords of form "name_0" cound confuse vector extractions</span>
<span class="comments">;-</span>
<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 2 THEN BEGIN
            PRINT,'Syntax:  result =  FXPAR( HDR, NAME  [, ABORT ])'
            RETURN, -1
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Determine the abort condition.</span>
<span class="comments">;</span>
        VALUE = 0
        IF N_PARAMS() LE 2 THEN BEGIN
            ABORT_RETURN = 0
            ABORT = 'FITS Header'
        END ELSE ABORT_RETURN = 1
        IF ABORT_RETURN THEN ON_ERROR,1 ELSE ON_ERROR,2
<span class="comments">;</span>
<span class="comments">;  Check for valid header.  Check header for proper attributes.</span>
<span class="comments">;</span>
        S = SIZE(HDR)
        IF ( S[0] NE 1 ) OR ( S[2] NE 7 ) THEN $
            MESSAGE,'FITS Header (first parameter) must be a string array'
<span class="comments">;</span>
<span class="comments">;  Convert the selected keyword NAME to uppercase.</span>
<span class="comments">;</span>
        NAM = STRTRIM( STRUPCASE(NAME) )
<span class="comments">;</span>
<span class="comments">;  Determine if NAME is of form 'keyword*'.  If so, then strip off the '*', and</span>
<span class="comments">;  set the VECTOR flag.  One must consider the possibility that NAM is an empty</span>
<span class="comments">;  string.</span>
<span class="comments">;</span>
        NAMELENGTH1 = (STRLEN(NAM) - 1) > 1
        IF STRPOS( NAM, '*' ) EQ NAMELENGTH1 THEN BEGIN    
            NAM = STRMID( NAM, 0, NAMELENGTH1)  
            VECTOR = 1                          <span class="comments">;Flag for vector output  </span>
            NAME_LENGTH = STRLEN(NAM)           <span class="comments">;Length of name </span>
            NUM_LENGTH = 8 - NAME_LENGTH        <span class="comments">;Max length of number portion  </span>
            IF NUM_LENGTH LE 0 THEN MESSAGE,    $
                'Keyword length must be 8 characters or less'
<span class="comments">;</span>
<span class="comments">;  Otherwise, extend NAME with blanks to eight characters.</span>
<span class="comments">;</span>
        ENDIF ELSE BEGIN
            WHILE STRLEN(NAM) LT 8 DO NAM = NAM + ' '
            VECTOR = 0
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  If of the form 'keyword*', then find all instances of 'keyword' followed by</span>
<span class="comments">;  a number.  Store the positions of the located keywords in NFOUND, and the</span>
<span class="comments">;  value of the number field in NUMBER.</span>
<span class="comments">;</span>
        IF N_ELEMENTS(START)     EQ 0 THEN START = -1L
        START = LONG(START[0])
        IF NOT VECTOR AND START GE 0 THEN BEGIN
            IF N_ELEMENTS(PRECHECK)  EQ 0 THEN PRECHECK = 5
            IF N_ELEMENTS(POSTCHECK) EQ 0 THEN POSTCHECK = 20
            NHEADER = N_ELEMENTS(HDR)
            MN = (START - PRECHECK)  > 0
            MX = (START + POSTCHECK) &lt<span class="comments">; (NHEADER-1)      ;Corrected bug</span>
            KEYWORD = STRMID(HDR[MN:MX], 0, 8)
        ENDIF ELSE BEGIN
            RESTART:
            START   = -1L
            KEYWORD = STRMID( HDR, 0, 8)
        ENDELSE

        IF VECTOR THEN BEGIN
            NFOUND = WHERE(STRPOS(KEYWORD,NAM) GE 0, MATCHES)
            IF ( MATCHES GT 0 ) THEN BEGIN
                NUMST= STRMID(HDR[NFOUND], NAME_LENGTH, NUM_LENGTH)
                NUMBER = INTARR(MATCHES)-1
                FOR I = 0, MATCHES-1 DO         $
                    IF VALID_NUM( NUMST[I], NUM) THEN NUMBER[I] = NUM
                IGOOD = WHERE(NUMBER GE 0, MATCHES)
                IF MATCHES GT 0 THEN BEGIN
                    NFOUND = NFOUND[IGOOD]
                    NUMBER = NUMBER[IGOOD]
 		    G = WHERE(NUMBER GT 0, MATCHES)
 		    IF MATCHES GT 0 THEN NUMBER = NUMBER[G]     
		ENDIF
            ENDIF
<span class="comments">;</span>
<span class="comments">;  Otherwise, find all the instances of the requested keyword.  If more than</span>
<span class="comments">;  one is found, and NAME is not one of the special cases, then print an error</span>
<span class="comments">;  message.</span>
<span class="comments">;</span>
        ENDIF ELSE BEGIN
            NFOUND = WHERE(KEYWORD EQ NAM, MATCHES)
            IF MATCHES EQ 0 AND START GE 0 THEN GOTO, RESTART
            IF START GE 0 THEN NFOUND = NFOUND + MN
            IF (MATCHES GT 1) AND (NAM NE 'HISTORY ') AND               $
                (NAM NE 'COMMENT ') AND (NAM NE '') THEN        $
                MESSAGE,/INFORMATIONAL, 'WARNING- Keyword ' +   $
                NAM + 'located more than once in ' + ABORT
            IF (MATCHES GT 0) THEN START = NFOUND[MATCHES-1]
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  Extract the parameter field from the specified header lines.  If one of the</span>
<span class="comments">;  special cases, then done.</span>
<span class="comments">;</span>
        IF MATCHES GT 0 THEN BEGIN
            LINE = HDR[NFOUND]
            SVALUE = STRTRIM( STRMID(LINE,9,71),2)
            IF (NAM EQ 'HISTORY ') OR (NAM EQ 'COMMENT ') OR    $
                    (NAM EQ '        ') THEN BEGIN
                VALUE = STRTRIM( STRMID(LINE,8,72),2)
                COMMENTS = STRARR(N_ELEMENTS(VALUE))
<span class="comments">;</span>
<span class="comments">;  Otherwise, test to see if the parameter contains a string, signalled by</span>
<span class="comments">;  beginning with a single quote character (') (apostrophe).</span>
<span class="comments">;</span>
            END ELSE FOR I = 0,MATCHES-1 DO BEGIN
                IF ( STRMID(SVALUE[I],0,1) EQ "'" ) THEN BEGIN
                    TEST = STRMID( SVALUE[I],1,STRLEN( SVALUE[I] )-1)
                    NEXT_CHAR = 0
                    OFF = 0
                    VALUE = ''
<span class="comments">;</span>
<span class="comments">;  Find the next apostrophe.</span>
<span class="comments">;</span>
NEXT_APOST:
                    ENDAP = STRPOS(TEST, "'", NEXT_CHAR)
                    IF ENDAP LT 0 THEN MESSAGE,         $
                        'WARNING: Value of '+NAME+' invalid in '+ABORT+ " (no trailing ')", /info
                    VALUE = VALUE + STRMID( TEST, NEXT_CHAR, ENDAP-NEXT_CHAR )
<span class="comments">;</span>
<span class="comments">;  Test to see if the next character is also an apostrophe.  If so, then the</span>
<span class="comments">;  string isn't completed yet.  Apostrophes in the text string are signalled as</span>
<span class="comments">;  two apostrophes in a row.</span>
<span class="comments">;</span>
                    IF STRMID( TEST, ENDAP+1, 1) EQ "'" THEN BEGIN    
                        VALUE = VALUE + "'"
                        NEXT_CHAR = ENDAP+2      
                        GOTO, NEXT_APOST
                    ENDIF
<span class="comments">;</span>
<span class="comments">;  Extract the comment, if any.</span>
<span class="comments">;</span>
                    SLASH = STRPOS(TEST, "/", ENDAP)
                    IF SLASH LT 0 THEN COMMENT = '' ELSE        $
                        COMMENT = STRMID(TEST, SLASH+1, STRLEN(TEST)-SLASH-1)

<span class="comments">;</span>
<span class="comments">; CM 19 Sep 1997</span>
<span class="comments">; This is a string that could be continued on the next line.  Check this</span>
<span class="comments">; possibility with the following four criteria: *1) Ends with '&'</span>
<span class="comments">; (2) Next line is CONTINUE  (3) LONGSTRN keyword is present (recursive call to</span>
<span class="comments">;  FXPAR) 4. /NOCONTINE is not set</span>

    IF NOT KEYWORD_SET(NOCONTINUE) THEN BEGIN
                    OFF = OFF + 1
                    VAL = STRTRIM(VALUE,2)

                    IF (STRLEN(VAL) GT 0) AND $
                      (STRMID(VAL, STRLEN(VAL)-1, 1) EQ '&') AND $
                      (STRMID(HDR[NFOUND[I]+OFF],0,8) EQ 'CONTINUE') THEN BEGIN
                       IF (SIZE(FXPAR(HDR, 'LONGSTRN',/NOCONTINUE)))[1] EQ 7 THEN BEGIN                    
                      VALUE = STRMID(VAL, 0, STRLEN(VAL)-1)
                      TEST = HDR[NFOUND[I]+OFF]
                      TEST = STRMID(TEST, 8, STRLEN(TEST)-8)
                      TEST = STRTRIM(TEST, 2)
                      IF STRMID(TEST, 0, 1) NE "'" THEN MESSAGE, $
                        'ERROR: Invalidly CONTINUEd string in '+ABORT
                      NEXT_CHAR = 1
                      GOTO, NEXT_APOST
                    ENDIF
                   ENDIF
    ENDIF

<span class="comments">;</span>
<span class="comments">;  If not a string, then separate the parameter field from the comment field.</span>
<span class="comments">;</span>
                ENDIF ELSE BEGIN
                    TEST = SVALUE[I]
                    SLASH = STRPOS(TEST, "/")
                    IF SLASH GT 0 THEN BEGIN
                        COMMENT = STRMID(TEST, SLASH+1, STRLEN(TEST)-SLASH-1)
                        TEST = STRMID(TEST, 0, SLASH)
                    END ELSE COMMENT = ''
<span class="comments">;</span>
<span class="comments">;  Find the first word in TEST.  Is it a logical value ('T' or 'F')?</span>
<span class="comments">;</span>
                    TEST2 = TEST
                    VALUE = GETTOK(TEST2,' ')
                    TEST2 = STRTRIM(TEST2,2)
                    IF ( VALUE EQ 'T' ) THEN BEGIN
                        VALUE = 1
                    END ELSE IF ( VALUE EQ 'F' ) THEN BEGIN
                        VALUE = 0
                    END ELSE BEGIN
<span class="comments">;</span>
<span class="comments">;  Test to see if a complex number.  It's a complex number if the value and the</span>
<span class="comments">;  next word, if any, both are valid numbers.</span>
<span class="comments">;</span>
                        IF STRLEN(TEST2) EQ 0 THEN GOTO, NOT_COMPLEX
                        VALUE2 = GETTOK(TEST2,' ')
                        IF VALID_NUM(VALUE,VAL1) AND VALID_NUM(VALUE2,VAL2) $
                                THEN BEGIN
                            VALUE = COMPLEX(VAL1,VAL2)
                            GOTO, GOT_VALUE
                        ENDIF
<span class="comments">;</span>
<span class="comments">;  Not a complex number.  Decide if it is a floating point, double precision,</span>
<span class="comments">;  or integer number.  If an error occurs, then a string value is returned.</span>
<span class="comments">;  If the integer is not within the range of a valid long value, then it will </span>
<span class="comments">;  be converted to a double.  </span>
<span class="comments">;</span>
NOT_COMPLEX:
                        ON_IOERROR, GOT_VALUE
                        VALUE = TEST
                        IF NOT VALID_NUM(VALUE) THEN GOTO, GOT_VALUE
                        IF (STRPOS(VALUE,'.') GE 0) OR (STRPOS(VALUE,'E') $
                                GE 0) OR (STRPOS(VALUE,'D') GE 0) THEN BEGIN
                            IF ( STRPOS(VALUE,'D') GT 0 ) OR $
                                    ( STRLEN(VALUE) GE 8 ) THEN BEGIN
                                VALUE = DOUBLE(VALUE)
                                END ELSE VALUE = FLOAT(VALUE)
                        ENDIF ELSE BEGIN
                            LMAX = 2.0D^31 - 1.0D
                            LMIN = -2.0D^31       <span class="comments">;Typo fixed Feb 2010</span>
                            VALUE = DOUBLE(VALUE)
                            if (VALUE GE LMIN) and (VALUE LE LMAX) THEN $
                                VALUE = LONG(VALUE)
                        ENDELSE
                            
<span class="comments">;</span>
GOT_VALUE:
                        ON_IOERROR, NULL
                    ENDELSE
                ENDELSE         <span class="comments">; if string</span>
<span class="comments">;</span>
<span class="comments">;  Add to vector if required.</span>
<span class="comments">;</span>
                IF VECTOR THEN BEGIN
                    MAXNUM = MAX(NUMBER)
                    IF ( I EQ 0 ) THEN BEGIN
                        IF N_ELEMENTS(DATATYPE) EQ 0 THEN BEGIN
                            <span class="comments">;; Data type determined from keyword</span>
                            SZ_VALUE = SIZE(VALUE)
                        ENDIF ELSE BEGIN
                            <span class="comments">;; Data type requested by user</span>
                            SZ_VALUE = SIZE(DATATYPE[0])
                        ENDELSE
                        RESULT = MAKE_ARRAY( MAXNUM, TYPE=SZ_VALUE[1])
                        COMMENTS = STRARR(MAXNUM)
                    ENDIF 
                    RESULT[   NUMBER[I]-1 ] =  VALUE
                    COMMENTS[ NUMBER[I]-1 ] =  COMMENT
                ENDIF ELSE BEGIN
                    COMMENTS = COMMENT
                ENDELSE
            ENDFOR
<span class="comments">;</span>
<span class="comments">;  Set the value of !ERR for the number of matches for vectors, or simply 0</span>
<span class="comments">;  otherwise.</span>
<span class="comments">;</span>
            IF VECTOR THEN BEGIN
                !ERR = MATCHES
                RETURN, RESULT
            ENDIF ELSE !ERR = 0
<span class="comments">;</span>
<span class="comments">;  Error point for keyword not found.</span>
<span class="comments">;</span>
        ENDIF ELSE BEGIN
            IF ABORT_RETURN THEN MESSAGE,'Keyword '+NAM+' not found in '+ABORT
            !ERR = -1
        ENDELSE
<span class="comments">;</span>
        RETURN, VALUE
        END
</code>
    </div>
  </body>
</html>