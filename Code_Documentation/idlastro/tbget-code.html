<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:07 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tbget.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tbget.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="tbget:source"></a>function tbget, hdr_or_tbstr, tab, field, rows, nulls, NOSCALE = noscale, $
        CONTINUE = continue
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       TBGET</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return value(s) from specified column in a FITS binary table</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE</span>
<span class="comments">;       values = TBGET( h, tab, field, [ rows, nulls, /NOSCALE] )</span>
<span class="comments">;               or</span>
<span class="comments">;       values = TBGET( tb_str, tab, field, [ rows, nulls, /NOSCALE] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       h - FITS binary table header, e.g. as returned by FITS_READ</span>
<span class="comments">;                       or</span>
<span class="comments">;       tb_str - IDL structure extracted from FITS header by TBINFO.</span>
<span class="comments">;               Use of the IDL structure will improve processing speed</span>
<span class="comments">;       tab - FITS binary table array, e.g. as returned by FITS_READ</span>
<span class="comments">;       field - field name or number, scalar</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       rows -  scalar or vector giving row number(s)</span>
<span class="comments">;               Row numbers start at 0.  If not supplied or set to</span>
<span class="comments">;               -1 then values for all rows are returned</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;       /NOSCALE - If this keyword is set and nonzero, then the TSCALn and</span>
<span class="comments">;               TZEROn keywords will *not* be used to scale to physical values</span>
<span class="comments">;               Default is to perform scaling</span>
<span class="comments">;       CONTINUE - This keyword does nothing, it is kept for consistency with</span>
<span class="comments">;               with earlier versions of TBGET().</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       the values for the row are returned as the function value.</span>
<span class="comments">;       Null values are set to 0 or blanks for strings.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       nulls - null value flag of same length as the returned data.</span>
<span class="comments">;               Only used for integer data types, B, I, and J</span>
<span class="comments">;               It is set to 1 at null value positions and 0 elsewhere.</span>
<span class="comments">;               If supplied then the optional input, rows, must also</span>
<span class="comments">;               be supplied.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Read the columns labeled 'WAVELENGTH' and 'FLUX' from the second</span>
<span class="comments">;       extension of a FITS file 'spectra.fits' into IDL vectors w and f</span>
<span class="comments">;</span>
<span class="comments">;       IDL> fits_read,'spectra.fits',tab,htab,exten=2   ;Read 2nd extension</span>
<span class="comments">;       IDL> w = tbget(htab,tab,'wavelength')</span>
<span class="comments">;       IDL> f = tbget(htab,tab,'flux')</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       (1) If the column is variable length ('P') format, then TBGET() will </span>
<span class="comments">;       return the longword array of pointers into the heap area.   TBGET() </span>
<span class="comments">;       currently lacks the ability to actually extract the data from the </span>
<span class="comments">;       heap area.</span>
<span class="comments">;       (2) Use the higher-level procedure FTAB_EXT (which calls TBGET()) to</span>
<span class="comments">;       extract vectors directly from the FITS file.   </span>
<span class="comments">;       (3) Use the procedure FITS_HELP to determine which extensions are </span>
<span class="comments">;       binary tables, and FTAB_HELP or TBHELP to determine the columns of the</span>
<span class="comments">;       table</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       TBINFO, TBSIZE </span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Written  W. Landsman        February, 1991</span>
<span class="comments">;       Work for string and complex   W. Landsman         April, 1993</span>
<span class="comments">;       Default scaling by TSCALn, TZEROn, Added /NOSCALE keyword,</span>
<span class="comments">;       Fixed nulls output, return longword pointers for variable length</span>
<span class="comments">;               binary tables,     W. Landsman  December 1996</span>
<span class="comments">;       Added a check for zero width column  W. Landsman   April, 1997</span>
<span class="comments">;       Add TEMPORARY() and REFORM() for speed  W. Landsman  May, 1997</span>
<span class="comments">;       Use new structure returned by TBINFO    W. Landsman  August 1997</span>
<span class="comments">;       Add IS_IEEE_BIG(), No subscripting when all rows requested</span>
<span class="comments">;                               W. Landsman    March 2000</span>
<span class="comments">;       Use SIZE(/TNAME) instead of DATATYPE()  W. Landsman October 2001</span>
<span class="comments">;       Bypass IEEE_TO_HOST call for improved speed W. Landsman November 2002</span>
<span class="comments">;       Cosmetic changes to SIZE() calls W. Landsman December 2002</span>
<span class="comments">;       Added unofficial support for 64bit integers W. Landsman February 2003</span>
<span class="comments">;       Support unsigned integers, new pointer types of TSCAL and TZERO</span>
<span class="comments">;       returned by TBINFO   W. Landsman        April 2003</span>
<span class="comments">;       Add an i = i[0] for V6.0 compatibility  W. Landsman  August 2003</span>
<span class="comments">;       Use faster BYTEORDER byteswapping  W. Landsman April 2006</span>
<span class="comments">;       Free pointers if FITS header supplied W. Landsman March 2007</span>
<span class="comments">;-</span>
<span class="comments">;------------------------------------------------------------------</span>
 On_error,2
 compile_opt idl2
        
 if N_params() LT 3 then begin
    print, $
 'Syntax - values = TBGET(h, tab, field, [ rows, nulls, /NOSCALE ])'
    return, -1
 endif

<span class="comments">; get size of table</span>

 ndimen = size(tab,/n_dimen)
 if Ndimen EQ 1 then nrows =1 else $
 nrows = (size(tab,/dimen))[1]

<span class="comments">; get characteristics of specified field</span>

 case size(hdr_or_tbstr,/type) of 
 7: tbinfo,hdr_or_tbstr,tb_str,NOSCALE=noscale
 8: tb_str = hdr_or_tbstr
 else: message,'ERROR - Invalid FITS header or structure supplied' 
 endcase 

 tfields = N_elements(tb_str.ttype)

 case size(field,/TNAME) of

 'STRING': begin
      i = where( strupcase(tb_str.ttype) EQ strupcase(field), Nfound)
      if Nfound EQ 0 then $ 
         message,'Field ' + field + ' not found in header'
      i=i[0]
      end

 'UNDEFINED':message,'First parameter must be field name or number'
 
 ELSE: begin
      i = field[0]-1
      if (i LT 0 ) or (i GT tfields) then $
            message,'Field number must be between 1 and ' +strtrim(tfields,2)
      end

 endcase

<span class="comments">; Now that the right column has been found, extract necessary info about this</span>
<span class="comments">; column </span>

 ttype = tb_str.ttype[i]
 numval = tb_str.numval[i]
 tform = tb_str.tform[i]
 tbcol = tb_str.tbcol[i]
 width = tb_str.width[i]
 idltype = tb_str.idltype[i]
 tnull = tb_str.tnull[i]

 if numval EQ 0 then begin 
        message,/INF, 'Column ' + ttype + ' has zero width'
        return, -1
 endif

 if tform EQ 'P' then message, /INF, $ 
           'Variable Length column - returning array of pointers'

<span class="comments">; if rows not supplied then return all rows</span>

 if N_params() LT 4 then rows = -1

<span class="comments">; determine if scalar supplied</span>

 row = rows
 ndim = size(row,/N_dimen)  
 if row[0] LT 0 then nrow = nrows else  begin
     nrow = N_elements(row)
                                              <span class="comments">; check for valid row numbers</span>
     if (min(row) LT 0) or (max(row) GT (nrows-1)) then $
        message,'ERROR - Invalid row number: FITS table contains '+ $
        strtrim(nrows,2) + ' rows'
 endelse 
<span class="comments">; get column</span>


 if row[0] LT 0 then $                                 <span class="comments">;All rows?</span>
        d = tab[tbcol:tbcol + numval*width-1,*]  $
  else if ndim EQ 0 then  $                              <span class="comments">;scalar?                                               </span>
        d = tab[tbcol:tbcol + numval*width-1,row[0]] $
  else $                                        <span class="comments">;vector of rows</span>
        d = tab[tbcol:tbcol + numval*width-1,row]
 Nnull = 0
<span class="comments">; convert data to the correct type</span>

 case idltype of

 1:  begin
     temp = byte( d, 0, numval, nrow)
     if tform EQ 'L' then begin
       d = strarr( numval, nrow )
       for j = 0, numval*nrow-1 do d[j] = string( temp[j] )
     endif else if tnull NE 0 then nullval = where(d EQ tnull, Nnull)
     end

 2:  begin
     byteorder,d,/NTOHS, /SWAP_IF_LITTLE
     d = fix(d,0, numval, nrow)
     if tnull NE 0 then nullval = where(d EQ tnull, Nnull)
     end
 
 3:  begin
     byteorder,d,/NTOHL, /SWAP_IF_LITTLE
     d = long( d, 0, numval, nrow)
     if tnull NE 0 then nullval = where(d EQ tnull, Nnull)
     end

 4:  begin
     d = float( d, 0, numval, nrow)
     byteorder,d,/LSWAP, /SWAP_IF_LITTLE
     end

 5:  begin
     d = double( d, 0, numval, nrow)
     byteorder,d,/L64SWAP, /SWAP_IF_LITTLE
      end

 6:  begin
     d = complex( d, 0, numval, nrow)
     byteorder,d,/LSWAP, /SWAP_IF_LITTLE
     end

 7:  d = string(d)


 14: begin
     d = long64(d, 0, numval, nrow)
     byteorder, d, /L64swap, /SWAP_IF_LITTLE
     end

 endcase


 if not keyword_set(NOSCALE) then begin
    if tag_exist(tb_str,'TSCAL') then begin
        tscale = *tb_str.tscal[i]
        tzero = *tb_str.tzero[i]
        unsgn_int = (tzero EQ 32768) and (tscale EQ 1)
        unsgn_lng = (tzero EQ 2147483648) and (tscale EQ 1)
        if unsgn_int then d = uint(d) - uint(32768) $
        else if unsgn_lng then d = ulong(d) - ulong(2147483648) else $
        if ( (tscale NE 1.0) or (tzero NE 0.0) ) then $
                d = temporary(d)*tscale + tzero
	endif	
 endif

 if N_params() EQ 5 then begin
         nulls = bytarr(N_elements(d))
         if Nnull GT 0 then begin
                nulls[nullval] = 1b
                d[nullval] = 0
        endif
 endif  

<span class="comments">; Extract correct rows if vector supplied</span>

 if size(hdr_or_tbstr,/TYPE) NE 8 and (not keyword_set(NOSCALE)) then begin
       ptr_free, tb_str.tscal
       ptr_free, tb_str.tzero
 endif       

 if N_elements(d) EQ 1 then return, d[0] else return, reform(d,/overwrite)
 

 end
</code>
    </div>
  </body>
</html>