<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:19 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>aper.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="aper.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="aper:source"></a>pro aper,image,xc,yc,mags,errap,sky,skyerr,phpadu,apr,skyrad,badpix, $
       SETSKYVAL = setskyval,PRINT = print, SILENT = silent, FLUX=flux, $
       EXACT = exact, Nan = nan, READNOISE = readnoise, MEANBACK = meanback, $
       CLIPSIG=clipsig, MAXITER=maxiter,CONVERGE_NUM=converge_num, $
       MINSKY = minsky
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      APER</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Compute concentric aperture photometry (adapted from DAOPHOT) </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     APER can compute photometry in several user-specified aperture radii.  </span>
<span class="comments">;     A separate sky value is computed for each source using specified inner </span>
<span class="comments">;     and outer sky radii.   </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;     APER, image, xc, yc, [ mags, errap, sky, skyerr, phpadu, apr, skyrad, </span>
<span class="comments">;                       badpix, /NAN, /EXACT, /FLUX, PRINT = , /SILENT, </span>
<span class="comments">;                       /MEANBACK, MINSKY=, SETSKYVAL = ]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     IMAGE -  input image array</span>
<span class="comments">;     XC     - vector of x coordinates. </span>
<span class="comments">;     YC     - vector of y coordinates</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;     PHPADU - Photons per Analog Digital Units, numeric scalar.  Converts</span>
<span class="comments">;               the data numbers in IMAGE to photon units.  (APER assumes</span>
<span class="comments">;               Poisson statistics.)  </span>
<span class="comments">;     APR    - Vector of up to 12 REAL photometry aperture radii.</span>
<span class="comments">;     SKYRAD - Two element vector giving the inner and outer radii</span>
<span class="comments">;               to be used for the sky annulus.   Ignored if the SETSKYVAL</span>
<span class="comments">;              keyword is set.</span>
<span class="comments">;     BADPIX - Two element vector giving the minimum and maximum value</span>
<span class="comments">;               of a good pixel.   If badpix is not supplied or if BADPIX[0] is</span>
<span class="comments">;               equal to BADPIX[1] then it is assumed that there are no bad</span>
<span class="comments">;               pixels.     Note that fluxes will not be computed for any star</span>
<span class="comments">;               with a bad pixel within the aperture area, but that bad pixels</span>
<span class="comments">;               will be simply ignored for the sky computation.    The BADPIX</span>
<span class="comments">;               parameter is ignored if the /NAN keyword is set.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;     CLIPSIG - if /MEANBACK is set, then this is the number of sigma at which </span>
<span class="comments">;             to clip the background.  Default=3</span>
<span class="comments">;     CONVERGE_NUM:  if /MEANBACK is set then if the proportion of </span>
<span class="comments">;           rejected pixels is less than this fraction, the iterations stop.  </span>
<span class="comments">;           Default=0.02, i.e., iteration stops if fewer than 2% of pixels </span>
<span class="comments">;           excluded.</span>
<span class="comments">;     /EXACT -  By default, APER counts subpixels, but uses a polygon </span>
<span class="comments">;             approximation for the intersection of a circular aperture with</span>
<span class="comments">;             a square pixel (and normalizes the total area of the sum of the</span>
<span class="comments">;             pixels to exactly match the circular area).   If the /EXACT </span>
<span class="comments">;             keyword, then the intersection of the circular aperture with a</span>
<span class="comments">;             square pixel is computed exactly.    The /EXACT keyword is much</span>
<span class="comments">;             slower and is only needed when small (~2 pixels) apertures are</span>
<span class="comments">;             used with very undersampled data.    </span>
<span class="comments">;     /FLUX - By default, APER uses a magnitude system where a magnitude of</span>
<span class="comments">;               25 corresponds to 1 flux unit.   If set, then APER will keep</span>
<span class="comments">;              results in flux units instead of magnitudes.    </span>
<span class="comments">;     MAXITER if /MEANBACK is set then this is the ceiling on number of </span>
<span class="comments">;             clipping iterations of the background.  Default=5</span>
<span class="comments">;     /MEANBACK - if set, then the background is computed using the 3 sigma </span>
<span class="comments">;             clipped mean (using meanclip.pro) rather than using the mode </span>
<span class="comments">;             computed with mmm.pro.    This keyword is useful for the Poisson </span>
<span class="comments">;             count regime or where contamination is known  to be minimal.</span>
<span class="comments">;      MINSKY - Integer giving mininum number of sky values to be used with MMM</span>
<span class="comments">;             APER will not compute a flux if fewer valid sky elements are </span>
<span class="comments">;               within the sky annulus.   Default = 20.</span>
<span class="comments">;     /NAN  - If set then APER will check for NAN values in the image.   /NAN</span>
<span class="comments">;             takes precedence over the BADPIX parameter.   Note that fluxes </span>
<span class="comments">;             will not be computed for any star with a NAN pixel within the </span>
<span class="comments">;             aperture area, but that NAN pixels will be simply ignored for </span>
<span class="comments">;             the sky computation.</span>
<span class="comments">;     PRINT - if set and non-zero then APER will also write its results to</span>
<span class="comments">;               a file aper.prt.   One can specify the output file name by</span>
<span class="comments">;               setting PRINT = 'filename'.</span>
<span class="comments">;     READNOISE - Scalar giving the read noise (or minimum noise for any</span>
<span class="comments">;              pixel.   This value is passed to the procedure mmm.pro when</span>
<span class="comments">;              computing the sky, and is only need for images where</span>
<span class="comments">;              the noise is low, and pixel values are quantized.   </span>
<span class="comments">;     /SILENT -  If supplied and non-zero then no output is displayed to the</span>
<span class="comments">;               terminal.</span>
<span class="comments">;     SETSKYVAL - Use this keyword to force the sky to a specified value </span>
<span class="comments">;               rather than have APER compute a sky value.    SETSKYVAL </span>
<span class="comments">;               can either be a scalar specifying the sky value to use for </span>
<span class="comments">;               all sources, or a 3 element vector specifying the sky value, </span>
<span class="comments">;               the sigma of the sky value, and the number of elements used </span>
<span class="comments">;               to compute a sky value.   The 3 element form of SETSKYVAL</span>
<span class="comments">;               is needed for accurate error budgeting.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     MAGS   -  NAPER by NSTAR array giving the magnitude for each star in</span>
<span class="comments">;               each aperture.  (NAPER is the number of apertures, and NSTAR</span>
<span class="comments">;               is the number of stars).   If the /FLUX keyword is not set, then</span>
<span class="comments">;               a flux of 1 digital unit is assigned a zero point magnitude of </span>
<span class="comments">;               25.</span>
<span class="comments">;     ERRAP  -  NAPER by NSTAR array giving error for each star.  If a </span>
<span class="comments">;               magnitude could not be determined then  ERRAP = 9.99 (if in </span>
<span class="comments">;                magnitudes) or ERRAP = !VALUES.F_NAN (if /FLUX is set).</span>
<span class="comments">;     SKY  -    NSTAR element vector giving sky value for each star in </span>
<span class="comments">;               flux units</span>
<span class="comments">;     SKYERR -  NSTAR element vector giving error in sky values</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Determine the flux and error for photometry radii of 3 and 5 pixels</span>
<span class="comments">;       surrounding the position 234.2,344.3 on an image array, im.   Compute</span>
<span class="comments">;       the partial pixel area exactly.    Assume that the flux units are in</span>
<span class="comments">;       Poisson counts, so that PHPADU = 1, and the sky value is already known</span>
<span class="comments">;       to be 1.3, and that the range [-32767,80000] for bad low and bad high</span>
<span class="comments">;       pixels</span>
<span class="comments">;      </span>
<span class="comments">;</span>
<span class="comments">;       IDL> aper, im, 234.2, 344.3, flux, eflux, sky,skyerr, 1, [3,5], -1, $</span>
<span class="comments">;            [-32767,80000],/exact, /flux, setsky = 1.3</span>
<span class="comments">;       </span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       GETOPT, MMM, PIXWT(), STRN(), STRNUMBER()</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Reasons that a valid magnitude cannot be computed include the following:</span>
<span class="comments">;      (1) Star position is too close (within 0.5 pixels) to edge of the frame</span>
<span class="comments">;      (2) Less than 20 valid pixels available for computing sky</span>
<span class="comments">;      (3) Modal value of sky could not be computed by the procedure MMM</span>
<span class="comments">;      (4) *Any* pixel within the aperture radius is a "bad" pixel</span>
<span class="comments">;      (5) The total computed flux is negative.     In this case the negative</span>
<span class="comments">;          flux and error are returned.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;       For the case where the source is fainter than the background, APER will</span>
<span class="comments">;       return negative fluxes if /FLUX is set, but will otherwise give </span>
<span class="comments">;       invalid data (since negative fluxes can't be converted to magnitudes) </span>
<span class="comments">; </span>
<span class="comments">;       APER was modified in June 2000 in two ways: (1) the /EXACT keyword was</span>
<span class="comments">;       added (2) the approximation of the intersection of a circular aperture</span>
<span class="comments">;       with square pixels was improved (i.e. when /EXACT is not used) </span>
<span class="comments">; REVISON HISTORY:</span>
<span class="comments">;       Adapted to IDL from DAOPHOT June, 1989   B. Pfarr, STX</span>
<span class="comments">;       FLUX keyword added                       J. E. Hollis, February, 1996</span>
<span class="comments">;       SETSKYVAL keyword, increase maxsky       W. Landsman, May 1997</span>
<span class="comments">;       Work for more than 32767 stars           W. Landsman, August 1997</span>
<span class="comments">;       Don't abort for insufficient sky pixels  W. Landsman  May 2000</span>
<span class="comments">;       Added /EXACT keyword                     W. Landsman  June 2000 </span>
<span class="comments">;       Allow SETSKYVAL = 0                      W. Landsman  December 2000 </span>
<span class="comments">;       Set BADPIX[0] = BADPIX[1] to ignore bad pixels W. L.  January 2001     </span>
<span class="comments">;       Fix chk_badpixel problem introduced Jan 01 C. Ishida/W.L. February 2001</span>
<span class="comments">;       Set bad fluxes and error to NAN if /FLUX is set  W. Landsman Oct. 2001 </span>
<span class="comments">;       Remove restrictions on maximum sky radius W. Landsman  July 2003</span>
<span class="comments">;       Added /NAN keyword  W. Landsman November 2004</span>
<span class="comments">;       Set badflux=0 if neither /NAN nor badpix is set  M. Perrin December 2004</span>
<span class="comments">;       Added READNOISE keyword   W. Landsman January 2005</span>
<span class="comments">;       Added MEANBACK keyword   W. Landsman October 2005</span>
<span class="comments">;       Correct typo when /EXACT and multiple apertures used.  W.L. Dec 2005</span>
<span class="comments">;       Remove VMS-specific code W.L. Sep 2006</span>
<span class="comments">;       Add additional keywords if /MEANBACK is set W.L  Nov 2006</span>
<span class="comments">;       Allow negative fluxes if /FLUX is set  W.L.  Mar 2008</span>
<span class="comments">;       Previous update would crash if first star was out of range  W.L. Mar 2008</span>
<span class="comments">;       Fix floating equality test for bad magnitudes W.L./J.van Eyken Jul 2009</span>
<span class="comments">;       Added MINSKY keyword W.L. Dec 2011</span>
<span class="comments">;-</span>
 COMPILE_OPT IDL2
 On_error,2
<span class="comments">;             Set parameter limits</span>
 <span class="comments">;Smallest number of pixels from which the sky may be determined</span>
 if N_elements(minsky) EQ 0 then minsky = 20   
 maxsky = 10000         <span class="comments">;Maximum number of pixels allowed in the sky annulus.</span>
<span class="comments">;                                </span>
if N_params() LT 3 then begin    <span class="comments">;Enough parameters supplied?</span>
  print, $
  'Syntax - APER, image, xc, yc, [ mags, errap, sky, skyerr, phpadu, apr, '
  print,'             skyrad, badpix, /EXACT, /FLUX, SETSKYVAL = ,PRINT=, ]'
  print,'             /SILENT, /NAN, MINSKY='
  return
endif 

 s = size(image)
 if ( s[0] NE 2 ) then message, $
       'ERROR - Image array (first parameter) must be 2 dimensional'
 ncol = s[1] & nrow = s[2]           <span class="comments">;Number of columns and rows in image array</span>

  silent = keyword_set(SILENT)

 if ~keyword_set(nan) then begin
 if (N_elements(badpix) NE 2) then begin <span class="comments">;Bad pixel values supplied</span>
GET_BADPIX:  
   ans = ''
   print,'Enter low and high bad pixel values, [RETURN] for defaults'
   read,'Low and high bad pixel values [none]: ',ans
   if ans EQ  '' then badpix = [0,0] else begin
   badpix = getopt(ans,'F')
   if ( N_elements(badpix) NE 2 ) then begin
        message,'Expecting 2 scalar values',/continue
        goto,GET_BADPIX
   endif
   endelse
 endif 

 chk_badpix = badpix[0] LT badpix[1]     <span class="comments">;Ignore bad pixel checks?</span>
 endif

 if ( N_elements(apr) LT 1 ) then begin              <span class="comments">;Read in aperture sizes?</span>
   apr = fltarr(10)
   read, 'Enter first aperture radius: ',ap
   apr[0] = ap
   ap = 'aper'
   for i = 1,9 do begin                                                   
GETAP: 
      read,'Enter another aperture radius, [RETURN to terminate]: ',ap
      if ap EQ '' then goto,DONE  
      result = strnumber(ap,val)
      if result EQ 1 then apr[i] = val else goto, GETAP   
   endfor
DONE: 
   apr = apr[0:i-1]
 endif


 if N_elements(SETSKYVAL) GT 0 then begin
     if N_elements( SETSKYVAL ) EQ 1 then setskyval = [setskyval,0.,1.]
     if N_elements( SETSKYVAL ) NE 3 then message, $
        'ERROR - Keyword SETSKYVAL must contain 1 or 3 elements'
     skyrad = [ 0., max(apr) + 1]
 endif

<span class="comments">;Get radii of sky annulii</span>

 if N_elements(skyrad) NE 2 then begin
   skyrad = fltarr(2)
   read,'Enter inner and outer sky radius (pixel units): ',skyrad
 endif else skyrad = float(skyrad)

 if ( N_elements(phpadu) LT 1 ) then $ 
   read,'Enter scale factor in Photons per Analog per Digital Unit: ',phpadu

 Naper = N_elements( apr )                        <span class="comments">;Number of apertures</span>
 Nstars = min([ N_elements(xc), N_elements(yc) ])  <span class="comments">;Number of stars to measure</span>

 ms = strarr( Naper )       <span class="comments">;String array to display mag for each aperture</span>
 if keyword_set(flux) then $
          fmt = '(F8.1,1x,A,F7.1)' else $           <span class="comments">;Flux format</span>
          fmt = '(F9.3,A,F5.3)'                  <span class="comments">;Magnitude format</span>
 fmt2 = '(I5,2F8.2,F7.2,3A,3(/,28x,4A,:))'       <span class="comments">;Screen format</span>
 fmt3 = '(I4,5F8.2,6A,2(/,44x,9A,:))'            <span class="comments">;Print format</span>

 mags = fltarr( Naper, Nstars) & errap = mags           <span class="comments">;Declare arrays</span>
 sky = fltarr( Nstars )        & skyerr = sky     
 area = !PI*apr*apr                 <span class="comments">;Area of each aperture</span>

 if keyword_set(EXACT) then begin
      bigrad = apr + 0.5
      smallrad = apr/sqrt(2) - 0.5 
 endif
     

 if N_elements(SETSKYVAL) EQ 0 then begin

     rinsq =  (skyrad[0]> 0.)^2 
     routsq = skyrad[1]^2
 endif 

 if keyword_set(PRINT) then begin      <span class="comments">;Open output file and write header info?</span>
   if size(PRINT,/TNAME) NE 'STRING'  then file = 'aper.prt' $
                                   else file = print
   message,'Results will be written to a file ' + file,/INF
   openw,lun,file,/GET_LUN
   printf,lun,'Program: APER: '+ systime(), '   User: ', $
      getenv('USER'),'  Host: ',getenv('HOST')
   for j = 0, Naper-1 do printf,lun, $
               format='(a,i2,a,f4.1)','Radius of aperture ',j,' = ',apr[j]
   if N_elements(SETSKYVAL) EQ 0  then begin
   printf,lun,f='(/a,f4.1)','Inner radius for sky annulus = ',skyrad[0]
   printf,lun,f='(a,f4.1)', 'Outer radius for sky annulus = ',skyrad[1]
   endif else printf,lun,'Sky values fixed at ', strtrim(setskyval[0],2)
   if keyword_set(FLUX) then begin
       printf,lun,f='(/a)', $
           'Star   X       Y        Sky   SkySig    SkySkw   Fluxes'
      endif else printf,lun,f='(/a)', $
           'Star   X       Y        Sky   SkySig    SkySkw   Magnitudes'
 endif
 print = keyword_set(PRINT)

<span class="comments">;         Print header</span>
 if ~SILENT then begin
    if KEYWORD_SET(FLUX) then begin
       print, format="(/1X,'Star',5X,'X',7X,'Y',6X,'Sky',8X,'Fluxes')"
    endif else print, $ 
       format="(/1X,'Star',5X,'X',7X,'Y',6X,'Sky',8X,'Magnitudes')" 
 endif

<span class="comments">;  Compute the limits of the submatrix.   Do all stars in vector notation.</span>

 lx = fix(xc-skyrad[1]) > 0           <span class="comments">;Lower limit X direction</span>
 ux = fix(xc+skyrad[1]) &lt<span class="comments">; (ncol-1)    ;Upper limit X direction</span>
 nx = ux-lx+1                         <span class="comments">;Number of pixels X direction</span>
 ly = fix(yc-skyrad[1]) > 0           <span class="comments">;Lower limit Y direction</span>
 uy = fix(yc+skyrad[1]) &lt<span class="comments">; (nrow-1);   ;Upper limit Y direction</span>
 ny = uy-ly +1                        <span class="comments">;Number of pixels Y direction</span>
 dx = xc-lx                         <span class="comments">;X coordinate of star's centroid in subarray</span>
 dy = yc-ly                         <span class="comments">;Y coordinate of star's centroid in subarray</span>

 edge = (dx-0.5) &lt<span class="comments">; (nx+0.5-dx) &lt; (dy-0.5) &lt; (ny+0.5-dy) ;Closest edge to array</span>
 badstar = ((xc LT 0.5) or (xc GT ncol-1.5) $  <span class="comments">;Stars too close to the edge</span>
        or (yc LT 0.5) or (yc GT nrow-1.5))
<span class="comments">;</span>
 badindex = where( badstar, Nbad)              <span class="comments">;Any stars outside image</span>
 if ( Nbad GT 0 ) then message, /INF, $
      'WARNING - ' + strn(nbad) + ' star positions outside image'
      if keyword_set(flux) then begin 
          badval = !VALUES.F_NAN
	  baderr = badval
      endif else begin 
          badval = 99.999
	  baderr = 9.999
      endelse	  	  
 
 for i = 0L, Nstars-1 do begin           <span class="comments">;Compute magnitudes for each star</span>
   apmag = replicate(badval, Naper)   & magerr = replicate(baderr, Naper) 
   skymod = 0. & skysig = 0. &  skyskw = 0.  <span class="comments">;Sky mode sigma and skew</span>
   if badstar[i] then goto, BADSTAR         
   error1=apmag   & error2 = apmag   & error3 = apmag

   rotbuf = image[ lx[i]:ux[i], ly[i]:uy[i] ] <span class="comments">;Extract subarray from image</span>
<span class="comments">;  RSQ will be an array, the same size as ROTBUF containing the square of</span>
<span class="comments">;      the distance of each pixel to the center pixel.</span>

 
    dxsq = ( findgen( nx[i] ) - dx[i] )^2
    rsq = fltarr( nx[i], ny[i], /NOZERO )
   for ii = 0, ny[i]-1 do rsq[0,ii] = dxsq + (ii-dy[i])^2


 if keyword_set(exact) then begin 
       nbox = lindgen(nx[i]*ny[i])
       xx = reform( (nbox mod nx[i]), nx[i], ny[i])
       yy = reform( (nbox/nx[i]),nx[i],ny[i])
       x1 = abs(xx-dx[i]) 
       y1 = abs(yy-dy[i])
  endif else begin 
   r = sqrt(rsq) - 0.5    <span class="comments">;2-d array of the radius of each pixel in the subarray</span>
 endelse

<span class="comments">;  Select pixels within sky annulus, and eliminate pixels falling</span>
<span class="comments">;       below BADLO threshold.  SKYBUF will be 1-d array of sky pixels</span>
 if N_elements(SETSKYVAL) EQ 0 then begin

 skypix = ( rsq GE rinsq ) and ( rsq LE routsq )
 if keyword_set(nan) then skypix = skypix and finite(rotbuf) $
 else if chk_badpix then skypix = skypix and ( rotbuf GT badpix[0] ) and $
        (rotbuf LT badpix[1] )
 sindex =  where(skypix, Nsky) 
 Nsky =   Nsky &lt<span class="comments">; maxsky   ;Must be less than MAXSKY pixels</span>
 if ( nsky LT minsky ) then begin                       <span class="comments">;Sufficient sky pixels?</span>
    if ~silent then $
        message,'There aren''t enough valid pixels in the sky annulus.',/con
    goto, BADSTAR
 endif
  skybuf = rotbuf[ sindex[0:nsky-1] ]     

  if keyword_set(meanback) then $
   meanclip,skybuf,skymod,skysig, $ 
         CLIPSIG=clipsig, MAXITER=maxiter, CONVERGE_NUM=converge_num  else $
     mmm, skybuf, skymod, skysig, skyskw, readnoise=readnoise,minsky=minsky
           
 

<span class="comments">;  Obtain the mode, standard deviation, and skewness of the peak in the</span>
<span class="comments">;      sky histogram, by calling MMM.</span>

 skyvar = skysig^2    <span class="comments">;Variance of the sky brightness</span>
 sigsq = skyvar/nsky  <span class="comments">;Square of standard error of mean sky brightness</span>

<span class="comments">;If the modal sky value could not be determined, then all apertures for this</span>
<span class="comments">; star are bad</span>

 if ( skysig LT 0.0 ) then goto, BADSTAR 

 skysig = skysig &lt<span class="comments">; 999.99      ;Don't overload output formats</span>
 skyskw = skyskw >(-99)&lt<span class="comments">;999.9</span>
 endif else begin
    skymod = setskyval[0]
    skysig = setskyval[1]
    nsky = setskyval[2]
    skyvar = skysig^2
    sigsq = skyvar/nsky
    skyskw = 0
endelse



 for k = 0,Naper-1 do begin      <span class="comments">;Find pixels within each aperture</span>

   if ( edge[i] GE apr[k] ) then begin    <span class="comments">;Does aperture extend outside the image?</span>
     if keyword_set(EXACT) then begin
       mask = fltarr(nx[i],ny[i])
       good = where( ( x1 LT smallrad[k] ) and (y1 LT smallrad[k] ), Ngood)
       if Ngood GT 0 then mask[good] = 1.0
       bad = where(  (x1 GT bigrad[k]) or (y1 GT bigrad[k] ))   <span class="comments">;Fix 05-Dec-05</span>
       mask[bad] = -1

       gfract = where(mask EQ 0.0, Nfract) 
       if Nfract GT 0 then mask[gfract] = $
		PIXWT(dx[i],dy[i],apr[k],xx[gfract],yy[gfract]) > 0.0
       thisap = where(mask GT 0.0)
       thisapd = rotbuf[thisap]
       fractn = mask[thisap]
     endif else begin
<span class="comments">;</span>
       thisap = where( r LT apr[k] )   <span class="comments">;Select pixels within radius</span>
       thisapd = rotbuf[thisap]
       thisapr = r[thisap]
       fractn = (apr[k]-thisapr &lt<span class="comments">; 1.0 >0.0 ) ;Fraction of pixels to count</span>
       full = fractn EQ 1.0
       gfull = where(full, Nfull)
       gfract = where(1 - full)
       factor = (area[k] - Nfull ) / total(fractn[gfract])
      fractn[gfract] = fractn[gfract]*factor
    endelse

<span class="comments">;     If the pixel is bad, set the total counts in this aperture to a large</span>
<span class="comments">;        negative number</span>
<span class="comments">;</span>
   if keyword_set(NaN) then $
      badflux =  min(finite(thisapd)) EQ 0   $
   else if chk_badpix then begin
     minthisapd = min(thisapd, max = maxthisapd)
     badflux = (minthisapd LE badpix[0] ) or ( maxthisapd GE badpix[1])
   endif else badflux = 0
  
   if ~badflux then $ 
                 apmag[k] = total(thisapd*fractn) <span class="comments">;Total over irregular aperture</span>
  endif
endfor <span class="comments">;k</span>
   if keyword_set(flux) then g = where(finite(apmag), Ng)  else $
                             g = where(abs(apmag - badval) GT 0.01, Ng)
   if Ng GT 0 then begin 
  apmag[g] = apmag[g] - skymod*area[g]  <span class="comments">;Subtract sky from the integrated brightnesses</span>

<span class="comments">; Add in quadrature 3 sources of error: (1) random noise inside the star </span>
<span class="comments">; aperture, including readout noise and the degree of contamination by other </span>
<span class="comments">; stars in the neighborhood, as estimated by the scatter in the sky values </span>
<span class="comments">; (this standard error increases as the square root of the area of the</span>
<span class="comments">; aperture); (2) the Poisson statistics of the observed star brightness;</span>
<span class="comments">; (3) the uncertainty of the mean sky brightness (this standard error</span>
<span class="comments">; increases directly with the area of the aperture).</span>

   error1[g] = area[g]*skyvar   <span class="comments">;Scatter in sky values</span>
   error2[g] = (apmag[g] > 0)/phpadu  <span class="comments">;Random photon noise </span>
   error3[g] = sigsq*area[g]^2  <span class="comments">;Uncertainty in mean sky brightness</span>
   magerr[g] = sqrt(error1[g] + error2[g] + error3[g])

  if ~keyword_set(FLUX) then begin
    good = where (apmag GT 0.0, Ngood)     <span class="comments">;Are there any valid integrated fluxes?</span>
    if ( Ngood GT 0 ) then begin               <span class="comments">;If YES then compute errors</span>
      magerr[good] = 1.0857*magerr[good]/apmag[good]   <span class="comments">;1.0857 = log(10)/2.5</span>
      apmag[good] =  25.-2.5*alog10(apmag[good])  
   endif
 endif  
 endif

 BADSTAR:   
 
<span class="comments">;Print out magnitudes for this star</span>

 for ii = 0,Naper-1 do $              <span class="comments">;Concatenate mags into a string</span>

    ms[ii] = string( apmag[ii],'+-',magerr[ii], FORM = fmt)
   if PRINT then  printf,lun, $      <span class="comments">;Write results to file?</span>
      form = fmt3,  i, xc[i], yc[i], skymod, skysig, skyskw, ms
   if ~SILENT then print,form = fmt2, $       <span class="comments">;Write results to terminal?</span>
          i,xc[i],yc[i],skymod,ms

   sky[i] = skymod    &  skyerr[i] = skysig  <span class="comments">;Store in output variable</span>
   mags[0,i] = apmag  &  errap[0,i]= magerr
 endfor                                              <span class="comments">;i</span>

 if PRINT then free_lun, lun             <span class="comments">;Close output file</span>

 return
 end
</code>
    </div>
  </body>
</html>