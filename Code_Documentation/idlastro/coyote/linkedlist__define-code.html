<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:30 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>linkedlist__define.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="linkedlist__define.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   LINKEDLIST</span>
<span class="comments">;</span>
<span class="comments">; FILENAME:</span>
<span class="comments">;   linkedlist__define.pro</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">; </span>
<span class="comments">;   The purpose of this program is to implement a list that</span>
<span class="comments">;   is linked in both the forward and backward directions. There</span>
<span class="comments">;   is no restriction as to what can be stored in a linked list</span>
<span class="comments">;   node. The linked list is implemented as an object.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">; </span>
<span class="comments">;   FANNING SOFTWARE CONSULTING</span>
<span class="comments">;   David Fanning, Ph.D.</span>
<span class="comments">;   1645 Sheely Drive</span>
<span class="comments">;   Fort Collins, CO 80526 USA</span>
<span class="comments">;   Phone: 970-221-0438</span>
<span class="comments">;   E-mail: david@idlcoyote.com</span>
<span class="comments">;   Coyote's Guide to IDL Programming: http://www.idlcoyote.com/</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">; </span>
<span class="comments">;   General programming.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">; </span>
<span class="comments">;   mylist = Obj_New('LINKEDLIST', item)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">; </span>
<span class="comments">;   item: The first item added to the list. Items can be any</span>
<span class="comments">;     valid IDL variable type.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">; </span>
<span class="comments">;   Are you kidding?!</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">; </span>
<span class="comments">;   Be sure to destroy the LINKEDLIST object when you are finished</span>
<span class="comments">;   with it: Obj_Destroy, mylist</span>
<span class="comments">;</span>
<span class="comments">;   Node index numbers start at 0 and go to n-1, where n is the</span>
<span class="comments">;   number of items in the list.</span>
<span class="comments">;</span>
<span class="comments">; PUBLIC METHODS:</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; PRO LINKEDLIST::ADD, item, index, $</span>
<span class="comments">;     AFTER=after, $</span>
<span class="comments">;     BEFORE=before, $</span>
<span class="comments">;     ERROR=error, $</span>
<span class="comments">;     NO_COPY=no_copy, $</span>
<span class="comments">;     REPLACE=replace</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   The ADD method adds a data item to the list.</span>
<span class="comments">;</span>
<span class="comments">;   Parameters:</span>
<span class="comments">;</span>
<span class="comments">;   item: The data item to be added to the list. Required.</span>
<span class="comments">;</span>
<span class="comments">;   index: The location in the list where the data item is</span>
<span class="comments">;     to be added. If neither the AFTER or BEFORE keyword is</span>
<span class="comments">;     set, the item is added AFTER the item at the index location.</span>
<span class="comments">;     If index is missing, the index points to the last item in</span>
<span class="comments">;     the list. Optional.</span>
<span class="comments">;</span>
<span class="comments">;   Keywords:</span>
<span class="comments">;</span>
<span class="comments">;   AFTER: If this keyword is set, the item is added after the</span>
<span class="comments">;     item at the current index.</span>
<span class="comments">;</span>
<span class="comments">;   BEFORE: If this keyword is set, the item is added before the</span>
<span class="comments">;     item at the current index.</span>
<span class="comments">;     </span>
<span class="comments">;   ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;      </span>
<span class="comments">;   NO_COPY: If set, the item is transferred to the internal pointer using</span>
<span class="comments">;      a no copy method. This will cause the item variable to become undefined.</span>
<span class="comments">;      </span>
<span class="comments">;   REPLACE: If this keyword is set, the item will replace the current item at</span>
<span class="comments">;      the index location.</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; PRO LINKEDLIST::DELETE, index, ALL=all, DESTROY=destroy, ERROR=error   </span>
<span class="comments">;      </span>
<span class="comments">;   The DELETE method deletes an item from the list.</span>
<span class="comments">;</span>
<span class="comments">;   Parameters:</span>
<span class="comments">;</span>
<span class="comments">;   index: The location in the list where the data item is</span>
<span class="comments">;     to be delete. If index is missing, the index points to</span>
<span class="comments">;     the last item in the list. Optional.</span>
<span class="comments">;</span>
<span class="comments">;   Keywords:</span>
<span class="comments">;</span>
<span class="comments">;   ALL: If this keyword is set, all items in the list are deleted.</span>
<span class="comments">;</span>
<span class="comments">;   DESTROY: If the item at the node is an object or pointer, the</span>
<span class="comments">;     item will be destroyed before the node is deleted. This keyword</span>
<span class="comments">;     is turned on (set to 1) by default. Set to 0 to prevent destruction.</span>
<span class="comments">;</span>
<span class="comments">;    ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; FUNCTION LINKEDLIST::GET_COUNT</span>
<span class="comments">;</span>
<span class="comments">;   The GET_COUNT method returns the number of items in the list.</span>
<span class="comments">;</span>
<span class="comments">;   Return Value: The number of items stored in the linked list.</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; FUNCTION LINKEDLIST::GET_ITEM, index, $</span>
<span class="comments">;    ALL=all, $                 ; This ASSUMES all items stored are the same type!!!</span>
<span class="comments">;    Dereference=dereference, $ ; Obsolete. Ignored. Always returns item.</span>
<span class="comments">;    ItemPtr=itemPtr, $         ; The pointer to the item, if needed. Output.</span>
<span class="comments">;    NO_COPY=no_copy, $         ; Copy from location with NO_COPY.</span>
<span class="comments">;    ERROR=errorMsg             ; The error message. Null string if no error.</span>

<span class="comments">;</span>
<span class="comments">;   Parameters:</span>
<span class="comments">;</span>
<span class="comments">;   index: The location in the list from which the data item is</span>
<span class="comments">;     to be retrieved. If not present, the last item in the list</span>
<span class="comments">;     is retrieved. Optional.</span>
<span class="comments">;</span>
<span class="comments">;   Keywords:</span>
<span class="comments">;</span>
<span class="comments">;   DEREFERENCE: This keyword obsolete and only provided for backward compatibility.</span>
<span class="comments">;</span>
<span class="comments">;   ALL: Set this keyword to return an n-element array containing all the list</span>
<span class="comments">;      items.  This requires that all list items be of the same type, and</span>
<span class="comments">;      if they are arrays, they have 7 dimensions or fewer. If index is passed, </span>
<span class="comments">;      it is ignored.</span>
<span class="comments">;     </span>
<span class="comments">;   ITEMPTR: The pointer to the data item.</span>
<span class="comments">;   </span>
<span class="comments">;   NO_COPY: If this keyword is set, the item is transferred from the data</span>
<span class="comments">;      pointer using a NO_COPY method. This will undefine the item at that</span>
<span class="comments">;      indexed locaton.</span>
<span class="comments">;      </span>
<span class="comments">;    ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;</span>
<span class="comments">;   Return Value: The data item at this index on the list.</span>
<span class="comments">;     If ALL is set, then an array containing all the data items is returned.</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; FUNCTION LINKEDLIST::GET_NODE, index, ERROR=error</span>
<span class="comments">;</span>
<span class="comments">;   The GET_NODE method returns a pointer to the specified node</span>
<span class="comments">;   from the list.</span>
<span class="comments">;</span>
<span class="comments">;   Parameters:</span>
<span class="comments">;</span>
<span class="comments">;   index: The location in the list from which the data node is</span>
<span class="comments">;     to be retrieved. If not present, the last node in the list</span>
<span class="comments">;     is retrieved. The node is a structure with three fields:</span>
<span class="comments">;     Previous is a pointer to the previous node in the list.</span>
<span class="comments">;     Next is a pointer to the next node in the list. A null pointer</span>
<span class="comments">;     in the previous field indicates the first node on the list. A</span>
<span class="comments">;     null pointer in the next field indicates the last node on the</span>
<span class="comments">;     list. The item field is a pointer to the item stored in the</span>
<span class="comments">;     node. Optional.</span>
<span class="comments">;</span>
<span class="comments">;   ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;      </span>
<span class="comments">;   Return Value: A pointer to the specified node structure in</span>
<span class="comments">;     the linked list.</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; PRO LINKEDLIST::HELP, PRINT=print</span>
<span class="comments">;</span>
<span class="comments">; The HELP method performs a HELP command on each item</span>
<span class="comments">; in the linked list.</span>
<span class="comments">;</span>
<span class="comments">;   Keywords:</span>
<span class="comments">;</span>
<span class="comments">;    PRINT: If this keyword is set, the PRINT command is used</span>
<span class="comments">;      instead of the HELP command on the items in the list.</span>
<span class="comments">;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">; PRO LINKEDLIST::MOVE_NODE, nodeIndex, location, BEFORE=before, ERROR=error</span>
<span class="comments">;</span>
<span class="comments">;   The MOVE_NODE method moves a list node from one location to another.</span>
<span class="comments">;</span>
<span class="comments">;   Parameters:</span>
<span class="comments">;</span>
<span class="comments">;   nodeIndex: The location in the list of the node you are moving.</span>
<span class="comments">;     Required.</span>
<span class="comments">;</span>
<span class="comments">;   location: The location (index) you are moving the node to. If</span>
<span class="comments">;     location is missing, the location points to the node at the</span>
<span class="comments">;     end of the list.</span>
<span class="comments">;</span>
<span class="comments">;   Keywords:</span>
<span class="comments">;</span>
<span class="comments">;    BEFORE: If this keyword is set, the node is added to the</span>
<span class="comments">;      list before the location node. Otherwise, it is added after</span>
<span class="comments">;      the location node.</span>
<span class="comments">;</span>
<span class="comments">;    ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;      </span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">; PRO LINKEDLIST::REPLACE_ITEM, newItem, index, ERROR=error</span>
<span class="comments">;</span>
<span class="comments">;  Use this method to replace any item in the list with any other value.</span>
<span class="comments">;  This allows the caller to change an item without stepping through the</span>
<span class="comments">;  process of deleting an item then adding a new one.</span>
<span class="comments">;</span>
<span class="comments">;  Parameters:</span>
<span class="comments">;     index:  The location of the node you are replacing</span>
<span class="comments">;</span>
<span class="comments">;     newItem:  Any value of any data type.</span>
<span class="comments">;</span>
<span class="comments">;    ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;      </span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">; FUNCTION LINKEDLIST::HAVE_ITEM, index, ERROR=error</span>
<span class="comments">;</span>
<span class="comments">;  Use this method to check to see if an item exits at a particular location</span>
<span class="comments">;  on the list. Returns a 1 if the item is there, otherwise a 0.</span>
<span class="comments">;</span>
<span class="comments">;  Parameters:</span>
<span class="comments">;     index:  The location of the node you are replacing</span>
<span class="comments">;      </span>
<span class="comments">;    ERROR: On return, if this is not a null string, an error occurred</span>
<span class="comments">;      and this value is set equal to the error message.</span>
<span class="comments">;      </span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   mylist = Obj_New("LINKEDLIST", 5)</span>
<span class="comments">;   mylist->Add, 10</span>
<span class="comments">;   mylist->Add, 7, 1, /Before</span>
<span class="comments">;   mylist->Add, 12</span>
<span class="comments">;   print, mylist->Get_Item(/All)</span>
<span class="comments">;   mylist->Add, 'Bob', 2, /Replace</span>
<span class="comments">;   mylist->Help</span>
<span class="comments">;   mylist->Delete, 0</span>
<span class="comments">;   mylist->Help, /Print</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written by: David Fanning, 25 August 98.</span>
<span class="comments">;   25 August 99. Fixed several errors in various methods dealing with</span>
<span class="comments">;       moving nodes from one place to another. DWF.</span>
<span class="comments">;   13 June 2001. DWF. Added DEREFERENCE to the GET_ITEM method to</span>
<span class="comments">;       return the item itself, instead of the pointer to the item.</span>
<span class="comments">;   27 June 2001 Added REPLACE_ITEM method.  Ben Tupper.</span>
<span class="comments">;   7 April 2003. Added DESTROY keyword to DELETE method so that objects</span>
<span class="comments">;      and pointers could be cleaned up properly when they are deleted</span>
<span class="comments">;      from the linked list. DWF.</span>
<span class="comments">;   9 April 2003. Fixed a problem that occurs when deleting the last node. DWF.</span>
<span class="comments">;   3 Feb 2004. Make sure loop index vars are long.  Jeff Guerber</span>
<span class="comments">;   30 Jun 2004.  Added /ALL to GET_ITEM function.  Henry Throop, SWRI.</span>
<span class="comments">;   23 Nov 2004.  Fixed GET_ITEM, /ALL to accomodate structures and empty</span>
<span class="comments">;      lists.  Henry Throop.</span>
<span class="comments">;   21 February 2011. A complete refurbishing to incorporate changes and to fix bugs</span>
<span class="comments">;      I found in the SolarSoft version of this code. I've tried to make this compatible</span>
<span class="comments">;      with the version distributed with SolarSoft to reduce problems caused by two versions</span>
<span class="comments">;      of the software with the same name.</span>
<span class="comments">;    9 December 2011. Fixed a problem with the ALL keyword on the Get_Item method. DWF.</span>
<span class="comments">;-</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;  Copyright (c) 2008, by Fanning Software Consulting, Inc.                                ;</span>
<span class="comments">;  All rights reserved.                                                                    ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
PRO LINKEDLIST::ADD, item, index, $
    After=after, $
    Before=before, $
    Error=errorMsg, $
    No_Copy=no_copy, $
    Replace=replace


    <span class="comments">; This method is the public interface to the private ADD_+ methods.</span>
    <span class="comments">; If INDEX is not specified, the item is always added to the end</span>
    <span class="comments">; of the list. If INDEX is specified, but neither the BEFORE or</span>
    <span class="comments">; AFTER keywords are used, the item is added AFTER the INDEX specified.</span>
    
    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Must supply an item to add to the list.</span>
    IF N_Elements(item) EQ 0 THEN BEGIN
       errorMsg = 'Must supply an item to add to the list.'
       Message, errorMsg, /Continue
       RETURN
    END
    
    <span class="comments">; Check for index. If there is none, add to end of list.</span>
    IF N_Elements(index) EQ 0 THEN BEGIN
       self->Add_To_End, item, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; If this is the last index, add it to the end of list.</span>
    IF index GT (self.count-1) THEN BEGIN
       self->Add_To_End, item, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; Are we replacing an item?</span>
    IF Keyword_Set(replace) THEN BEGIN
        self -> Replace_Item, item, index, NO_COPY=no_copy, ERROR=errorMsg
        RETURN
    ENDIF
    
    <span class="comments">; BEFORE keyword set.</span>
    IF Keyword_Set(before) THEN BEGIN
       self->Add_Before, item, index, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; AFTER keyword set.</span>
    IF Keyword_Set(after) THEN BEGIN
       self->Add_After, item, index, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; No BEFORE or AFTER keywords. Add to location AFTER index.</span>
    self->Add_After, item, index, NO_COPY=no_copy, ERROR=errorMsg
    
END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::ADD_AFTER, item, index, NO_COPY=no_copy, ERROR=errorMsg

    <span class="comments">; This method adds an item node AFTER the item specified by</span>
    <span class="comments">; the index number. This is a private method. Use the public</span>
    <span class="comments">; ADD method to add an item to the list.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Must supply an item to add to the list.</span>
    IF N_Elements(item) EQ 0 THEN BEGIN
       errorMsg = 'Must supply an item to add to the list.'
       Message, errorMsg, /Continue
       RETURN
    END
    
    <span class="comments">; Check for index. If there is none, add to end of list.</span>
    IF N_Elements(index) EQ 0 THEN BEGIN
       self->Add_To_End, item, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; If this is the last index, add it to the end of list.</span>
    IF index GE (self.count-1) THEN BEGIN
       self->Add_To_End, item, NO_COPY=no_copy, ERROR=errorMsg
       RETURN
    ENDIF

    <span class="comments">; Create a new node and store the item in it.</span>
    currentNode = Ptr_New( {LINKEDLIST_NODE} )
    (*currentNode).item = Ptr_New(item, NO_COPY=no_copy)
    self.count = self.count + 1
    
    <span class="comments">; Get the node currently located at the index.</span>
    indexNode = self->Get_Node(index)
    
    <span class="comments">; Get the node that follows the indexNode.</span>
    nextNode = (*indexNode).next
    
    <span class="comments">; Update pointers.</span>
    (*indexNode).next = currentNode
    (*currentNode).previous = indexNode
    (*nextNode).previous = currentNode
    (*currentNode).next = nextNode

END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::ADD_BEFORE, item, index, NO_COPY=no_copy, ERROR=errorMsg

    <span class="comments">; This method adds an item node BEFORE the item specified by</span>
    <span class="comments">; the index number. This is a private method. Use the public</span>
    <span class="comments">; ADD method to add an item to the list.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Must supply an item to add to the list.</span>
    IF N_Elements(item) EQ 0 THEN BEGIN
       errorMsg = 'Must supply an item to add to the list.'
       Message, errorMsg, /Continue
       RETURN
    END
    
    <span class="comments">; Check for index. If there is none, add to head of list.</span>
    IF N_Elements(index) EQ 0 THEN index = 0

    <span class="comments">; Create a new node and store the item in it.</span>
    currentNode = Ptr_New( {LINKEDLIST_NODE} )
    (*currentNode).item = Ptr_New(item, NO_COPY=no_copy)
    self.count = self.count + 1
    
    <span class="comments">; Get the node currently located at the index.</span>
    indexNode = self->Get_Node(index)
    
    <span class="comments">; Get the node that is before the indexNode.</span>
    previousNode = (*indexNode).previous
    
    <span class="comments">; Update pointers.</span>
    (*indexNode).previous = currentNode
    (*currentNode).previous = previousNode
    (*currentNode).next = indexNode
    IF Ptr_Valid(previousNode) THEN $
       (*previousNode).next = currentNode ELSE $
       self.head = currentNode

END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::ADD_TO_END, item, NO_COPY=no_copy, ERROR=errorMsg

    <span class="comments">; This method adds an item to the tail of the list. This is </span>
    <span class="comments">; a private method. Use the public ADD method to add an </span>
    <span class="comments">; item to the list.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Must supply an item to add to the list.</span>
    IF N_Elements(item) EQ 0 THEN BEGIN
       errorMsg = 'Must supply an item to add to the list.'
       Message, errorMsg, /Continue
       RETURN
    END
    
    <span class="comments">; Is this the first item we are adding to the list?</span>
    IF self.count EQ 0 THEN BEGIN
    
        <span class="comments">; Create a new node.</span>
        currentNode = Ptr_New({ LINKEDLIST_NODE })
    
        <span class="comments">; Add the item to the node.</span>
        (*currentNode).item = Ptr_New(item, NO_COPY=no_copy)
    
         <span class="comments">; The head and tail point to current node.</span>
        self.head = currentNode
        self.tail = currentNode
     
        <span class="comments">; Update the node count.</span>
        self.count = self.count + 1
     
    ENDIF ELSE BEGIN <span class="comments">; Not first, but must add a node.</span>
     
        <span class="comments">; Create a new node.</span>
        currentNode = Ptr_New({ LINKEDLIST_NODE })
    
        <span class="comments">; Set the next field of the previous node.</span>
        (*self.tail).next = currentNode
     
        <span class="comments">; Add the item to the current node.</span>
        (*currentNode).item = Ptr_New(item, NO_COPY=no_copy)
    
        <span class="comments">; Set the previous field to point to previous node.</span>
        (*currentNode).previous = self.tail
    
        <span class="comments">; Update the tail field to point to current node.</span>
        self.tail = currentNode
    
        <span class="comments">; Update the node count.</span>
        self.count = self.count + 1
        
    ENDELSE
    
END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::DELETE, index, All=all, DESTROY=destroy, ERROR=errorMsg

    <span class="comments">; This method is the public interface to the private DELETE_+ methods.</span>
    <span class="comments">; If INDEX is not specified, the last item on the list is always deleted.</span>
    <span class="comments">; The ALL keyword will delete all the items on the list.</span>
    <span class="comments">; The DESTROY keyword will destroy any object or pointer item stored in</span>
    <span class="comments">; the node before the node is deleted.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Assume you want to destroy the items in the node.</span>
    IF (N_Elements(destroy) EQ 0) $
        THEN destroy = 1 $
        ELSE destroy = Keyword_Set(destroy)
    
    <span class="comments">; Delete all the nodes?</span>
    IF Keyword_Set(all) THEN BEGIN
       self->Delete_Nodes, DESTROY=destroy, ERROR=errorMsg
       RETURN
    ENDIF

    <span class="comments">; Check for index. If there is none, delete last node on list.</span>
    IF N_Elements(index) EQ 0 THEN BEGIN
       self->Delete_Last_Node, DESTROY=destroy, ERROR=errorMsg
       RETURN
    ENDIF
    
    <span class="comments">; Delete specified node.</span>
    IF index EQ (self.count - 1) THEN $
       self->Delete_Last_Node, DESTROY=destroy, ERROR=errorMsg ELSE $
       self->Delete_Node, index, DESTROY=destroy, ERROR=errorMsg
       
END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::DELETE_LAST_NODE, DESTROY=destroy, ERROR=errorMsg

    <span class="comments">; This method deletes the last node in the list. This is a </span>
    <span class="comments">; private method. Use the public DELETE method to delete an </span>
    <span class="comments">; item from the list.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Assume you want to destroy the items in the node.</span>
    IF (N_Elements(destroy) EQ 0) $
        THEN destroy = 1 $
        ELSE destroy = Keyword_Set(destroy)
    
    <span class="comments">; If there is nothing here, return.</span>
    IF self.count EQ 0 THEN RETURN
    
    <span class="comments">; This should be the last node.</span>
    currentNode = self.tail
    
    <span class="comments">; Free the item pointer and everything it points to.</span>
    IF Keyword_Set(destroy) THEN BEGIN
        IF Ptr_Valid((*currentNode).item) THEN Heap_Free, (*currentNode).item
    ENDIF    
    
    <span class="comments">; Is this the last node in the list?</span>
    IF NOT Ptr_Valid((*currentNode).previous) THEN BEGIN
        self.head = Ptr_New()
        self.tail = Ptr_New()
        self.count = 0
        Ptr_Free, (*currentNode).next
    ENDIF ELSE BEGIN
        previousNode = (*currentNode).previous
        self.tail = previousNode
        Ptr_Free, (*self.tail).next
        (*self.tail).next = Ptr_New()
        self.count = self.count - 1
    ENDELSE
    
    <span class="comments">; Release the currentNode pointer.</span>
    Ptr_Free, currentNode
END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::DELETE_NODE, index, DESTROY=destroy, ERROR=errorMsg

    <span class="comments">; This method deletes the indicated node from the list. This is a </span>
    <span class="comments">; private method. Use the public DELETE method to delete an </span>
    <span class="comments">; item from the list.</span>
    
    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Assume you want to destroy the items in the node.</span>
    IF (N_Elements(destroy) EQ 0) $
        THEN destroy = 1 $
        ELSE destroy = Keyword_Set(destroy)
    
    IF self.count EQ 0 THEN BEGIN
       errorMsg = 'No nodes to delete.'
       Message, errorMsg, /Continue
       RETURN
    ENDIF
    
    IF index GT (self.count - 1) THEN BEGIN
       errorMsg = 'No node with the requested index number.'
       Message, errorMsg, /Continue
       RETURN
    ENDIF
      
    <span class="comments">; Get the current node and free the item pointer.</span>
    currentNode = self->Get_Node(index)
    IF ~Ptr_Valid(currentNode) THEN BEGIN
        errorMsg = 'The current node is not a valid pointer.'
        Message, errorMsg, /Continue
        RETURN
    ENDIF
    
    <span class="comments">; Free the item pointer and everything it points to.</span>
    IF Keyword_Set(destroy) THEN $
    BEGIN
      theItem = *(*currentNode).item
      CASE Size(theItem, /TNAME) OF
         'OBJREF': Obj_Destroy, theItem
         'POINTER': Ptr_Free, theItem
         ELSE:
      ENDCASE
    ENDIF
    Ptr_Free, (*currentNode).item
    
    <span class="comments">; Is this the last node?</span>
    IF index EQ (self.count - 1) THEN BEGIN
        self->Delete_Last_Node, DESTROY=destroy, ERROR=errorMsg
        RETURN
    ENDIF
    
    <span class="comments">; Is this the first node in the list?</span>
    IF NOT Ptr_Valid((*currentNode).previous) THEN BEGIN
            nextNode = (*currentNode).next
            Ptr_Free, (*nextNode).previous
            (*nextNode).previous = Ptr_New()
            self.head = nextNode
    ENDIF ELSE BEGIN
            previousNode = (*currentNode).previous
            nextNode = (*currentNode).next
            (*nextNode).previous = previousNode
            (*previousNode).next = nextNode
    ENDELSE

    <span class="comments">; Release the currentNode pointer. </span>
    Ptr_Free, currentNode
    self.count = self.count - 1
END
<span class="comments">;------------------------------------------------------------------------</span>




PRO LINKEDLIST::DELETE_NODES, DESTROY=destroy, ERROR=errorMsg

    <span class="comments">; This method deletes all of the nodes. This is a private method. </span>
    <span class="comments">; Use the public DELETE method to delete all items from the list.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Assume you want to destroy the items in the node.</span>
    IF (N_Elements(destroy) EQ 0) $
        THEN destroy = 1 $
        ELSE destroy = Keyword_Set(destroy)
    
    <span class="comments">; Cycle through the list, deleting as you go.</span>
    WHILE Ptr_Valid(self.head) DO BEGIN
        currentNode = *self.head
        IF Keyword_Set(destroy) THEN $
        BEGIN
          theItem = *(currentNode.item)
          CASE Size(theItem, /TNAME) OF
             'OBJREF': Obj_Destroy, theItem
             'POINTER': Ptr_Free, theItem
             ELSE:
          ENDCASE
        ENDIF
        Ptr_Free, currentNode.previous
        Ptr_Free, currentNode.item
        self.head = currentNode.next
    ENDWHILE

    <span class="comments">; Free up that last pointer.</span>
    Ptr_Free, self.tail

    <span class="comments">; Update the count.</span>
    self.count = 0

END
<span class="comments">;------------------------------------------------------------------------</span>



FUNCTION LINKEDLIST::GET_COUNT

    <span class="comments">; This method returns the number of items in the list.</span>
    RETURN, self.count
END
<span class="comments">;------------------------------------------------------------------------</span>



FUNCTION LINKEDLIST::GET_ITEM, index, $
    ALL=all, $         <span class="comments">; This ASSUMES all items stored are the same type!!!</span>
    Dereference=dereference, $ <span class="comments">; Obsolete. Ignored. Always returns item.</span>
    ItemPtr=itemPtr, $ <span class="comments">; The pointer to the item, if needed. Output.</span>
    NO_COPY=no_copy, $
    ERROR=errorMsg

    <span class="comments">; This method returns the item stored at the index location.</span>
    <span class="comments">; The DEREFERENCE keyword is obsolete and is provide only</span>
    <span class="comments">; to allow backward compatibility. It is always set to 1.</span>
    <span class="comments">; If you wish to obtain the pointer to the item, use the</span>
    <span class="comments">; ItemPtr keyword. If an INDEX is not provided, the</span>
    <span class="comments">; last item is returned.</span>
    
    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN, Ptr_New()
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    dereference = 1
    
    <span class="comments">; Last item, if index is unspecified.</span>
    IF N_Elements(index) EQ 0 THEN index = self.count - 1
    
    <span class="comments">; Make sure there are items in the list.</span>
    IF self.count EQ 0 THEN BEGIN
       errorMsg = 'Nothing is currently stored in the list.'
       Message, errorMsg, /CONTINUE
       RETURN, Ptr_New()
    ENDIF
    
    <span class="comments">; The index has to be in range.</span>
    IF index GT (self.count-1) OR index LT 0 THEN BEGIN
       errorMsg = 'Requested node index is out of range.'
       Message, errorMsg, /CONTINUE
       RETURN, Ptr_New()
    ENDIF
    
    <span class="comments">; Start at the head of the list.</span>
    currentNode = self.head
    
    <span class="comments">; Is this a valid pointer?</span>
    IF ~Ptr_Valid(currentNode) THEN BEGIN
        errorMsg = 'The current node pointer is invalid.'
        Message, errorMsg, /CONTINUE
        RETURN, Ptr_New()
    ENDIF
    
    <span class="comments">; Is the ALL keyword set. ; We are going *assume* the items are all the same type.</span>
    IF Keyword_Set(ALL) THEN BEGIN 
    
        item  = self->Get_Item()
        num   = self.count
        
        <span class="comments">; If items in list are x * y arrays, then for n items, we return a n * x * y ... array</span>
        <span class="comments">; Since IDL's maximum arrays are 8D, this means that this particular routine works only up to 7D arrays.</span>
        <span class="comments">;</span>
        <span class="comments">; There is an unadvertised limitation in IDL's MAKE_ARRAY() function, in that it does not allow</span>
        <span class="comments">; the automatic creation of structures by passing TYPE=8.  Instead, we use the VALUE= keyword</span>
        <span class="comments">; keyword to MAKE_ARRAY.  This takes a scalar and not a vector.</span>
          dim_item      = Size(item, /N_DIMENSIONS) 
          IF (dim_item gt 0) THEN BEGIN
            size_item   = Size(item, /DIMENSIONS)
            type_item   = Size(item, /TYPE)
            arr         =  Make_Array(dimension=[num,size_item], val=item[0])
        
          ENDIF ELSE BEGIN
            type_item   = Size(item, /TYPE)
            arr         = Make_Array(dimension=[num], val=item[0])
          ENDELSE
        
          dim_item_save = dim_item
          type_item_save= type_item
        
          <span class="comments">; Rather than call Get_Item for each element, it is much faster to march through the list</span>
          <span class="comments">; sequentially and extract every item as we get to it.</span>
          <span class="comments">; After we extract each item, we check to make sure that its type and size are the same as for the</span>
          <span class="comments">; first item; if they're not, we generate an error and return.  This is a bit conservative -- we</span>
          <span class="comments">; could promote ints to floats, for instance -- but it's safe.</span>
          currentNode = self.head
          FOR i = 0L, num-1 DO BEGIN
        
                item        =  *((*currentNode).item)
                dim_item    = Size(item, /N_DIMENSIONS)            <span class="comments">; number of dimensions</span>
                type_item    = Size(item, /TYPE)
                IF ((type_item NE type_item_save) OR (dim_item NE dim_item_save)) THEN BEGIN
                    errorMsg = 'Inconsistent type or size for Get_Item(/ALL).  Use Get_Item(index) instead.'
                    Message, errorMsg, /CONTINUE
                    RETURN, Ptr_New()
                ENDIF
            
                <span class="comments">; How many dimensions are there?</span>
                CASE dim_item OF
                  0 : arr[i]               = item
                  1 : arr[i,*]             = item
                  2 : arr[i,*,*]           = item
                  3 : arr[i,*,*,*]         = item
                  4 : arr[i,*,*,*,*]       = item
                  5 : arr[i,*,*,*,*,*]     = item
                  6 : arr[i,*,*,*,*,*,*]   = item
                  7 : arr[i,*,*,*,*,*,*,*] = item
                  ELSE : BEGIN
                    errorMsg = 'Maximum array size for Get_Item(/ALL) exceeded.  Use Get_Item(index) instead.'
                    Message, errorMgs, /CONTINUE
                    RETURN, Ptr_New()
                  END
                ENDCASE
                currentNode = (*currentNode).next
          ENDFOR
        
          RETURN, arr
    
    ENDIF <span class="comments">; if keyword ALL is set.</span>

    <span class="comments">; Find the item asked for by traversing the list.</span>
    FOR j=0L, index-1 DO currentNode = (*currentNode).next
    
    <span class="comments">; Get the item pointer.</span>
    itemPtr = (*currentNode).item
    
    <span class="comments">; Return the item.</span>
    IF Ptr_Valid(itemPtr) THEN BEGIN
        RETURN, *itemPtr 
    ENDIF ELSE BEGIN
        errorMsg = 'The item pointer is invalid.'
        Message, errorMsg, /CONTINUE
        RETURN, Ptr_New()
   ENDELSE
    
END
<span class="comments">;------------------------------------------------------------------------</span>



FUNCTION LINKEDLIST::GET_NODE, index, ERROR=errorMsg

    <span class="comments">; This method returns a pointer to the asked-for node.</span>
    <span class="comments">; Ask for the node by number or order in the list</span>
    <span class="comments">; (node numbers start at 0).</span>
    
    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, errorMsg, /Continue
       RETURN, Ptr_New()
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Gets last node by default.</span>
    IF N_Elements(index) EQ 0 THEN index = self.count - 1
    
    <span class="comments">; Make sure there are items in the list.</span>
    IF self.count EQ 0 THEN BEGIN
       errorMsg = 'Nothing is currently stored in the list.'
       Message, errorMsg, /Continue
       RETURN, Ptr_New()
    ENDIF
    
    IF index GT (self.count - 1) OR index LT 0 THEN BEGIN
       errorMsg = 'Sorry. Requested node is not in list.'
       Message, errorMsg, /Continue
       RETURN, Ptr_New()
    ENDIF  
    
    <span class="comments">; Start at the head of the list.</span>
    currentNode = self.head
   
    <span class="comments">; Find the item asked for by traversing the list.</span>
    FOR j=0L, index-1 DO currentNode = (*currentNode).next
    
    <span class="comments">; Return the pointer to the node.</span>
    RETURN, currentNode
    
END
<span class="comments">;------------------------------------------------------------------------</span>



FUNCTION LINKEDLIST::GET_VALUE, index, NO_COPY=no_copy, ERROR=errorMsg

    <span class="comments">; This method returns the item stored at index in the list.</span>
    <span class="comments">; It is a synonym for Get_Item. Added here to be compatible with</span>
    <span class="comments">; SolarSoft changes to LinkImage.</span>
    
    RETURN, self -> Get_Item(index, NO_COPY=no_copy, ERROR=errorMsg)

END
<span class="comments">;------------------------------------------------------------------------</span>


FUNCTION LINKEDLIST::HAVE_ITEM, index, ERROR=errorMsg

    <span class="comments">; This method returns a 1 if there is a valid item stored at the</span>
    <span class="comments">; index location. Otherwise, it returns a 0.</span>
    
    <span class="comments">; Try to get the item. See if you were successful.</span>
    item = self -> Get_Item(ERROR=errorMsg, ITEMPTR=itemPtr)
    IF errorMsg NE "" THEN RETURN, 0
    IF ~Ptr_Valid(itemPtr) THEN RETURN, 0
    
    RETURN, 1
    
END
<span class="comments">;------------------------------------------------------------------------</span>


PRO LINKEDLIST::HELP, Print=print

    <span class="comments">; This method performs a HELP command on the items</span>
    <span class="comments">; in the linked list. If the PRINT keyword is set, the</span>
    <span class="comments">; data items are printed instead.</span>
    
    <span class="comments">; Are there nodes to work with?</span>
    IF NOT Ptr_Valid(self.head) THEN BEGIN
        ok = Widget_Message('No nodes in Linked List.')
        RETURN
    ENDIF
    
    <span class="comments">; First node.</span>
    currentNode = *self.head
    IF Keyword_Set(print) THEN Print, *currentNode.item ELSE $
        Help, *currentNode.item
    
    <span class="comments">; The rest of the nodes. End of list indicated by null pointer.</span>
    WHILE currentNode.next NE Ptr_New() DO BEGIN
        nextNode = *currentNode.next
        IF Keyword_Set(print) THEN Print, *nextNode.item ELSE $
            Help, *nextNode.item
        currentNode = nextNode
    ENDWHILE

END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::MOVE_NODE, nodeIndex, location, Before=before, Error=errormsg

    <span class="comments">; This method moves the requested node to a new location.</span>
    <span class="comments">; The node is added AFTER the target location, unless the BEFORE</span>
    <span class="comments">; keyword is used.</span>

    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, !Error_State.MSG, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; A node index is required.</span>
    IF N_Elements(nodeIndex) EQ 0 THEN BEGIN
       errorMsg = 'A node index is required in MOVE_NODE method.'
       Message, errorMsg, /Continue
       RETURN
    ENDIF

    <span class="comments">; If location is not specified the node is moved to the</span>
    <span class="comments">; end of the list.</span>
    IF N_Elements(location) EQ 0 THEN BEGIN
       location = (self->Get_Count()) - 1
    ENDIF

    <span class="comments">; Add the node to the list.</span>
    currentNode = self->Get_Node(nodeIndex)
    
    <span class="comments">; If the current node is not a valid pointer, there is problem.</span>
    IF ~Ptr_Valid(currentNode) THEN BEGIN
        errorMsg = 'The requested node is not a valid pointer.'
        Message, errorMsg, /Continue
        RETURN
    ENDIF

    IF Keyword_Set(before) THEN BEGIN
       self->Add, *(*currentNode).item, location, /Before
    ENDIF ELSE BEGIN
       self->Add, *(*currentNode).item, location, /After
    ENDELSE

    <span class="comments">; Delete the node from its current location.</span>
    IF location LT nodeIndex THEN $
       self->Delete, nodeIndex + 1 ELSE $
       self->Delete, nodeIndex


END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::REPLACE_ITEM, item, index, NO_COPY=no_copy, ERROR=errorMsg

    <span class="comments">; This method replace an item with another item at a particular</span>
    <span class="comments">; index. If index is not supplied, the the last index is used.</span>
    
    Catch, error
    IF error NE 0 THEN BEGIN
       Catch, /Cancel
       errorMsg = !Error_State.MSG
       Message, !Error_State.MSG, /Continue
       RETURN
    ENDIF

    <span class="comments">; Assume no error.</span>
    errorMsg = ""
    
    <span class="comments">; Must supply an item to add to the list.</span>
    IF N_Elements(item) EQ 0 THEN BEGIN
       errorMsg = 'Must supply an item to add to the list.'
       Message, errorMsg, /Continue
       RETURN
    END
    
    <span class="comments">; Check for index. If there is none, add to end of list.</span>
    IF N_Elements(index) EQ 0 THEN index = self.count - 1
    
    <span class="comments">; Start at the head of the list.</span>
    currentNode = self.head
    
    <span class="comments">; Is this a valid pointer?</span>
    IF ~Ptr_Valid(currentNode) THEN BEGIN
        errorMsg = 'The current node pointer is invalid.'
        Message, errorMsg, /CONTINUE
        RETURN
    ENDIF
    
    <span class="comments">; Find the item asked for by traversing the list.</span>
    FOR j=0L, index-1 DO currentNode = (*currentNode).next
    
    <span class="comments">; Get the item pointer.</span>
    itemPtr = (*currentNode).item
    
    <span class="comments">; Replace the item, if you can.</span>
    IF Ptr_Valid(itemPtr) THEN BEGIN
    
        <span class="comments">; Stuff the new item into the place of the old item.</span>
        IF Keyword_Set(no_copy) THEN BEGIN
            *(*currentNode).item = Temporary(item)
        ENDIF ELSE BEGIN
             *(*currentNode).item = item  
        ENDELSE
        
    ENDIF ELSE BEGIN
    
        errorMsg = 'The item pointer is invalid.'
        Message, errorMsg, /CONTINUE
        RETURN
        
   ENDELSE

END 
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST::CLEANUP

    <span class="comments">; This method deletes all of the nodes and cleans up</span>
    <span class="comments">; the objects pointers.</span>
    
    self->Delete_Nodes
    Ptr_Free, self.head
    Ptr_Free, self.tail
    
END
<span class="comments">;------------------------------------------------------------------------</span>



FUNCTION LINKEDLIST::INIT, item

    <span class="comments">; Initialize the linked list. Add an item if required.</span>
    
    IF N_Params() EQ 0 THEN RETURN, 1
    self->Add, item
    RETURN, 1
    
END
<span class="comments">;------------------------------------------------------------------------</span>



PRO LINKEDLIST__DEFINE

   <span class="comments">; The implementation of a LINKEDLIST object.</span>

   struct = { LINKEDLIST_NODE, $    <span class="comments">; The LINKEDLIST NODE structure.</span>
              previous:Ptr_New(), $ <span class="comments">; A pointer to the previous node.</span>
              item:Ptr_New(), $     <span class="comments">; A pointer to the data item.</span>
              next:Ptr_New()  $     <span class="comments">; A pointer to the next node.</span>
              }

   struct = { LINKEDLIST, $         <span class="comments">; The LINKEDLIST object.</span>
              head:Ptr_New(), $     <span class="comments">; A pointer to the first node.</span>
              tail:Ptr_New(), $     <span class="comments">; A pointer to the last node.</span>
              count:0L $            <span class="comments">; The number of nodes in the list.</span>
              }

END
<span class="comments">;------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>