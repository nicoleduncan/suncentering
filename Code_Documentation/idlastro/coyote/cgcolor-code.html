<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:15 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cgcolor.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cgcolor.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;</span>
<span class="comments">; NAME:</span>
<span class="comments">;   cgColor</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">; The purpose of this function is to obtain drawing colors</span>
<span class="comments">; by name and in a device/decomposition independent way.</span>
<span class="comments">; The color names and values may be read in as a file, or 192 color</span>
<span class="comments">; names and values are supplied with the program. These colors were</span>
<span class="comments">; obtained from the file rgb.txt, found on most X-Window distributions,</span>
<span class="comments">; and from colors in the Brewer color tables (http://colorbrewer2.org/).</span>
<span class="comments">; Representative colors were chosen from across the color spectrum. </span>
<span class="comments">; If the color names '0', '1', '2', ..., '255' are used, they will</span>
<span class="comments">; correspond to the colors in the current color table in effect at</span>
<span class="comments">; the time the cgColor program is called.</span>
<span class="comments">;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Copyright (c) 2011, by Fanning Software Consulting, Inc. All rights reserved.           ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  Redistribution and use in source and binary forms, with or without                      ;</span>
<span class="comments">;  modification, are permitted provided that the following conditions are met:             ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;      * Redistributions of source code must retain the above copyright                    ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer.                     ;</span>
<span class="comments">;      * Redistributions in binary form must reproduce the above copyright                 ;</span>
<span class="comments">;        notice, this list of conditions and the following disclaimer in the               ;</span>
<span class="comments">;        documentation and/or other materials provided with the distribution.              ;</span>
<span class="comments">;      * Neither the name of Fanning Software Consulting, Inc. nor the names of its        ;</span>
<span class="comments">;        contributors may be used to endorse or promote products derived from this         ;</span>
<span class="comments">;        software without specific prior written permission.                               ;</span>
<span class="comments">;                                                                                          ;</span>
<span class="comments">;  THIS SOFTWARE IS PROVIDED BY FANNING SOFTWARE CONSULTING, INC. ''AS IS'' AND ANY        ;</span>
<span class="comments">;  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    ;</span>
<span class="comments">;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT     ;</span>
<span class="comments">;  SHALL FANNING SOFTWARE CONSULTING, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,             ;</span>
<span class="comments">;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    ;</span>
<span class="comments">;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;         ;</span>
<span class="comments">;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND             ;</span>
<span class="comments">;  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT              ;</span>
<span class="comments">;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS           ;</span>
<span class="comments">;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            ;</span>
<span class="comments">;******************************************************************************************;</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; The purpose of this function is to obtain drawing colors</span>
<span class="comments">; by name and in a device/decomposition independent way.</span>
<span class="comments">; The color names and values may be read in as a file, or 192 color</span>
<span class="comments">; names and values are supplied with the program. These colors were</span>
<span class="comments">; obtained from the file rgb.txt, found on most X-Window distributions,</span>
<span class="comments">; and from colors in the `Brewer color tables &lt;http://colorbrewer2.org/>`.</span>
<span class="comments">; Representative colors were chosen from across the color spectrum. </span>
<span class="comments">; If the color names '0', '1', '2', ..., '255' are used, they will</span>
<span class="comments">; correspond to the colors in the current color table in effect at</span>
<span class="comments">; the time the `cgColor` program is called.</span>
<span class="comments">; </span>
<span class="comments">; The program requires the `Coyote Library &lt;http://www.idlcoyote.com/documents/programs.php>`</span>
<span class="comments">; to be installed on your machine.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;    Graphics</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    To get drawing colors in a device-decomposed independent way::</span>
<span class="comments">;</span>
<span class="comments">;        axisColor = cgColor("Green", !D.Table_Size-2)</span>
<span class="comments">;        backColor = cgColor("Charcoal", !D.Table_Size-3)</span>
<span class="comments">;        dataColor = cgColor("Yellow", !D.Table_Size-4)</span>
<span class="comments">;        Plot, Findgen(11), Color=axisColor, Background=backColor, /NoData</span>
<span class="comments">;        OPlot, Findgen(11), Color=dataColor</span>
<span class="comments">;</span>
<span class="comments">;    To set the viewport color in object graphics::</span>
<span class="comments">;</span>
<span class="comments">;        theView = Obj_New('IDLgrView', Color=cgColor('Charcoal', /Triple))</span>
<span class="comments">;</span>
<span class="comments">;    To change the viewport color later::</span>
<span class="comments">;</span>
<span class="comments">;        theView->SetProperty, Color=cgColor('Antique White', /Triple)</span>
<span class="comments">;</span>
<span class="comments">;    To load the drawing colors "red", "green", and "yellow" at indices 100-102, type this::</span>
<span class="comments">;</span>
<span class="comments">;        IDL> TVLCT, cgColor(["red", "green", "yellow"], /Triple), 100</span>
<span class="comments">;           </span>
<span class="comments">;    To interactively choose a color, set the SELECTCOLOR keyword::</span>
<span class="comments">;    </span>
<span class="comments">;        IDL> color = cgColor(/SelectColor)</span>
<span class="comments">;        </span>
<span class="comments">;    The cgPickColorName program is a good way to learn the names of the colors available::</span>
<span class="comments">;    </span>
<span class="comments">;        IDL> color = cgPickColorName()</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;       FANNING SOFTWARE CONSULTING::</span>
<span class="comments">;           David W. Fanning </span>
<span class="comments">;           1645 Sheely Drive</span>
<span class="comments">;           Fort Collins, CO 80526 USA</span>
<span class="comments">;           Phone: 970-221-0438</span>
<span class="comments">;           E-mail: david@idlcoyote.com</span>
<span class="comments">;           Coyote's Guide to IDL Programming: http://www.idlcoyote.com</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;     Change History::</span>
<span class="comments">;        Written by: David W. Fanning</span>
<span class="comments">;        Modified FSC_COLOR to create cgColor 9 February 2011. DWF.</span>
<span class="comments">;        Modified to allow a three-element color triple to be used in place of the color</span>
<span class="comments">;           name parameter. This allows one user-defined color to be used. 4 Dec 2011. DWF.</span>
<span class="comments">;        Modified to allow byte and 16-bit integer values to be used to specify colors</span>
<span class="comments">;           in the current color table. 5 Dec 2011. DWF.</span>
<span class="comments">;        Modified to allow the "opposite" pixel to be determined in the Z-graphics buffer. 24 Dec 2011. DWF.</span>
<span class="comments">;        Modified the code to handle long integers depending on the current color mode and the</span>
<span class="comments">;            number of values passed in. 10 January 2012. DWF.</span>
<span class="comments">;        Made sure the return values are BYTES not INTEGERS, in cases where this is expected. 10 Jan 2012. DWF.</span>
<span class="comments">;        Added "Background" as a color name. The opposite of "Opposite". 1 Feb 2012. DWF.</span>
<span class="comments">;        When returning a vector of color values, now making sure to return a byte array if </span>
<span class="comments">;             in indexed color mode. 27 Feb 2012. DWF.</span>
<span class="comments">;        Added Compile Opt id2 to all file modules. 22 July 2012. DWF.</span>
<span class="comments">;        Added "opposite" and "background" colors to Brewer colors. 14 August 2012. DWF.</span>
<span class="comments">;        </span>
<span class="comments">; :Copyright:</span>
<span class="comments">;     Copyright (c) 2009-2012, Fanning Software Consulting, Inc.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">;+</span>
<span class="comments">; This function accepts a [red, green, blue] triple that</span>
<span class="comments">; describes a particular color and returns a 24-bit long</span>
<span class="comments">; integer that is equivalent to (can be decomposed into)</span>
<span class="comments">; that color. </span>
<span class="comments">; </span>
<span class="comments">; :Params:</span>
<span class="comments">;    color: in, required, type=byte</span>
<span class="comments">;       A three-element byte array containing the color</span>
<span class="comments">;       triple. The triple can be either a row or column</span>
<span class="comments">;       vector of three elements or it can be an N-by-3 array of</span>
<span class="comments">;       color triples.</span>
<span class="comments">;-</span>
FUNCTION cgColor_Color24, color

    Compile_Opt idl2

    ON_ERROR, 2
    
    s = Size(color)
    
    IF s[0] EQ 1 THEN BEGIN
       IF s[1] NE 3 THEN Message, 'Input color parameter must be a 3-element vector.'
       RETURN, color[0] + (color[1] * 2L^8) + (color[2] * 2L^16)
    ENDIF ELSE BEGIN
       IF s[2] GT 3 THEN Message, 'Input color parameter must be an N-by-3 array.'
       RETURN, color[*,0] + (color[*,1] * 2L^8) + (color[*,2] * 2L^16)
    ENDELSE

END <span class="comments">;--------------------------------------------------------------------------------------------</span>

<span class="comments">;+</span>
<span class="comments">; The purpose of this function is to obtain drawing colors</span>
<span class="comments">; by name and in a device/decomposition independent way.</span>
<span class="comments">; </span>
<span class="comments">; :Returns:</span>
<span class="comments">;     The return value depends on the color mode in effect at the time</span>
<span class="comments">;     the program is called and which keyword is used with the program.</span>
<span class="comments">;     In normal operation, if the graphics device is using indexed color</span>
<span class="comments">;     mode, the program will load a color at a unique (or specified)</span>
<span class="comments">;     index and return that index number. If the graphics device is using</span>
<span class="comments">;     decomposed color mode, the program will create a 24-bit color value</span>
<span class="comments">;     that can be used to specify the particular color desired. In this</span>
<span class="comments">;     case, no color is loaded in the color table. This is the preferred</span>
<span class="comments">;     mode for working with colors in IDL.</span>
<span class="comments">;     </span>
<span class="comments">; :Params:</span>
<span class="comments">;    theColour: required, optional, type=varies</span>
<span class="comments">;        Normally the name of the color desired. However, this can also be</span>
<span class="comments">;        a string index number (e.g., '215') or a byte or short integer</span>
<span class="comments">;        value (e.g, 215B or 215S). If this is the case, the color</span>
<span class="comments">;        in the current color table at this index number is used for the </span>
<span class="comments">;        color that is returned. The value may also be a vector of color names. </span>
<span class="comments">;        The color may also be a three-element byte or integer array specifying a </span>
<span class="comments">;        user-defined color triple. Only one color triple is allowed.</span>
<span class="comments">;</span>
<span class="comments">;        To see a list of the color names available set the NAMES keyword. Colors available are these::</span>
<span class="comments">;</span>
<span class="comments">;           Active            Almond     Antique White        Aquamarine             Beige            Bisque</span>
<span class="comments">;           Black               Blue       Blue Violet             Brown         Burlywood        Cadet Blue</span>
<span class="comments">;           Charcoal       Chartreuse         Chocolate             Coral   Cornflower Blue          Cornsilk</span>
<span class="comments">;           Crimson              Cyan    Dark Goldenrod         Dark Gray        Dark Green        Dark Khaki</span>
<span class="comments">;           Dark Orchid      Dark Red       Dark Salmon   Dark Slate Blue         Deep Pink       Dodger Blue</span>
<span class="comments">;           Edge                 Face         Firebrick      Forest Green             Frame              Gold</span>
<span class="comments">;           Goldenrod            Gray             Green      Green Yellow         Highlight          Honeydew</span>
<span class="comments">;           Hot Pink       Indian Red             Ivory             Khaki          Lavender        Lawn Green</span>
<span class="comments">;           Light Coral    Light Cyan        Light Gray      Light Salmon   Light Sea Green      Light Yellow</span>
<span class="comments">;           Lime Green          Linen           Magenta            Maroon       Medium Gray     Medium Orchid</span>
<span class="comments">;           Moccasin             Navy             Olive        Olive Drab            Orange        Orange Red</span>
<span class="comments">;           Orchid     Pale Goldenrod        Pale Green            Papaya              Peru              Pink</span>
<span class="comments">;           Plum          Powder Blue            Purple               Red              Rose        Rosy Brown</span>
<span class="comments">;           Royal Blue   Saddle Brown            Salmon       Sandy Brown         Sea Green          Seashell</span>
<span class="comments">;           Selected           Shadow            Sienna          Sky Blue        Slate Blue        Slate Gray</span>
<span class="comments">;           Snow         Spring Green        Steel Blue               Tan              Teal              Text</span>
<span class="comments">;           Thistle            Tomato         Turquoise            Violet        Violet Red             Wheat</span>
<span class="comments">;           White              Yellow</span>
<span class="comments">;</span>
<span class="comments">;        Here are the Brewer color names::</span>
<span class="comments">;</span>
<span class="comments">;           WT1        WT2       WT3       WT4       WT5       WT6       WT7       WT8</span>
<span class="comments">;           TAN1      TAN2      TAN3      TAN4      TAN5      TAN6      TAN7      TAN8</span>
<span class="comments">;           BLK1      BLK2      BLK3      BLK4      BLK5      BLK6      BLK7      BLK8</span>
<span class="comments">;           GRN1      GRN2      GRN3      GRN4      GRN5      GRN6      GRN7      GRN8</span>
<span class="comments">;           BLU1      BLU2      BLU3      BLU4      BLU5      BLU6      BLU7      BLU8</span>
<span class="comments">;           ORG1      ORG2      ORG3      ORG4      ORG5      ORG6      ORG7      ORG8</span>
<span class="comments">;           RED1      RED2      RED3      RED4      RED5      RED6      RED7      RED8</span>
<span class="comments">;           PUR1      PUR2      PUR3      PUR4      PUR5      PUR6      PUR7      PUR8</span>
<span class="comments">;           PBG1      PBG2      PBG3      PBG4      PBG5      PBG6      PBG7      PBG8</span>
<span class="comments">;           YGB1      YGB2      YGB3      YGB4      YGB5      YGB6      YGB7      YGB8</span>
<span class="comments">;           RYB1      RYB2      RYB3      RYB4      RYB5      RYB6      RYB7      RYB8</span>
<span class="comments">;           TG1        TG2       TG3       TG4       TG5       TG6       TG7       TG8</span>
<span class="comments">;            </span>
<span class="comments">;        The color name "OPPOSITE" is also available. It chooses a color "opposite" to the </span>
<span class="comments">;        color of the pixel in the upper-right corner of the display, if a window is open.</span>
<span class="comments">;        Otherwise, this color is "black" in PostScript and "white" everywhere else.</span>
<span class="comments">;        The color OPPOSITE is used if this parameter is absent or a color name is mis-spelled.</span>
<span class="comments">;        </span>
<span class="comments">;         The color name "BACKGROUND" can similarly be used to select the color of the pixel</span>
<span class="comments">;         in the upper-right corner of the display, if a window is open.</span>
<span class="comments">;           </span>
<span class="comments">;    colorindex: in, optional, type=byte</span>
<span class="comments">;        The color table index where the color should be loaded. Colors are</span>
<span class="comments">;        loaded into the color table only if using indexed color mode in the</span>
<span class="comments">;        current graphics device. If this parameter is missing, the color will</span>
<span class="comments">;        be loaded at a unique color index number, if necessary.</span>
<span class="comments">;        </span>
<span class="comments">; :Keywords:</span>
<span class="comments">;     allcolors: in, optional, type=boolean, default=0</span>
<span class="comments">;        Set this keyword to return indices, or 24-bit values, or color</span>
<span class="comments">;        triples, for all the known colors, instead of for a single color.</span>
<span class="comments">;     brewer: in, optional, type=boolean, default=0</span>
<span class="comments">;        An obsolete keyword. If used, only Brewer colors are loaded into the color</span>
<span class="comments">;        vectors internally.</span>
<span class="comments">;     cancel: out, optional, type=boolean, default=0</span>
<span class="comments">;        This keyword is always set to 0, unless that SELECTCOLOR keyword is used.</span>
<span class="comments">;        Then it will correspond to the value of the CANCEL output keyword in cgPickColorName.</span>
<span class="comments">;     check_connection: in, optional, type=boolean, default=0</span>
<span class="comments">;         An obsolete keyword now completely ignored.</span>
<span class="comments">;     colorstructure: out, optional, type=structure</span>
<span class="comments">;        This output keyword (if set to a named variable) will return a</span>
<span class="comments">;        structure in which the fields will be the known color names (without spaces)</span>
<span class="comments">;        and the values of the fields will be either color table index numbers or</span>
<span class="comments">;        24-bit color values. If you have specified a vector of color names, then</span>
<span class="comments">;        this will be a structure containing just those color names as fields.</span>
<span class="comments">;     decomposed: in, optional, type=boolean</span>
<span class="comments">;        Set this keyword to 0 or 1 to force the return value to be</span>
<span class="comments">;        a color table index or a 24-bit color value, respectively. This</span>
<span class="comments">;        keyword is normally set by the color state of the current graphics device.</span>
<span class="comments">;     filename: in, optional, type=string</span>
<span class="comments">;        The  name of an ASCII file that can be opened to read in color values and color </span>
<span class="comments">;        names. There should be one color per row in the file. Please be sure there are </span>
<span class="comments">;        no blank lines in the file. The format of each row should be::</span>
<span class="comments">;</span>
<span class="comments">;           redValue  greenValue  blueValue  colorName</span>
<span class="comments">;</span>
<span class="comments">;        Color values should be between 0 and 255. Any kind of white-space</span>
<span class="comments">;        separation (blank characters, commas, or tabs) are allowed. The color</span>
<span class="comments">;        name should be a string, but it should NOT be in quotes. A typical</span>
<span class="comments">;        entry into the file would look like this::</span>
<span class="comments">;</span>
<span class="comments">;           255   255   0   Yellow</span>
<span class="comments">;     names: in, optional, type=boolian, default=0</span>
<span class="comments">;        If this keyword is set, the return value of the function is a string array </span>
<span class="comments">;        containing the names of the colors. These names would be appropriate, for example, </span>
<span class="comments">;        in building a list widget with the names of the colors. If the NAMES</span>
<span class="comments">;        keyword is set, the COLOR and INDEX parameters are ignored.</span>
<span class="comments">;     ncolors: out, optional, type=integer</span>
<span class="comments">;        Returns the number of colors that cgColor "knows" about. Currently ncolors=193.</span>
<span class="comments">;     nodisplay: in, optional, type=boolean, default=0</span>
<span class="comments">;        An obsolete keyword, now totally ignored.</span>
<span class="comments">;     row: in, optional, type=boolean</span>
<span class="comments">;        If this keyword is set, the return value of the function when the TRIPLE</span>
<span class="comments">;        keyword is set is returned as a row vector, rather than as the default</span>
<span class="comments">;        column vector. This is required, for example, when you are trying to</span>
<span class="comments">;        use the return value to set the color for object graphics objects. This</span>
<span class="comments">;        keyword is completely ignored, except when used in combination with the</span>
<span class="comments">;        TRIPLE keyword.</span>
<span class="comments">;     selectcolor: in, optional, type=boolean</span>
<span class="comments">;       Set this keyword if you would like to select the color name with</span>
<span class="comments">;       the cgPickColorName program. Selecting this keyword automaticallys sets</span>
<span class="comments">;       the INDEX positional parameter. If this keyword is used, any keywords</span>
<span class="comments">;       appropriate for cgPickColorName can also be used. If this keyword is used,</span>
<span class="comments">;       the first positional parameter can be a color name that will appear in</span>
<span class="comments">;       the SelectColor box.</span>
<span class="comments">;     triple: in, optional, type=boolean</span>
<span class="comments">;        Setting this keyword will force the return value of the function to</span>
<span class="comments">;        always be a color triple, regardless of color decomposition state or</span>
<span class="comments">;        visual depth of the machine. The value will be a three-element column</span>
<span class="comments">;        vector unless the ROW keyword is also set.</span>
<span class="comments">;     _ref_extra: in, optional</span>
<span class="comments">;        Any keyword parameter appropriate for cgPickColorName can be used.</span>
<span class="comments">;       These include BOTTOM, COLUMNS, GROUP_LEADER, INDEX, and TITLE.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
FUNCTION cgColor, theColour, colorIndex, $
   AllColors=allcolors, $
   Brewer=brewer, $ <span class="comments">; This keyword is no longer used.</span>
   Check_Connection=check_connection, $ <span class="comments">; This keyword is completely ignored.</span>
   ColorStructure=colorStructure, $
   Cancel=cancelled, $
   Decomposed=decomposedState, $
    Filename=filename, $
   Names=names, $
   NColors=ncolors, $
   NoDisplay=nodisplay, $ <span class="comments">; This keyword is completely ignored.</span>
   Row=row, $
   SelectColor=selectcolor, $
   Triple=triple, $
  _Ref_Extra=extra
  
    Compile_Opt idl2
   
    <span class="comments">; Return to caller as the default error behavior.</span>
    On_Error, 2
        
    <span class="comments">; Error handling for the rest of the program.</span>
    Catch, theError
    IF theError NE 0 THEN BEGIN
       Catch, /Cancel
       ok = Error_Message(/Traceback)
       cancelled = 1
       RETURN, !P.Color
    ENDIF
    
    <span class="comments">; Set up PostScript device for working with colors.</span>
    IF !D.Name EQ 'PS' THEN Device, COLOR=1, BITS_PER_PIXEL=8
    
    <span class="comments">; I don't want to change the original variable.</span>
    IF N_Elements(theColour) NE 0 THEN theColor = theColour ELSE $
        theColor = 'OPPOSITE'
        
     <span class="comments">; Allow the color values to be something other than a string.</span>
     <span class="comments">; There will be some ambiguity between a color triple and a number</span>
     <span class="comments">; array of three elements, but I am willing to live with this.</span>
     IF Size(theColor, /TNAME) NE 'STRING' THEN BEGIN
     
        <span class="comments">; Make sure this is not a 1x3 array, which we want to treat as a color triple.</span>
        IF (N_Elements(theColor) EQ 3) && (Size(theColor, /N_DIMENSIONS) EQ 2) THEN BEGIN
            theColor = Reform(theColor)
        ENDIF
     
        <span class="comments">; Allow the color to be a three-element array of byte values.</span>
        <span class="comments">; If it is, we will define the USERDEF color with these values.</span>
        <span class="comments">; Otherwise the USERDEF color will be unused.</span>
        IF (Size(theColor, /N_DIMENSIONS) EQ 1) && $
           (N_Elements(theColor) EQ 3) && $
           (Max(theColor) LE 255) && $
           (Min(theColor) GE 0) THEN BEGIN
           usercolor = theColor
           theColor = 'USERDEF'
        ENDIF
        
        <span class="comments">; If the input didn't qualify as a color triple, then see if you </span>
        <span class="comments">; can somehow make sense of the number values.</span>
        IF Size(theColor, /TNAME) NE 'STRING' THEN BEGIN
        
          <span class="comments">; We can assume that any number that is a byte or short integer must</span>
          <span class="comments">; be an index into the color table.</span>
          IF (Size(theColor, /TYPE) LE 2) THEN theColor = StrTrim(Fix(theColor),2)
          
          <span class="comments">; Long integers are problematic. If the current color mode is INDEXED, then</span>
          <span class="comments">; we will treat long integers as color indices. If it is DECOMPOSED, then if</span>
          <span class="comments">; there is just one value, we can handle this as a color triple.</span>
          IF (Size(theColor, /TYPE) EQ 3) THEN BEGIN
             
               IF GetDecomposedState() THEN BEGIN
                   IF N_Elements(theColor) EQ 1 THEN BEGIN
                      usercolor = [theColor MOD 2L^8, (theColor MOD 2L^16)/2L^8, theColor/2L^16]
                      theColor = 'USERDEF'
                   ENDIF ELSE Message, 'Do not know how to handle a vector of LONG integers!
               ENDIF ELSE BEGIN
                   IF N_Elements(theColor) EQ 1 THEN BEGIN
                      IF theColor LE 255 THEN BEGIN
                          theColor = StrTrim(Fix(theColor),2)
                      ENDIF ELSE Message, 'Long integer ' + StrTrim(theColor,2) + ' is out of indexed color range.'
                   ENDIF ELSE Message, 'Do not know how to handle a vector of LONG integers!
               ENDELSE
               
          ENDIF
          
          <span class="comments">; Anything that is not an BYTE, INTEGER, LONG, or STRING causes problems.</span>
          IF (Size(theColor, /TYPE) GT 4) && (Size(theColor, /TNAME) NE 'STRING') THEN BEGIN
             Message, 'Use BYTE, INTEGER, or STRING data to specify a color.'
          ENDIF
        ENDIF
     ENDIF
        
    <span class="comments">; Make sure the color parameter is a string.</span>
    varName = Size(theColor, /TNAME)
    IF varName NE 'STRING' THEN $
       Message, 'The color name parameter must be a string.', /NoName
       
    <span class="comments">; We don't want underscores in color names. Turn all underscores</span>
    <span class="comments">; to spaces.</span>
    FOR j=0,N_Elements(theColor)-1 DO BEGIN
        theColor[j] = StrJoin( StrSplit(theColor[j], '_', /Extract, $
           /Preserve_Null), ' ')
    ENDFOR
    
    <span class="comments">; Make sure the color is compressed and uppercase.   </span>
    theColor = StrUpCase(StrCompress(StrTrim(theColor,2), /Remove_All))
    
    <span class="comments">; Get the pixel value of the "opposite" color. This is the pixel color</span>
    <span class="comments">; opposite the pixel color in the upper right corner of the display.</span>
    IF ((!D.Window GE 0) && ((!D.Flags AND 256) NE 0)) || (!D.Name EQ 'Z') THEN BEGIN
       opixel = cgSnapshot(!D.X_Size-1,  !D.Y_Size-1, 1, 1)
       IF N_Elements(opixel) NE 3 THEN BEGIN
            IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, /Get
            opixel = [rrr[opixel], ggg[opixel], bbb[opixel]]
       ENDIF
    ENDIF ELSE BEGIN
       IF (!D.Name EQ 'PS') THEN opixel = [255,255,255] ELSE opixel = [0,0,0]
    ENDELSE
    IF N_Elements(opixel) EQ 0 THEN opixel = [0,0,0]
    bgcolor = opixel
    opixel = 255 - opixel
    
    <span class="comments">; Read the first color as bytes. If none of the bytes are less than 48</span>
    <span class="comments">; or greater than 57, then this is a "number" string and you should</span>
    <span class="comments">; assume the current color table is being used.</span>
    bytecheck = Byte(theColor[0])
    i = Where(bytecheck LT 48, lessthan)
    i = Where(bytecheck GT 57, greaterthan)
    IF (lessthan + greaterthan) EQ 0 THEN useCurrentColors = 1 ELSE useCurrentColors = 0
    
    <span class="comments">; Get the decomposed state of the IDL session right now.</span>
    IF N_Elements(decomposedState) EQ 0 THEN BEGIN
       IF Float(!Version.Release) GE 5.2 THEN BEGIN
          IF (!D.Name EQ 'X' OR !D.Name EQ 'WIN' OR !D.Name EQ 'MAC') THEN BEGIN
             Device, Get_Decomposed=decomposedState
          ENDIF ELSE decomposedState = 0
       ENDIF ELSE decomposedState = 0
       IF (Float(!Version.Release) GE 6.4) AND (!D.NAME EQ 'Z') THEN BEGIN
          Device, Get_Decomposed=decomposedState, Get_Pixel_Depth=theDepth
          IF theDepth LT 24 THEN decomposedState = 0
       ENDIF
    ENDIF ELSE decomposedState = Keyword_Set(decomposedState)
    
    <span class="comments">; Get depth of visual display (and decomposed state for PostScript devices).</span>
    IF (!D.Flags AND 256) NE 0 THEN Device, Get_Visual_Depth=theDepth ELSE theDepth = 8
    IF (Float(!Version.Release) GE 6.4) AND (!D.NAME EQ 'Z') THEN Device, Get_Pixel_Depth=theDepth
    IF (!D.NAME EQ 'PS') AND (Float(!Version.Release) GE 7.1) THEN BEGIN
       decomposedState = DecomposedColor(DEPTH=theDepth)
   ENDIF

    <span class="comments">; Need brewer colors?</span>
    brewer = Keyword_Set(brewer)
    
    <span class="comments">; Load the colors.</span>
    IF N_Elements(filename) NE 0 THEN BEGIN
    
       <span class="comments">; Count the number of rows in the file.</span>
       ncolors = File_Lines(filename)
    
       <span class="comments">; Read the data.</span>
       OpenR, lun, filename, /Get_Lun
       rvalue = BytArr(NCOLORS)
       gvalue = BytArr(NCOLORS)
       bvalue = BytArr(NCOLORS)
       colors = StrArr(NCOLORS)
       redvalue = 0B
       greenvalue = 0B
       bluevalue = 0B
       colorvalue = ""
       FOR j=0L, NCOLORS-1 DO BEGIN
          ReadF, lun, redvalue, greenvalue, bluevalue, colorvalue
          rvalue[j] = redvalue
          gvalue[j] = greenvalue
          bvalue[j] = bluevalue
          colors[j] = colorvalue
       ENDFOR
       Free_Lun, lun
    
       <span class="comments">; Trim the colors array of blank characters.</span>
       colors = StrTrim(colors, 2)
    
    ENDIF ELSE BEGIN
    
       <span class="comments">; Set up the color vectors.</span>
       IF Keyword_Set(Brewer) THEN BEGIN
       
           <span class="comments">; Set up the color vectors.</span>
           colors = [ 'WT1', 'WT2', 'WT3', 'WT4', 'WT5', 'WT6', 'WT7', 'WT8']
           rvalue = [  255,   255,   255,   255,   255,   245,   255,   250 ]
           gvalue = [  255,   250,   255,   255,   248,   245,   245,   240 ]
           bvalue = [  255,   250,   240,   224,   220,   220,   238,   230 ]
           colors = [ colors, 'TAN1', 'TAN2', 'TAN3', 'TAN4', 'TAN5', 'TAN6', 'TAN7', 'TAN8']
           rvalue = [ rvalue,   250,   255,    255,    255,    255,    245,    222,    210 ]
           gvalue = [ gvalue,   235,   239,    235,    228,    228,    222,    184,    180 ]
           bvalue = [ bvalue,   215,   213,    205,    196,    181,    179,    135,    140 ]
           colors = [ colors, 'BLK1', 'BLK2', 'BLK3', 'BLK4', 'BLK5', 'BLK6', 'BLK7', 'BLK8']
           rvalue = [ rvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           gvalue = [ gvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           bvalue = [ bvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           colors = [ colors, 'GRN1', 'GRN2', 'GRN3', 'GRN4', 'GRN5', 'GRN6', 'GRN7', 'GRN8']
           rvalue = [ rvalue,   250,   223,    173,    109,     53,     35,      0,       0 ]
           gvalue = [ gvalue,   253,   242,    221,    193,    156,     132,    97,      69 ]
           bvalue = [ bvalue,   202,   167,    142,    115,     83,      67,    52,      41 ]
           colors = [ colors, 'BLU1', 'BLU2', 'BLU3', 'BLU4', 'BLU5', 'BLU6', 'BLU7', 'BLU8']
           rvalue = [ rvalue,   232,   202,    158,     99,     53,     33,      8,       8 ]
           gvalue = [ gvalue,   241,   222,    202,    168,    133,    113,     75,      48 ]
           bvalue = [ bvalue,   250,   240,    225,    211,    191,    181,    147,     107 ]
           colors = [ colors, 'ORG1', 'ORG2', 'ORG3', 'ORG4', 'ORG5', 'ORG6', 'ORG7', 'ORG8']
           rvalue = [ rvalue,   254,    253,    253,    250,    231,    217,    159,    127 ]
           gvalue = [ gvalue,   236,    212,    174,    134,     92,     72,     51,     39 ]
           bvalue = [ bvalue,   217,    171,    107,     52,     12,      1,      3,      4 ]
           colors = [ colors, 'RED1', 'RED2', 'RED3', 'RED4', 'RED5', 'RED6', 'RED7', 'RED8']
           rvalue = [ rvalue,   254,    252,    252,    248,    225,    203,    154,    103 ]
           gvalue = [ gvalue,   232,    194,    146,     97,     45,     24,     12,      0 ]
           bvalue = [ bvalue,   222,    171,    114,     68,     38,     29,     19,     13 ]
           colors = [ colors, 'PUR1', 'PUR2', 'PUR3', 'PUR4', 'PUR5', 'PUR6', 'PUR7', 'PUR8']
           rvalue = [ rvalue,   244,    222,    188,    152,    119,    106,     80,     63 ]
           gvalue = [ gvalue,   242,    221,    189,    148,    108,     82,     32,      0 ]
           bvalue = [ bvalue,   248,    237,    220,    197,    177,    163,    139,    125 ]
           colors = [ colors, 'PBG1', 'PBG2', 'PBG3', 'PBG4', 'PBG5', 'PBG6', 'PBG7', 'PBG8']
           rvalue = [ rvalue,   243,    213,    166,     94,     34,      3,      1,      1 ]
           gvalue = [ gvalue,   234,    212,    189,    164,    138,    129,    101,     70 ]
           bvalue = [ bvalue,   244,    232,    219,    204,    171,    139,     82,     54 ]
           colors = [ colors, 'YGB1', 'YGB2', 'YGB3', 'YGB4', 'YGB5', 'YGB6', 'YGB7', 'YGB8']
           rvalue = [ rvalue,   244,    206,    127,     58,     30,     33,     32,      8 ]
           gvalue = [ gvalue,   250,    236,    205,    175,    125,     95,     48,     29 ]
           bvalue = [ bvalue,   193,    179,    186,    195,    182,    168,    137,     88 ]
           colors = [ colors, 'RYB1', 'RYB2', 'RYB3', 'RYB4', 'RYB5', 'RYB6', 'RYB7', 'RYB8']
           rvalue = [ rvalue,   201,    245,    253,    251,    228,    193,    114,     59 ]
           gvalue = [ gvalue,    35,    121,    206,    253,    244,    228,    171,     85 ]
           bvalue = [ bvalue,    38,    72,     127,    197,    239,    239,    207,    164 ]
           colors = [ colors, 'TG1', 'TG2', 'TG3', 'TG4', 'TG5', 'TG6', 'TG7', 'TG8']
           rvalue = [ rvalue,  84,    163,   197,   220,   105,    51,    13,     0 ]
           gvalue = [ gvalue,  48,    103,   141,   188,   188,   149,   113,    81 ]
           bvalue = [ bvalue,   5,     26,    60,   118,   177,   141,   105,    71 ]
           colors = [ colors, 'OPPOSITE', 'BACKGROUND']
           rvalue = [ rvalue,  opixel[0],  bgcolor[0]]
           gvalue = [ gvalue,  opixel[1],  bgcolor[1]]
           bvalue = [ bvalue,  opixel[2],  bgcolor[2]]
       
       ENDIF ELSE BEGIN
       
           <span class="comments">; Set up the color vectors. Both original and Brewer colors.</span>
           colors= ['White']
           rvalue = [ 255]
           gvalue = [ 255]
           bvalue = [ 255]
           colors = [ colors,   'Snow',     'Ivory','Light Yellow', 'Cornsilk',     'Beige',  'Seashell' ]
           rvalue = [ rvalue,     255,         255,       255,          255,          245,        255 ]
           gvalue = [ gvalue,     250,         255,       255,          248,          245,        245 ]
           bvalue = [ bvalue,     250,         240,       224,          220,          220,        238 ]
           colors = [ colors,   'Linen','Antique White','Papaya',     'Almond',     'Bisque',  'Moccasin' ]
           rvalue = [ rvalue,     250,        250,        255,          255,          255,          255 ]
           gvalue = [ gvalue,     240,        235,        239,          235,          228,          228 ]
           bvalue = [ bvalue,     230,        215,        213,          205,          196,          181 ]
           colors = [ colors,   'Wheat',  'Burlywood',    'Tan', 'Light Gray',   'Lavender','Medium Gray' ]
           rvalue = [ rvalue,     245,        222,          210,      230,          230,         210 ]
           gvalue = [ gvalue,     222,        184,          180,      230,          230,         210 ]
           bvalue = [ bvalue,     179,        135,          140,      230,          250,         210 ]
           colors = [ colors,  'Gray', 'Slate Gray',  'Dark Gray',  'Charcoal',   'Black',  'Honeydew', 'Light Cyan' ]
           rvalue = [ rvalue,      190,      112,          110,          70,         0,         240,          224 ]
           gvalue = [ gvalue,      190,      128,          110,          70,         0,         255,          255 ]
           bvalue = [ bvalue,      190,      144,          110,          70,         0,         255,          240 ]
           colors = [ colors,'Powder Blue',  'Sky Blue', 'Cornflower Blue', 'Cadet Blue', 'Steel Blue','Dodger Blue', 'Royal Blue',  'Blue' ]
           rvalue = [ rvalue,     176,          135,          100,              95,            70,           30,           65,            0 ]
           gvalue = [ gvalue,     224,          206,          149,             158,           130,          144,          105,            0 ]
           bvalue = [ bvalue,     230,          235,          237,             160,           180,          255,          225,          255 ]
           colors = [ colors,  'Navy', 'Pale Green','Aquamarine','Spring Green',  'Cyan' ]
           rvalue = [ rvalue,        0,     152,          127,          0,            0 ]
           gvalue = [ gvalue,        0,     251,          255,        250,          255 ]
           bvalue = [ bvalue,      128,     152,          212,        154,          255 ]
           colors = [ colors, 'Turquoise', 'Light Sea Green', 'Sea Green','Forest Green',  'Teal','Green Yellow','Chartreuse', 'Lawn Green' ]
           rvalue = [ rvalue,      64,          143,               46,          34,             0,      173,           127,         124 ]
           gvalue = [ gvalue,     224,          188,              139,         139,           128,      255,           255,         252 ]
           bvalue = [ bvalue,     208,          143,               87,          34,           128,       47,             0,           0 ]
           colors = [ colors, 'Green', 'Lime Green', 'Olive Drab',  'Olive','Dark Green','Pale Goldenrod']
           rvalue = [ rvalue,      0,        50,          107,        85,            0,          238 ]
           gvalue = [ gvalue,    255,       205,          142,       107,          100,          232 ]
           bvalue = [ bvalue,      0,        50,           35,        47,            0,          170 ]
           colors = [ colors,     'Khaki', 'Dark Khaki', 'Yellow',  'Gold', 'Goldenrod','Dark Goldenrod']
           rvalue = [ rvalue,        240,       189,        255,      255,      218,          184 ]
           gvalue = [ gvalue,        230,       183,        255,      215,      165,          134 ]
           bvalue = [ bvalue,        140,       107,          0,        0,       32,           11 ]
           colors = [ colors,'Saddle Brown',  'Rose',   'Pink', 'Rosy Brown','Sandy Brown', 'Peru']
           rvalue = [ rvalue,     139,          255,      255,        188,        244,        205 ]
           gvalue = [ gvalue,      69,          228,      192,        143,        164,        133 ]
           bvalue = [ bvalue,      19,          225,      203,        143,         96,         63 ]
           colors = [ colors,'Indian Red',  'Chocolate',  'Sienna','Dark Salmon',   'Salmon','Light Salmon' ]
           rvalue = [ rvalue,    205,          210,          160,        233,          250,       255 ]
           gvalue = [ gvalue,     92,          105,           82,        150,          128,       160 ]
           bvalue = [ bvalue,     92,           30,           45,        122,          114,       122 ]
           colors = [ colors,  'Orange',      'Coral', 'Light Coral',  'Firebrick', 'Dark Red', 'Brown',  'Hot Pink' ]
           rvalue = [ rvalue,       255,         255,        240,          178,        139,       165,        255 ]
           gvalue = [ gvalue,       165,         127,        128,           34,          0,        42,        105 ]
           bvalue = [ bvalue,         0,          80,        128,           34,          0,        42,        180 ]
           colors = [ colors, 'Deep Pink',    'Magenta',   'Tomato', 'Orange Red',   'Red', 'Crimson', 'Violet Red' ]
           rvalue = [ rvalue,      255,          255,        255,        255,          255,      220,        208 ]
           gvalue = [ gvalue,       20,            0,         99,         69,            0,       20,         32 ]
           bvalue = [ bvalue,      147,          255,         71,          0,            0,       60,        144 ]
           colors = [ colors,    'Maroon',    'Thistle',       'Plum',     'Violet',    'Orchid','Medium Orchid']
           rvalue = [ rvalue,       176,          216,          221,          238,         218,        186 ]
           gvalue = [ gvalue,        48,          191,          160,          130,         112,         85 ]
           bvalue = [ bvalue,        96,          216,          221,          238,         214,        211 ]
           colors = [ colors,'Dark Orchid','Blue Violet',  'Purple']
           rvalue = [ rvalue,      153,          138,       160]
           gvalue = [ gvalue,       50,           43,        32]
           bvalue = [ bvalue,      204,          226,       240]
           colors = [ colors, 'Slate Blue',  'Dark Slate Blue']
           rvalue = [ rvalue,      106,            72]
           gvalue = [ gvalue,       90,            61]
           bvalue = [ bvalue,      205,           139]
           colors = [ colors, 'WT1', 'WT2', 'WT3', 'WT4', 'WT5', 'WT6', 'WT7', 'WT8']
           rvalue = [ rvalue,  255,   255,   255,   255,   255,   245,   255,   250 ]
           gvalue = [ gvalue,  255,   250,   255,   255,   248,   245,   245,   240 ]
           bvalue = [ bvalue,  255,   250,   240,   224,   220,   220,   238,   230 ]
           colors = [ colors, 'TAN1', 'TAN2', 'TAN3', 'TAN4', 'TAN5', 'TAN6', 'TAN7', 'TAN8']
           rvalue = [ rvalue,   250,   255,    255,    255,    255,    245,    222,    210 ]
           gvalue = [ gvalue,   235,   239,    235,    228,    228,    222,    184,    180 ]
           bvalue = [ bvalue,   215,   213,    205,    196,    181,    179,    135,    140 ]
           colors = [ colors, 'BLK1', 'BLK2', 'BLK3', 'BLK4', 'BLK5', 'BLK6', 'BLK7', 'BLK8']
           rvalue = [ rvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           gvalue = [ gvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           bvalue = [ bvalue,   250,   230,    210,    190,    128,     110,    70,       0 ]
           colors = [ colors, 'GRN1', 'GRN2', 'GRN3', 'GRN4', 'GRN5', 'GRN6', 'GRN7', 'GRN8']
           rvalue = [ rvalue,   250,   223,    173,    109,     53,     35,      0,       0 ]
           gvalue = [ gvalue,   253,   242,    221,    193,    156,     132,    97,      69 ]
           bvalue = [ bvalue,   202,   167,    142,    115,     83,      67,    52,      41 ]
           colors = [ colors, 'BLU1', 'BLU2', 'BLU3', 'BLU4', 'BLU5', 'BLU6', 'BLU7', 'BLU8']
           rvalue = [ rvalue,   232,   202,    158,     99,     53,     33,      8,       8 ]
           gvalue = [ gvalue,   241,   222,    202,    168,    133,    113,     75,      48 ]
           bvalue = [ bvalue,   250,   240,    225,    211,    191,    181,    147,     107 ]
           colors = [ colors, 'ORG1', 'ORG2', 'ORG3', 'ORG4', 'ORG5', 'ORG6', 'ORG7', 'ORG8']
           rvalue = [ rvalue,   254,    253,    253,    250,    231,    217,    159,    127 ]
           gvalue = [ gvalue,   236,    212,    174,    134,     92,     72,     51,     39 ]
           bvalue = [ bvalue,   217,    171,    107,     52,     12,      1,      3,      4 ]
           colors = [ colors, 'RED1', 'RED2', 'RED3', 'RED4', 'RED5', 'RED6', 'RED7', 'RED8']
           rvalue = [ rvalue,   254,    252,    252,    248,    225,    203,    154,    103 ]
           gvalue = [ gvalue,   232,    194,    146,     97,     45,     24,     12,      0 ]
           bvalue = [ bvalue,   222,    171,    114,     68,     38,     29,     19,     13 ]
           colors = [ colors, 'PUR1', 'PUR2', 'PUR3', 'PUR4', 'PUR5', 'PUR6', 'PUR7', 'PUR8']
           rvalue = [ rvalue,   244,    222,    188,    152,    119,    106,     80,     63 ]
           gvalue = [ gvalue,   242,    221,    189,    148,    108,     82,     32,      0 ]
           bvalue = [ bvalue,   248,    237,    220,    197,    177,    163,    139,    125 ]
           colors = [ colors, 'PBG1', 'PBG2', 'PBG3', 'PBG4', 'PBG5', 'PBG6', 'PBG7', 'PBG8']
           rvalue = [ rvalue,   243,    213,    166,     94,     34,      3,      1,      1 ]
           gvalue = [ gvalue,   234,    212,    189,    164,    138,    129,    101,     70 ]
           bvalue = [ bvalue,   244,    232,    219,    204,    171,    139,     82,     54 ]
           colors = [ colors, 'YGB1', 'YGB2', 'YGB3', 'YGB4', 'YGB5', 'YGB6', 'YGB7', 'YGB8']
           rvalue = [ rvalue,   244,    206,    127,     58,     30,     33,     32,      8 ]
           gvalue = [ gvalue,   250,    236,    205,    175,    125,     95,     48,     29 ]
           bvalue = [ bvalue,   193,    179,    186,    195,    182,    168,    137,     88 ]
           colors = [ colors, 'RYB1', 'RYB2', 'RYB3', 'RYB4', 'RYB5', 'RYB6', 'RYB7', 'RYB8']
           rvalue = [ rvalue,   201,    245,    253,    251,    228,    193,    114,     59 ]
           gvalue = [ gvalue,    35,    121,    206,    253,    244,    228,    171,     85 ]
           bvalue = [ bvalue,    38,    72,     127,    197,    239,    239,    207,    164 ]
           colors = [ colors, 'TG1', 'TG2', 'TG3', 'TG4', 'TG5', 'TG6', 'TG7', 'TG8']
           rvalue = [ rvalue,  84,    163,   197,   220,   105,    51,    13,     0 ]
           gvalue = [ gvalue,  48,    103,   141,   188,   188,   149,   113,    81 ]
           bvalue = [ bvalue,   5,     26,    60,   118,   177,   141,   105,    71 ]
           colors = [ colors, 'OPPOSITE', 'BACKGROUND']
           rvalue = [ rvalue,  opixel[0],  bgcolor[0]]
           gvalue = [ gvalue,  opixel[1],  bgcolor[1]]
           bvalue = [ bvalue,  opixel[2],  bgcolor[2]]
         ENDELSE
   ENDELSE
   
    <span class="comments">; If you have a USERDEF color (from a color triple) then load it here.</span>
    IF N_Elements(usercolor) NE 0 THEN BEGIN
       colors = [colors, 'USERDEF']
       rvalue = [rvalue, usercolor[0]]
       gvalue = [gvalue, usercolor[1]]
       bvalue = [bvalue, usercolor[2]]
    ENDIF
       
    <span class="comments">; Load the colors from the current color table, if you need them.</span>
    IF useCurrentColors THEN BEGIN
        IF (!D.Name NE 'NULL') THEN TVLCT, rrr, ggg, bbb, /GET
        IF decomposedState EQ 0 THEN BEGIN
            colors = SIndgen(256)
            rvalue = rrr
            gvalue = ggg
            bvalue = bbb           
        ENDIF ELSE BEGIN
            colors = [colors, SIndgen(256)]
            rvalue = [rvalue, rrr]
            gvalue = [gvalue, ggg]
            bvalue = [bvalue, bbb]
        ENDELSE
    ENDIF
    
    <span class="comments">; Make sure we are looking at compressed, uppercase names.</span>
    colors = StrUpCase(StrCompress(StrTrim(colors,2), /Remove_All))

    <span class="comments">; Check synonyms of color names.</span>
    FOR j=0, N_Elements(theColor)-1 DO BEGIN
       IF StrUpCase(theColor[j]) EQ 'GREY' THEN theColor[j] = 'GRAY'
       IF StrUpCase(theColor[j]) EQ 'LIGHTGREY' THEN theColor[j] = 'LIGHTGRAY'
       IF StrUpCase(theColor[j]) EQ 'MEDIUMGREY' THEN theColor[j] = 'MEDIUMGRAY'
       IF StrUpCase(theColor[j]) EQ 'SLATEGREY' THEN theColor[j] = 'SLATEGRAY'
       IF StrUpCase(theColor[j]) EQ 'DARKGREY' THEN theColor[j] = 'DARKGRAY'
       IF StrUpCase(theColor[j]) EQ 'AQUA' THEN theColor[j] = 'AQUAMARINE'
       IF StrUpCase(theColor[j]) EQ 'SKY' THEN theColor[j] = 'SKYBLUE'
       IF StrUpCase(theColor[j]) EQ 'NAVYBLUE' THEN theColor[j] = 'NAVY'
       IF StrUpCase(theColor[j]) EQ 'CORNFLOWER' THEN theColor[j] = 'CORNFLOWERBLUE'
       IF StrUpCase(theColor[j]) EQ 'BROWN' THEN theColor[j] = 'SIENNA'
    ENDFOR
    
    <span class="comments">; How many colors do we have?</span>
    ncolors = N_Elements(colors)
    
    <span class="comments">; Check for offset.</span>
    IF (theDepth EQ 8) OR (decomposedState EQ 0) THEN offset = !D.Table_Size - ncolors - 2 ELSE offset = 0
    IF (useCurrentColors) AND (decomposedState EQ 0) THEN offset = 0
        
    <span class="comments">; Did the user want to select a color name? If so, we set</span>
    <span class="comments">; the color name and color index, unless the user provided</span>
    <span class="comments">; them. In the case of a single positional parameter, we treat</span>
    <span class="comments">; this as the color index number as long as it is not a string.</span>
    cancelled = 0.0
    IF Keyword_Set(selectcolor) THEN BEGIN
    
       CASE N_Params() OF
          0: BEGIN
             theColor = cgPickColorName(Filename=filename, _Strict_Extra=extra, Cancel=cancelled, BREWER=brewer)
             IF cancelled THEN RETURN, !P.Color
             IF theDepth GT 8 AND (decomposedState EQ 1) THEN BEGIN
                   colorIndex = Fix(!P.Color &lt<span class="comments">; (!D.Table_Size - 1))</span>
             ENDIF ELSE BEGIN
                   colorIndex = Where(StrUpCase(colors) EQ StrUpCase(StrCompress(theColor, /Remove_All)), count) + offset
                   colorIndex = Fix(colorIndex[0])
                   IF count EQ 0 THEN Message, 'Cannot find color: ' + StrUpCase(theColor), /NoName
             ENDELSE
    
             END
          1: BEGIN
             IF Size(theColor, /TName) NE 'STRING' THEN BEGIN
                colorIndex = Fix(theColor)
                theColor = brewer ? 'WT1' : 'White'
             ENDIF ELSE colorIndex = Fix(!P.Color &lt<span class="comments">; 255)</span>
             theColor = cgPickColorName(theColor, Filename=filename, _Strict_Extra=extra, Cancel=cancelled, BREWER=brewer)
             IF cancelled THEN RETURN, !P.Color
             END
          2: BEGIN
             theColor = cgPickColorName(theColor, Filename=filename, _Strict_Extra=extra, Cancel=cancelled, BREWER=brewer)
             IF cancelled THEN RETURN, !P.Color
             END
       ENDCASE
    ENDIF
    
    <span class="comments">; Make sure you have a color name and color index.</span>
    CASE N_Elements(theColor) OF
       0: BEGIN
             theColor = brewer ? 'WT1' : 'White'
             IF N_Elements(colorIndex) EQ 0 THEN BEGIN
                IF theDepth GT 8 THEN BEGIN
                   colorIndex = Fix(!P.Color &lt<span class="comments">; (!D.Table_Size - 1))</span>
                ENDIF ELSE BEGIN
                   colorIndex = Where(colors EQ theColor, count) + offset
                   colorIndex = Fix(colorIndex[0])
                   IF count EQ 0 THEN Message, 'Cannot find color: ' + theColor, /NoName
                ENDELSE
             ENDIF ELSE colorIndex = 0S > colorIndex &lt<span class="comments">; Fix((!D.Table_Size - 1))</span>
          ENDCASE
    
       1: BEGIN
             type = Size(theColor, /TNAME)
             IF type NE 'STRING' THEN Message, 'The color must be expressed as a color name.'
             theColor = theColor[0] <span class="comments">; Make it a scalar or you run into a WHERE function "feature". :-(</span>
             IF N_Elements(colorIndex) EQ 0 THEN BEGIN
                IF (theDepth GT 8) AND (decomposedState EQ 1) THEN BEGIN
                   colorIndex = Fix(!P.Color &lt<span class="comments">; (!D.Table_Size - 1))</span>
                ENDIF ELSE BEGIN
                   colorIndex = Where(colors EQ theColor, count) + offset
                   colorIndex = Fix(colorIndex[0])
                   IF count EQ 0 THEN Message, 'Cannot find color: ' + theColor, /NoName
                ENDELSE
             ENDIF ELSE colorIndex = 0S > colorIndex &lt<span class="comments">; Fix(!D.Table_Size - 1)</span>
             ENDCASE
    
       ELSE: BEGIN
             type = Size(theColor, /TNAME)
             IF type NE 'STRING' THEN Message, 'The colors must be expressed as color names.'
             ncolors = N_Elements(theColor)
             CASE N_Elements(colorIndex) OF
                0: colorIndex = Fix(Indgen(ncolors) + (!D.Table_Size - (ncolors + 1)))
                1: colorIndex = Fix(Indgen(ncolors) + colorIndex)
                ELSE: IF N_Elements(colorIndex) NE ncolors THEN $
                   Message, 'Index vector must be the same length as color name vector.'
             ENDCASE
    
                <span class="comments">; Did the user want color triples?</span>
    
             IF Keyword_Set(triple) THEN BEGIN
                colors = BytArr(ncolors, 3)
                FOR j=0,ncolors-1 DO colors[j,*] = cgColor(theColor[j], colorIndex[j], Filename=filename, $
                   Decomposed=decomposedState, /Triple, BREWER=brewer)
                RETURN, Byte(colors)
             ENDIF ELSE BEGIN
                colors = LonArr(ncolors)
                FOR j=0,ncolors-1 DO colors[j] = cgColor(theColor[j], colorIndex[j], Filename=filename, $
                   Decomposed=decomposedState, BREWER=brewer)
                IF decomposedState THEN RETURN, colors ELSE RETURN, Byte(colors)
            ENDELSE
          END
    ENDCASE
    
    <span class="comments">; Did the user ask for the color names? If so, return them now.</span>
    IF Keyword_Set(names) THEN RETURN, Reform(colors, 1, ncolors)
    
    <span class="comments">; Process the color names.</span>
    theNames = StrUpCase( StrCompress(colors, /Remove_All ) )
    
    <span class="comments">; Find the asked-for color in the color names array.</span>
    theIndex = Where(theNames EQ StrUpCase(StrCompress(theColor, /Remove_All)), foundIt)
    theIndex = theIndex[0]
    
    <span class="comments">; If the color can't be found, report it and continue with the color set to "OPPOSITE."</span>
    IF foundIt EQ 0 THEN BEGIN
       Message, "Can't find color " + theColor + ". Substituting 'OPPOSITE'.", /Informational
       theColor = 'OPPOSITE'
       theIndex = Where(StrUpCase(colors) EQ 'OPPOSITE')
    ENDIF
    
    <span class="comments">; Get the color triple for this color.</span>
    r = rvalue[theIndex]
    g = gvalue[theIndex]
    b = bvalue[theIndex]
    
    <span class="comments">; Did the user want a color triple? If so, return it now.</span>
    IF Keyword_Set(triple) THEN BEGIN
       IF Keyword_Set(allcolors) THEN BEGIN
          IF Keyword_Set(row) $
             THEN RETURN, Byte(Transpose([[rvalue], [gvalue], [bvalue]])) $
             ELSE RETURN, Byte([[rvalue], [gvalue], [bvalue]])
       ENDIF ELSE BEGIN
          IF Keyword_Set(row) THEN RETURN, Byte([r, g, b]) ELSE RETURN, Byte([[r], [g], [b]])
       ENDELSE
    ENDIF
    
    <span class="comments">; Otherwise, we are going to return either an index</span>
    <span class="comments">; number where the color has been loaded, or a 24-bit</span>
    <span class="comments">; value that can be decomposed into the proper color.</span>
    IF decomposedState THEN BEGIN
    
       <span class="comments">; Need a color structure?</span>
       IF Arg_Present(colorStructure) THEN BEGIN
          theColors = cgColor_Color24([[rvalue], [gvalue], [bvalue]])
          colorStructure = Create_Struct(theNames[0], theColors[0])
          FOR j=1, ncolors-1 DO colorStructure = Create_Struct(colorStructure, theNames[j], theColors[j])
       ENDIF
    
       IF Keyword_Set(allcolors) THEN BEGIN
          RETURN, cgColor_Color24([[rvalue], [gvalue], [bvalue]])
       ENDIF ELSE BEGIN
          RETURN, cgColor_Color24([r, g, b])
       ENDELSE
    
    ENDIF ELSE BEGIN
    
       IF Keyword_Set(allcolors) THEN BEGIN
    
          <span class="comments">; Need a color structure?</span>
          IF Arg_Present(colorStructure) THEN BEGIN
             allcolorIndex = !D.Table_Size - ncolors - 2
             IF allcolorIndex LT 0 THEN $
                Message, 'Number of colors exceeds available color table values. Returning.', /NoName
             IF (allcolorIndex + ncolors) GT 255 THEN $
                Message, 'Number of colors exceeds available color table indices. Returning.', /NoName
             theColors = IndGen(ncolors) + allcolorIndex
             colorStructure = Create_Struct(theNames[0],  theColors[0])
             FOR j=1, ncolors-1 DO colorStructure = Create_Struct(colorStructure, theNames[j], theColors[j])
          ENDIF
    
          IF N_Elements(colorIndex) EQ 0 THEN colorIndex = Fix(!D.Table_Size - ncolors - 2)
          IF colorIndex LT 0 THEN $
             Message, 'Number of colors exceeds available color table values. Returning.', /NoName
          IF (colorIndex + ncolors) GT 255 THEN BEGIN
             colorIndex = Fix(!D.Table_Size - ncolors - 2)
          ENDIF
          IF (!D.Name NE 'PRINTER') AND (!D.Name NE 'NULL') THEN TVLCT, rvalue, gvalue, bvalue, colorIndex
          RETURN, BIndGen(ncolors) + colorIndex
       ENDIF ELSE BEGIN
    
          <span class="comments">; Need a color structure?</span>
          IF Arg_Present(colorStructure) THEN BEGIN
             colorStructure = Create_Struct(theColor,  colorIndex)
          ENDIF
    
          IF (!D.Name NE 'PRINTER') AND (!D.Name NE 'NULL') THEN $
              TVLCT, rvalue[theIndex], gvalue[theIndex], bvalue[theIndex], colorIndex
          RETURN, Byte(colorIndex)
       ENDELSE
    
    
    ENDELSE

END <span class="comments">;-------------------------------------------------------------------------------------------------------</span>
</code>
    </div>
  </body>
</html>