<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:55 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>permute.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="permute.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	PERMUTE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	This function returns an array containing the numbers</span>
<span class="comments">;	[0, ..., N-1] in random order.  They are useful as indices</span>
<span class="comments">;	when permuting a dataset, for example in a balanced bootstrap</span>
<span class="comments">;	Monte Carlo algorithm.      </span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	Statistics.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;	Result = PERMUTE(N)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	N:	The number of items to be permuted.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;	SEED:	A random number seed, see RANDOMU.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	This function returns an N-element array containing a random</span>
<span class="comments">;	permutation of the integers from 0 through N-1.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;	Unless Seed is specified, IDL's global random number</span>
<span class="comments">;	seed is changed. </span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	This is an in-place swapping algorithm.  It starts with an</span>
<span class="comments">;	index array.  For each position in the array, it swaps the</span>
<span class="comments">;	occupant of that position with the occupant of a random</span>
<span class="comments">;	position from there (inclusive) to the end of the array.  The</span>
<span class="comments">;	last iteration is not necessary to compute, since it swaps</span>
<span class="comments">;	with itself.</span>
<span class="comments">;</span>
<span class="comments">;	See http://www.techuser.net/randpermgen.html for a proof.  The</span>
<span class="comments">;	2-line code there has been optimized for IDL's vector</span>
<span class="comments">;	architecture.  This is a linear-time algorithm.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">; Show some permutations of 6 numbers:</span>
<span class="comments">;	print, permute(6)</span>
<span class="comments">;	    0           2           1           3           4           5</span>
<span class="comments">;	print, permute(6)</span>
<span class="comments">;           2           4           3           5           1           0</span>
<span class="comments">;	print, permute(6)</span>
<span class="comments">;	    0           4           3           1           2           5</span>
<span class="comments">;</span>
<span class="comments">; Permute the array [2, 4, 6, 8]</span>
<span class="comments">;	a = [2, 4, 6, 8]</span>
<span class="comments">;	print, a[permute(4)]</span>
<span class="comments">;       4       8       6       2</span>
<span class="comments">;</span>
<span class="comments">; Test randomness (results should be close to k):</span>
<span class="comments">; m = 6l</span>
<span class="comments">; k = 10000l</span>
<span class="comments">; n = m * k</span>
<span class="comments">; a = lonarr(m, n)</span>
<span class="comments">; for i = 0l, n-1, 1 do a[*, i] = permute(m)</span>
<span class="comments">; for i = 0l, m-1, 1 do print, histogram(a[i, *])</span>
<span class="comments">;         9885       10062       10051        9915       10028       10059</span>
<span class="comments">;        10096       10087       10094        9913        9933        9877</span>
<span class="comments">;        10041       10013        9968        9958        9911       10109</span>
<span class="comments">;         9880        9858       10166       10049       10081        9966</span>
<span class="comments">;        10093        9915        9800       10166        9969       10057</span>
<span class="comments">;        10005       10065        9921        9999       10078        9932</span>
<span class="comments">;</span>
<span class="comments">; Time the algorithm:</span>
<span class="comments">; maxn = 7</span>
<span class="comments">; t = dblarr(maxn)</span>
<span class="comments">; n = 10L^(indgen(maxn)+1)</span>
<span class="comments">; for i = 0, maxn-1, 1 do begin &$</span>
<span class="comments">;   t1 = systime(/s) &$</span>
<span class="comments">;   print, n[i] &$</span>
<span class="comments">;   a = permute(n[i]) &$</span>
<span class="comments">;   t2 = systime(/s) &$</span>
<span class="comments">;   t[i] = t2-t1 &$</span>
<span class="comments">; endfor</span>
<span class="comments">; print, '        Elements         Seconds   Elements Per Second'</span>
<span class="comments">; print, transpose([[n], [t], [t/n]])</span>
<span class="comments">; </span>
<span class="comments">;         Elements         Seconds   Elements Per Second</span>
<span class="comments">;        10.000000   0.00012397766   1.2397766e-05</span>
<span class="comments">;        100.00000   0.00015020370   1.5020370e-06</span>
<span class="comments">;        1000.0000    0.0011651516   1.1651516e-06</span>
<span class="comments">;        10000.000     0.018178225   1.8178225e-06</span>
<span class="comments">;        100000.00      0.13504505   1.3504505e-06</span>
<span class="comments">;        1000000.0       1.3817160   1.3817160e-06</span>
<span class="comments">;        10000000.       14.609985   1.4609985e-06</span>
<span class="comments">;</span>
<span class="comments">; These times are for a 2.071 GHz AMD Athlon 2800+ CPU.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Joseph Harrington, Cornell.  2006-03-22</span>
<span class="comments">;			jh@alum.mit.edu</span>
<span class="comments">;-</span>
<a id="PERMUTE:source"></a>function PERMUTE, N, Seed

<span class="comments">; Don't stop here!</span>
on_error, 2

<span class="comments">; test inputs</span>
if n eq 1 then return, 0L
if n lt 1 then message, 'N = ' + strtrim(n, 2) + ', must be 1 or more.'

ar  = lindgen(n)
rar = reverse(ar[0 : n - 2]) + 2
r   = (n - 1) - long( randomu(seed, n - 1) * rar )

for i = 0L, n - 2, 1 do begin
  t = ar[i]
  ar[i] = ar[r[i]]
  ar[r[i]] = t
endfor

return, ar
end

</code>
    </div>
  </body>
</html>