<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:29 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>filter_image.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="filter_image.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="filter_image:source"></a>function filter_image, image, SMOOTH=width_smooth, ITERATE_SMOOTH=iterate, $
                              MEDIAN=width_median, ALL_PIXELS=all_pixels, $
                              FWHM_GAUSSIAN=fwhm, NO_FT_CONVOL=no_ft, PSF=psf
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FILTER_IMAGE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Identical to MEDIAN or SMOOTH but handle edges and allow iterations.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Computes the average and/or median of pixels in moving box,</span>
<span class="comments">;       replacing center pixel with the computed average and/or median,</span>
<span class="comments">;       (using the IDL SMOOTH() or MEDIAN() functions).</span>
<span class="comments">;       The main reason for using this function is the options to</span>
<span class="comments">;       also process the pixels at edges and corners of image, and,</span>
<span class="comments">;       to apply iterative smoothing simulating convolution with Gaussian,</span>
<span class="comments">;       and/or to convolve image with a Gaussian kernel.    Users might also</span>
<span class="comments">;       look at the function ESTIMATOR_FILTER() introduced in IDL 7.1.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       Result = filter_image( image, SMOOTH=width, MEDIAN = width, /ALL_PIXELS</span>
<span class="comments">;                               /ITERATE, FWHM =,  /NO_FT_CONVOL)</span>
<span class="comments">;</span>
<span class="comments">; INPUT:</span>
<span class="comments">;       image = 2-D array (matrix)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       SMOOTH = scalar (odd) integer specifying the width of a square box </span>
<span class="comments">;               for moving average, in # pixels.  /SMOOTH  means use box </span>
<span class="comments">;               width = 3 pixels for smoothing.</span>
<span class="comments">;</span>
<span class="comments">;        MEDIAN = scalar (usually odd) integer specifying the width of square </span>
<span class="comments">;               moving box for median filter, in # pixels.   /MEDIAN  means use</span>
<span class="comments">;               box width = 3 pixels for median filter.</span>
<span class="comments">;   </span>
<span class="comments">;       /ALL_PIXELS causes the edges of image to be filtered as well.   This</span>
<span class="comments">;               is accomplished by reflecting pixels adjacent to edges outward</span>
<span class="comments">;               (similar to the /EDGE_WRAP keyword in CONVOL).</span>
<span class="comments">;               Note that this is a different algorithm from the /EDGE_TRUNCATE </span>
<span class="comments">;               keyword to SMOOTH or CONVOL, which duplicates the nearest pixel.   </span>
<span class="comments">;</span>
<span class="comments">;       /ITERATE means apply smooth(image,3) iteratively for a count of</span>
<span class="comments">;               (box_width-1)/2 times (=radius), when box_width >= 5.</span>
<span class="comments">;               This is equivalent to convolution with a Gaussian PSF</span>
<span class="comments">;               of FWHM = 2 * sqrt( radius ) as radius gets large.</span>
<span class="comments">;               Note that /ALL_PIXELS is automatically applied,</span>
<span class="comments">;               giving better results in the iteration limit.</span>
<span class="comments">;               (also, MEDIAN keyword is ignored when /ITER is specified).</span>
<span class="comments">;</span>
<span class="comments">;       FWHM_GAUSSIAN = Full-width half-max of Gaussian to convolve with image. </span>
<span class="comments">;                       FWHM can be a single number (circular beam),</span>
<span class="comments">;                       or 2 numbers giving axes of elliptical beam.</span>
<span class="comments">;</span>
<span class="comments">;       /NO_FT_CONVOL causes the convolution to be computed directly,</span>
<span class="comments">;               with intrinsic IDL CONVOL function.   The default is to use </span>
<span class="comments">;               FFT when factors of size are all LE 13.   Note that </span>
<span class="comments">;               external function convolve.pro handles both cases)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT/OUTPUT KEYWORD:</span>
<span class="comments">;     PSF = Array containing the PSF used during the convolution.   This </span>
<span class="comments">;           keyword is only active if the FWHM_GAUSSIAN keyword is also </span>
<span class="comments">;           specified.     If PSF is undefined on input, then upon output it</span>
<span class="comments">;           contains the Gaussian convolution specified by the FWHM_GAUSSIAN</span>
<span class="comments">;           keyword.    If the PSF array is defined on input then it is used </span>
<span class="comments">;           as the convolution kernel,  the value of the  FWHM_GAUSSIAN keyword</span>
<span class="comments">;           is ignored.      Typically, on a first call set PSF to an undefined</span>
<span class="comments">;           variable, which can be reused for subsequent calls to prevent </span>
<span class="comments">;           recalculation of the Gaussian PSF.</span>
<span class="comments">; RESULT:</span>
<span class="comments">;       Function returns the smoothed, median filtered, or convolved image.</span>
<span class="comments">;       If both SMOOTH and MEDIAN are specified, median filter is applied first.</span>
<span class="comments">;       If only SMOOTH is applied, then output is of same type as input.  If</span>
<span class="comments">;       either MEDIAN or FWHM_GAUSSIAN is supplied than the output is at least</span>
<span class="comments">;       floating (double if the input image is double). </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       To apply 3x3 moving median filter and</span>
<span class="comments">;       then 3x3 moving average, both applied to all pixels:</span>
<span class="comments">;</span>
<span class="comments">;               Result = filter_image( image, /SMOOTH, /MEDIAN, /ALL )</span>
<span class="comments">;</span>
<span class="comments">;       To iteratively apply 3x3 moving average filter for 4 = (9-1)/2 times,</span>
<span class="comments">;       thus approximating convolution with Gaussian of FWHM = 2*sqrt(4) = 4 :</span>
<span class="comments">;</span>
<span class="comments">;               Result = filter_image( image, SMOOTH=9, /ITER )</span>
<span class="comments">;</span>
<span class="comments">;       To convolve all pixels with Gaussian of FWHM = 3.7 x 5.2 pixels:</span>
<span class="comments">;</span>
<span class="comments">;               Result = filter_image( image, FWHM=[3.7,5.2], /ALL )</span>
<span class="comments">;</span>
<span class="comments">; EXTERNAL CALLS:</span>
<span class="comments">;       function psf_gaussian</span>
<span class="comments">;       function convolve</span>
<span class="comments">;       pro factor</span>
<span class="comments">;       function prime          ;all these called only if FWHM is specified</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       If both /ALL_PIXELS (or /ITERATE)  keywords are set then</span>
<span class="comments">;       create a larger image by reflecting the edges outward, then call the </span>
<span class="comments">;       IDL MEDIAN() or SMOOTH() function on the larger image, and just return </span>
<span class="comments">;       the central part (the original size image).</span>
<span class="comments">;</span>
<span class="comments">;       NAN values are recognized during calls to MEDIAN() or SMOOTH(), but </span>
<span class="comments">;       not for convolution with a Gaussian (FWHM keyword supplied). </span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Written, 1991, Frank Varosi, NASA/GSFC.</span>
<span class="comments">;       FV, 1992, added /ITERATE option.</span>
<span class="comments">;       FV, 1993, added FWHM_GAUSSIAN= option.</span>
<span class="comments">;       Use /EVEN call to median, recognize NAN values in SMOOTH </span>
<span class="comments">;                  W. Landsman   June 2001</span>
<span class="comments">;       Added PSF keyword,   Bjorn Heijligers/WL, September 2001</span>
<span class="comments">;       Keep same output data type if /ALL_PIXELS supplied A. Steffl Mar 2011</span>
<span class="comments">;-</span>
  compile_opt idl2
  
  if N_params() LT 1 then begin
      print,'Syntax - Result = filter_image( image, SMOOTH=width, /ALL_PIXELS'
      print,'                 MEDIAN= width, ITERATE, FWHM=,  /NO_FT_CONVOL'
      return, -1
  endif

        sim = size( image )
        Lx = sim[1]-1
        Ly = sim[2]-1

        if (sim[0] NE 2) || (sim[4] LE 4) then begin
                message,"input must be an image (a matrix)",/INFO
                return,image
           endif

        if keyword_set( iterate ) then begin
                if N_elements( width_smooth ) NE 1 then return,image
                if (width_smooth LT 1) then return,image
                imf = image
                nit = (width_smooth>3)/2
                for i=1,nit do  imf = filter_image( imf, /SMOOTH, /ALL )
                return,imf
           endif

        box_wid = 0
        if keyword_set( width_smooth ) then box_wid = width_smooth > 3
        if keyword_set( width_median ) then box_wid = (width_median > box_wid)>3

        if keyword_set( fwhm ) then begin
                npix = ( 3 * fwhm[ 0: ( (N_elements( fwhm )-1) &lt<span class="comments">; 1 ) ] ) > 3</span>
                npix = 2 * fix( npix/2 ) + 1    <span class="comments">;make # pixels odd.</span>
                box_wid = box_wid > max( [npix] )
           endif

        if (box_wid LT 3) then return, image

        if keyword_set(all_pixels) then begin
                
                box_wid = fix( box_wid )
                radius = (box_wid/2) > 1
                Lxr = Lx+radius
                Lyr = Ly+radius
                rr = 2*radius
		imf = make_array(sim[1]+rr, sim[2]+rr, type = sim[3])
                imf[radius,radius] = image              <span class="comments">; reflect edges outward</span>
                                                        <span class="comments">; to make larger image.</span>
                imf[  0,0] = rotate( imf[radius:rr,*], 5 )      <span class="comments">;Left</span>
                imf[Lxr,0] = rotate( imf[Lx:Lxr,*], 5 )         <span class="comments">;right</span>
                imf[0,  0] = rotate( imf[*,radius:rr], 7 )      <span class="comments">;bottom</span>
                imf[0,Lyr] = rotate( imf[*,Ly:Lyr], 7 )         <span class="comments">;top</span>

          endif else begin
                radius=0
                imf = image
           endelse

        if keyword_set( width_median ) then $
                       imf = median(/even, imf, width_median>3 ) 
                            
        if keyword_set( width_smooth ) then $
              imf = smooth( imf, width_smooth>3, /NAN )

        if keyword_set( fwhm ) then begin

                if N_elements( no_ft ) NE 1 then begin
                        sim = size( imf )
                        factor,sim[1],pfx,nfx,/quiet
                        factor,sim[2],pfy,nfy,/quiet
                        no_ft = max( [pfx,pfy] ) GT 13
                   endif

                if N_elements(PSF) EQ 0 then $
                          psf=psf_gaussian( NP=npix,FWHM=fwhm,/NORM )
			  
                imf = convolve( imf,  NO_FT=no_ft, psf) 
          endif

    if radius GT 0 then $
                return, imf[ radius:(Lx+radius), radius:(Ly+radius) ] $
           else return, imf
end
</code>
    </div>
  </body>
</html>