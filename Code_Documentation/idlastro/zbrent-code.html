<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:14 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>zbrent.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="zbrent.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="ZBRENT:source"></a>function ZBRENT, x1, x2, FUNC_NAME=func_name, _EXTRA = _extra,   $
                         MAX_ITERATIONS=maxit, TOLERANCE=TOL
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     ZBRENT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Find the zero of a 1-D function up to specified tolerance.</span>
<span class="comments">; EXPLANTION:</span>
<span class="comments">;     This routine assumes that the function is known to have a zero.</span>
<span class="comments">;     Adapted from procedure of the same name in "Numerical Recipes" by</span>
<span class="comments">;     Press et al. (1992), Section 9.3</span>
<span class="comments">;</span>
<span class="comments">; CALLING:</span>
<span class="comments">;       x_zero = ZBRENT( x1, x2, FUNC_NAME="name", MaX_Iter=, Tolerance=, </span>
<span class="comments">;                                 _EXTRA =  )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       x1, x2 = scalars, 2 points which bracket location of function zero,</span>
<span class="comments">;                                               that is, F(x1) &lt; 0 &lt; F(x2).</span>
<span class="comments">;       Note: computations are performed with</span>
<span class="comments">;       same precision (single/double) as the inputs and user supplied function.</span>
<span class="comments">;</span>
<span class="comments">; REQUIRED INPUT KEYWORD:</span>
<span class="comments">;       FUNC_NAME = function name (string)</span>
<span class="comments">;               Calling mechanism should be:  F = func_name( px )</span>
<span class="comments">;               where:  px = scalar independent variable, input.</span>
<span class="comments">;                       F = scalar value of function at px,</span>
<span class="comments">;                           should be same precision (single/double) as input.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       MAX_ITER = maximum allowed number iterations, default=100.</span>
<span class="comments">;       TOLERANCE = desired accuracy of minimum location, default = 1.e-3.</span>
<span class="comments">;</span>
<span class="comments">;       Any other keywords are passed directly to the user-supplied function</span>
<span class="comments">;       via the _EXTRA facility.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Returns the location of zero, with accuracy of specified tolerance.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Brent's method to find zero of a function by using bracketing,</span>
<span class="comments">;       bisection, and inverse quadratic interpolation,</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Find the root of the COSINE function between 1. and 2.  radians</span>
<span class="comments">;</span>
<span class="comments">;        IDL> print, zbrent( 1, 2, FUNC = 'COS')</span>
<span class="comments">;</span>
<span class="comments">;       and the result will be !PI/2 within the specified tolerance</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1992.</span>
<span class="comments">;       FV.1994, mod to check for single/double prec. and set zeps accordingly.</span>
<span class="comments">;       Use MACHAR() to define machine precision   W. Landsman September 2002</span>
<span class="comments">;       Added _EXTRA keyword  W. Landsman  December 2011</span>
<span class="comments">;       Need to check whether user function accepts keywords W.L. Jan 2012</span>
<span class="comments">;-</span>
        compile_opt idl2
        if N_params() LT 2 then begin
             print,'Syntax - result = ZBRENT( x1, x2, FUNC_NAME = ,'
             print,'                  [ MAX_ITER = , TOLERANCE = , _EXTRA=])'
             return, -1
        endif

        kpresent = keyword_set(_EXTRA)
        if N_elements( TOL ) NE 1 then TOL = 1.e-3
        if N_elements( maxit ) NE 1 then maxit = 100

        if size(x1,/TNAME) EQ 'DOUBLE' OR size(x2,/TNAME) EQ 'DOUBLE' then begin
                xa = double( x1 )
                xb = double( x2 )
                zeps = (machar(/DOUBLE)).eps   <span class="comments">;machine epsilon in double.</span>
          endif else begin
                xa = x1
                xb = x2
                zeps = (machar(/DOUBLE)).eps   <span class="comments">;machine epsilon, in single </span>
           endelse
        
	if kpresent then begin 
          fa = call_function( func_name, xa, _EXTRA = _extra )
          fb = call_function( func_name, xb, _EXTRA = _extra )
        endif else begin 
          fa = call_function( func_name, xa )
          fb = call_function( func_name, xb )
	endelse
        fc = fb

        if (fb*fa GT 0) then begin
                message,"root must be bracketed by the 2 inputs",/INFO
                return,xa
           endif

        for iter = 1,maxit do begin

                if (fb*fc GT 0) then begin
                        xc = xa
                        fc = fa
                        Din = xb - xa
                        Dold = Din
                   endif

                if (abs( fc ) LT abs( fb )) then begin
                        xa = xb   &   xb = xc   &   xc = xa
                        fa = fb   &   fb = fc   &   fc = fa
                   endif

                TOL1 = 0.5*TOL + 2*abs( xb ) * zeps     <span class="comments">;Convergence check</span>
                xm = (xc - xb)/2.

                if (abs( xm ) LE TOL1) || (fb EQ 0) then return,xb

                if (abs( Dold ) GE TOL1) && (abs( fa ) GT abs( fb )) then begin

                        S = fb/fa       <span class="comments">;attempt inverse quadratic interpolation</span>

                        if (xa EQ xc) then begin
                                p = 2 * xm * S
                                q = 1-S
                          endif else begin
                                T = fa/fc
                                R = fb/fc
                                p = S * (2*xm*T*(T-R) - (xb-xa)*(R-1) )
                                q = (T-1)*(R-1)*(S-1)
                           endelse

                        if (p GT 0) then q = -q
                        p = abs( p )
                        test = ( 3*xm*q - abs( q*TOL1 ) ) &lt<span class="comments">; abs( Dold*q )</span>

                        if (2*p LT test)  then begin
                                Dold = Din              <span class="comments">;accept interpolation</span>
                                Din = p/q
                          endif else begin
                                Din = xm                <span class="comments">;use bisection instead</span>
                                Dold = xm
                           endelse

                  endif else begin

                        Din = xm    <span class="comments">;Bounds decreasing to slowly, use bisection</span>
                        Dold = xm
                   endelse

                xa = xb
                fa = fb         <span class="comments">;evaluate new trial root.</span>

                if (abs( Din ) GT TOL1) then xb = xb + Din $
                                        else xb = xb + TOL1 * (1-2*(xm LT 0))

                if kpresent then $
                   fb = call_function( func_name, xb, _EXTRA = _extra ) else $
                   fb = call_function( func_name, xb )
		   
          endfor

        message,"exceeded maximum number of iterations: "+strtrim(iter,2),/INFO

return, xb
end
</code>
    </div>
  </body>
</html>