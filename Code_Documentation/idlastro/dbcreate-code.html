<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:25 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbcreate.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbcreate.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbcreate:source"></a>pro dbcreate,name,newindex,newdb,maxitems,EXTERNAL=EXTERNAL, Maxentry=maxentry
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;       DBCREATE</span>
<span class="comments">; PURPOSE:      </span>
<span class="comments">;       Create a new data base (.dbf), index (.dbx) or description (.dbh) file</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       A database definition (.dbd) file must already exist in the current</span>
<span class="comments">;       directory or in a ZDBASE directory.    The new .dbf, .dbx and/or .dbh</span>
<span class="comments">;       files will be written to the same directory.   So if the .dbd file is </span>
<span class="comments">;       in a ZDBASE directory, then the user must have write privilege to that </span>
<span class="comments">;       directory</span>
<span class="comments">;</span>
<span class="comments">;       This version allows record length to be larger than 32767 bytes</span>
<span class="comments">; CALLING SEQUENCE:     </span>
<span class="comments">;       dbcreate, name,[ newindex, newdb, maxitems]  [,/EXTERNAL, MAXENTRY=]  </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:       </span>
<span class="comments">;       name- name of the data base (with no qualifier), scalar string. </span>
<span class="comments">;               The description will be read from the file "NAME".dbd </span>
<span class="comments">;               Maximum length of name is 19 characters.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:      </span>
<span class="comments">;       newindex - if non-zero then a new index file is created,</span>
<span class="comments">;               otherwise it is assumed that changes do not affect the</span>
<span class="comments">;               index file. (default=0)</span>
<span class="comments">;       newdb - if non-zero then a new data base file (.dbf) will</span>
<span class="comments">;               be created. Otherwise changes are assumed not to affect</span>
<span class="comments">;               the file's present format.</span>
<span class="comments">;       maxitems - maximum number of items in data base.</span>
<span class="comments">;               If not supplied then the number of items is</span>
<span class="comments">;               limited to 200.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       NONE.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:       </span>
<span class="comments">;</span>
<span class="comments">;       external - If set, then the database is written with an external data</span>
<span class="comments">;               representation.  This allows the database files to be used on</span>
<span class="comments">;               any computer platform, e.g. through NFS mounts, but some</span>
<span class="comments">;               overhead is added to reading the files.  The default is to</span>
<span class="comments">;               write the data in the native format of the computer being used.</span>
<span class="comments">;</span>
<span class="comments">;               This keyword is only paid attention to if NEWDB or NEWINDEX</span>
<span class="comments">;               are nonzero.  Otherwise, the database is opened to find</span>
<span class="comments">;               out if it uses external representation or not.</span>
<span class="comments">;</span>
<span class="comments">;               Extreme caution should be used if this keyword is used with</span>
<span class="comments">;               only NEWINDEX set to a nonzero value.  This mode is allowed so</span>
<span class="comments">;               that databases written on machines which already use the</span>
<span class="comments">;               external data representation format, e.g. Sun workstations, to</span>
<span class="comments">;               be marked external so that other machines can read them.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;       MAXENTRY - positive integer giving the maximum number of entries in the</span>
<span class="comments">;               database (needed to adjust the size of the index file).   This</span>
<span class="comments">;               keyword can be used to supercede the  #maxentries line in the </span>
<span class="comments">;               .dbd file (the larger of the two numbers will be used).</span>
<span class="comments">; PROCEDURE CALLS:      </span>
<span class="comments">;       GETTOK(), FIND_WITH_DEF(), ZPARCHECK</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS: </span>
<span class="comments">;       If newdb=0 is not specified, the changes to the .dbd file can</span>
<span class="comments">;       not alter the length of the records in the data base file.</span>
<span class="comments">;       and may not alter positions of current fields in the file.</span>
<span class="comments">;       permissible changes are:</span>
<span class="comments">;               1) utilization of spares to create a item or field</span>
<span class="comments">;               2) change in field name(s)</span>
<span class="comments">;               3) respecification of index items</span>
<span class="comments">;               4) changes in default print formats</span>
<span class="comments">;               5) change in data base title</span>
<span class="comments">;               6) changes in pointer specification to other data</span>
<span class="comments">;                       data bases</span>
<span class="comments">;</span>
<span class="comments">;       !priv must be 2 or greater to execute this routine.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:  </span>
<span class="comments">;       data base description file ZDBASE:name.dbh is created</span>
<span class="comments">;       and optionally ZDBASE:name.dbf (data file) and</span>
<span class="comments">;       ZDBASE.dbx (index file) if it is a new data base.</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:     </span>
<span class="comments">;       D. Lindler, GSFC/HRS, October 1987</span>
<span class="comments">;       Modified:  Version 1, William Thompson, GSFC, 29 March 1994</span>
<span class="comments">;                  Version 2, William Thompson, GSFC/CDS (ARC), 28 May 1994</span>
<span class="comments">;                  Added EXTERNAL keyword.</span>
<span class="comments">;       Version 4, William Thompson, GSFC, 3 November 1994</span>
<span class="comments">;                       Modified to allow ZDBASE to be a path string.</span>
<span class="comments">;       8/14/95  JKF/ACC - allow EXTERNAL data for newindex OR newdb modes.</span>
<span class="comments">;       Make sure all databases closed before starting W. Landsman June 1997</span>
<span class="comments">;       Added new unsigned and 64 bit integer datatypes W. Landsman July 2001</span>
<span class="comments">;       Make sure to use lowercase filenames on Unix W. Landsman May 2006</span>
<span class="comments">;       Added MAXENTRY keyword   W. Landsman July 2006</span>
<span class="comments">;       Assume since V5.5, remove obsolete keywords to OPEN W. Landsman Sep2006</span>
<span class="comments">;       No longer required to be a ZDBASE directory  W. Landsman Feb 2008</span>
<span class="comments">;       Fix Feb 2008 bug when files are in current dir W. L.  May 2008</span>
<span class="comments">;       Fix May 2008 bug when files are not in current dir (sigh) W. L. May 2008</span>
<span class="comments">;       Warn if database length exceeds 32767 bytes  W.L. Dec 2009</span>
<span class="comments">;       Remove spurious warning that database name is too long W.L. April 2010</span>
<span class="comments">;       Support entry lengths larger than 32767 bytes W.L. Oct. 2010</span>
<span class="comments">;       Better testing for valid print formats W.L. Nov 2010</span>
<span class="comments">;-</span>
<span class="comments">;----------------------------------------------------------</span>
 On_error,2                         <span class="comments">;Return to caller</span>
 compile_opt idl2

if N_Params() LT 1 then begin
      print,'Syntax - dbcreate, name, [ newindex, newdb, maxitems ]'
      print,'  Input Keywords:         /EXTERNAL, MAXENTRY= '
      print,'  !PRIV must be 2 or greater to execute this routine'
      return
endif
<span class="comments">;</span>
<span class="comments">; check privilege</span>
<span class="comments">;</span>
if !priv LT 2 then  $
        message,'!PRIV must be 2 or greater to execute this routine'
<span class="comments">;</span>
<span class="comments">; check parameters</span>
<span class="comments">;</span>
zparcheck, 'DBCREATE', name, 1, 7, 0, 'Database Name'
if N_params() LT 2 then newindex = 0
if N_params() LT 3 then newdb = 0
if N_params() LT 4 then maxitems = 200
if not keyword_set(maxentry) then maxentry = 1
filename = strlowcase(strtrim(name,2))
if strlen(filename) GT 19 then message,/INF, $
   'Warning - database name must not exceed 19 characters'

 dbclose                         <span class="comments">;Close any databases already open</span>
 <span class="comments">;</span>
<span class="comments">; open .dbd file</span>
<span class="comments">;</span>
get_lun, unit                   <span class="comments">;get free unit number</span>
dbdname =  find_with_def(filename+'.dbd', 'ZDBASE')
fdecomp,dbdname,disk,dir
zdir = disk+ dir 
if zdir EQ '' then cd,current=zdir
zdir = zdir + path_sep()
if ~file_test(zdir,/write) then message, $
   'ERROR - must have write privileges to directory ' + zdir
openr, unit, dbdname,error=err
if err NE 0 then goto, Bad_IO
On_ioerror, BAD_IO              <span class="comments">;On I/O errors go to BAD_IO</span>

<span class="comments">;</span>
<span class="comments">; Decide whether or not external data representation should be used.</span>
<span class="comments">;   8/14/95  JKF/ACC - allow EXTERNAL data for newindex OR newdb modes.</span>
<span class="comments">;</span>
if ((newindex ne 0) or (newdb ne 0)) or $
                (~file_test(zdir+ filename+'.dbh')) then begin
        extern = keyword_set(external)
end else begin
        openr,tempunit,zdir +filename+'.dbh',/get_lun
        point_lun,tempunit,119
        extern = 0b
        readu,tempunit,extern
        free_lun,tempunit
endelse
<span class="comments">;</span>
<span class="comments">; set up data buffers</span>
<span class="comments">;</span>
names = strarr(maxitems)                        <span class="comments">;names of items</span>
numvals = replicate(1L,maxitems)                   <span class="comments">;number of values</span>
type = intarr(maxitems)                         <span class="comments">;data type</span>
nbytes = intarr(maxitems)                       <span class="comments">;number of bytes in item</span>
desc = strarr(maxitems)                         <span class="comments">;descriptions of items</span>
sbyte = lonarr(maxitems)                        <span class="comments">;starting byte position</span>
format = strarr(maxitems)                       <span class="comments">;print formats</span>
headers = strarr(3,maxitems)                    <span class="comments">;print headers</span>
headers[*,*]='               '                  <span class="comments">;init headers</span>
title = ''                                      <span class="comments">;data base title</span>
index = intarr(maxitems)                        <span class="comments">;index type</span>
pointers = strarr(maxitems)                     <span class="comments">;pointer array</span>
npointers = 0
maxentries = 30000L
alloc = 100L
<span class="comments">;</span>
<span class="comments">; first item is always entry number</span>
<span class="comments">;</span>
names[0] = 'ENTRY'
type[0] = 3             <span class="comments">;longword integer</span>
nbytes[0] = 4           <span class="comments">;four bytes</span>
desc[0] = 'Entry or Record Number'
format[0] = 'I8'
headers[1,0] = 'ENTRY'
nitems = 1S             <span class="comments">;Short integer</span>
nextbyte = 4            <span class="comments">;next byte position in record</span>

<span class="comments">;</span>
<span class="comments">; read and process input data</span>
<span class="comments">;</span>
block='TITLE'                           <span class="comments">;assume first block is title</span>
inputst=''
while not eof(unit) do begin            <span class="comments">;loop on records in the file</span>
<span class="comments">;</span>
<span class="comments">; process next line of input</span>
<span class="comments">;</span>
    readf,unit,inputst
    print,inputst
    st=gettok(inputst,';')
    if strtrim(st,2) eq '' then goto,next       <span class="comments">;skip blank lines</span>
    if strmid(st,0,1) eq '#' then begin
        block=strupcase(strmid(st,1,strlen(st)-1))<span class="comments">;begin new block</span>
        goto,next
    end
<span class="comments">;</span>
    case strtrim(block,2) of

        'TITLE' : title=st

        'MAXENTRIES' : maxentries=long(strtrim(st,2)) > maxentry

        'ITEMS' : begin
<span class="comments">;</span>
<span class="comments">;               process statement in form</span>
<span class="comments">;                       &lt;itemname> &lt;datatype> &lt;description></span>
<span class="comments">;</span>
                item_name=" "
                item_name=strupcase(gettok(st,' '))
                st = strtrim(st, 1)
                item_type = " "
                item_type=gettok(st,' ')
                st = strtrim(st, 1)
                desc[nitems]=st
                if item_name eq '' then $
                        message,'Invalid item name',/IOERROR
                names[nitems]=gettok(item_name,'(')
                if item_name ne '' then $               <span class="comments">;is it a vector</span>
                        numvals[nitems]=fix(gettok(item_name,')')) 
                if item_type eq '' then $
                  message,'Item data type not supplied for item ' + $
                          strupcase(item_name),/IOERROR
                data_type=strmid(strupcase(gettok(item_type,'*')),0,1)
                num_bytes=item_type
                if num_bytes eq '' then num_bytes='4'
                if (data_type eq 'R') or (data_type eq 'I') or $
                   (data_type eq 'U') then $
                                data_type=data_type+num_bytes
                case data_type of
                        'B' : begin & idltype= 1 & nb=1 & ff='I6' & end
                        'L' : begin & idltype= 1 & nb=1 & ff='I6' & end
                        'I2': begin & idltype= 2 & nb=2 & ff='I7' & end
                        'I4': begin & idltype= 3 & nb=4 & ff='I11' & end
                        'I8': begin & idltype= 14 & nb=8 & ff='I22' & end
                        'R4': begin & idltype= 4 & nb=4 & ff='G12.6' & end
                        'R8': begin & idltype= 5 & nb=8 & ff='G20.12' & end
                        'U2': begin & idltype= 12 & nb=2 & ff='I7' & end
                        'U4': begin & idltype= 13 & nb=4 & ff='I11' & end
                        'U8': begin & idltype= 15 & nb=8 & ff='I22' & end
                        'C' : begin
                                idltype = 7
                                nb=fix(num_bytes)
                                ff='A'+num_bytes
                              end
                        else: message,'Invalid data type "'+ item_type+ $
                                       '" specified',/IOERROR
                endcase
                format[nitems]=ff                       <span class="comments">;default print format</span>
                headers[1,nitems]=names[nitems] <span class="comments">;default print header</span>
                type[nitems]=idltype            <span class="comments">;idl data type for item</span>
                nbytes[nitems]=nb               <span class="comments">;number of bytes for item</span>
                sbyte[nitems]=nextbyte          <span class="comments">;position in record for item</span>
                nextbyte=nextbyte+nb*numvals[nitems] <span class="comments">;next byte position</span>
                nitems=nitems+1
                end

        'FORMATS': begin
<span class="comments">;</span>
<span class="comments">;                process strings in form:</span>
<span class="comments">;                       &lt;item name> &lt;format> &lt;header1>,&lt;header2>,&lt;header3></span>
<span class="comments">;</span>
                item_name=" "
                item_name=strupcase(gettok(st,' '))
                item_no=0
                while item_no lt nitems do begin
                        if strtrim(names[item_no]) eq item_name then begin
                                st = strtrim(st, 1)
                                format[item_no]=gettok(st,' ')
                                if strtrim(st,2) ne '' then begin
                                        st = strtrim(st, 1)
                                        headers[0,item_no]=gettok(st,',')
                                        headers[1,item_no]=gettok(st,',')
                                        headers[2,item_no]=strtrim(st)
                                endif
                        endif
                        item_no=item_no+1
                endwhile
                end

        'POINTERS': begin
<span class="comments">;</span>
<span class="comments">;               process record in form:</span>
<span class="comments">;                       &lt;item name> &lt;data base name></span>
<span class="comments">;</span>
                item_name=strupcase(gettok(st,' '))
                item_no=0
                while item_no lt nitems do begin
                        if strtrim(names[item_no]) eq item_name then $
                                pointers[item_no]=strupcase(strtrim(st, 1))
                        item_no=item_no+1
                endwhile
                endcase

        'INDEX': begin
<span class="comments">;</span>
<span class="comments">;               process record of type:</span>
<span class="comments">;               &lt;item name> &lt;index type></span>
<span class="comments">;</span>
                item_name=strupcase(gettok(st,' '))
                st = strtrim(st, 1)
                indextype=gettok(st,' ')
                item_no=0
                while item_no lt nitems do begin
                        if strtrim(names[item_no]) eq item_name then begin
                            case strupcase(indextype) of
                                'INDEX' : index[item_no]=1
                                'SORTED': index[item_no]=2
                                'SORT'  : index[item_no]=3
                                'SORT/INDEX' : index[item_no]=4
                                else    : message,'Invalid index type',/IOERROR
                            endcase
                        endif
                        item_no=item_no+1
                endwhile
                end
        else : begin
                print,'DBCREATE-- invalid block specfication of ',block
                print,'   Valid values are #TITLE, #ITEMS, #FORMATS, #INDEX,'
                print,'   #MAXENTRIES or #POINTERS'
               end
        endcase
next:
endwhile<span class="comments">; loop on records</span>

<span class="comments">;</span>
<span class="comments">; create data base descriptor record --------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;       byte array of 120 values</span>
<span class="comments">;</span>
<span class="comments">;       bytes</span>
<span class="comments">;         0-18   data base name character*19</span>
<span class="comments">;         19-79  data base title character*61</span>
<span class="comments">;         80-81  number of items (integer*2)</span>
<span class="comments">;         105-108  record length of DBF file (integer*4)</span>
<span class="comments">;         84-117 values filled in by DBOPEN</span>
<span class="comments">;         119    equals 1 if keyword EXTERNAL is true.</span>
<span class="comments">;</span>
totbytes=((nextbyte+3)/4*4)  <span class="comments">;make record length a multiple of 4</span>
drec = bytarr(120)
drec[0:79]=32b                      <span class="comments">;blanks</span>
drec[0] = byte(strupcase(filename))
drec[19] = byte(title)
drec[80] = byte(fix(nitems),0,2)
drec[105] = byte(long(totbytes),0,4)
drec[118] = 1b
drec[119] = byte(extern)
<span class="comments">;</span>
<span class="comments">; create item description records</span>
<span class="comments">;</span>
<span class="comments">;  irec(*,i) contains decription of item number i with following</span>
<span class="comments">;  byte assignments:</span>
<span class="comments">;       0-19    item name (character*20)</span>
<span class="comments">;       20-21   IDL data type (integet*2)</span>
<span class="comments">;       24-25   Starting byte position i record (integer*2)</span>
<span class="comments">;       26-27   Number of bytes per data value (integer*2)</span>
<span class="comments">;       28      Index type</span>
<span class="comments">;       29-97   Item description</span>
<span class="comments">;       98-99   Field length of the print format</span>
<span class="comments">;       100     Pointer flag</span>
<span class="comments">;       101-119 Data base this item points to</span>
<span class="comments">;       120-125 Print format</span>
<span class="comments">;       126-170 Print headers</span>
<span class="comments">;       179-182   Number of values for item (1 for scalar) (integer*4)</span>
<span class="comments">;       183-186 Starting byte position in original DBF record (integer*4)</span>
<span class="comments">;       187-199 Added by DBOPEN</span>
irec=bytarr(200,nitems)
rec=bytarr(200)
headers = strmid(headers,0,15)       <span class="comments">;Added 15-Sep-92</span>

for i=0,nitems-1 do begin
        rec[0:19]=32b  &  rec[101:170]=32b    <span class="comments">;Default string values are blanks</span>
        rec[29:87] = 32b
        rec[0]  = byte(names[i])
        rec[20] = byte(type[i],0,2)
        rec[179] = byte(numvals[i],0,4)
        rec[183] = byte(sbyte[i],0,4)
        rec[26] = byte(nbytes[i],0,2)
        rec[28] = index[i]
        rec[29] = byte(desc[i])
        if strtrim(pointers[i]) ne '' then rec[100]=1 else rec[100]=0
        rec[101]= byte(strupcase(pointers[i]))
        rec[120]= byte(format[i])
        ff=strtrim(format[i])
	test = strnumber(gettok(strmid(ff,1,strlen(ff)-1),'.'),val)
        if test then flen =fix(val) else $    <span class="comments">;Modified Nov-10</span>
	   message,'Invalid print format supplied: ' + format[i],/IOERROR
        rec[98] = byte(flen,0,2)
        rec[126]= byte(headers[0,i]) > 32b    <span class="comments">;Modified Nov-91</span>
        rec[141]= byte(headers[1,i]) > 32b
        rec[156]= byte(headers[2,i]) > 32b
        irec[0,i]=rec

end
<span class="comments">;</span>
<span class="comments">; Make sure user is on ZDBASE and write description file</span>
<span class="comments">;</span>

 close,unit
 openw,unit,zdir + filename+'.dbh'
On_ioerror, NULL 
if extern then begin
        tmp = fix(drec,80,1) & byteorder,tmp,/htons & drec[80] = byte(tmp,0,2)
        tmp = long(drec,105,1) & byteorder,tmp,/htonl & drec[105] = byte(tmp,0,4)
<span class="comments">;</span>
        tmp = fix(irec[20:27,*],0,4,nitems)
        byteorder,tmp,/htons 
        irec[20,0] = byte(tmp,0,8,nitems)
<span class="comments">;</span>
        tmp = fix(irec[98:99,*],0,1,nitems)
        byteorder,tmp,/htons 
        irec[98,0] = byte(tmp,0,2,nitems)
<span class="comments">;</span>
        tmp = fix(irec[171:178,*],0,4,nitems)
        byteorder,tmp,/htons 
        irec[171,0] = byte(tmp,0,8,nitems)
	
	tmp = long(irec[179:186,*],0,2,nitems)
        byteorder,tmp,/htonl 
        irec[179,0] = byte(tmp,0,8,nitems)

endif
writeu, unit, drec
writeu, unit, irec
<span class="comments">;</span>
<span class="comments">; if new data base create .dbf and .dbx files -----------------------------</span>
<span class="comments">;</span>

if newdb then begin
    close,unit
    openw, unit, zdir + filename+'.dbf'
    header = bytarr(totbytes)
    p = assoc(unit,header)
    p[0] = header
end

<span class="comments">;</span>
<span class="comments">; determine if any indexed items</span>
<span class="comments">;</span>
nindex = total(index GT 0)
<span class="comments">;</span>
<span class="comments">; create empty index file if needed</span>
<span class="comments">;</span>
if (nindex GT 0) and (newindex) then begin
        indexed = where(index GT 0)
<span class="comments">;</span>
<span class="comments">; create header array</span>
<span class="comments">;       header=intarr(7,nindex)</span>
<span class="comments">;               header(i,*) contains values</span>
<span class="comments">;               i=0     item number</span>
<span class="comments">;               i=1     index type</span>
<span class="comments">;               i=2     idl data type for the item</span>
<span class="comments">;               i=3     starting block for header</span>
<span class="comments">;               i=4     starting block for data</span>
<span class="comments">;               i=5     starting block for indices (type 3)</span>
<span class="comments">;               i=6     starting block for unsorted data (type 4)</span>
<span class="comments">;</span>
        nb = (maxentries+511)/512       <span class="comments">;number of 512 value groups</span>
        nextblock = 1
        header = lonarr(7,nindex)
        for ii = 0, nindex-1 do begin
                item = indexed[ii]
                header[0,ii] = item
                header[1,ii] = index[item]
                header[2,ii] = type[item]
                data_blocks = nbytes[item]*nb
                if index[item] NE 1 $
                             then header_blocks = (nbytes[item]*nb+511)/512 $
                             else header_blocks = 0
                if (index[item] eq 3) or (index[item] EQ 4) then $
                                 index_blocks=(4*nb) else index_blocks=0
                if index[item] EQ 4 then unsort_blocks = data_blocks else $
                                                        unsort_blocks=0
                header[3,ii] = nextblock
                header[4,ii] = nextblock+header_blocks
                header[5,ii] = header[4,ii]+data_blocks
                header[6,ii] = header[5,ii]+index_blocks
                nextblock = header[6,ii]+unsort_blocks
        end
        totblocks = nextblock
        close, unit
        openw, unit, zdir + filename+'.dbx'
<span class="comments">;</span>
        p = assoc(unit,lonarr(2))
        tmp = [long(nindex),maxentries]
        if extern then byteorder, tmp,/htonl
        p[0] = tmp
<span class="comments">;</span>
        p = assoc(unit,lonarr(7,nindex),8)
        tmp = header
        if extern then byteorder, tmp,/htonl
        p[0] = tmp
endif
free_lun, unit
return
<span class="comments">;</span>
BAD_IO: free_lun,unit
print, !ERROR_STATE.MSG_PREFIX + !ERROR_STATE.MSG
print, !ERROR_STATE.MSG_PREFIX + !ERROR_STATE.SYS_mSG

return
<span class="comments">;</span>
end
</code>
    </div>
  </body>
</html>