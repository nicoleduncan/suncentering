<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:27 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbsearch.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbsearch.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbsearch:source"></a>pro dbsearch,type,svals,values,good, FULLSTRING = fullstring, COUNT = count
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	DBSEARCH</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Subroutine of DBFIND() to search a vector for specified values</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	dbsearch, type, svals, values, good, [ /FULLSTRING, COUNT = ] </span>
<span class="comments">;</span>
<span class="comments">; INPUT: </span>
<span class="comments">;	type - type of search (output from dbfparse)</span>
<span class="comments">;	svals - search values (output from dbfparse)</span>
<span class="comments">;	values - array of values to search</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;	good - indices of good values</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;	/FULLSTRING - By default, one has a match if a search string is </span>
<span class="comments">;		included in any part of a database value (substring match).   </span>
<span class="comments">;		But if /FULLSTRING is set, then all characters in the database</span>
<span class="comments">;		value must match the search string (excluding leading and </span>
<span class="comments">;		trailing blanks).    Both types of string searches are case</span>
<span class="comments">;		insensitive.</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       COUNT  - Integer scalar giving the number of valid matches</span>
<span class="comments">;  SIDE EFFECTS:</span>
<span class="comments">;	The obsolete system variable !ERR is set to number of good values</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;	D. Lindler  July,1987</span>
<span class="comments">;       Added COUNT keyword, deprecate !ERR   W. Landsman   March 2000</span>
<span class="comments">;      Some speed improvements W.L. August 2008</span>
<span class="comments">;       Add compound operators, slightly faster WL November 2009</span>
<span class="comments">;-</span>
<span class="comments">;-----------------------------------------------------------</span>
 On_error,2
 compile_opt idl2
 
 svals = strupcase(svals)
<span class="comments">;</span>
<span class="comments">; determine data type of values to be searched</span>
<span class="comments">;</span>
 datatype=size(values,/type) & nv = N_elements(values)
 
<span class="comments">;</span>
<span class="comments">; convert svals to correct data type</span>
<span class="comments">;</span>
 nvals = type>2
 if datatype NE 7 then sv = replicate(values[0],nvals) else $
                      sv = replicate(' ',nvals)
 On_ioerror, BADVAL              <span class="comments">;Trap any type conversions</span>
 sv[0]= svals[0:nvals-1]
 On_ioerror, NULL
 sv0=sv[0] & sv1=sv[1]
<span class="comments">;</span>
<span class="comments">; -----------------------------------------------------------</span>
<span class="comments">;      STRING SEARCHES (Must use STRPOS to search for substring match)</span>
<span class="comments">;</span>
if datatype EQ 7 then begin
    values = strupcase(values)
    case type of
						
         0: if keyword_set(FULLSTRING) then $            <span class="comments">;Exact string match?</span>
	    valid = strtrim(values,2) EQ strtrim(sv0,2) else $
	    valid = strpos(values,strtrim(sv0,2)) GE 0   <span class="comments">;substring search</span>
        -1: valid = values GE sv0                        <span class="comments">;greater than</span>
	-3: valid = (values GE sv0) and (values LE sv1)  <span class="comments">;in range</span>
	-4: valid = strtrim(values) NE ''       <span class="comments">;non zero (i.e. not null)</span>
        -5: message, $                                  <span class="comments">;Tolerance value</span>
               ' Tolerance specification for strings is not valid'
         else:  begin
                sv = strtrim(sv,2)
		sv = sv[uniq(sv,sort(sv))]     <span class="comments">;Remove duplicates</span>
		type = N_elements(sv)
                valid = bytarr(nv)

		if keyword_set(FULLSTRING) then begin
		values = strtrim(values,2)
                for ii = 0l,type-1 do valid OR= (values EQ sv[ii]) 

                endif else begin

                for ii=0L,type-1 do begin               <span class="comments">;within set of substring</span>
		valid OR= (strpos(values,sv[ii]) GE 0)		
                endfor

		endelse
                end
	endcase
	good = where(valid, count)
	return
end
<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------</span>
<span class="comments">;		ALL OTHER DATA TYPES</span>
case type of
 
	 0: good = where( values EQ sv0, count )               <span class="comments">;value=sv0</span>
	-1: good = where( values GE sv0, count )		<span class="comments">;value>sv0</span>
	-2: good = where( values LE sv1, count )		<span class="comments">;value&lt;sv1</span>
	-3: begin				<span class="comments">;sv0&lt;value&lt;sv1</span>
	    if sv1 lt sv0 then begin
	        temp=sv0
		sv0=sv1
		sv1=temp
	    end
	    good=where((values GE sv0) and (values LE sv1), count)
	    end 	
	-5: begin				<span class="comments">;sv1 is tolerance</span>
	    minv=sv0-abs(sv1)
	    maxv=sv0+abs(sv1)
	    good=where( (values GE minv) and (values LE maxv), count)
	    end
	-4: good=where(values, count)		<span class="comments">;non-zero</span>
	else: begin				<span class="comments">;set of values	</span>
            sv = sv[uniq(sv,sort(sv))]     <span class="comments">;Remove duplicates</span>
	      type = N_elements(sv)
	      valid = bytarr(nv) 

	      for i=0L,type-1 do begin		<span class="comments">;loop on possible values  </span>
	         valid OR= (values EQ sv[i])
	      endfor
	      good = where(valid, count) 	    
  

              if count EQ 0 then good = intarr(1)-1   <span class="comments">;Make sure good is defined</span>
	      !err=count
	      end
endcase
return
BADVAL: !ERR=-2       <span class="comments">;Illegal search value supplied</span>
return
end
</code>
    </div>
  </body>
</html>