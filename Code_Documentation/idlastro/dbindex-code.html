<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbindex.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbindex.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbindex:source"></a>pro dbindex,items
<span class="comments">;+                      </span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBINDEX</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Procedure to create index file for data base </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:     </span>
<span class="comments">;       dbindex, [ items ]</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       items - names or numbers of items to be index -- if not supplied,</span>
<span class="comments">;               then all indexed fields will be processed.  </span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       Index file &lt;name>.dbx is created on disk location ZDBASE:</span>
<span class="comments">;</span>
<span class="comments">; OPERATIONAL NOTES:</span>
<span class="comments">;       (1) Data base must have been previously opened for update</span>
<span class="comments">;       by DBOPEN </span>
<span class="comments">;</span>
<span class="comments">;       (2) Only 18 items can be indexed at one time.   If the database has</span>
<span class="comments">;       more than 18 items, then two separate calls to DBINDEX are needed.</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       DBINDEX_BLK, DB_INFO(), DB_ITEM, DB_ITEM_INFO(), IEEE_TO_HOST, </span>
<span class="comments">;       IS_IEEE_BIG()</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       version 2  D. Lindler  Nov 1987 (new db format)</span>
<span class="comments">;       W. Landsman    added optional items parameter Feb 1989 </span>
<span class="comments">;       William Thompson, GSFC/CDS (ARC), 30 May 1994</span>
<span class="comments">;               Added support for external (IEEE) data format</span>
<span class="comments">;       Test if machine is bigendian  W. Landsman     May, 1996</span>
<span class="comments">;       Change variable name of BYTESWAP to BSWAP  W. Thompson  Mar, 1997</span>
<span class="comments">;       Increased number of fields to 15   W. Landsman   June, 1997</span>
<span class="comments">;       Increase number of items to 18     W. Landsman  November 1999</span>
<span class="comments">;       Allow multiple valued (nonstring) index items W. Landsman November 2000</span>
<span class="comments">;       Use 64 bit integers for V5.2 or later  W. Landsman February 2001</span>
<span class="comments">;       Do not use EXECUTE() for V6.1 or later, improve efficiency </span>
<span class="comments">;                W. Landsman   December 2006</span>
<span class="comments">;       Automatically enlarge .dbx file if needed, fix major bug in last</span>
<span class="comments">;             update    W. Landsman Dec 2006</span>
<span class="comments">;       Assume since V6.1    W. Landsman   June 2009</span>
<span class="comments">;       Allow sorted string items   W. Landsman   October 2009</span>
<span class="comments">;-                                         </span>
<span class="comments">;*****************************************************************</span>
 On_error,2                <span class="comments">;Return to caller</span>
 compile_opt idl2

<span class="comments">; Check to see if data base is opened for update</span>

 if db_info('UPDATE') EQ 0 then message, $
        'Database must be opened for update'

<span class="comments">; Extract index items from data base</span>

 if N_params() EQ 1 then db_item,items,itnum else begin 
      nitems = db_info('ITEMS',0)
      itnum = indgen(nitems)
 endelse

 indextype = db_item_info('INDEX',itnum)
 indexed = where(indextype, Nindex)                 <span class="comments">;Select only indexed items</span>
 if Nindex LE 0 then begin
        message,'Database has no indexed items',/INF
        return
 endif else if Nindex GT 18 then begin
        message,'ERROR - Only 18 items can be indexed at one time',/INF
        return
 endif

 indextype = indextype[indexed]
 if N_params() EQ 1 then indexed = itnum[indexed]

<span class="comments">; get info on indexed items</span>

 nbytes = db_item_info('NBYTES',indexed)         <span class="comments">;Number of bytes</span>
 idltype = db_item_info('IDLTYPE',indexed)       <span class="comments">;IDL type</span>
 sbyte = db_item_info('SBYTE',indexed)           <span class="comments">;Starting byte</span>
 nval = db_item_info('NVALUES',indexed)          <span class="comments">;Number of values per entry</span>

<span class="comments">; get db info</span>

 nentries = db_info('ENTRIES',0)
 if nentries EQ 0 then begin
  message, 'ERROR - database contains no entries',/INF
  return
 endif
 unit = db_info('UNIT_DBX',0)                      <span class="comments">;unit number of index file</span>
 external = db_info('EXTERNAL',0)                  <span class="comments">;external format?</span>
 bswap = external ? not IS_IEEE_BIG() : 0

<span class="comments">; read header info of index file (mapped file)</span>

 reclong = assoc(unit,lonarr(2),0)
 h = reclong[0]  <span class="comments">;first two longwords</span>
 if bswap then ieee_to_host,h
 maxentries = h[1]      <span class="comments">;max allowed entries</span>
<span class="comments">; If necessary, enlarge the size of the .dbx file.    All indexed items must</span>
<span class="comments">; then be reindexed.</span>
 if maxentries lt nentries then begin
        message,'Enlarging index (.dbx) file to support ' +  $
	         strtrim(nentries,2) + ' entries',/INF
	dbname = db_info('name',0)	 
        dbcreate,dbname,1,maxentry=nentries,external=db_info('external')
	dbopen, dbname, 1
        nitems = db_info('ITEMS',0)
        itnum = indgen(nitems)   
 endif
 
 nindex2 = h[0] <span class="comments">;number of indexed items</span>
 if nindex2 LT nindex then goto, NOGOOD   
 reclong = assoc(unit,lonarr(7,nindex2),8)
 header = reclong[0]            <span class="comments">;index header</span>
 if bswap then ieee_to_host,header
 hitem = header[0,*]            <span class="comments">;indexed item numbers</span>
 hindex = header[1,*]           <span class="comments">;index type</span>
 htype = header[2,*]            <span class="comments">;idl data type</span>
 hblock = header[3,*]           <span class="comments">;starting block of header</span>
 sblock = header[4,*]           <span class="comments">;starting block of data values</span>
 iblock = header[5,*]           <span class="comments">;starting block of indices (type=3)</span>
 ublock = header[6,*]           <span class="comments">;starting block of unsorted data (type=4)</span>

<span class="comments">; extract index items...maximum of 18 indexed fields.</span>

 list = lindgen(nentries)+1l
 dbext_dbf,list,0,sbyte,nbytes*nval,idltype,nval, $
               v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18

 for i = 0,nindex-1 do begin
        <span class="comments">;</span>
        <span class="comments">; place item in variable v</span>
        <span class="comments">;</span>
        v = (scope_varfetch('v' + strtrim(i+1,2))) 
        pos = where(hitem EQ indexed[i], N_found)
        if N_found LE 0 then goto, NOGOOD    
        pos = pos[0]
        if hindex[pos] NE indextype[i] then goto, NOGOOD  
        if ( idltype[i] EQ 7 ) then v = byte(v)
<span class="comments">;</span>
<span class="comments">; process according to index type ---------------------------------------</span>
<span class="comments">;</span>
        reclong = assoc(unit,lonarr(1),(iblock[pos]*512LL))
        case indextype[i] of
 
        1: begin                                <span class="comments">;indexed (unsorted)</span>

                datarec = dbindex_blk(unit, sblock[pos], 512, 0, idltype[i])
   		datarec[0] =  bswap ? swap_endian(v,/swap_if_little) : v
           end
<span class="comments">; </span>
        2: begin                                <span class="comments">;values are already sorted</span>

                nb=(nentries+511L)/512          <span class="comments">;number of 512 value blocks</span>
                ind=indgen(nb)*512LL             <span class="comments">;position at start of each block</span>
                sval=v[ind]                     <span class="comments">;value at start of each block</span>
<span class="comments">;</span>
                datarec = dbindex_blk(unit, hblock[pos], 512, 0, idltype[i])
                datarec[0] = bswap ? swap_endian(sval,/swap_if_little) : sval
 <span class="comments">;</span>
                datarec = dbindex_blk(unit, sblock[pos], 512, 0, idltype[i])
   		datarec[0] =  bswap ? swap_endian(v,/swap_if_little) : v
           end
 
        3: begin                                <span class="comments">; sort item before storage</span>
                
                if idltype[i] EQ 7 then begin 
		    svv = string(v)
		    sub= bsort(svv) 
		    v = byte(svv[sub])
		endif     else begin 
		   sub=bsort(v)                    <span class="comments">;sort values</span>
                   v=v[sub]
                endelse
		nb=(nentries+511)/512           <span class="comments">;number of 512 value blocks</span>
                ind=l64indgen(nb)*512LL             <span class="comments">;position at start of each block</span>
                if idltype[i] EQ 7 then sval=v[*,ind] else sval = v[ind] 
		                    <span class="comments">;value at start of each block</span>
                datarec = dbindex_blk(unit, hblock[pos], 512, 0, idltype[i])
 		datarec[0] = bswap ? swap_endian(sval,/swap_if_little) : sval
<span class="comments">;</span>
                datarec = dbindex_blk(unit, sblock[pos], 512, 0, idltype[i])
  		datarec[0] =  bswap ? swap_endian(v,/swap_if_little) : v
                reclong[0] = bswap ? swap_endian(sub+1,/swap_if_little) : sub+1                <span class="comments">;indices</span>
           end
        4: begin                                <span class="comments">; sort item before storage</span>
                
                datarec = dbindex_blk(unit, ublock[pos], 512, 0, idltype[i])
 		datarec[0] =  bswap ? swap_endian(v,/swap_if_little) : v
                if idltype[i] EQ 7 then begin 
		    svv = string(v)
		    sub= bsort(svv) 
		    v = byte(svv[sub])
		endif     else begin 
		   sub=bsort(v)                    <span class="comments">;sort values</span>
                   v=v[sub]
                endelse
   
   
                  nb=(nentries+511)/512           <span class="comments">;number of 512 value blocks</span>
                ind=l64indgen(nb)*512LL             <span class="comments">;position at start of each block</span>
                if idltype[i] EQ 7 then sval=v[*,ind] else sval = v[ind] 
		                    <span class="comments">;value at start of each block</span>
                datarec = dbindex_blk(unit, hblock[pos], 512, 0, idltype[i])
                datarec[0] = bswap ? swap_endian(sval,/swap_if_little) : sval
 <span class="comments">;</span>
 		datarec = dbindex_blk(unit, sblock[pos], 512, 0, idltype[i])
		datarec[0] =  bswap ? swap_endian(v,/swap_if_little) : v
<span class="comments">;</span>
                 reclong[0] = bswap ?swap_endian(sub+1,/swap_if_little) : sub+1                <span class="comments">;indices</span>
	   end
        endcase
endfor
return
NOGOOD:    
        print,'DBINDEX-- Inconsistency in .dbh and .dbx file'
        print,'Run dbcreate to create a new index file'
        return
end
</code>
    </div>
  </body>
</html>