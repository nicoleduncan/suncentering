<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:58 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>quadterp.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="quadterp.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO quadterp, xtab, ytab, xint, yint, MISSING = MISSING
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       QUADTERP     </span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Quadratic interpolation of X,Y vectors onto a new X grid</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Interpolate a function Y = f(X) at specified grid points using an</span>
<span class="comments">;       average of two neighboring 3 point quadratic (Lagrangian) interpolants.</span>
<span class="comments">;       Use LINTERP for linear interpolation</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       QUADTERP, Xtab, Ytab, Xint, Yint, [ MISSING = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUT: </span>
<span class="comments">;       Xtab - Vector (X TABle) containing the current independent variable </span>
<span class="comments">;               Must be either monotonic increasing or decreasing</span>
<span class="comments">;       Ytab - Vector (Y TABle) containing the dependent variable defined</span>
<span class="comments">;               at each of the points of XTAB.</span>
<span class="comments">;       Xint - Scalar or vector giving the values of X for which interpolated </span>
<span class="comments">;               Y values are sought</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT: </span>
<span class="comments">;       Yint - Interpolated value(s) of Y, same number of points as Xint</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       MISSING - Scalar specifying Yint value(s) to be assigned, when Xint</span>
<span class="comments">;               value(s) are outside of the range of Xtab.     Default is to</span>
<span class="comments">;               truncate the out of range Yint value(s) to the nearest value </span>
<span class="comments">;               of Ytab.   See the help for the INTERPOLATE function.</span>
<span class="comments">; METHOD:</span>
<span class="comments">;       3-point Lagrangian interpolation.  The average of the two quadratics </span>
<span class="comments">;       derived from the four nearest  points is returned in YTAB.   A single</span>
<span class="comments">;       quadratic is used near the end points.   VALUE_LOCATE is used </span>
<span class="comments">;       to locate center point of the interpolation.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       QUADTERP provides one method of high-order interpolation.   The </span>
<span class="comments">;           RSI interpol.pro function includes the following alternatives:</span>
<span class="comments">;</span>
<span class="comments">;       interpol(/LSQUADRATIC) - least squares quadratic fit to a 4 pt </span>
<span class="comments">;               neighborhood</span>
<span class="comments">;       interpol(/QUADRATIC) - quadratic fit to a 3 pt neighborhood</span>
<span class="comments">;       interpol(/SPLINE) - cubic spline fit to a 4 pt neighborhood</span>
<span class="comments">;</span>
<span class="comments">;       Also, the IDL Astro function HERMITE fits a cubic polynomial and its</span>
<span class="comments">;             derivative to the two nearest points. </span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       Unless MISSING keyword is set, points outside the range of Xtab in </span>
<span class="comments">;       which valid quadratics can be computed are returned at the value </span>
<span class="comments">;       of the nearest end point of Ytab (i.e. Ytab[0] and Ytab[NPTS-1] ).</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       A spectrum has been defined using a wavelength vector WAVE and a</span>
<span class="comments">;       flux vector FLUX.  Interpolate onto a new wavelength grid, e.g. </span>
<span class="comments">;</span>
<span class="comments">;       IDL> wgrid = [1540.,1541.,1542.,1543.,1544.,1545.]</span>
<span class="comments">;       IDL> quadterp, wave, flux, wgrid, fgrid </span>
<span class="comments">;     </span>
<span class="comments">;       FGRID will be a 5 element vector containing the quadratically</span>
<span class="comments">;       interpolated values of FLUX at the wavelengths given in WGRID.</span>
<span class="comments">;</span>
<span class="comments">;  EXTERNAL ROUTINES:</span>
<span class="comments">;       ZPARCHECK</span>
<span class="comments">;  REVISION HISTORY:</span>
<span class="comments">;       31 October 1986 by B. Boothman, adapted from the IUE RDAF</span>
<span class="comments">;       12 December 1988 J. Murthy, corrected error in Xint</span>
<span class="comments">;       September 1992, W. Landsman, fixed problem with double precision</span>
<span class="comments">;       August 1993, W. Landsman, added MISSING keyword</span>
<span class="comments">;       June, 1995, W. Landsman, use single quadratic near end points</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Fix occasional problem with integer X table,  </span>
<span class="comments">;       YINT is a scalar if XINT is a scalar   W. Landsman Dec 1999</span>
<span class="comments">;       Use VALUE_LOCATE instead of TABINV W. Landsman  Feb. 2000</span>
<span class="comments">;-</span>
 On_error,2
 compile_opt idl2

 if N_params() LT 4 then begin
     print,'Syntax - QUADTERP, xtab, ytab, xint, yint, [ MISSING = ]'
     return
 endif

 zparcheck,'QUADTERP',xtab,1,[1,2,3,4,5],1,'Independent (X) vector'
 zparcheck,'QUADTERP',ytab,2,[1,2,3,4,5],1,'Dependent (Y) vector'

 npts = min( [N_elements(xtab), N_elements(ytab) ] )
 m = n_elements(xint)

 if size(xtab,/TNAME) NE 'DOUBLE' then xt = float(xtab) else xt = xtab
 
 Xmin = min( [ Xtab[0],Xtab[npts-1] ], max = Xmax)
 u = xint > Xmin &lt<span class="comments">; Xmax </span>

 if npts LT 3 then  $
     message,' ERROR - At least 3 points required for quadratic interpolation'

<span class="comments">; Determine index of data-points from which interpolation is made </span>

        index = value_locate(xtab,xint) > 0L &lt<span class="comments">; (npts-2)</span>

<span class="comments">; First quadratic   </span>
 
        i0 = (index-1) > 0   & i1 = i0+1 & i2 = (i1 +1)
        x0  = xt[i0]  & x1 = xt[i1] & x2 = xt[i2]
        p1 = ytab[i0] * (u-x1) * (u-x2) / ((x0-x1) * (x0-x2)) + $
             ytab[i1] * (u-x0) * (u-x2) / ((x1-x0) * (x1-x2)) + $
             ytab[i2] * (u-x0) * (u-x1) / ((x2-x0) * (x2-x1))

<span class="comments">; Second Quadratic</span>

        i2 = (index+2) &lt<span class="comments">; (npts-1) & i1 = i2-1 & i0 = (i1-1)</span>
        x0  = xt[i0]  & x1 = xt[i1] & x2 = xt[i2]
        p2 =  ytab[i0] * (u-x1) * (u-x2) / ((x0-x1) * (x0-x2)) + $
              ytab[i1] * (u-x0) * (u-x2) / ((x1-x0) * (x1-x2)) + $
              ytab[i2] * (u-x0) * (u-x1) / ((x2-x0) * (x2-x1))
  
  
      yint = (p1 + p2) / 2.    <span class="comments">;Average of two quadratics</span>

  if N_elements(missing) EQ 1 then begin
        bad = where( (Xint LT Xmin) or (Xint GT Xmax ), Nbad)
        if Nbad GT 0 then Yint[bad] = missing
  endif
 

 return
 end
</code>
    </div>
  </body>
</html>