<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:33 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxaddpar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxaddpar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;       FXADDPAR</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;       Add or modify a parameter in a FITS header array.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;       This version of FXADDPAR will write string values longer than 68 </span>
<span class="comments">;       characters using the FITS continuation convention described at </span>
<span class="comments">;       http://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/ofwg_recomm/r13.html</span>
<span class="comments">; Use         : </span>
<span class="comments">;       FXADDPAR, HEADER, NAME, VALUE, COMMENT</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;       HEADER  = String array containing FITS header.  The maximum string</span>
<span class="comments">;                 length must be equal to 80.  If not defined, then FXADDPAR</span>
<span class="comments">;                 will create an empty FITS header array.</span>
<span class="comments">;</span>
<span class="comments">;       NAME    = Name of parameter.  If NAME is already in the header the</span>
<span class="comments">;                 value and possibly comment fields are modified. Otherwise a</span>
<span class="comments">;                 new record is added to the header.  If NAME is equal to</span>
<span class="comments">;                 either "COMMENT" or "HISTORY" then the value will be added to</span>
<span class="comments">;                 the record without replacement.  In this case the comment</span>
<span class="comments">;                 parameter is ignored.</span>
<span class="comments">;</span>
<span class="comments">;       VALUE   = Value for parameter.  The value expression must be of the</span>
<span class="comments">;                 correct type, e.g. integer, floating or string.</span>
<span class="comments">;                 String values of 'T' or 'F' are considered logical</span>
<span class="comments">;                 values unless the /NOLOGICAL keyword is set.  If the value is</span>
<span class="comments">;                 a string and is "long" (more than 69 characters), then it </span>
<span class="comments">;                 may be continued over more than one line using the OGIP </span>
<span class="comments">;                 CONTINUE standard.</span>
<span class="comments">;</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;       COMMENT = String field.  The '/' is added by this routine.  Added</span>
<span class="comments">;                 starting in position 31.  If not supplied, or set equal to ''</span>
<span class="comments">;                 (the null string), then any previous comment field in the</span>
<span class="comments">;                 header for that keyword is retained (when found).</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;       HEADER  = Updated header array.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;       None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;       BEFORE  = Keyword string name.  The parameter will be placed before the</span>
<span class="comments">;                 location of this keyword.  For example, if BEFORE='HISTORY'</span>
<span class="comments">;                 then the parameter will be placed before the first history</span>
<span class="comments">;                 location.  This applies only when adding a new keyword;</span>
<span class="comments">;                 keywords already in the header are kept in the same position.</span>
<span class="comments">;</span>
<span class="comments">;       AFTER   = Same as BEFORE, but the parameter will be placed after the</span>
<span class="comments">;                 location of this keyword.  This keyword takes precedence over</span>
<span class="comments">;                 BEFORE.</span>
<span class="comments">;</span>
<span class="comments">;       FORMAT  = Specifies FORTRAN-like format for parameter, e.g. "F7.3".  A</span>
<span class="comments">;                 scalar string should be used.  For complex numbers the format</span>
<span class="comments">;                 should be defined so that it can be applied separately to the</span>
<span class="comments">;                 real and imaginary parts.      If not supplied, then the IDL</span>
<span class="comments">;                 default formatting is used, except that double precision is</span>
<span class="comments">;                 given a format of G19.12.</span>
<span class="comments">;</span>
<span class="comments">;       /NOCONTINUE = By default, FXADDPAR will break strings longer than 68 </span>
<span class="comments">;                characters into multiple lines using the continuation</span>
<span class="comments">;                convention.    If this keyword is set, then the line will</span>
<span class="comments">;                instead be truncated to 68 characters.    This was the default</span>
<span class="comments">;                behaviour of FXADDPAR prior to December 1999.  </span>
<span class="comments">;</span>
<span class="comments">;      /NOLOGICAL = If set, then the values 'T' and 'F' are not interpreted as</span>
<span class="comments">;                logical values, and are simply added without interpretation.</span>
<span class="comments">;</span>
<span class="comments">;	ERRMSG	 = If defined and passed, then any error messages will be</span>
<span class="comments">;		   returned to the user in this parameter rather than</span>
<span class="comments">;		   depending on the MESSAGE routine in IDL, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXADDPAR, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;       DETABIFY(), FXPAR(), FXPARPOS()</span>
<span class="comments">; Common      : </span>
<span class="comments">;       None.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;       Warning -- Parameters and names are not checked against valid FITS</span>
<span class="comments">;       parameter names, values and types.</span>
<span class="comments">;</span>
<span class="comments">;       The required FITS keywords SIMPLE (or XTENSION), BITPIX, NAXIS, NAXIS1,</span>
<span class="comments">;       NAXIS2, etc., must be entered in order.  The actual values of these</span>
<span class="comments">;       keywords are not checked for legality and consistency, however.</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;       All HISTORY records are inserted in order at the end of the header.</span>
<span class="comments">;</span>
<span class="comments">;       All COMMENT records are also inserted in order at the end of the</span>
<span class="comments">;       header, but before the HISTORY records.  The BEFORE and AFTER keywords</span>
<span class="comments">;       can override this.</span>
<span class="comments">;</span>
<span class="comments">;       All records with no keyword (blank) are inserted in order at the end of</span>
<span class="comments">;       the header, but before the COMMENT and HISTORY records.  The BEFORE and</span>
<span class="comments">;       AFTER keywords can override this.</span>
<span class="comments">;</span>
<span class="comments">;       All other records are inserted before any of the HISTORY, COMMENT, or</span>
<span class="comments">;       "blank" records.  The BEFORE and AFTER keywords can override this.</span>
<span class="comments">;</span>
<span class="comments">;       String values longer than 68 characters will be split into multiple</span>
<span class="comments">;       lines using the OGIP CONTINUE convention, unless the /NOCONTINUE keyword</span>
<span class="comments">;       is set.    For a description of the CONTINUE convention see    </span>
<span class="comments">;       http://fits.gsfc.nasa.gov/registry/continue_keyword.html</span>
<span class="comments">; Category    : </span>
<span class="comments">;       Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;       William Thompson, Jan 1992, from SXADDPAR by D. Lindler and J. Isensee.</span>
<span class="comments">;       Differences include:</span>
<span class="comments">;</span>
<span class="comments">;               * LOCATION parameter replaced with keywords BEFORE and AFTER.</span>
<span class="comments">;               * Support for COMMENT and "blank" FITS keywords.</span>
<span class="comments">;               * Better support for standard FITS formatting of string and</span>
<span class="comments">;                 complex values.</span>
<span class="comments">;               * Built-in knowledge of the proper position of required</span>
<span class="comments">;                 keywords in FITS (although not necessarily SDAS/Geis) primary</span>
<span class="comments">;                 headers, and in TABLE and BINTABLE extension headers.</span>
<span class="comments">;</span>
<span class="comments">;       William Thompson, May 1992, fixed bug when extending length of header,</span>
<span class="comments">;       and new record is COMMENT, HISTORY, or blank.</span>
<span class="comments">; Written     : </span>
<span class="comments">;       William Thompson, GSFC, January 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;       Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;               Incorporated into CDS library.</span>
<span class="comments">;       Version 2, William Thompson, GSFC, 5 September 1997</span>
<span class="comments">;               Fixed bug replacing strings that contain "/" character--it</span>
<span class="comments">;               interpreted the following characters as a comment.</span>
<span class="comments">;       Version 3, Craig Markwardt, GSFC,  December 1997</span>
<span class="comments">;               Allow long values to extend over multiple lines</span>
<span class="comments">;	Version 4, D. Lindler, March 2000, modified to use capital E instead</span>
<span class="comments">;		of a lower case e for exponential format.</span>
<span class="comments">;       Version 4.1 W. Landsman April 2000, make user-supplied format uppercase</span>
<span class="comments">;       Version 4.2 W. Landsman July 2002, positioning of EXTEND keyword</span>
<span class="comments">;       Version 5, 23-April-2007, William Thompson, GSFC</span>
<span class="comments">;       Version 6, 02-Aug-2007, WTT, bug fix for OGIP long lines</span>
<span class="comments">;       Version 6.1, 10-Feb-2009, W. Landsman, increase default format precision</span>
<span class="comments">;       Version 6.2  30-Sep-2009, W. Landsman, added /NOLOGICAL keyword</span>
<span class="comments">; Version     : </span>
<span class="comments">;       Version 6.2, 30-Sep-2009</span>
<span class="comments">;-</span>
<span class="comments">;</span>

<span class="comments">; This is a utility routine, which splits a parameter into several</span>
<span class="comments">; continuation bits.</span>
PRO FXADDPAR_CONTPAR, VALUE, CONTINUED
  
  APOST = "'"
  BLANK = STRING(REPLICATE(32B,80)) <span class="comments">;BLANK line</span>

  <span class="comments">;; The value may not need to be CONTINUEd.  If it does, then split</span>
  <span class="comments">;; out the first value now.  The first value does not have a</span>
  <span class="comments">;; CONTINUE keyword, because it will be grafted onto the proper</span>
  <span class="comments">;; keyword in the calling routine.</span>

  IF (STRLEN(VALUE) GT 68) THEN BEGIN
      CONTINUED = [ STRMID(VALUE, 0, 67)+'&' ]
      VALUE = STRMID(VALUE, 67, STRLEN(VALUE)-67)
  ENDIF ELSE BEGIN
      CONTINUED = [ VALUE ]
      RETURN
  ENDELSE

  <span class="comments">;; Split out the remaining values.</span>
  WHILE( STRLEN(VALUE) GT 0 ) DO BEGIN
      H = BLANK

      <span class="comments">;; Add CONTINUE keyword</span>
      STRPUT, H, 'CONTINUE  '+APOST
      <span class="comments">;; Add the next split</span>
      IF(STRLEN(VALUE) GT 68) THEN BEGIN
          STRPUT, H, STRMID(VALUE, 0, 67)+'&'+APOST, 11
          VALUE = STRMID(VALUE, 67, STRLEN(VALUE)-67)
      ENDIF ELSE BEGIN
          STRPUT, H, VALUE+APOST, 11
          VALUE = ''
      ENDELSE

      CONTINUED = [ CONTINUED, H ]
  ENDWHILE

  RETURN
END

<span class="comments">; Utility routine to add a warning to the file.  The calling routine</span>
<span class="comments">; must ensure that the header is in a consistent state before calling</span>
<span class="comments">; FXADDPAR_CONTWARN because the header will be subsequently modified</span>
<span class="comments">; by calls to FXADDPAR.</span>
PRO FXADDPAR_CONTWARN, HEADER, NAME

<span class="comments">;  By OGIP convention, the keyword LONGSTRN is added to the header as</span>
<span class="comments">;  well.  It should appear before the first occurrence of a long</span>
<span class="comments">;  string encoded with the CONTINUE convention.</span>

  CONTKEY = FXPAR(HEADER, 'LONGSTRN', COUNT = N_LONGSTRN)

<span class="comments">;  Calling FXADDPAR here is okay since the state of the header is</span>
<span class="comments">;  clean now.</span>
  IF N_LONGSTRN GT 0 THEN $
    RETURN

  FXADDPAR, HEADER, 'LONGSTRN', 'OGIP 1.0', $
    ' The OGIP long string convention may be used.', $
    BEFORE=NAME

  FXADDPAR, HEADER, 'COMMENT', $
    ' This FITS file may contain long string keyword values that are', $
    BEFORE=NAME

  FXADDPAR, HEADER, 'COMMENT', $
    " continued over multiple keywords.  This convention uses the  '&'", $
    BEFORE=NAME

  FXADDPAR, HEADER, 'COMMENT', $
    ' character at the end of a string which is then continued', $
    BEFORE=NAME

  FXADDPAR, HEADER, 'COMMENT', $
    " on subsequent keywords whose name = 'CONTINUE'.", $
    BEFORE=NAME

  RETURN
END


PRO FXADDPAR, HEADER, NAME, VALUE, COMMENT, BEFORE=BEFORE,      $
              AFTER=AFTER, FORMAT=FORMAT, NOCONTINUE = NOCONTINUE, $
              ERRMSG=ERRMSG, NOLOGICAL=NOLOGICAL

        ON_ERROR,2                              <span class="comments">;Return to caller</span>
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 3 THEN BEGIN
            MESSAGE = 'Syntax:  FXADDPAR, HEADER, NAME, VALUE [, COMMENT ]'
            GOTO, HANDLE_ERROR
        ENDIF
<span class="comments">;</span>
<span class="comments">; Define a blank line and the END line</span>
<span class="comments">;</span>
        ENDLINE = 'END' + STRING(REPLICATE(32B,77))     <span class="comments">;END line</span>
        BLANK = STRING(REPLICATE(32B,80))               <span class="comments">;BLANK line</span>
<span class="comments">;</span>
<span class="comments">;  If no comment was passed, then use a null string.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 4 THEN COMMENT = ''
<span class="comments">;</span>
<span class="comments">;  Check the HEADER array.</span>
<span class="comments">;</span>
        N = N_ELEMENTS(HEADER)          <span class="comments">;# of lines in FITS header</span>
        IF N EQ 0 THEN BEGIN            <span class="comments">;header defined?</span>
                HEADER=STRARR(36)       <span class="comments">;no, make it.</span>
                HEADER[0]=ENDLINE
                N=36
        ENDIF ELSE BEGIN
                S = SIZE(HEADER)        <span class="comments">;check for string type</span>
                IF (S[0] NE 1) OR (S[2] NE 7) THEN BEGIN
                    MESSAGE = 'FITS Header (first parameter) must be a ' + $
                      'string array'
                    GOTO, HANDLE_ERROR
                ENDIF
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  Make sure NAME is 8 characters long</span>
<span class="comments">;</span>
        NN = STRING(REPLICATE(32B,8))   <span class="comments">;8 char name</span>
        STRPUT,NN,STRUPCASE(NAME)       <span class="comments">;Insert name</span>
<span class="comments">;</span>
<span class="comments">;  Check VALUE.</span>
<span class="comments">;</span>
        S = SIZE(VALUE)         <span class="comments">;get type of value parameter</span>
        STYPE = S[S[0]+1]
        IF S[0] NE 0 THEN BEGIN
                MESSAGE = 'Keyword Value (third parameter) must be scalar'
                GOTO, HANDLE_ERROR
        END ELSE IF STYPE EQ 0 THEN BEGIN
                MESSAGE = 'Keyword Value (third parameter) is not defined'
                GOTO, HANDLE_ERROR
        END ELSE IF STYPE EQ 8 THEN BEGIN
                MESSAGE = 'Keyword Value (third parameter) cannot be structure'
                GOTO, HANDLE_ERROR
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Extract first 8 characters of each line of header, and locate END line</span>
<span class="comments">;</span>
        KEYWRD = STRMID(HEADER,0,8)                     <span class="comments">;Header keywords</span>
        IEND = WHERE(KEYWRD EQ 'END     ',NFOUND)
<span class="comments">;</span>
<span class="comments">;  If no END, then add it.  Either put it after the last non-null string, or</span>
<span class="comments">;  append it to the end.</span>
<span class="comments">;</span>
        IF NFOUND EQ 0 THEN BEGIN
                II = WHERE(STRTRIM(HEADER) NE '',NFOUND)
                II = MAX(II) + 1
                IF (NFOUND EQ 0) OR (II EQ N_ELEMENTS(HEADER)) THEN     $
                        HEADER = [HEADER,ENDLINE] ELSE HEADER[II] = ENDLINE
                KEYWRD = STRMID(HEADER,0,8)
                IEND = WHERE(KEYWRD EQ 'END     ',NFOUND)
        ENDIF
<span class="comments">;</span>
        IEND = IEND[0] > 0                      <span class="comments">;Make scalar</span>
<span class="comments">;</span>
<span class="comments">;  History, comment and "blank" records are treated differently from the</span>
<span class="comments">;  others.  They are simply added to the header array whether there are any</span>
<span class="comments">;  already there or not.</span>
<span class="comments">;</span>
        IF (NN EQ 'COMMENT ') OR (NN EQ 'HISTORY ') OR          $
                        (NN EQ '        ') THEN BEGIN
<span class="comments">;</span>
<span class="comments">;  If the header array needs to grow, then expand it in increments of 36 lines.</span>
<span class="comments">;</span>
                IF IEND GE (N-1) THEN BEGIN
                        HEADER = [HEADER,REPLICATE(BLANK,36)]
                        N = N_ELEMENTS(HEADER)
                ENDIF
<span class="comments">;</span>
<span class="comments">;  Format the record.</span>
<span class="comments">;</span>
                NEWLINE = BLANK
                STRPUT,NEWLINE,NN+STRING(VALUE),0
<span class="comments">;</span>
<span class="comments">;  If a history record, then append to the record just before the end.</span>
<span class="comments">;</span>
                IF NN EQ 'HISTORY ' THEN BEGIN
                        HEADER[IEND] = NEWLINE          <span class="comments">;add history rec.</span>
                        HEADER[IEND+1]=ENDLINE          <span class="comments">;move end up</span>
<span class="comments">;</span>
<span class="comments">;  The comment record is placed immediately after the last previous comment</span>
<span class="comments">;  record, or immediately before the first history record, unless overridden by</span>
<span class="comments">;  either the BEFORE or AFTER keywords.</span>
<span class="comments">;</span>
                END ELSE IF NN EQ 'COMMENT ' THEN BEGIN
                        I = FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE=BEFORE)
                        IF I EQ IEND THEN I =   $
                            FXPARPOS(KEYWRD,IEND,AFTER='COMMENT',$
                                     BEFORE='HISTORY')
                        HEADER[I+1] = HEADER[I:N-2]     <span class="comments">;move rest up</span>
                        HEADER[I] = NEWLINE             <span class="comments">;insert comment</span>
<span class="comments">;</span>
<span class="comments">;  The "blank" record is placed immediately after the last previous "blank"</span>
<span class="comments">;  record, or immediately before the first comment or history record, unless</span>
<span class="comments">;  overridden by either the BEFORE or AFTER keywords.</span>
<span class="comments">;</span>
                END ELSE BEGIN
                        I = FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE=BEFORE)
                        IF I EQ IEND THEN I =   $
                            FXPARPOS(KEYWRD,IEND,AFTER='',BEFORE='COMMENT')&lt<span class="comments">;$</span>
                            FXPARPOS(KEYWRD,IEND,AFTER='',BEFORE='HISTORY')
                        HEADER[I+1] = HEADER[I:N-2]     <span class="comments">;move rest up</span>
                        HEADER[I] = NEWLINE             <span class="comments">;insert "blank"</span>
                ENDELSE
                RETURN
        ENDIF                           <span class="comments">;history/comment/blank</span>
<span class="comments">;</span>
<span class="comments">;  Find location to insert keyword.  If the keyword is already in the header,</span>
<span class="comments">;  then simply replace it.  If no new comment is passed, then retain the old</span>
<span class="comments">;  one.</span>
<span class="comments">;</span>
        IPOS  = WHERE(KEYWRD EQ NN,NFOUND)
        IF NFOUND GT 0 THEN BEGIN
                I = IPOS[0]
                IF COMMENT EQ '' THEN BEGIN
                        SLASH = STRPOS(HEADER[I],'/')
                        QUOTE = STRPOS(HEADER[I],"'")
                        IF (QUOTE GT 0) AND (QUOTE LT SLASH) THEN BEGIN
                                QUOTE = STRPOS(HEADER[I],"'",QUOTE+1)
                                IF QUOTE LT 0 THEN SLASH = -1 ELSE      $
                                        SLASH = STRPOS(HEADER[I],'/',QUOTE+1)
                        ENDIF
                        IF SLASH NE -1 THEN     $
                                COMMENT = STRMID(HEADER[I],SLASH+1,80) ELSE $
                                COMMENT = STRING(REPLICATE(32B,80))
                ENDIF
                GOTO, REPLACE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Start of section dealing with the positioning of required FITS keywords.  If</span>
<span class="comments">;  the keyword is SIMPLE, then it must be at the beginning.</span>
<span class="comments">;</span>
        IF NN EQ 'SIMPLE  ' THEN BEGIN
                I = 0
                GOTO, INSERT
        ENDIF
<span class="comments">;</span>
<span class="comments">;  In conforming extensions, if the keyword is XTENSION, then it must be at the</span>
<span class="comments">;  beginning. </span>
<span class="comments">;</span>
        IF NN EQ 'XTENSION' THEN BEGIN
                I = 0
                GOTO, INSERT
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is BITPIX, then it must follow the either SIMPLE or XTENSION</span>
<span class="comments">;  keyword.</span>
<span class="comments">;</span>
        IF NN EQ 'BITPIX  ' THEN BEGIN
                IF (KEYWRD[0] NE 'SIMPLE  ') AND                $
                        (KEYWRD[0] NE 'XTENSION') THEN BEGIN
                    MESSAGE = 'Header must start with either SIMPLE or XTENSION'
                    GOTO, HANDLE_ERROR
                ENDIF
                I = 1
                GOTO, INSERT
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is NAXIS, then it must follow the BITPIX keyword.</span>
<span class="comments">;</span>
        IF NN EQ 'NAXIS   ' THEN BEGIN
                IF KEYWRD[1] NE 'BITPIX  ' THEN BEGIN
                    MESSAGE = 'Required BITPIX keyword not found'
                    GOTO, HANDLE_ERROR
                ENDIF
                I = 2
                GOTO, INSERT
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is NAXIS1, then it must follow the NAXIS keyword.</span>
<span class="comments">;</span>
        IF NN EQ 'NAXIS1  ' THEN BEGIN
                IF KEYWRD[2] NE 'NAXIS   ' THEN BEGIN
                    MESSAGE = 'Required NAXIS keyword not found'
                    GOTO, HANDLE_ERROR
                ENDIF
                I = 3
                GOTO, INSERT
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is NAXIS&lt;n>, then it must follow the NAXIS&lt;n-1> keyword.</span>
<span class="comments">;</span>
        IF STRMID(NN,0,5) EQ 'NAXIS' THEN BEGIN
                NUM_AXIS = FIX(STRMID(NN,5,3))
                PREV = STRING(REPLICATE(32B,8))         <span class="comments">;Format NAXIS&lt;n-1></span>
                STRPUT,PREV,'NAXIS',0                   <span class="comments">;Insert NAXIS</span>
                STRPUT,PREV,STRTRIM(NUM_AXIS-1,2),5     <span class="comments">;Insert &lt;n-1></span>
                IF KEYWRD[NUM_AXIS+1] NE PREV THEN BEGIN
                    MESSAGE = 'Required '+PREV+' keyword not found'
                    GOTO, HANDLE_ERROR
                ENDIF
                I = NUM_AXIS + 2
                GOTO, INSERT
        ENDIF

<span class="comments">;</span>
<span class="comments">;  If the keyword is EXTEND, then it must follow the last NAXIS* keyword.</span>
<span class="comments">;</span>

        IF NN EQ 'EXTEND  ' THEN BEGIN
                IF KEYWRD[2] NE 'NAXIS   ' THEN BEGIN
                    MESSAGE = 'Required NAXIS keyword not found'
                    GOTO, HANDLE_ERROR
                ENDIF
                FOR I = 3, N-2 DO $   
                    IF STRMID(KEYWRD[I],0,5) NE 'NAXIS' THEN GOTO, INSERT 
                   
         ENDIF
    
<span class="comments">;</span>
<span class="comments">;  If the first keyword is XTENSION, and has the value of either 'TABLE' or</span>
<span class="comments">;  'BINTABLE', then there are some additional required keywords.</span>
<span class="comments">;</span>
        IF KEYWRD[0] EQ 'XTENSION' THEN BEGIN
                XTEN = FXPAR(HEADER,'XTENSION')
                IF (XTEN EQ 'TABLE   ') OR (XTEN EQ 'BINTABLE') THEN BEGIN
<span class="comments">;</span>
<span class="comments">;  If the keyword is PCOUNT, then it must follow the NAXIS2 keyword.</span>
<span class="comments">;</span>
                        IF NN EQ 'PCOUNT  ' THEN BEGIN
                                IF KEYWRD[4] NE 'NAXIS2  ' THEN BEGIN
                                    MESSAGE = 'Required NAXIS2 keyword not found'
                                    GOTO, HANDLE_ERROR
                                ENDIF
                                I = 5
                                GOTO, INSERT
                        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is GCOUNT, then it must follow the PCOUNT keyword.</span>
<span class="comments">;</span>
                        IF NN EQ 'GCOUNT  ' THEN BEGIN
                                IF KEYWRD[5] NE 'PCOUNT  ' THEN BEGIN
                                    MESSAGE = 'Required PCOUNT keyword not found'
                                    GOTO, HANDLE_ERROR
                                ENDIF
                                I = 6
                                GOTO, INSERT
                        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the keyword is TFIELDS, then it must follow the GCOUNT keyword.</span>
<span class="comments">;</span>
                        IF NN EQ 'TFIELDS ' THEN BEGIN
                                IF KEYWRD[6] NE 'GCOUNT  ' THEN BEGIN
                                    MESSAGE = 'Required GCOUNT keyword not found'
                                    GOTO, HANDLE_ERROR
                                ENDIF
                                I = 7
                                GOTO, INSERT
                        ENDIF
                ENDIF
        ENDIF
<span class="comments">;</span>
<span class="comments">;  At this point the location has not been determined, so a new line is added</span>
<span class="comments">;  at the end of the FITS header, but before any blank, COMMENT, or HISTORY</span>
<span class="comments">;  keywords, unless overridden by the BEFORE or AFTER keywords.</span>
<span class="comments">;</span>
        I = FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE=BEFORE)
        IF I EQ IEND THEN I =                                     $
            FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE='')         &lt<span class="comments">; $</span>
            FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE='COMMENT')  &lt<span class="comments">; $</span>
            FXPARPOS(KEYWRD,IEND,AFTER=AFTER,BEFORE='HISTORY')
<span class="comments">;</span>
<span class="comments">;  A new line needs to be added.  First check to see if the length of the</span>
<span class="comments">;  header array needs to be extended.  Then insert a blank record at the proper</span>
<span class="comments">;  place.</span>
<span class="comments">;</span>
INSERT:
        IF IEND EQ (N-1) THEN BEGIN
                HEADER = [HEADER,REPLICATE(BLANK,36)]
                N = N_ELEMENTS(HEADER)
        ENDIF
        HEADER[I+1] = HEADER[I:N-2]
        HEADER[I] = BLANK
        IEND = IEND + 1        <span class="comments">; CM 24 Sep 1997</span>
<span class="comments">;</span>
<span class="comments">;  Now put value into keyword at line I.</span>
<span class="comments">;</span>
REPLACE: 
        H=BLANK                 <span class="comments">;80 blanks</span>
        STRPUT,H,NN+'= '        <span class="comments">;insert name and =.</span>
        APOST = "'"             <span class="comments">;quote (apostrophe) character</span>
        TYPE = SIZE(VALUE)      <span class="comments">;get type of value parameter</span>
<span class="comments">;</span>
<span class="comments">;  Store the value depending on the data type.  If a character string, first</span>
<span class="comments">;  check to see if it is one of the logical values "T" (true) or "F" (false).</span>
<span class="comments">;</span>

        IF TYPE[1] EQ 7 THEN BEGIN              <span class="comments">;which type?</span>
                UPVAL = STRUPCASE(VALUE)        <span class="comments">;force upper case.</span>
                IF ~KEYWORD_SET(NOLOGICAL)  $ 
		   &&  ((UPVAL EQ 'T') OR (UPVAL EQ 'F')) THEN BEGIN
                        STRPUT,H,UPVAL,29       <span class="comments">;insert logical value.</span>
<span class="comments">;</span>
<span class="comments">;  Otherwise, remove any tabs, and check for any apostrophes in the string.</span>
<span class="comments">;</span>
                END ELSE BEGIN
                        VAL = DETABIFY(VALUE)
                        NEXT_CHAR = 0
                        REPEAT BEGIN
                                AP = STRPOS(VAL,"'",NEXT_CHAR)
                                IF AP GE 66 THEN BEGIN
                                        VAL = STRMID(VAL,0,66)
                                END ELSE IF AP GE 0 THEN BEGIN
                                        VAL = STRMID(VAL,0,AP+1) + APOST + $
                                          STRMID(VAL,AP+1,80)
                                        NEXT_CHAR = AP + 2
                                ENDIF
                        ENDREP UNTIL AP LT 0

<span class="comments">;</span>
<span class="comments">;  If a long string, then add the comment as soon as possible.</span>
<span class="comments">;</span>
<span class="comments">; CM 24 Sep 1997</span>
<span class="comments">;  Separate parameter if it needs to be CONTINUEd.</span>
<span class="comments">;</span>
                        IF NOT KEYWORD_SET(NOCONTINUE) THEN $
                             FXADDPAR_CONTPAR, VAL, CVAL  ELSE $
                             CVAL = STRMID(VAL,0,68)
                        K = I + 1
                        <span class="comments">;; See how many CONTINUE lines there already are</span>
                        WHILE K LT IEND DO BEGIN
                            IF STRMID(HEADER[K],0,8) NE 'CONTINUE' THEN $
                              GOTO, DONE_CHECK_CONT
                            K = K + 1
                        ENDWHILE
                        
                        DONE_CHECK_CONT:
                        NOLDCONT = K - I - 1
                        NNEWCONT = N_ELEMENTS(CVAL) - 1

                        <span class="comments">;; Insert new lines if needed</span>
                        IF NNEWCONT GT NOLDCONT THEN BEGIN
                            INS = NNEWCONT - NOLDCONT
                            WHILE IEND+INS GE N DO BEGIN
                                HEADER = [HEADER, REPLICATE(BLANK,36)]
                                N = N_ELEMENTS(HEADER)
                            ENDWHILE
                        ENDIF 

                        <span class="comments">;; Shift the old lines properly</span>
                        IF NNEWCONT NE NOLDCONT THEN $
                          HEADER[I+NNEWCONT+1] = HEADER[I+NOLDCONT+1:IEND]
                        IEND = IEND + NNEWCONT - NOLDCONT

                        <span class="comments">;; Blank out any lines at the end if needed</span>
                        IF NNEWCONT LT NOLDCONT THEN BEGIN
                            DEL = NOLDCONT - NNEWCONT
                            HEADER[IEND+1:IEND+DEL] = REPLICATE('', DEL)
                        ENDIF

                        IF STRLEN(CVAL[0]) GT 18 THEN BEGIN
                            STRPUT,H,APOST+STRMID(CVAL[0],0,68)+APOST+ $
                              ' /'+COMMENT,10
                            HEADER[I]=H
                                
<span class="comments">;  There might be a continuation of this string.  CVAL would contain</span>
<span class="comments">;  more than one element if that is so.</span>
                            
                            <span class="comments">;; Add new continuation lines</span>
                            IF N_ELEMENTS(CVAL) GT 1 THEN BEGIN
                              HEADER[I+1] = CVAL[1:*]
                            
                            <span class="comments">;; Header state is now clean, so add</span>
                            <span class="comments">;; warning to header</span>

                               FXADDPAR_CONTWARN, HEADER, NAME
                            ENDIF
                            DONE_CONT:
                            RETURN
<span class="comments">;</span>
<span class="comments">;  If a short string, then pad out to at least eight characters.</span>
<span class="comments">;</span>
                        END ELSE BEGIN
                                STRPUT,H,APOST+CVAL[0],10
                                STRPUT,H,APOST,11+(STRLEN(CVAL[0])>8)
                        ENDELSE

                    ENDELSE
<span class="comments">;</span>
<span class="comments">;  If complex, then format the real and imaginary parts, and add the comment</span>
<span class="comments">;  beginning in column 51.</span>
<span class="comments">;</span>
        END ELSE IF TYPE[1] EQ 6 THEN BEGIN
                IF N_ELEMENTS(FORMAT) EQ 1 THEN BEGIN   <span class="comments">;use format keyword</span>
                        VR = STRING(FLOAT(VALUE),    '('+STRUPCASE(FORMAT)+')')
                        VI = STRING(IMAGINARY(VALUE),'('+STRUPCASE(FORMAT)+')')
                 END ELSE BEGIN
                        VR = STRTRIM(FLOAT(VALUE),2)
                        VI = STRTRIM(IMAGINARY(VALUE),2)
                ENDELSE
                SR = STRLEN(VR)  &  STRPUT,H,VR,(30-SR)>10
                SI = STRLEN(VI)  &  STRPUT,H,VI,(50-SI)>30
                STRPUT,H,' /'+COMMENT,50
                HEADER[I] = H
                RETURN
<span class="comments">;</span>
<span class="comments">;  If not complex or a string, then format according to either the FORMAT</span>
<span class="comments">;  keyword, or the default for that datatype.</span>
<span class="comments">;</span>
        END ELSE BEGIN
                IF (N_ELEMENTS(FORMAT) EQ 1) THEN $ <span class="comments">;use format keyword</span>
                        V = STRING(VALUE,'('+STRUPCASE(FORMAT)+')' ) ELSE BEGIN
			IF TYPE[1] EQ 5 THEN $
			V = STRING(VALUE,FORMAT='(G19.12)') ELSE $
                        V = STRTRIM(strupcase(VALUE),2)    <span class="comments">;default format</span>
			ENDELSE
                S = STRLEN(V)                 <span class="comments">;right justify</span>
                STRPUT,H,V,(30-S)>10          <span class="comments">;insert</span>
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  Add the comment, and store the completed line in the header.</span>
<span class="comments">;</span>
        STRPUT,H,' /',30        <span class="comments">;add ' /'</span>
        STRPUT,H,COMMENT,32     <span class="comments">;add comment</span>
        HEADER[I]=H             <span class="comments">;save line</span>
<span class="comments">;</span>
        ERRMSG = ''
        RETURN
<span class="comments">;</span>
<span class="comments">;  Error handling point.</span>
<span class="comments">;</span>
HANDLE_ERROR:
	IF ARG_PRESENT(ERRMSG) THEN ERRMSG = 'FXADDPAR: ' + MESSAGE	$
		ELSE MESSAGE, MESSAGE
        RETURN
        END

</code>
    </div>
  </body>
</html>