<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:13 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>wherenan.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="wherenan.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">        FUNCTION WHERENAN, ARRAY, COUNT
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      WHERENAN()</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Find the indices of all big-endian NaN values in an array.  OBSOLETE</span>
<span class="comments">; EXPLANATION: </span>
<span class="comments">;      Find the positions of all values within an array that correspond to the</span>
<span class="comments">;      big-endian NaN (not-a-number) special values.    </span>
<span class="comments">;</span>
<span class="comments">;      THIS PROCEDURE ONLY IDENTIFIES BIG_ENDIAN NaN VALUES.  DO NOT USE IT </span>
<span class="comments">;      TO IDENTIFY NaN VALUES IN GENERAL.   Instead, to identify NaN values on </span>
<span class="comments">;      the host machine use the FINITE() function </span>
<span class="comments">;</span>
<span class="comments">;      IDL>     result = where( finite(array,/NAN) )</span>
<span class="comments">;       </span>
<span class="comments">;      The main purpose of this routine is to catch  NaN special values </span>
<span class="comments">;      written in big_endian format (e.g. FITS data) on a little endian </span>
<span class="comments">;      machine prior to conversion with e.g. IEEE_TO_HOST.    It was needed</span>
<span class="comments">;      many years ago because VMS machines could not handle big-endian </span>
<span class="comments">;      special values, but this routine is now kept only for backwards </span>
<span class="comments">;      compatibility.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      Result = WHERENAN( ARRAY [, COUNT ] )</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;      ARRAY   = Array to test against the IEEE NaN special values.  Must be</span>
<span class="comments">;                of either floating point, double-precision, or complex type.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;      The result of the function is the indices of all values of ARRAY</span>
<span class="comments">;      corresponding to the IEEE NaN specification, similar to the IDL WHERE</span>
<span class="comments">;      function.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT PARAMETERS:</span>
<span class="comments">;      COUNT   = Number of values found corresponding to IEEE NaN.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;      If no NaN values are found, or if ARRAY is not of type float, double</span>
<span class="comments">;      precision, or complex, then -1 is returned, and COUNT is set to 0.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;      ARRAY must be of type float, double-precision, or complex.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;      The bit patterns of the numbers being tested are compared against the</span>
<span class="comments">;      IEEE NaN standard.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;      William Thompson, Feb. 1992.</span>
<span class="comments">;      William Thompson, Oct. 1992, fixed bug regarding order of bytes on VAX</span>
<span class="comments">;              machines.</span>
<span class="comments">;      Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
<span class="comments">;</span>
        ON_ERROR,2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 1 THEN MESSAGE,        $
                'Syntax:  Result = WHERENAN(ARRAY [,COUNT])'
<span class="comments">;</span>
<span class="comments">;  Parse the input array based on the datatype.</span>
<span class="comments">;</span>
        SZ = SIZE(ARRAY)
        CASE SZ[SZ[0]+1] OF
<span class="comments">;</span>
<span class="comments">;  Single precision floating point.</span>
<span class="comments">;</span>
                4:  BEGIN
                        LARRAY = LONG(ARRAY,0,N_ELEMENTS(ARRAY))
                        BYTEORDER,LARRAY,/NTOHL
                        E0 = '7F800000'X
                        E = LARRAY AND E0
                        F = LARRAY AND '7FFFFF'X
                        RESULT = WHERE((E EQ E0) AND (F NE 0), COUNT)
                        END
<span class="comments">;</span>
<span class="comments">;  Double precision floating point.</span>
<span class="comments">;</span>
                5:  BEGIN
                        LARRAY = LONG(ARRAY,0,2,N_ELEMENTS(ARRAY))
                        BYTEORDER,LARRAY,/NTOHL
                        E0 = '7FF00000'X
                        E = LARRAY[0,*] AND E0
                        F1 = LARRAY[0,*] AND 'FFFFF'X
                        RESULT = WHERE((E EQ E0) AND ((F1 NE 0) OR      $
                                (LARRAY[1,*] NE 0)), COUNT)
                        END
<span class="comments">;</span>
<span class="comments">;  Single precision complex floating point.</span>
<span class="comments">;</span>
                6:  BEGIN
                        LARRAY = LONG(ARRAY,0,2,N_ELEMENTS(ARRAY))
                        BYTEORDER,LARRAY,/NTOHL
                        E0 = '7F800000'X
                        E1 = LARRAY[0,*] AND E0
                        E2 = LARRAY[1,*] AND E0
                        F1 = LARRAY[0,*] AND '7FFFFF'X
                        F2 = LARRAY[1,*] AND '7FFFFF'X
                        RESULT = WHERE(((E1 EQ E0) AND (F1 NE 0)) OR    $
                                ((E2 EQ E0) AND (F2 NE 0)), COUNT)
                        END
                ELSE:  BEGIN
                        MESSAGE,'Data type must be floating point',/INFORMATIONAL
                        RESULT = -1
                        COUNT = 0
                        END
        ENDCASE
<span class="comments">;</span>
        RETURN, RESULT
        END
</code>
    </div>
  </body>
</html>