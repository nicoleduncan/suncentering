<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:31 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>forprint.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="forprint.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="forprint:source"></a>pro forprint, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, $
      v15,v16,v17,v18,TEXTOUT = textout, FORMAT = format, SILENT = SILENT, $ 
      STARTLINE = startline, NUMLINE = numline, COMMENT = comment, $
      SUBSET = subset, NoCOMMENT=Nocomment,STDOUT=stdout, WIDTH=width
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FORPRINT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Print a set of vectors by looping over each index value.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       If W and F are equal length vectors, then the statement</span>
<span class="comments">;               IDL> forprint, w, f   </span>
<span class="comments">;       is equivalent to </span>
<span class="comments">;               IDL> for i = 0L, N_elements(w)-1 do print,w[i],f[i]    </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       forprint, v1,[ v2, v3, v4,....v18, FORMAT = , TEXTOUT = ,STARTLINE =,</span>
<span class="comments">;                                  SUBSET=, NUMLINE =, /SILENT, COMMENT= ] </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       V1,V2,...V18 - Arbitary IDL vectors.  If the vectors are not of</span>
<span class="comments">;               equal length then the number of rows printed will be equal</span>
<span class="comments">;               to the length of the smallest vector.   Up to 18 vectors</span>
<span class="comments">;               can be supplied.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;       TEXTOUT - Controls print output device, defaults to !TEXTOUT</span>
<span class="comments">;</span>
<span class="comments">;               textout=1       TERMINAL using /more option if available</span>
<span class="comments">;               textout=2       TERMINAL without /more option</span>
<span class="comments">;               textout=3       file 'forprint.prt'</span>
<span class="comments">;               textout=4       file 'laser.tmp' </span>
<span class="comments">;               textout=5      user must open file</span>
<span class="comments">;               textout =      filename (default extension of .prt)</span>
<span class="comments">;               textout=7       Append to &lt;program>.prt file if it exists</span>
<span class="comments">;</span>
<span class="comments">;       COMMENT - String scalar or vector to write to the first line of output </span>
<span class="comments">;                file if  TEXTOUT > 2.    By default, FORPRINT will write a time</span>
<span class="comments">;                stamp on the first line.   Use /NOCOMMENT if you don't want </span>
<span class="comments">;                FORPRINT to write anything in the output file.    If COMMENT</span>
<span class="comments">;                is a vector then one line will be written for each element.</span>
<span class="comments">;       FORMAT - Scalar format string as in the PRINT procedure.  The use</span>
<span class="comments">;               of outer parenthesis is optional.   Ex. - format="(F10.3,I7)"</span>
<span class="comments">;               This program will automatically remove a leading "$" from</span>
<span class="comments">;               incoming format statements. Ex. - "$(I4)" would become "(I4)".</span>
<span class="comments">;               If omitted, then IDL default formats are used.</span>
<span class="comments">;       /NOCOMMENT  - Set this keyword if you don't want any comment line</span>
<span class="comments">;               line written as the first line in a harcopy output file.</span>
<span class="comments">;       /SILENT - Normally, with a hardcopy output (TEXTOUT > 2), FORPRINT will</span>
<span class="comments">;                print an informational message.    If the SILENT keyword</span>
<span class="comments">;               is set and non-zero, then this message is suppressed.</span>
<span class="comments">;       SUBSET - Index vector specifying elements to print.   No error checking</span>
<span class="comments">;               is done to make sure the indicies are valid.  The statement</span>
<span class="comments">;</span>
<span class="comments">;              IDL> forprint,x,y,z,subset=s</span>
<span class="comments">;                       is equivalent to </span>
<span class="comments">;              IDL> for i=0,n-1 do print, x[s[i]], y[s[i]], z[s[i]]</span>
<span class="comments">;</span>
<span class="comments">;       STARTLINE - Integer scalar specifying the first line in the arrays</span>
<span class="comments">;               to print.   Default is STARTLINE = 1, i.e. start at the</span>
<span class="comments">;               beginning of the arrays.    (If a SUBSET keyword is supplied</span>
<span class="comments">;               then STARTLINE refers to first element in the subscript vector.)</span>
<span class="comments">;      /STDOUT - If set, the force standard output unit (=-1) if not writing </span>
<span class="comments">;               to a file.   This allows the FORPINT output to be captured</span>
<span class="comments">;               in a journal file.    Only needed for non-GUI terminals </span>
<span class="comments">;       WIDTH - Line width for wrapping, passed onto OPENW when using hardcopy.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       None</span>
<span class="comments">; SYSTEM VARIABLES:</span>
<span class="comments">;       If keyword TEXTOUT is not used, the default is the nonstandard </span>
<span class="comments">;       keyword !TEXTOUT.    If you want to use FORPRINT to write more than </span>
<span class="comments">;       once to the same file, or use a different file name then set </span>
<span class="comments">;       TEXTOUT=5, and open and close then file yourself (see documentation </span>
<span class="comments">;       of TEXTOPEN for more info).</span>
<span class="comments">;       </span>
<span class="comments">;       One way to add the non-standard system variables !TEXTOUT and !TEXTUNIT</span>
<span class="comments">;       is to use the procedure ASTROLIB</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Suppose W,F, and E are the wavelength, flux, and epsilon vectors for</span>
<span class="comments">;       a spectrum.   Print these values to a file 'output.dat' in a nice </span>
<span class="comments">;       format.</span>
<span class="comments">;</span>
<span class="comments">;       IDL> fmt = '(F10.3,1PE12.2,I7)'</span>
<span class="comments">;       IDL> forprint, F = fmt, w, f, e, TEXT = 'output.dat'</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       TEXTOPEN, TEXTCLOSE</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written    W. Landsman             April, 1989</span>
<span class="comments">;       Keywords textout and format added, J. Isensee, July, 1990</span>
<span class="comments">;       Made use of parenthesis in FORMAT optional  W. Landsman  May 1992</span>
<span class="comments">;       Added STARTLINE keyword W. Landsman    November 1992</span>
<span class="comments">;       Set up so can handle 18 input vectors. J. Isensee, HSTX Corp. July 1993</span>
<span class="comments">;       Handle string value of TEXTOUT   W. Landsman, HSTX September 1993</span>
<span class="comments">;       Added NUMLINE keyword            W. Landsman, HSTX February 1996</span>
<span class="comments">;       Added SILENT keyword             W. Landsman, RSTX, April 1998</span>
<span class="comments">;       Much faster printing to a file   W. Landsman, RITSS, August, 2001</span>
<span class="comments">;       Use SIZE(/TNAME) instead of DATATYPE() W. Landsman SSAI October 2001</span>
<span class="comments">;       Fix skipping of first line bug introduced Aug 2001  W. Landsman Nov2001</span>
<span class="comments">;       Added /NOCOMMENT keyword, the SILENT keyword now controls only </span>
<span class="comments">;       the display of informational messages.  W. Landsman June 2002</span>
<span class="comments">;       Skip PRINTF if IDL in demo mode  W. Landsman  October 2004</span>
<span class="comments">;       Assume since V5.4 use BREAK instead of GOTO W. Landsman April 2006</span>
<span class="comments">;       Add SUBSET keyword, warning if different size vectors passed. </span>
<span class="comments">;                                     P.Broos,W.Landsman. Aug 2006</span>
<span class="comments">;       Change keyword_set() to N_elements W. Landsman  Oct 2006</span>
<span class="comments">;       Added /STDOUT keyword  W. Landsman Oct 2006</span>
<span class="comments">;       Fix error message for undefined variable W. Landsman  April 2007</span>
<span class="comments">;       Added WIDTH keyword    J. Bailin  Nov 2010</span>
<span class="comments">;       Allow multiple (vector) comment lines  W. Landsman April 2011</span>
<span class="comments">;-            </span>
  On_error,2                               <span class="comments">;Return to caller</span>
  compile_opt idl2

  npar = N_params()
  if npar EQ 0 then begin
      print,'Syntax - FORPRINT, v1, [ v2, v3,...v18, FORMAT =, /SILENT, SUBSET='
      print,'      /NoCOMMENT, COMMENT =, STARTLINE = , NUMLINE =, TEXTOUT =, WIDTH =]'
      return
  endif

  if ~keyword_set( STARTLINE ) then startline = 1l else $
         startline = startline > 1l 

  fmt="F"                 <span class="comments">;format flag</span>
  npts = N_elements(v1)

  if ( npts EQ 0 ) then message,'ERROR - Parameter 1 is not defined'

<span class="comments">;  Remove "$" sign from format string and append parentheses if not </span>
<span class="comments">;  already present</span>

  if N_elements( format ) EQ 1 then begin

     fmt = "T"                                 <span class="comments">;format present</span>
     frmt = format            
     if strmid(frmt,0,1) eq '$' then $
          frmt = strmid(frmt,1,strlen(frmt)-1) <span class="comments">;rem. '$' from format if present</span>

     if strmid(frmt,0,1) NE '(' then frmt = '(' + frmt
     if strmid( frmt,strlen(frmt)-1,1) NE ')' then frmt = frmt + ')'

  endif

  if npar GT 1 then begin         <span class="comments">;Get number of elements in smallest array</span>

      for i = 2, npar do begin 
          tst = execute('this_npts =  N_elements(v'+strtrim(i,2)+')')
          if this_npts EQ 0 then $
              message,'ERROR - Parameter ' + strtrim(i,2) + ' is not defined'
          
          if ((npts NE this_npts) && ~keyword_set(silent)) then $
            message,/INF,'Warning, vectors have different lengths.' 
          
          npts = npts &lt<span class="comments">; this_npts</span>
      endfor

  endif

  if keyword_set(NUMLINE) then npts = (startline + numline-1) &lt<span class="comments">; npts</span>

  if N_Elements(SUBSET) GT 0 then begin
       npts = N_elements(subset) &lt<span class="comments">; npts</span>
       index = '[subset[i]]'
  endif else index = '[i]'  
     
  
  str = 'v1'  + index
  if npar GT 1 then $
       for i = 2, npar do str = str + ',v' + strtrim(i,2) + index

<span class="comments">; Use default output dev.</span>
   demo = lmgr(/demo)
   if ~demo then begin 

   if ~keyword_set( TEXTOUT ) then textout = !TEXTOUT 
   if size( textout,/TNAME) EQ 'STRING' then text_out = 6  $      <span class="comments">;make numeric</span>
                                  else text_out = textout

   textopen,'FORPRINT',TEXTOUT=textout,SILENT=silent,STDOUT=STDOUT, $
       MORE_SET = more_set, WIDTH=width
   if ( text_out GT 2 ) && (~keyword_set(NOCOMMENT)) then begin
       Ncomm = N_elements(comment)
       if Ncomm GT 0 then $
        for i=0,ncomm-1 do printf,!TEXTUNIT,comment[i] else $
        printf,!TEXTUNIT,'FORPRINT: ',systime()
  endif 
  endif
 
   if fmt EQ "F" then begin            <span class="comments">;Use default formats</span>

   if demo then begin
         test =  execute('for i=startline-1,npts-1 do print,' + str)
        
   endif else if more_set then begin      
      for i = startline-1, npts-1 do begin 

          test = execute('printf,!TEXTUNIT,' + str) 
               if !ERR EQ 1 then BREAK       <span class="comments">;Did user press 'Q' key?</span>

      endfor
   endif else test = $
          execute('for i=startline-1,npts-1 do printf,!TEXTUNIT,' + str)

   endif else begin                    <span class="comments">;User specified format</span>

   if demo then begin
         test =  execute('for i=startline-1,npts-1 do print,FORMAT=frmt,' + str)
 
   endif else  if more_set then begin

      for i = startline-1, npts-1 do begin 

         test = execute( 'printf, !TEXTUNIT,  FORMAT=frmt,' + str ) 
                if !ERR EQ 1 then BREAK

      endfor

    endif else test = $
        execute('for i=startline-1,npts-1 do printf,!TEXTUNIT,FORMAT=frmt,'+str)
        

  endelse


  textclose, TEXTOUT = textout          <span class="comments">;Close unit opened by TEXTOPEN</span>

  return
  end
</code>
    </div>
  </body>
</html>