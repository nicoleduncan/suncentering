<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:20 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>checksum32.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="checksum32.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="checksum32:source"></a>pro checksum32, array, checksum, FROM_IEEE = from_IEEE, NOSAVE = nosave
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       CHECKSUM32</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       To compute the 32bit checksum of an array (ones-complement arithmetic)</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       The 32bit checksum is adopted in the FITS Checksum convention</span>
<span class="comments">;       http://heasarc.gsfc.nasa.gov/docs/heasarc/fits/checksum.html</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       CHECKSUM32, array, checksum, [/FROM_IEEE, /NoSAVE]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       array - any numeric idl array.  If the number of bytes in the array is </span>
<span class="comments">;               not a multiple of four then it is padded with zeros internally</span>
<span class="comments">;               (the array is returned unchanged).   Convert a string array </span>
<span class="comments">;               (e.g. a FITS header) to bytes prior to calling CHECKSUM32.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       checksum - unsigned long scalar, giving sum of array elements using </span>
<span class="comments">;                  ones-complement arithmetic</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;</span>
<span class="comments">;      /FROM_IEEE - If this keyword is set, then the input is assumed to be in</span>
<span class="comments">;           big endian format (e.g. an untranslated FITS array).   This keyword</span>
<span class="comments">;           only has an effect on little endian machines (e.g. Linux boxes).</span>
<span class="comments">;</span>
<span class="comments">;      /NoSAVE - if set, then the input array is not saved upon exiting.   Use </span>
<span class="comments">;           the /NoSave keyword to save time if the input array is not needed </span>
<span class="comments">;           in further computations. </span>
<span class="comments">; METHOD:</span>
<span class="comments">;       Uses TOTAL() to sum the array into a double precision variable.  The</span>
<span class="comments">;       overflow bits beyond 2^32 are then shifted back to the least significant</span>
<span class="comments">;       bits.    Due to the limited precision of a DOUBLE variable, the summing</span>
<span class="comments">;       is done in chunks determined by MACHAR(). Adapted from FORTRAN code in</span>
<span class="comments">;      heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node30.html</span>
<span class="comments">;</span>
<span class="comments">;      Could probably be done in a cleverer way (similar to the C</span>
<span class="comments">;      implementation) but then the array-oriented TOTAL() function could not </span>
<span class="comments">;      be used.</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1) Not valid for object or pointer data types</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Find the 32 bit checksum of the array x = findgen(35)</span>
<span class="comments">;</span>
<span class="comments">;       IDL> checksum32, x, s    ===> s =  2920022024</span>
<span class="comments">; FUNCTION CALLED:</span>
<span class="comments">;       HOST_TO_IEEE, IS_IEEE_BIG(), N_BYTES()</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written    W. Landsman          June 2001</span>
<span class="comments">;       Work correctly on little endian machines, added /FROM_IEEE and /NoSave</span>
<span class="comments">;                  W. Landsman          November 2002</span>
<span class="comments">;       Pad with zeros when array size not a multiple of 4 W.Landsman Aug 2003</span>
<span class="comments">;       Always copy to new array, somewhat slower but more robust algorithm</span>
<span class="comments">;           especially for Linux boxes   W. Landsman Sep. 2004 </span>
<span class="comments">;       Sep. 2004 update not implemented correctly (sigh) W. Landsman Dec 2004         </span>
<span class="comments">;       No need to byteswap 4 byte datatypes on little endian W. L. May 2009</span>
<span class="comments">;       Use /INTEGER keyword to TOTAL() function W.L. June 2009</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
 if N_params() LT 2 then begin
      print,'Syntax - CHECKSUM32, array, checksum, /FROM_IEEE, /NoSAVE'
      return
 endif
 idltype = size(array,/type)

<span class="comments">; Convert data to byte.  If array size is not a multiple of 4, then we pad with</span>
<span class="comments">; zeros </span>

 N = N_bytes(array)
 Nremain = N mod 4
 if Nremain GT 0 then begin 
     if keyword_set(nosave) then $
           uarray = [ byte(temporary(array),0,N), bytarr(4-Nremain)]  $
           else uarray =  [ byte(array,0,N), bytarr(4-Nremain)] 
      N = N + 4 - Nremain 
 endif else  begin 
      if keyword_set(nosave) then $
           uarray =  byte( temporary(array) ,0,N) else $
           uarray =  byte( array ,0,N) 
 endelse
 	    
<span class="comments">; Get maximum number of base 2 digits available in double precision, and </span>
<span class="comments">; compute maximum number of longword values that can be coadded without losing</span>
<span class="comments">; any precision.    Since we will sum unsigned longwords, the original array</span>
<span class="comments">; must be byteswapped as longwords.</span>

 maxnum = long64(2)^31       
 Niter =  (N-1)/maxnum
 checksum = long64(0)
  word32 =  long64(2)^32
  bswap  = ~is_ieee_big()
  if bswap then begin
       if ~keyword_set( from_ieee) then begin 
            if (idltype NE 3) && (idltype NE 4) then begin 
	         if idltype NE 1 then host_to_ieee, uarray,idltype=idltype   
                 byteorder,uarray,/NTOHL
	   endif	 
       endif else byteorder,uarray,/NTOHL	     
 endif
 
 for i=0, Niter do begin

   if i EQ Niter then begin 
           nbyte = (N mod maxnum) 
           if nbyte EQ 0 then nbyte = maxnum
   endif else nbyte = maxnum

   checksum = checksum + total(ulong(  uarray,maxnum*i,nbyte/4), /integer)
<span class="comments">; Fold any overflow bits beyond 32 back into the word.</span>

   hibits = long(checksum/word32)
   while hibits GT 0 do begin
     checksum = checksum - (hibits*word32) + hibits    
     hibits = long(checksum/word32)
  endwhile

   checksum = ulong(checksum)

 endfor

 return
 end
</code>
    </div>
  </body>
</html>