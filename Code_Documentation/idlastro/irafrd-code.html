<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:43 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>irafrd.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="irafrd.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="irafrd:source"></a>pro irafrd,im,hd,filename, SILENT=silent    <span class="comments">;Read in IRAF image array and header array</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     IRAFRD</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Read an IRAF (.imh) file into IDL image and header arrays.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       The internal IRAF format changed somewhat in IRAF V2.11 to a machine</span>
<span class="comments">;       independent format, with longer filename allocations.  This version </span>
<span class="comments">;       of IRAFRD should be able to read either format. </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       IRAFRD, im, hdr, filename, [/SILENT ]  </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       FILENAME -  Character string giving the name of the IRAF image </span>
<span class="comments">;               header.  If omitted, then program will prompt for the </span>
<span class="comments">;               file name.  IRAFRD always assumes the header file has an </span>
<span class="comments">;               extension '.imh'.    IRAFRD will automatically locate the</span>
<span class="comments">;               ".pix" file containing the data by parsing the contents of </span>
<span class="comments">;               the .imh file.   (If the parse is unsuccesful, then IRAFRD looks</span>
<span class="comments">;               in the same directory as the .imh file.)</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       IM - array containing image data</span>
<span class="comments">;       HDR - string array containing header.  Basic information in the</span>
<span class="comments">;               IRAF header is converted to a FITS style header</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       /SILENT  - If this keyword is set and non-zero, then messages displayed</span>
<span class="comments">;               while reading the image will be suppressed.  </span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1)  Image size and history sections of the IRAF header are copied </span>
<span class="comments">;               into the FITS header HDR.  Other information (e.g. astrometry)</span>
<span class="comments">;               might not be included unless it is also in the history section</span>
<span class="comments">;       (2)  IRAFRD ignores the node name when deciphering the name of the</span>
<span class="comments">;               IRAF ".pix" file.</span>
<span class="comments">;       (3)  Certain FITS keywords ( DATATYPE, IRAFNAME) may appear more than</span>
<span class="comments">;               once in the output name</span>
<span class="comments">;       (4)  Does not read the DATE keyword for the new (V2.11) IRAF files</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       IRAFRD obtains dimensions and type of image from the IRAF header.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       FDECOMP, SXADDPAR, SXPAR()</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written W. Landsman, STX January 1989</span>
<span class="comments">;       Converted to IDL Version 2.  M. Greason, STX, June 1990</span>
<span class="comments">;       Updated for DecStation compatibility   W. Landsman   March 1992</span>
<span class="comments">;       Don't leave an open LUN  W. Landsman   July 1993</span>
<span class="comments">;       Don't overwrite existing OBS-DATE  W. Landsman  October 1994</span>
<span class="comments">;       Don't bomb on very long FITS headers W. Landsman  April 1995</span>
<span class="comments">;       Work on Alpha/OSF and Linux      W. Landsman     Dec 1995</span>
<span class="comments">;       Remove /VMSIMG keyword, improve efficiency when physical and</span>
<span class="comments">;               image dimensions differ   W. Landsman     April 1996</span>
<span class="comments">;       Don't use FINDFILE (too slow)     W. Landsman     Oct 1996</span>
<span class="comments">;       Read V2.11 files, remove some parameter checks W. Landsman Nov. 1997</span>
<span class="comments">;       Fixed problem reading V2.11 files with long headers Jan. 1998</span>
<span class="comments">;       Accept names with multiple extensions    W. Landsman   April 98 </span>
<span class="comments">;       Test for big endian machine under V2.11 format W. Landsman Feb. 1999</span>
<span class="comments">;       Don't read past the end of file for V5.4 compatilibity  W.L.  Jan. 2001</span>
<span class="comments">;       Convert to square brackets W.L   May 2001</span>
<span class="comments">;       Assume since V5.4, remove SPEC_DIR()   W. L.   April 2006</span>
<span class="comments">;-</span>
 On_error,2                    <span class="comments">;Return to caller</span>
 compile_opt idl2
 npar = N_params() 

 if ( npar EQ 0 ) then begin 
   print,'Syntax - IRAFRD, im, hdr, [filename, /SILENT ]'
   return
 endif 

 if ( npar EQ 3 ) then $
    if ( N_elements(filename) EQ 0 ) then message, $
        'Third parameter (IRAF Header file name) must be a character string' $
    else begin  
         file_name = filename
         goto,FINDER
    endelse 

  file_name = ''  <span class="comments">;Get file name if not supplied</span>
  read,'Enter name of IRAF data file (no quotes): ',file_name    
  if ( file_name EQ '' ) then return

FINDER: 
  fdecomp, file_name, disk, dir, name, ext, ver  

  IF ext EQ 'imh' THEN fname = file_name ELSE fname = file_name + '.imh'

  openr, lun1, fname, /GET_LUN, ERROR = error  <span class="comments">;Open the IRAF header file</span>
  if error NE 0 then  $
    message, 'Unable to find IRAF header file '+ FILE_EXPAND_PATH(fname) 

<span class="comments">; Get image size and name from IRAF header</span>
 irafver = bytarr(5)
 readu, lun1, irafver
 newformat = string(irafver) EQ 'imhv2' 
 big_endian = is_ieee_big()

 if newformat then begin
        hdrsize = 2048
        doffset = 2048
 endif else begin
        hdrsize = 572
        doffset = 1024
 endelse 

 point_lun, lun1, 0             <span class="comments">;Back to top of the header</span>
 tmp = assoc(lun1,bytarr(hdrsize))
 hdr = tmp[0]
 hdr2 = hdr

 if not newformat then begin       <span class="comments">;Old format is not machine independent</span>

        if not big_endian then begin
                byteorder,hdr,/sswap
                byteorder,hdr,/lswap
        endif

        hdrlen =   fix(hdr,12)         <span class="comments">;Length (in words) of header</span>
        datatype = fix(hdr,16)         <span class="comments">;IRAF datatype</span>
        ndim =  fix(hdr,20)         <span class="comments">;Number of dimensions</span>
        if ( ndim GT 5 ) then $
                message,'Too stupid to do more than 5 dimensions'
        if (ndim EQ 0) then message,'IRAF file contains no data (NAXIS = 0)'

        dimen = long(hdr2,24,ndim)       <span class="comments">;Get vector of image dimensions </span>
        physdim = long(hdr2,52,ndim)     <span class="comments">;Get vector of physical dimensions</span>

        if big_endian then pixname = string( hdr[412+indgen(80)*2] ) else $
                           pixname = string( hdr2[413+indgen(80)*2] )
 endif else begin

        hdrlen =   long(hdr,6)         <span class="comments">;Length (in words) of header</span>
        datatype = fix(hdr,12)         <span class="comments">;IRAF datatype</span>
        ndim =   fix(hdr,20)         <span class="comments">;Number of dimensions</span>
        if big_endian then begin
              byteorder,hdrlen,/NTOHL
              byteorder,datatype,/NTOHS
              byteorder,ndim,/NTOHS
        endif
        if ( ndim GT 7 ) then $
                message,'Too stupid to do more than 7 dimensions'
        if (ndim EQ 0) then message,'IRAF file contains no data (NAXIS = 0)'

        dimen =  long(hdr,22,ndim)       <span class="comments">;Get vector of image dimensions </span>
        physdim = long(hdr,50,ndim)     <span class="comments">;Get vector of physical dimensions</span>
        if big_endian then begin
               byteorder,dimen,/NTOHL
               byteorder,physdim, /NTOHL
        endif
        pixname = string(hdr[126:126+255])
 endelse 

 expos = strpos(pixname,'!')
 pixname = strmid(pixname,expos+1,strlen(pixname))

 expos = strpos(pixname,'!')
 pixname = strmid(pixname,expos+1,strlen(pixname))

 if strmid(pixname,0,4) eq 'HDR$' then begin
        if disk + dir EQ '' then begin 
                cd, CURRENT = curdir 
                curdir = curdir + path_sep()
        endif else curdir = disk+dir
        pixname = curdir +  strmid(pixname,4,strlen(pixname))
 endif

<span class="comments">;  Use file name found in header to open .pix file.  If this file is not</span>
<span class="comments">;  found then look for a .pix file in the same directory as the header  </span>
 
 openr, lun2, pixname, ERROR=err, /GET_LUN     <span class="comments">; ...on given directory</span>

 if ( err LT 0 ) then begin
     openr,lun2, name + '.pix', ERROR = err, /GET_LUN   
     if ( err LT 0 ) then goto, NOFILE   
 endif 

 if not keyword_set(SILENT) then begin 
                                            
        sdim = strtrim(dimen[0],2)
        message,'Now reading '+strjoin(sdim,' by ')  + $
                 ' IRAF array', /INFORM
 endif 

<span class="comments">;       Convert from IRAF data types to IDL data types</span>

 CASE datatype OF
        1: begin & dtype = 1  & bitpix = 8 & end            <span class="comments">;Byte </span>
        3: begin & dtype = 2  & bitpix = 16 & end            <span class="comments">;Integer*2 </span>
        4: begin & dtype = 3  & bitpix = 32 & end            <span class="comments">;Integer*4 </span>
        5: begin & dtype = 3  & bitpix = 32 & end            <span class="comments">;Integer*4 </span>
        6: begin & dtype = 4  & bitpix = -32 & end           <span class="comments">;Real*4 </span>
        7: begin & dtype = 5  & bitpix = -64 & end            <span class="comments">;Real*8 </span>
        11: begin &dtype = 3  & bitpix = 16 & end            <span class="comments">;Integer*2</span>
        else: message,'Unknown Datatype Code ' + strtrim(datatype,2)
 endcase 

<span class="comments">; Read the .pix file, skipping the first 1024 bytes.   The last physical </span>
<span class="comments">; dimension can be set equal to the image dimension.</span>

 physdim[ndim-1] = dimen[ndim-1]
 tmp = assoc (lun2, make_array(DIMEN = physdim, TYPE= dtype, /NOZERO), doffset)
 im = tmp[0]

<span class="comments">; If the physical dimension of an IRAF image is larger than the image size,</span>
<span class="comments">; then extract the appropriate subimage</span>

 dimen = dimen - 1
 pdim = physdim - 1
 case ndim of
        1 :
        2 : if dimen[0] LT pdim[0] then im = im[ 0:dimen[0], *]
        3 : if total(dimen LT pdim) then im = im[ 0:dimen[0], 0:dimen[1], * ]
        4 : if total(dimen LT pdim) then $
                im = im[ 0:dimen[0], 0:dimen[1], 0:dimen[2], * ]
        5 : if total(dimen LT pdim) then $
                im = im[ 0:dimen[0], 0:dimen[1], 0:dimen[2], 0:dimen[3], *]
        6:  if total(dimen LT pdim) then $
                im = im[ 0:dimen[0], 0:dimen[1], 0:dimen[2], 0:dimen[3], $
                         0:dimen[4], *]
        7: if total(dimen LT pdim) then $
                im = im[ 0:dimen[0], 0:dimen[1], 0:dimen[2], 0:dimen[3], $
                         0:dimen[4], 0:dimen[5], *]
 endcase

 hd = strarr(ndim + 5) + string(' ',format='(a80)')      <span class="comments">;Create empty FITS hdr</span>
 hd[0] = 'END' + string(replicate(32b,77))
  
 sxaddpar, hd, 'SIMPLE', 'T',' Read by IDL:  '+ systime()
 sxaddpar, hd, 'BITPIX', bitpix
 sxaddpar, hd, 'NAXIS', ndim        <span class="comments">;# of dimensions</span>
 if ( ndim GT 0 ) then $
   for i = 1, ndim do sxaddpar,hd,'NAXIS' + strtrim(i,2),dimen[i-1]+1

 sxaddpar,hd,'irafname',name + '.imh'   <span class="comments">;Add history records</span>

 if ( hdrlen GT 513 ) then begin    <span class="comments">;Add history records</span>

        if newformat then nfits = (hdrlen*2l - 2049)/81 else $
                          nfits = (hdrlen*4l - 2054)/162
        tmp = assoc(lun1,bytarr(hdrlen*4l &lt<span class="comments">; (fstat(lun1)).size ))</span>
        hdr = tmp[0]
        if not newformat then if not big_endian then byteorder, hdr, /SSWAP 
SKIP1:  
        if newformat then $
                object = string( hdr[638 + indgen(67)] ) else $
                object = string( hdr[732 + indgen(67)*2] ) 
        if (object NE '') then $
        sxaddpar, hd, 'OBJECT', object,' Object Name'     <span class="comments">;Add object name</span>

        endline = where( strmid(hd,0,8) EQ 'END     ')     
        endline = endline[0]
        endfits = hd[endline]
        hd = [ hd[0:endline-1], strarr(nfits+1) ]

        if newformat then begin
                index = indgen(80)
                for i = 0l,nfits-1 do $
                        hd[endline+i] = string( hdr[2046 + 81*i + index] )
        endif else begin 
                index = indgen(80)*2
                for i = 0l,nfits-1 do $
                        hd[endline+i] = string( hdr[ 2052 + 162*i + index] )
        endelse

        hd[endline + nfits] = endfits         <span class="comments">;Add back END keyword</span>
        
        if not newformat then begin
        history = string(hdr[ 892 + indgen(580)*2] )
        st1 = gettok( history, string(10B))             
        if big_endian then $
                origin = gettok( strmid( st1, 1, strlen(st1)),"'") else $
                origin = gettok( strmid( st1, 0, strlen(st1)),"'")
        sxaddpar, hd, 'ORIGIN', origin, ' ', 'IRAFNAME'   <span class="comments">; Add 'ORIGIN" record</span>

        test = sxpar(hd,'HISTORY', Count = N)
        if N EQ 0 then begin
         while (strpos(history,string(10B)) GE 0) do begin

                 hist_rec = gettok( history, string(10B) ) <span class="comments">; Add history comment strings</span>
                 sxaddpar, hd, 'HISTORY', hist_rec
         endwhile
       endif
        endif
 endif

 free_lun,lun1,lun2

 return                        <span class="comments">;Successful return</span>

NOFILE:  

 message,'Unable to find IRAF pixel file ' + pixname,/CON
 free_lun,lun1
 return

 end 
</code>
    </div>
  </body>
</html>