<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:53 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ngp.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ngp.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION ngp,value,posx,nx,posy,ny,posz,nz, $
             AVERAGE=average,WRAPAROUND=wraparound,NO_MESSAGE=no_message
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       NGP</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Interpolate an irregularly sampled field using Nearest Grid Point</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This function interpolates irregularly gridded points to a</span>
<span class="comments">;       regular grid using Nearest Grid Point.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       Mathematical functions, Interpolation</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       Result = NGP, VALUE, POSX, NX[, POSY, NY, POSZ, NZ, </span>
<span class="comments">;                     /AVERAGE, /WRAPAROUND, /NO_MESSAGE]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       VALUE: Array of sample weights (field values). For e.g. a</span>
<span class="comments">;              temperature field this would be the temperature and the</span>
<span class="comments">;              keyword AVERAGE should be set. For e.g. a density field</span>
<span class="comments">;              this could be either the particle mass (AVERAGE should</span>
<span class="comments">;              not be set) or the density (AVERAGE should be set).</span>
<span class="comments">;       POSX:  Array of X coordinates of field samples, unit indices: [0,NX>.</span>
<span class="comments">;       NX:    Desired number of grid points in X-direction.</span>
<span class="comments">;       </span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;      POSY: Array of Y coordinates of field samples, unit indices: [0,NY>.</span>
<span class="comments">;      NY:   Desired number of grid points in Y-direction.</span>
<span class="comments">;      POSZ: Array of Z coordinates of field samples, unit indices: [0,NZ>.</span>
<span class="comments">;      NZ:   Desired number of grid points in Z-direction.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       AVERAGE:    Set this keyword if the nodes contain field samples</span>
<span class="comments">;                   (e.g. a temperature field). The value at each grid</span>
<span class="comments">;                   point will then be the average of all the samples</span>
<span class="comments">;                   allocated to it. If this keyword is not set, the</span>
<span class="comments">;                   value at each grid point will be the sum of all the</span>
<span class="comments">;                   nodes allocated to it (e.g. for a density field from</span>
<span class="comments">;                   a distribution of particles). (D=0). </span>
<span class="comments">;       WRAPAROUND: Set this keyword if the data is periodic and if you</span>
<span class="comments">;                   want the first grid point to contain samples of both</span>
<span class="comments">;                   sides of the volume (see below). (D=0).</span>
<span class="comments">;       NO_MESSAGE: Suppress informational messages.</span>
<span class="comments">;</span>
<span class="comments">; Example of default NGP allocation: n0=4, *=gridpoint.</span>
<span class="comments">;</span>
<span class="comments">;     0   1   2   3     Index of gridpoints</span>
<span class="comments">;     *   *   *   *     Grid points</span>
<span class="comments">;   |---|---|---|---|   Range allocated to gridpoints ([0.0,1.0> --> 0, etc.)</span>
<span class="comments">;   0   1   2   3   4   posx</span>
<span class="comments">;</span>
<span class="comments">; Example of NGP allocation for WRAPAROUND: n0=4, *=gridpoint.</span>
<span class="comments">;</span>
<span class="comments">;   0   1   2   3         Index of gridpoints</span>
<span class="comments">;   *   *   *   *         Grid points</span>
<span class="comments">; |---|---|---|---|--     Range allocated to gridpoints ([0.5,1.5> --> 1, etc.)</span>
<span class="comments">;   0   1   2   3   4=0   posx</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Prints that a NGP interpolation is being performed of x</span>
<span class="comments">;       samples to y grid points, unless NO_MESSAGE is set. </span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       All input arrays must have the same dimensions.</span>
<span class="comments">;       Postition coordinates should be in `index units' of the</span>
<span class="comments">;       desired grid: POSX=[0,NX>, etc.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Nearest grid point is determined for each sample.</span>
<span class="comments">;       Samples are allocated to nearest grid points.</span>
<span class="comments">;       Grid point values are computed (sum or average of samples).</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       nx = 20</span>
<span class="comments">;       ny = 10</span>
<span class="comments">;       posx = randomu(s,1000)</span>
<span class="comments">;       posy = randomu(s,1000)</span>
<span class="comments">;       value = posx^2+posy^2</span>
<span class="comments">;       field = ngp(value,posx*nx,nx,posy*ny,ny,/average)</span>
<span class="comments">;       surface,field,/lego</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Use tsc.pro or cic.pro for a higher order interpolation schemes.    A </span>
<span class="comments">;       standard reference for these interpolation methods is:   R.W. Hockney </span>
<span class="comments">;       and J.W. Eastwood, Computer Simulations Using Particles (New York: </span>
<span class="comments">;       McGraw-Hill, 1981).</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by Joop Schaye, Feb 1999.</span>
<span class="comments">;       Check for LONG overflow  P. Riley/W. Landsman   December 1999</span>
<span class="comments">;-</span>

nrsamples=n_elements(value)
nparams=n_params()
dim=(nparams-1)/2

IF dim LE 2 THEN BEGIN
    nz=1
    IF dim EQ 1 THEN ny=1
ENDIF
nxny = long(nx)*long(ny)


<span class="comments">;---------------------</span>
<span class="comments">; Some error handling.</span>
<span class="comments">;---------------------</span>

on_error,2  <span class="comments">; Return to caller if an error occurs.</span>

IF NOT (nparams EQ 3 OR nparams EQ 5 OR nparams EQ 7) THEN BEGIN
    message,'Incorrect number of arguments!',/continue
    message,'Syntax: NGP, VALUE, POSX, NX[, POSY, NY, POSZ, NZ,' + $
      ' /AVERAGE, /WRAPAROUND, /NO_MESSAGE]'
ENDIF 

IF (nrsamples NE n_elements(posx)) OR $
  (dim GE 2 AND nrsamples NE n_elements(posy)) OR $
  (dim EQ 3 AND nrsamples NE n_elements(posz)) THEN $
  message,'Input arrays must have the same dimensions!'

IF NOT keyword_set(no_message) THEN $
  print,'Interpolating ' + strtrim(string(nrsamples,format='(i10)'),1) $
  + ' samples to ' + strtrim(string(nxny*nz,format='(i10)'),1) + $
  ' grid points using NGP...'


<span class="comments">;-----------------------------</span>
<span class="comments">; Compute nearest grid points.</span>
<span class="comments">;-----------------------------</span>

IF keyword_set(wraparound) THEN BEGIN
    <span class="comments">; Coordinates of nearest grid point (ngp).</span>
    ngx=fix(posx+0.5)
    <span class="comments">; Periodic boundary conditions.</span>
    bad=where(ngx EQ nx,count)
    IF count NE 0 THEN ngx[bad]=0
    IF dim GE 2 THEN BEGIN 
        ngy=fix(posy+0.5)
        bad=where(ngy EQ ny,count)
        IF count NE 0 THEN ngy[bad]=0
        IF dim EQ 3 THEN BEGIN
            ngz=fix(posz+0.5)
            bad=where(ngz EQ nz,count)
            IF count NE 0 THEN ngz[bad]=0
        ENDIF
    ENDIF 
    bad=0  <span class="comments">; Free memory.</span>
ENDIF ELSE BEGIN
    <span class="comments">; Coordinates of nearest grid point (ngp).</span>
    ngx=fix(posx)
    IF dim GE 2 THEN BEGIN  
        ngy=fix(posy)
        IF dim EQ 3 THEN ngz=fix(posz)
    ENDIF
ENDELSE

<span class="comments">; Indices of grid points to which samples are assigned.</span>
CASE dim OF
    1: index=temporary(ngx)
    2: index=temporary(ngx)+temporary(ngy)*nx
    3: index=temporary(ngx)+temporary(ngy)*nx+temporary(ngz)*nxny
ENDCASE


<span class="comments">;-------------------------------</span>
<span class="comments">; Interpolate samples to grid.</span>
<span class="comments">;-------------------------------</span>

field=fltarr(nx,ny,nz)

FOR i=0l,nrsamples-1l DO field[index[i]]=field[index[i]]+value[i]


<span class="comments">;--------------------------</span>
<span class="comments">; Compute weighted average.</span>
<span class="comments">;--------------------------</span>

IF keyword_set(average) THEN BEGIN
    <span class="comments">; Number of samples per grid point.</span>
    frequency=histogram(temporary(index),min=0,max=nxny*nz-1l)
    
    <span class="comments">; Normalize.</span>
    good=where(frequency NE 0,nrgood)
    field[good]=temporary(field[good])/temporary(frequency[good])
ENDIF

return,field

END  <span class="comments">; End of function ngp.</span>








</code>
    </div>
  </body>
</html>