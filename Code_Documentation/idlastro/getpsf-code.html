<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:39 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>getpsf.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="getpsf.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="getpsf:source"></a>pro getpsf,image,xc,yc,apmag,sky,ronois,phpadu, gauss,psf,idpsf,psfrad, $
            fitrad,psfname, DEBUG = debug
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	GETPSF</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	To generate a point-spread function (PSF) from observed stars. </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;	The PSF is represented as a 2-dimensional Gaussian</span>
<span class="comments">;	(integrated over each pixel) and a lookup table of residuals.</span>
<span class="comments">;	The lookup table and Gaussian parameters are output in a FITS</span>
<span class="comments">;	image file.   The PSF FITS file created by GETPSF can be</span>
<span class="comments">;	read with the procedure RDPSF.      Adapted from the 1986 STSDAS </span>
<span class="comments">;	version of DAOPHOT</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	GETPSF, image, xc, yc, apmag, sky, [ronois, phpadu, gauss, psf, </span>
<span class="comments">;			idpsf, psfrad, fitrad, psfname, /DEBUG ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	IMAGE  - input image array</span>
<span class="comments">;	XC     - input vector of x coordinates (from FIND), these should be</span>
<span class="comments">;		IDL (first pixel is (0,0)) convention.</span>
<span class="comments">;	YC     - input vector of y coordinates (from FIND)</span>
<span class="comments">;	APMAG  - vector of magnitudes (from APER), used for initial estimate</span>
<span class="comments">;		of gaussian intensity.  If APMAG is multidimensional, (more</span>
<span class="comments">;		than 1 aperture was used in APER) then the first aperture</span>
<span class="comments">;		is used.</span>
<span class="comments">;	SKY    - vector of sky values (from APER)                </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;	The user will be prompted for the following parameters if not supplied.</span>
<span class="comments">;</span>
<span class="comments">;	RONOIS - readout noise per pixel, (in electrons, or equivalent photons)</span>
<span class="comments">;	PHPADU - photons per analog digital unit, used to scale the data</span>
<span class="comments">;		numbers in IMAGE into photon units</span>
<span class="comments">;	IDPSF  - subscripts of the list of stars created by </span>
<span class="comments">;		APER which will be used to define the PSF.   Stars whose</span>
<span class="comments">;		centroid does not fall within PSFRAD of the edge of the frame,</span>
<span class="comments">;		or for which a Gaussian fit requires more than 25 iterations,</span>
<span class="comments">;		will be ignored when creating the final PSF.</span>
<span class="comments">;	PSFRAD - the scalar radius, in pixels, of the circular area within</span>
<span class="comments">;		which the PSF will be defined.   This should be slightly larger</span>
<span class="comments">;		than the radius of the brightest star that one will be</span>
<span class="comments">;		interested in.</span>
<span class="comments">;	FITRAD - the scalar radius, in pixels of the circular area used in the</span>
<span class="comments">;		least-square star fits.  Stetson suggest that FITRAD should</span>
<span class="comments">;		approximately equal to the FWHM, slightly less for crowded</span>
<span class="comments">;		fields.  (FITRAD must be smaller than PSFRAD.)</span>
<span class="comments">;	PSFNAME- Name of the FITS file that will contain the table of residuals,</span>
<span class="comments">;		and the best-fit Gaussian parameters.    This file is </span>
<span class="comments">;		subsequently required for use by NSTAR.  </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;	GAUSS  - 5 element vector giving parameters of gaussian fit to the </span>
<span class="comments">;		first PSF star</span>
<span class="comments">;		GAUSS(0) - height of the gaussian (above sky)</span>
<span class="comments">;		GAUSS(1) - the offset (in pixels) of the best fitting gaussian</span>
<span class="comments">;			and the original X centroid</span>
<span class="comments">;		GAUSS(2) - similiar offset from the Y centroid </span>
<span class="comments">;		GAUSS(3) - Gaussian sigma in X</span>
<span class="comments">;		GAUSS(4) - Gaussian sigma in Y</span>
<span class="comments">;	PSF    - 2-d array of PSF residuals after a Gaussian fit.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	GETPSF fits a Gaussian profile to the core of the first PSF star </span>
<span class="comments">;	and generates a look-up table of the residuals of the</span>
<span class="comments">;	actual image data from the Gaussian fit.  If desired, it will then</span>
<span class="comments">;	fit this PSF to another star (using PKFIT) to determine its precise </span>
<span class="comments">;	centroid, scale the same Gaussian to the new star's core, and add the</span>
<span class="comments">;	differences between the actual data and the scaled Gaussian to the</span>
<span class="comments">;	table of residuals.   (In other words, the Gaussian fit is performed</span>
<span class="comments">;       only on the first star.)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;	DEBUG - if this keyword is set and non-zero, then the result of each</span>
<span class="comments">;		fitting iteration will be displayed.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED</span>
<span class="comments">;	DAOERF, MAKE_2D, MKHDR, RINTER(), PKFIT, STRNUMBER(), STRN(), WRITEFITS</span>
<span class="comments">;</span>
<span class="comments">; REVISON HISTORY:</span>
<span class="comments">;	Adapted from the 1986 version of DAOPHOT in STSDAS</span>
<span class="comments">;	IDL Version 2  W Landsman           November 1988</span>
<span class="comments">;	Use DEBUG keyword instead of !DEBUG  W. Landsman       May 1996</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-                                              </span>
 On_error,2                      <span class="comments">;Return to caller</span>

 common rinter,c1,c2,c3,init	<span class="comments">;Save time in RINTER</span>
 init = 0                        <span class="comments">;Initialize the common blocks</span>

 npar = N_params()

 if npar LT 5 then begin	 	<span class="comments">;Enough parameters passed?</span>
   print,'Syntax -  GETPSF, image, x, y, mags, sky, '
   print,'       [ronois, phpadu, gauss, psf, idpsf, psfrad, fitrad, ' + $
         'psfname, /DEBUG]'
   return
 endif

 s = size(image)    		<span class="comments">;Get number of rows and columns in image</span>
 ncol = s[1] & nrow = s[2]
 nstar = N_elements(xc)	        <span class="comments">;Total # of stars identified in image</span>

 if N_elements(idpsf) LT 1 then begin	<span class="comments">;Array of PSF id's defined?</span>
   idpsf = intarr(25)
   i = 0 &  id = ''
   print,"GETPSF: Enter index of stars to be used for PSF, one index per line"
   RD_ID:   
   print,'Enter a stellar ID ( [RETURN] when finished) '
   read,id
   if id EQ '' then begin             <span class="comments">;Did User hit the [RETURN] key</span>
             if i EQ 0 then return    <span class="comments">;No stellar ID's supplied</span>
             idpsf = idpsf[0:i-1]
             goto, GOT_ID     
   endif else result = strnumber(id,val)

   if not result then print,string(7b),'INVALID INPUT:' else $
         if (val GE nstar) or (val LT 0) then $ 
                print,string(7b),'INVALID ID NUMBER' else begin
             idpsf[i] = fix(val) 
             i = i+1
         endelse
   goto,RD_ID
 endif 

GOT_ID:  

 if N_elements(psfrad) NE 1 then read, $
   'Enter radius (in pixels) of circular area defining the PSF: ',psfrad
 if N_elements(fitrad) NE 1 then read, $
   'Enter radius (in pixels) to be used for Gaussian fitting: ',fitrad
 if fitrad GE psfrad then $
    message,'ERROR - Fitting radius must be smaller than radius defining PSF'

 if N_elements(ronois) NE 1 then read, $
   'Enter readout noise per pixel: ',ronois
 if N_elements(phpadu) NE 1 then read, $
   'Enter photons per analog digital unit: ',phpadu

 numpsf = N_elements(idpsf)      <span class="comments">;# of stars used to create the PSF</span>

 smag = size(apmag)     <span class="comments">;Is APMAG multidimensional?</span>
 if N_elements(apmag) NE smag[1] then mag = apmag[0,*] else mag = apmag[*]

 n = 2*fix(psfrad+0.5)+1  <span class="comments">;(Odd) width of box that contains PSF circle</span>
 npsf = 2*n+7             <span class="comments">;Lookup table has half pixel interpolation</span>
 nbox = n+7		 <span class="comments">;(Even) Width of subarray to be extracted from image</span>
 nhalf = nbox/2           

 if keyword_set(DEBUG) then begin
    print,'GETPSF: Fitting radius - ',string(float(fitrad),'(F5.1)')
    print,'        PSF Radius     - ',string(float(psfrad),'(F5.1)')
    print,'        Stellar IDs: ',idpsf   & print,' '
 endif

 boxgen = findgen(nbox)
 make_2d, boxgen, boxgen, xgen, ygen

<span class="comments">;               Find the first PSF star in the star list.</span>
 nstrps = -1	<span class="comments">;Counter for number of stars used to create PSF</span>
GETSTAR: 

 nstrps = nstrps + 1       
 if nstrps GE numpsf then $
     message,'ERROR - No valid PSF stars were supplied'

 istar = idpsf[nstrps]       <span class="comments">;ID number of first PSF star</span>
 ixcen = fix(xc[istar])      
 iycen = fix(yc[istar])

<span class="comments">;  Now a subarray F will be read in from the big image, given by </span>
<span class="comments">;  IXCEN-NBOX/2+1 &lt;= x &lt;= IXCEN+NBOX/2, IYCEN-NBOX/2+1 &lt;= y &lt;= IYCEN+NBOX/2.  </span>
<span class="comments">;  (NBOX is an even number.)  In the subarray, the coordinates of the centroid</span>
<span class="comments">;  of the star will lie between NBOX/2 and NBOX/2+1 in each coordinate.</span>

 lx = ixcen-nhalf+1  &  ux = ixcen + nhalf  <span class="comments">;Upper & lower bounds in X</span>
 ly = iycen-nhalf+1  &  uy = iycen + nhalf
 if ((lx LT 0)   or (ly LT 0) or $     <span class="comments">;Star too close to edge?</span>
   (ux GE ncol) or (uy GE nrow)) then begin    
   print,'GETPSF: Star ',strn(istar),' too near edge of frame.'
   goto, GETSTAR
 endif                      

 f = image[lx:ux,ly:uy] - sky[istar]  <span class="comments">;Read in subarray, subtract off sky</span>

<span class="comments">; An integrated Gaussian function will be fit to the central part of the</span>
<span class="comments">; stellar profile.  Initially, a 5x5 box centered on the centroid of the </span>
<span class="comments">; star is used, but if the sigma in one coordinate drops to less than</span>
<span class="comments">; 1 pixel, then the box width of 3 will be used in that coordinate.</span>
<span class="comments">; If the sigma increases to over 3 pixels, then a box width of 7 will be </span>
<span class="comments">; used in that coordinate</span>

 x = xc[istar] - lx    <span class="comments">;X coordinate of stellar centroid in subarray F</span>
 y = yc[istar] - ly    <span class="comments">;Y coordinate of stellar centroid in subarray F</span>
 ix = fix(x+0.5)       <span class="comments">;Index of pixel containing centroid</span>
 iy = fix(y+0.5) 
<span class="comments">;                     ;Begin least squares</span>
 h = max(f)  	      <span class="comments">;Initial guess for peak intensity</span>
 sigx = 2.0 & sigy = 2.0                                       
 dxcen=0.  &  dycen=0.
<span class="comments">;</span>
 niter = 0                    <span class="comments">;Beginning of big iteration loop</span>
 v = fltarr(5)
 c = fltarr(5,5)
<span class="comments">;                            Print the current star</span>
 fmt1 = "(/17X, 'STAR', 5X, 'X', 8X, 'Y', 5X, 'MAG  1', 5X, 'SKY')"
 fmt2 = "(15X, I5, 2F9.2, 12F9.3)"
 if keyword_set(DEBUG) then begin
    print,format=fmt1          
    print,format=fmt2,istar, xc[istar], yc[istar], mag[istar], sky[istar]
 endif

 if keyword_set(DEBUG) then print,'GETPSF: Gaussian Fit Iteration'

 REPEAT BEGIN		     <span class="comments">;Begin the iterative loop</span>

 niter = niter + 1
 if niter GT 100 then begin   <span class="comments">;No convergence after 100 iterations?</span>
    message,'No convergence after 100 iterations for star ' + strn(istar),/INF
    goto, GETSTAR 
 endif

      if sigx LE 1 then nx = 1  $  <span class="comments">;A default box width </span>
 else if sigx GT 3 then nx = 3  $
 else                   nx = 2

      if sigy LE 1 then ny = 1  $
 else if sigy GT 3 then ny = 3  $
 else                   ny = 2

 a = [H, x+dxcen,y+dycen,sigx,sigy]
 xin = (findgen(2*nx+1)-nx) + ix
 yin = (findgen(2*ny+1)-ny) + iy
 make_2d, xin, yin
 DAOERF, xin, yin, a, g, t

<span class="comments">;  The T's are the first derivatives of the model profile with respect</span>
<span class="comments">;  to the five fitting parameters H, DXCEN, DYCEN, SIGX, and SIGY.</span>
<span class="comments">;  Note that the center of the best-fitting Gaussian profile is</span>
<span class="comments">;  expressed as an offset from the centroid of the star.  In the case of</span>
<span class="comments">;  a general, asymmetric stellar profile, the center of symmetry of the</span>
<span class="comments">;  best-fitting Gaussian profile will not necessarily coincide with the</span>
<span class="comments">;  centroid determined by any arbitrary centroiding algorithm.  </span>

 dh = f[ ix-nx:ix+nx, iy-ny:iy+ny] - g <span class="comments">;Subtract best fit Gaussian from subarray</span>
 for kk = 0,4 do begin
      tk = t[*,kk]
      v[kk] = total( dh * tk )
      for ll = 0,4 do c[kk,ll] = total( tk * t[*,ll] )
 endfor

 c = invert(c,status)	<span class="comments">;IDL version assumes INVERT is successful</span>

 if status EQ 1 then begin
     message,'Singular matrix encountered fitting star ' + strn(istar),/INF
     goto, GETSTAR
 endif 

 z = c#v         <span class="comments">;Multiply by vector of residuals</span>

 h = h + z[0]/(1.0+4.0*abs(z[0]/h))	<span class="comments">;Correct the fitting parameters</span>
 dxcen = dxcen+z[1]/(1.0+3.0*abs(z[1]))
 dycen = dycen+z[2]/(1.0+3.0*abs(z[2]))
 sigx = sigx+z[3]/(1.0+4.0*abs(z[3]/sigx))
 sigy = sigy+z[4]/(1.0+4.0*abs(z[4]/sigy))

 if keyword_set(DEBUG) then print,niter,h,dxcen,dycen,sigx,sigy

 endrep until $ 				<span class="comments">;Test for convergence  </span>
       (abs(z[0]/h)+abs(z[3]/sigx)+abs(z[4]/sigy) LT 0.0001)

<span class="comments">;  Now that the solution has converged, we can generate an</span>
<span class="comments">;  array containing the differences between the actual stellar profile</span>
<span class="comments">;  and the best-fitting Gaussian analytic profile.</span>

 a = [H, x+dxcen, y+dycen, sigx,sigy]  <span class="comments">;Parameters for Gaussian fit</span>
 DAOERF,xgen,ygen,a,g                  <span class="comments">;Compute Gaussian</span>
 f = f - g                             <span class="comments">;Residuals (Real profile - Gaussian)</span>

 psfmag = mag[istar]
 xpsf1 = xc[istar] & ypsf1 = yc[istar]

<span class="comments">; The look-up table is obtained by interpolation within the array of</span>
<span class="comments">; fitting residuals.  We need to interpolate because we want the look-up</span>
<span class="comments">; table to be centered accurately on the centroid of the star, which of </span>
<span class="comments">; course is at some fractional-pixel position in the original data.</span>

 ncen = (npsf-1)/2.
 psfgen = (findgen(npsf) - ncen)/2.         <span class="comments">;Index function for PSF array</span>
 YY = psfgen + Y   &  XX = psfgen + X
 make_2d,xx,yy
 psf = RINTER(F, XX, YY)            <span class="comments">;Interpolate residuals onto current star</span>
 gauss = [h,dxcen,dycen,sigx,sigy]
 goodstar = nstrps                   <span class="comments">;Index of first good star</span>

<span class="comments">; For each additional star, determine the precise  coordinates of the </span>
<span class="comments">; centroid and the relative brightness of the star</span>
<span class="comments">; by least-squares fitting to the current version of the point-spread</span>
<span class="comments">; function.  Then subtract off the appropriately scaled integral under</span>
<span class="comments">; the analytic Gaussian function  and add the departures of the actual </span>
<span class="comments">; data from the analytic Gaussian function to the look-up table.</span>

GETMORE:            <span class="comments">;Loop for additional PSF stars begins here                 </span>
 nstrps = nstrps+1
 if nstrps GE numpsf then goto,WRITEOUT	<span class="comments">;Have all the stars been done?</span>

 istar = idpsf[nstrps]
 ixcen = fix(xc[istar])
 iycen = fix(yc[istar])                  
 scale = 10.^(-0.4*(mag[istar]-psfmag))

<span class="comments">; Fit the current version of the point-spread function to the data for</span>
<span class="comments">; this star.</span>

 lx = ixcen-nhalf+1 & ux =ixcen + nhalf
 ly = iycen-nhalf+1 & uy =iycen + nhalf
 if ( (lx LT 0) or (ly LT 0) or $             <span class="comments">;Star too close to edge?</span>
    (ux GE ncol) or (uy GE nrow)) then begin  
   print,'GETPSF: Star ',strn(istar),' too near edge of frame.'
   goto,GETMORE
 endif                      

 if keyword_set(DEBUG) then begin
   print,format=fmt1
   print,format=fmt2, istar, xc[istar], yc[istar], mag[istar], sky[istar]
 endif

 f = image[lx:ux,ly:uy]
 x = xc[istar]-lx   &   y = yc[istar]-ly   

 pkfit, f, scale, x, y, sky[istar], fitrad, ronois, phpadu, $
		gauss, psf, errmag, chi, sharp, niter, DEBUG = debug

 if niter EQ 25 then begin	<span class="comments">;Convergence in less than 25 iterations?</span>
      print,'GETPSF: No convergence after 25 iterations for star',istar
      goto, GETMORE 
 endif

 a = [gauss[0], x+dxcen,y+dycen,sigx,sigy]  <span class="comments">;Parameters of successful fit</span>
 daoerf,xgen,ygen,a,e
 f = f - scale*e -sky[istar]	           <span class="comments">;Compute array of residuals</span>

<span class="comments">; Values of the array of residuals are now interpolated to an NPSF by</span>
<span class="comments">; NPSF (NPSF is an odd number) array centered on the centroid of the</span>
<span class="comments">; star, and added to the existing look-up table of corrections to the </span>
<span class="comments">; analytic profile </span>

 xx = psfgen + x
 yy = psfgen + y 
 make_2d,xx,yy
 psf = psf + RINTER(f,xx,yy)    

<span class="comments">; Now correct both the height of the analytic Gaussian, and the value</span>
<span class="comments">; of the aperture-magnitude of the point-spread function for the</span>
<span class="comments">; inclusion of the additional star.</span>

 psfmag = -2.5*alog10((1.+scale)*10^(-0.4*psfmag))
 gauss[0] = gauss[0]*(1.+scale)
 goodstar = [ goodstar, nstrps]
 goto, GETMORE  

WRITEOUT:   

<span class="comments">; Create FITS file containing the PSF created.</span>

 if ( N_elements(psfname) EQ  0 ) then begin
   psfname=''
   read,'Enter name of FITS file to contain final PSF ([RETURN] to exit): ',psfname
 endif

if ( psfname EQ  '' ) then return

 mkhdr, hdr, psf         <span class="comments">;Create a minimal FITS header</span>
 sxaddpar, hdr, 'PHPADU', phpadu, 'Photons per Analog Digital Unit'
 sxaddpar, hdr, 'RONOIS', ronois, 'Readout Noise'
 sxaddpar, hdr, 'PSFRAD', psfrad, 'Radius where PSF is defined (pixels)'
 sxaddpar, hdr, 'FITRAD', fitrad, 'Fitting Radius'
 sxaddpar, hdr, 'PSFMAG', psfmag, 'PSF Magnitude'
 sxaddpar, hdr, 'GAUSS1', gauss[0], 'Gaussian Scale Factor'
 sxaddpar, hdr, 'GAUSS2', gauss[1], 'Gaussian X Position'
 sxaddpar, hdr, 'GAUSS3', gauss[2], 'Gaussian Y Position'
 sxaddpar, hdr, 'GAUSS4', gauss[3], 'Gaussian Sigma: X Direction'
 sxaddpar, hdr, 'GAUSS5', gauss[4], 'Gaussian Sigma: Y Direction'

 ngood = N_elements(goodstar)
 sxaddhist,'GETPSF: '+ systime() + ' ' + strn(ngood) +  $
           ' Stars Used to Create PSF',hdr

  sxaddhist,'GETPSF: ID - '+ string(idpsf[goodstar[0:12&lt<span class="comments">;ngood-1]], $</span>
    format='(13i5)'),hdr

 if ngood gt 13 then $
     sxaddhist,'GETPSF: ID - '+ string(idpsf[goodstar[13:*]], $
     format='(13i5)'),hdr

 sxaddhist,'PSF Coordinates:'+ $
    string(xpsf1, format='(F7.2)') + $
    string(ypsf1, format='(F7.2)'), hdr

 writefits,psfname,psf,hdr

 return
 end
</code>
    </div>
  </body>
</html>