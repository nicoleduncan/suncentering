<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>readfits.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="readfits.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       READFITS</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Read a FITS file into IDL data and header variables. </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       READFITS() can read FITS files compressed with gzip or Unix (.Z) </span>
<span class="comments">;       compression.  FPACK ( http://heasarc.gsfc.nasa.gov/fitsio/fpack/ )</span>
<span class="comments">;       compressed FITS files can also be read provided that the FPACK software</span>
<span class="comments">;       is installed.</span>
<span class="comments">;       See http://idlastro.gsfc.nasa.gov/fitsio.html for other ways of</span>
<span class="comments">;       reading FITS files with IDL.   </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       Result = READFITS( Filename/Fileunit,[ Header, heap, /NOSCALE, EXTEN_NO=,</span>
<span class="comments">;                     NSLICE=, /SILENT , STARTROW =, NUMROW = , HBUFFER=,</span>
<span class="comments">;                     /CHECKSUM, /COMPRESS, /FPACK, /No_Unsigned, NaNVALUE = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Filename = Scalar string containing the name of the FITS file  </span>
<span class="comments">;                 (including extension) to be read.   If the filename has</span>
<span class="comments">;                  a *.gz extension, it will be treated as a gzip compressed</span>
<span class="comments">;                  file.   If it has a .Z extension, it will be treated as a</span>
<span class="comments">;                  Unix compressed file.     If Filename is an empty string then</span>
<span class="comments">;                  the user will be queried for the file name.</span>
<span class="comments">;                                   OR</span>
<span class="comments">;       Fileunit - A scalar integer specifying the unit of an already opened</span>
<span class="comments">;                  FITS file.  The unit will remain open after exiting </span>
<span class="comments">;                  READFITS().  There are two possible reasons for choosing </span>
<span class="comments">;                  to specify a unit number rather than a file name:</span>
<span class="comments">;          (1) For a FITS file with many extensions, one can move to the </span>
<span class="comments">;              desired extensions with FXPOSIT() and then use READFITS().  This</span>
<span class="comments">;              is more efficient than repeatedly starting at the beginning of </span>
<span class="comments">;              the file.</span>
<span class="comments">;          (2) For reading a FITS file across a Web http: address after opening</span>
<span class="comments">;              the unit with the SOCKET procedure </span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Result = FITS data array constructed from designated record.</span>
<span class="comments">;                If the specified file was not found, then Result = -1</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       Header = String array containing the header from the FITS file.</span>
<span class="comments">;              If you don't need the header, then the speed may be improved by</span>
<span class="comments">;              not supplying this parameter.    Note however, that omitting </span>
<span class="comments">;              the header can imply /NOSCALE, i.e. BSCALE and BZERO values</span>
<span class="comments">;              may not be applied.</span>
<span class="comments">;       heap = For extensions, the optional heap area following the main</span>
<span class="comments">;              data array (e.g. for variable length binary extensions).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       /CHECKSUM - If set, then READFITS() will call FITS_TEST_CHECKSUM to </span>
<span class="comments">;                verify the data integrity if CHECKSUM keywords are present</span>
<span class="comments">;                in the FITS header.   Cannot be used with the NSLICE, NUMROW</span>
<span class="comments">;                or STARTROW keywords, since verifying the checksum requires </span>
<span class="comments">;               that all the data be read.  See FITS_TEST_CHECKSUM() for more</span>
<span class="comments">;               information.</span>
<span class="comments">;</span>
<span class="comments">;       /COMPRESS - Signal that the file is gzip compressed.  By default, </span>
<span class="comments">;               READFITS will assume that if the file name extension ends in </span>
<span class="comments">;               '.gz' then the file is gzip compressed.   The /COMPRESS keyword</span>
<span class="comments">;               is required only if the the gzip compressed file name does not </span>
<span class="comments">;               end in '.gz' or .ftz</span>
<span class="comments">;              </span>
<span class="comments">;</span>
<span class="comments">;       EXTEN_NO - non-negative scalar integer specifying the FITS extension to</span>
<span class="comments">;               read.  For example, specify EXTEN = 1 or /EXTEN to read the </span>
<span class="comments">;               first FITS extension.   </span>
<span class="comments">;</span>
<span class="comments">;       /FPACK - Signal that the file is compressed with the FPACK software. </span>
<span class="comments">;               http://heasarc.gsfc.nasa.gov/fitsio/fpack/ ) By default, </span>
<span class="comments">;               (READFITS will assume that if the file name extension ends in </span>
<span class="comments">;               .fz that it is fpack compressed.     The FPACK software must</span>
<span class="comments">;               be installed on the system </span>
<span class="comments">;   </span>
<span class="comments">;        HBUFFER - Number of lines in the header, set this to slightly larger</span>
<span class="comments">;                than the expected number of lines in the FITS header, to </span>
<span class="comments">;               improve performance when reading very large FITS headers. </span>
<span class="comments">;               Should be a multiple of 36 -- otherwise it will be modified</span>
<span class="comments">;               to the next higher multiple of 36.   Default is 180</span>
<span class="comments">;</span>
<span class="comments">;       /NOSCALE - If present and non-zero, then the ouput data will not be</span>
<span class="comments">;                scaled using the optional BSCALE and BZERO keywords in the </span>
<span class="comments">;                FITS header.   Default is to scale.</span>
<span class="comments">;</span>
<span class="comments">;       /NO_UNSIGNED - By default, if the header indicates an unsigned integer </span>
<span class="comments">;               (BITPIX = 16, BZERO=2^15, BSCALE=1) then READFITS() will output </span>
<span class="comments">;               an IDL unsigned integer data type (UINT).   But if /NO_UNSIGNED</span>
<span class="comments">;               is set, then the data is converted to type LONG.  </span>
<span class="comments">;</span>
<span class="comments">;       NSLICE - An integer scalar specifying which N-1 dimensional slice of a </span>
<span class="comments">;                N-dimensional array to read.   For example, if the primary </span>
<span class="comments">;                image of a file 'wfpc.fits' contains a 800 x 800 x 4 array, </span>
<span class="comments">;                then </span>
<span class="comments">;</span>
<span class="comments">;                 IDL> im = readfits('wfpc.fits',h, nslice=2)</span>
<span class="comments">;                           is equivalent to </span>
<span class="comments">;                 IDL> im = readfits('wfpc.fits',h)</span>
<span class="comments">;                 IDL> im = im[*,*,2]</span>
<span class="comments">;                 but the use of the NSLICE keyword is much more efficient.</span>
<span class="comments">;                 Note that any degenerate dimensions are ignored, so that the</span>
<span class="comments">;                 above code would also work with a 800 x 800 x 4 x 1 array.</span>
<span class="comments">;</span>
<span class="comments">;       NUMROW -  Scalar non-negative integer specifying the number of rows </span>
<span class="comments">;                 of the image or table extension to read.   Useful when one </span>
<span class="comments">;                 does not want to read the entire image or table.  </span>
<span class="comments">;</span>
<span class="comments">;       POINT_LUN  -  Position (in bytes) in the FITS file at which to start</span>
<span class="comments">;                 reading.   Useful if READFITS is called by another procedure</span>
<span class="comments">;                 which needs to directly read a FITS extension.    Should </span>
<span class="comments">;                 always be a multiple of 2880, and not be used with EXTEN_NO</span>
<span class="comments">;                 keyword.</span>
<span class="comments">;</span>
<span class="comments">;       /SILENT - Normally, READFITS will display the size the array at the</span>
<span class="comments">;                 terminal.  The SILENT keyword will suppress this</span>
<span class="comments">;</span>
<span class="comments">;        STARTROW - Non-negative integer scalar specifying the row</span>
<span class="comments">;               of the image or extension table at which to begin reading. </span>
<span class="comments">;               Useful when one does not want to read the entire table.  </span>
<span class="comments">;</span>
<span class="comments">;       NaNVALUE - This keyword is included only for backwards compatibility</span>
<span class="comments">;                  with routines that require IEEE "not a number" values to be</span>
<span class="comments">;                  converted to a regular value.</span>
<span class="comments">;</span>
<span class="comments">;       /UNIXPIPE - When a FileUnit is supplied to READFITS(), then /UNIXPIPE</span>
<span class="comments">;                 indicates that the unit is to a Unix pipe, and that </span>
<span class="comments">;                 no automatic byte swapping is performed.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Read a FITS file test.fits into an IDL image array, IM and FITS </span>
<span class="comments">;       header array, H.   Do not scale the data with BSCALE and BZERO.</span>
<span class="comments">;</span>
<span class="comments">;              IDL> im = READFITS( 'test.fits', h, /NOSCALE)</span>
<span class="comments">;</span>
<span class="comments">;       If the file contains a FITS extension, it could be read with</span>
<span class="comments">;</span>
<span class="comments">;              IDL> tab = READFITS( 'test.fits', htab, /EXTEN )</span>
<span class="comments">;</span>
<span class="comments">;       The function TBGET() can be used for further processing of a binary </span>
<span class="comments">;       table, and FTGET() for an ASCII table.</span>
<span class="comments">;       To read only rows 100-149 of the FITS extension,</span>
<span class="comments">;</span>
<span class="comments">;              IDL> tab = READFITS( 'test.fits', htab, /EXTEN, </span>
<span class="comments">;                                   STARTR=100, NUMR = 50 )</span>
<span class="comments">;</span>
<span class="comments">;       To read in a file that has been compressed:</span>
<span class="comments">;</span>
<span class="comments">;              IDL> tab = READFITS('test.fits.gz',h)</span>
<span class="comments">;</span>
<span class="comments">; ERROR HANDLING:</span>
<span class="comments">;       If an error is encountered reading the FITS file, then </span>
<span class="comments">;               (1) the system variable !ERROR_STATE.CODE is set negative </span>
<span class="comments">;                   (via the MESSAGE facility)</span>
<span class="comments">;               (2) the error message is displayed (unless /SILENT is set),</span>
<span class="comments">;                   and the message is also stored in !!ERROR_STATE.MSG</span>
<span class="comments">;               (3) READFITS returns with a value of -1</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       (1) Cannot handle random group FITS</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       (1) If data is stored as integer (BITPIX = 16 or 32), and BSCALE</span>
<span class="comments">;       and/or BZERO keywords are present, then the output array is scaled to </span>
<span class="comments">;       floating point (unless /NOSCALE is present) using the values of BSCALE</span>
<span class="comments">;       and BZERO.   In the header, the values of BSCALE and BZERO are then </span>
<span class="comments">;       reset to 1. and 0., while the original values are written into the </span>
<span class="comments">;       new keywords O_BSCALE and O_BZERO.     If the BLANK keyword was</span>
<span class="comments">;       present (giving the value of undefined elements *prior* to the </span>
<span class="comments">;       application of BZERO and BSCALE) then the *keyword* value will be</span>
<span class="comments">;       updated with the values of BZERO and BSCALE.</span>
<span class="comments">;       </span>
<span class="comments">;       (2) The use of the NSLICE keyword is incompatible with the NUMROW</span>
<span class="comments">;       or STARTROW keywords.</span>
<span class="comments">;</span>
<span class="comments">;       (3) On some Unix shells, one may get a "Broken pipe" message if reading</span>
<span class="comments">;        a Unix compressed (.Z) file, and not reading to the end of the file </span>
<span class="comments">;       (i.e. the decompression has not gone to completion).     This is an </span>
<span class="comments">;        informative message only, and should not affect the output of READFITS.   </span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       Functions:   SXPAR()</span>
<span class="comments">;       Procedures:  MRD_SKIP, SXADDPAR, SXDELPAR</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Original Version written in 1988, W.B. Landsman   Raytheon STX</span>
<span class="comments">;       Revision History prior to October 1998 removed          </span>
<span class="comments">;       Major rewrite to eliminate recursive calls when reading extensions</span>
<span class="comments">;                  W.B. Landsman  Raytheon STX                    October 1998</span>
<span class="comments">;       Add /binary modifier needed for Windows  W. Landsman    April 1999</span>
<span class="comments">;       Read unsigned datatypes, added /no_unsigned   W. Landsman December 1999</span>
<span class="comments">;       Output BZERO = 0 for unsigned data types   W. Landsman   January 2000</span>
<span class="comments">;       Update to V5.3 (see notes)  W. Landsman                  February 2000</span>
<span class="comments">;       Fixed logic error in use of NSLICE keyword  W. Landsman  March 2000</span>
<span class="comments">;       Fixed byte swapping for Unix compress files on little endian machines</span>
<span class="comments">;                                    W. Landsman    April 2000</span>
<span class="comments">;       Added COMPRESS keyword, catch IO errors W. Landsman September 2000</span>
<span class="comments">;       Option to read a unit number rather than file name W.L    October 2001</span>
<span class="comments">;       Fix undefined variable problem if unit number supplied W.L. August 2002</span>
<span class="comments">;       Don't read entire header unless needed   W. Landsman  Jan. 2003</span>
<span class="comments">;       Added HBUFFER keyword    W. Landsman   Feb. 2003</span>
<span class="comments">;       Added CHECKSUM keyword   W. Landsman   May 2003</span>
<span class="comments">;       Restored NaNVALUE keyword for backwards compatibility,</span>
<span class="comments">;               William Thompson, 16-Aug-2004, GSFC</span>
<span class="comments">;       Recognize .ftz extension as compressed  W. Landsman   September 2004</span>
<span class="comments">;       Fix unsigned integer problem introduced Sep 2004 W. Landsman Feb 2005</span>
<span class="comments">;       Don't modify header for unsigned integers, preserve double precision</span>
<span class="comments">;           BSCALE value  W. Landsman March 2006</span>
<span class="comments">;       Use gzip instead of compress for Unix compress files W.Landsman Sep 2006</span>
<span class="comments">;       Call MRD_SKIP to skip bytes on different file types W. Landsman Oct 2006</span>
<span class="comments">;       Make ndata 64bit for very large files E. Hivon/W. Landsman May 2007</span>
<span class="comments">;       Fixed bug introduced March 2006 in applying Bzero C. Magri/W.L. Aug 2007</span>
<span class="comments">;       Check possible 32bit overflow when using NSKIP W. Landsman Mar 2008</span>
<span class="comments">;       Always reset BSCALE, BZERO even for unsigned integers W. Landsman May 2008</span>
<span class="comments">;       Make ndata 64bit for very large extensions J. Schou/W. Landsman Jan 2009</span>
<span class="comments">;       Use PRODUCT() to compute # of data points  W. Landsman  May 2009</span>
<span class="comments">;       Read FPACK compressed file via UNIX pipe. W. Landsman May 2009</span>
<span class="comments">;       Fix error using NUMROW,STARTROW with non-byte data, allow these </span>
<span class="comments">;           keywords to be used with primary array  W. Landsman July 2009</span>
<span class="comments">;       Ignore degenerate trailing dimensions with NSLICE keyword W.L. Oct 2009</span>
<span class="comments">;       Add DIALOG_PICKFILE() if filename is an empty string  W.L. Apr 2010</span>
<span class="comments">;       Set BLANK values *before* applying BSCALE,BZERO, use short-circuit</span>
<span class="comments">;           operators  W.L. May 2010</span>
<span class="comments">;      Skip extra SPAWN with FPACK decompress J. Eastman, W.L. July 2010</span>
<span class="comments">;      Fix possible problem when startrow=0 supplied J. Eastman/W.L. Aug 2010</span>
<span class="comments">;      First header is not necessarily primary if unit supplied WL Jan 2011</span>
<span class="comments">;-</span>
<a id="READFITS:source"></a>function READFITS, filename, header, heap, CHECKSUM=checksum, $ 
                   COMPRESS = compress, HBUFFER=hbuf, EXTEN_NO = exten_no, $
                   NOSCALE = noscale, NSLICE = nslice, $
                   NO_UNSIGNED = no_unsigned,  NUMROW = numrow, $
                   POINTLUN = pointlun, SILENT = silent, STARTROW = startrow, $
                   NaNvalue = NaNvalue, FPACK = fpack, UNIXpipe=unixpipe

  On_error,2                    <span class="comments">;Return to user</span>
  compile_opt idl2
  On_IOerror, BAD

<span class="comments">; Check for filename input</span>

   if N_params() LT 1 then begin                
      print,'Syntax - im = READFITS( filename, [ h, heap, /NOSCALE, /SILENT,'
      print,'                 EXTEN_NO =, STARTROW = , NUMROW=, NSLICE = ,'
      print,'                 HBUFFER = ,/NO_UNSIGNED, /CHECKSUM, /COMPRESS]'
      return, -1
   endif

   unitsupplied = size(filename,/TNAME) NE 'STRING'

<span class="comments">; Set default keyword values</span>

   silent = keyword_set( SILENT )
   do_checksum = keyword_set( CHECKSUM )
   if N_elements(exten_no) EQ 0 then exten_no = 0

<span class="comments">;  Check if this is a Unix compressed file.   (gzip files are handled </span>
<span class="comments">;  separately using the /compress keyword to OPENR).</span>

    if N_elements(unixpipe) EQ 0 then unixpipe = 0                  
    if unitsupplied then unit = filename else begin
    len = strlen(filename)
    if len EQ 0 then begin
        filename =dialog_pickfile(filter=['*.fit*;*.fts*;*.img*'], $
	title='Please select a FITS file',/must_exist)
        len = strlen(filename)
    endif 
    ext = strlowcase(strmid(filename,len-3,3))
    gzip = (ext EQ '.gz') || (ext EQ 'ftz')
    compress = keyword_set(compress) || gzip[0]
    unixZ =  (strmid(filename, len-2, 2) EQ '.Z') 
    fcompress = keyword_set(fpack) || ( ext EQ '.fz') 
    unixpipe = unixZ || fcompress	      

 
<span class="comments">;  Go to the start of the file.</span>

   openr, unit, filename, ERROR=error,/get_lun, $
                COMPRESS = compress, /swap_if_little_endian
   if error NE 0 then begin
        message,/con,' ERROR - Unable to locate file ' + filename
        return, -1
   endif

<span class="comments">;  Handle Unix or Fpack compressed files which will be opened via a pipe using</span>
<span class="comments">;  the SPAWN command.     </span>

        if unixZ then begin
                free_lun, unit
                spawn, 'gzip -cd '+filename, unit=unit                 
                gzip = 1b

        endif else if fcompress then begin 
	        free_lun, unit
		spawn,'funpack -S ' + filename, unit=unit,/sh
                if eof(unit) then begin 
		    message,'Error spawning FPACK decompression',/CON
		    free_lun,unit
		    return,-1
		endif    
	endif	
  endelse
  if keyword_set(POINTLUN) then mrd_skip, unit, pointlun

  doheader = arg_present(header) or do_checksum
  if doheader  then begin
          if N_elements(hbuf) EQ 0 then hbuf = 180 else begin
                  remain = hbuf mod 36
                  if remain GT 0 then hbuf = hbuf + 36-remain
           endelse
  endif else hbuf = 36

  for ext = 0L, exten_no do begin
               
<span class="comments">;  Read the next header, and get the number of bytes taken up by the data.</span>

       block = string(replicate(32b,80,36))
       w = [-1]
       if ((ext EQ exten_no) && (doheader)) then header = strarr(hbuf) $
                                             else header = strarr(36)
       headerblock = 0L
       i = 0L      

       while w[0] EQ -1 do begin
          
       if EOF(unit) then begin 
            message,/ CON, $
               'EOF encountered attempting to read extension ' + strtrim(ext,2)
            if ~unitsupplied then free_lun,unit
            return,-1
       endif

      readu, unit, block
      headerblock = headerblock + 1
      w = where(strlen(block) NE 80, Nbad)
      if (Nbad GT 0) then begin
           message,'Warning-Invalid characters in header',/INF,NoPrint=Silent
           block[w] = string(replicate(32b, 80))
      endif
      w = where(strcmp(block,'END     ',8), Nend)
      if (headerblock EQ 1) || ((ext EQ exten_no) && (doheader)) then begin
              if Nend GT 0 then  begin
             if headerblock EQ 1 then header = block[0:w[0]]   $
                                 else header = [header[0:i-1],block[0:w[0]]]
             endif else begin
                header[i] = block
                i = i+36
                if i mod hbuf EQ 0 then $
                              header = [header,strarr(hbuf)]
           endelse
          endif
      endwhile

      if (ext EQ 0 ) && ~(keyword_set(pointlun) || unitsupplied ) then $
             if strmid( header[0], 0, 8)  NE 'SIMPLE  ' then begin
              message,/CON, $
                 'ERROR - Header does not contain required SIMPLE keyword'
                if ~unitsupplied then free_lun, unit
                return, -1
      endif

                
<span class="comments">; Get parameters that determine size of data region.</span>
                
       bitpix =  sxpar(header,'BITPIX')
       byte_elem = abs(bitpix)/8               <span class="comments">;Bytes per element</span>
       naxis  = sxpar(header,'NAXIS')
       gcount = sxpar(header,'GCOUNT') > 1
       pcount = sxpar(header,'PCOUNT')
                
       if naxis GT 0 then begin 
            dims = sxpar( header,'NAXIS*')           <span class="comments">;Read dimensions</span>
	    ndata = product(dims,/integer)
       endif else ndata = 0
                
       nbytes = byte_elem * gcount * (pcount + ndata)

<span class="comments">;  Move to the next extension header in the file.   Use MRD_SKIP to skip with</span>
<span class="comments">;  fastest available method (POINT_LUN or readu) for different file</span>
<span class="comments">;  types (regular, compressed, Unix pipe, socket) </span>

      if ext LT exten_no then begin
                nrec = long((nbytes + 2879) / 2880)
                if nrec GT 0 then mrd_skip, unit, nrec*2880L    
       endif
       endfor

 case BITPIX of 
           8:   IDL_type = 1          <span class="comments">; Byte</span>
          16:   IDL_type = 2          <span class="comments">; Integer*2</span>
          32:   IDL_type = 3          <span class="comments">; Integer*4</span>
          64:   IDL_type = 14         <span class="comments">; Integer*8</span>
         -32:   IDL_type = 4          <span class="comments">; Real*4</span>
         -64:   IDL_type = 5          <span class="comments">; Real*8</span>
        else:   begin
                message,/CON, 'ERROR - Illegal value of BITPIX (= ' +  $
                strtrim(bitpix,2) + ') in FITS header'
                if ~unitsupplied then free_lun,unit
                return, -1
                end
  endcase     
 
  if nbytes EQ 0 then begin
        if ~SILENT then message, $
                "FITS header has NAXIS or NAXISi = 0,  no data array read",/CON
        if do_checksum then begin
             result = FITS_TEST_CHECKSUM(header, data, ERRMSG = errmsg)
             if ~SILENT then begin
               case result of 
                1: message,/INF,'CHECKSUM keyword in header is verified'
               -1: message,/CON, errmsg
                else: 
                endcase
              endif
        endif
        if ~unitsupplied then free_lun, unit
        return,-1
 endif

<span class="comments">; Check for FITS extensions, GROUPS</span>

 groups = sxpar( header, 'GROUPS' ) 
 if groups then message,NoPrint=Silent, $
           'WARNING - FITS file contains random GROUPS', /INF

<span class="comments">; If an extension, did user specify row to start reading, or number of rows</span>
<span class="comments">; to read?</span>

   if N_elements(STARTROW) EQ 0 then startrow = 0       <span class="comments">;updated Aug 2010</span>
   if naxis GE 2 then nrow = dims[1] else nrow = ndata
   if ~keyword_set(NUMROW) then numrow = nrow
   if do_checksum then if ((startrow GT 0) || $
      (numrow LT nrow) || (N_elements(nslice) GT 0)) then begin 
      message,/CON, $
      'Warning - CHECKSUM not applied when STARTROW, NUMROW or NSLICE is set'
      do_checksum = 0
   endif 

   if exten_no GT 0 then begin
        xtension = strtrim( sxpar( header, 'XTENSION' , Count = N_ext),2)
        if N_ext EQ 0 then message, /INF, NoPRINT = Silent, $
                'WARNING - Header missing XTENSION keyword'
   endif 

   if ((startrow NE 0) || (numrow NE nrow)) then begin
        if startrow GE dims[1] then begin
           message,'ERROR - Specified starting row ' + strtrim(startrow,2) + $
          ' but only ' + strtrim(dims[1],2) + ' rows in extension',/CON
           if ~unitsupplied then free_lun,unit
           return,-1
        endif 
        dims[1] = dims[1] - startrow    
        dims[1] = dims[1] &lt<span class="comments">; numrow</span>
        sxaddpar, header, 'NAXIS2', dims[1]
	if startrow GT 0 then mrd_skip, unit, byte_elem*startrow*dims[0]

    endif else if (N_elements(NSLICE) EQ 1) then begin
 
        ldim = naxis-1
        lastdim = dims[ldim]
	while lastdim EQ 1 do begin
	      ldim = ldim-1
	      lastdim = dims[ldim]
	endwhile
	       if nslice GE lastdim then begin 
	      message,/CON, $
        'ERROR - Value of NSLICE must be less than ' + strtrim(lastdim,2)
               if ~unitsupplied then free_lun, unit
 	      return, -1
	endif      
        dims = dims[0:ldim-1]
        for i = ldim,naxis-1 do sxdelpar,header,'NAXIS' + strtrim(i+1,2)
        naxis = ldim
        sxaddpar,header,'NAXIS' + strtrim(ldim,2),1
        ndata = ndata/lastdim
        nskip = long64(nslice)*ndata*byte_elem
	if Ndata GT 0 then mrd_skip, unit, nskip  
  endif


  if ~SILENT then begin   <span class="comments">;Print size of array being read</span>

         if exten_no GT 0 then message, $
                     'Reading FITS extension of type ' + xtension, /INF  
	 if N_elements(dims) EQ 1 then $
	 st = 'Now reading ' + strtrim(dims,2) + ' element vector' else $	          
	 st = 'Now reading ' + strjoin(strtrim(dims,2),' by ') + ' array'
         if (exten_no GT 0) && (pcount GT 0) then st = st + ' + heap area'
         message,/INF,st   
   endif

<span class="comments">; Read Data in a single I/O call.   Only need byteswapping for data read with</span>
<span class="comments">; bidirectional pipe.</span>

    data = make_array( DIM = dims, TYPE = IDL_type, /NOZERO)
    readu, unit, data
    if unixpipe  then swap_endian_inplace,data,/swap_if_little
    if (exten_no GT 0) && (pcount GT 0) then begin
        theap = sxpar(header,'THEAP')
        skip = theap - N_elements(data)
        if skip GT 0 then begin 
                temp = bytarr(skip,/nozero)
                readu, unit, skip
        endif
        heap = bytarr(pcount*gcount*byte_elem)
        readu, unit, heap
        if do_checksum then $
        result = fits_test_checksum(header,[data,heap],ERRMSG=errmsg)
    endif else if do_checksum then $
        result = fits_test_checksum(header, data, ERRMSG = errmsg)
    if ~unitsupplied then free_lun, unit
    if do_checksum then if ~SILENT then begin
        case result of 
        1: message,/INF,'CHECKSUM keyword in header is verified'
       -1: message,/CON, 'CHECKSUM ERROR! ' + errmsg
        else: 
        endcase
    endif

<span class="comments">; Scale data unless it is an extension, or /NOSCALE is set</span>
<span class="comments">; Use "TEMPORARY" function to speed processing.  </span>

   do_scale = ~keyword_set( NOSCALE )
   if (do_scale && (exten_no GT 0)) then do_scale = xtension EQ 'IMAGE' 
   if do_scale then begin

          if bitpix GT 0 then $
                blank = sxpar( header, 'BLANK', Count = N_blank) $
		else N_blank = 0
 
          Bscale = sxpar( header, 'BSCALE' , Count = N_bscale)
          Bzero = sxpar(header, 'BZERO', Count = N_Bzero )
         if (N_blank GT 0) && ((N_bscale GT 0) || (N_Bzero GT 0)) then $
                 sxaddpar,header,'O_BLANK',blank,' Original BLANK value'
       
 
 
<span class="comments">; Check for unsigned integer (BZERO = 2^15) or unsigned long (BZERO = 2^31)</span>

          if ~keyword_set(No_Unsigned) then begin
            no_bscale = (Bscale EQ 1) || (N_bscale EQ 0)
            unsgn_int = (bitpix EQ 16) && (Bzero EQ 32768) && no_bscale
            unsgn_lng = (bitpix EQ 32) && (Bzero EQ 2147483648) && no_bscale
            unsgn = unsgn_int || unsgn_lng
           endif else unsgn = 0

          if unsgn then begin
                    if unsgn_int then begin  
                        data =  uint(data) - 32768US
			if N_blank then blank = uint(blank) - 32768US 
		   endif else  begin 
                         data = ulong(data) - 2147483648UL
			if N_blank then blank = ulong(blank) - 2147483648UL
		   endelse 
		   if N_blank then sxaddpar,header,'BLANK',blank
                   sxaddpar, header, 'BZERO', 0
                   sxaddpar, header, 'O_BZERO', Bzero,' Original BZERO Value'
               
          endif else begin
 
          if N_Bscale GT 0  then $ 
               if ( Bscale NE 1. ) then begin
	           if size(Bscale,/TNAME) NE 'DOUBLE' then $
                      data *= float(Bscale) else $ 
		      data *= Bscale 
		  if N_blank then blank *= bscale    
                  sxaddpar, header, 'BSCALE', 1.
                   sxaddpar, header, 'O_BSCALE', Bscale,' Original BSCALE Value'
		   
               endif

         if N_Bzero GT 0  then $
               if (Bzero NE 0) then begin
	             if size(Bzero,/TNAME) NE 'DOUBLE' then $
                      data += float(Bzero) else $    <span class="comments">;Fixed Aug 07</span>
                      data +=  Bzero
		      if N_blank then blank += bzero
                     sxaddpar, header, 'BZERO', 0.
                     sxaddpar, header, 'O_BZERO', Bzero,' Original BZERO Value'
               endif
        
        endelse
	if  N_blank then sxaddpar,header,'BLANK',blank
        endif


<span class="comments">; Return array.  If necessary, first convert NaN values.</span>

        if n_elements(nanvalue) eq 1 then begin
            w = where(finite(data,/nan),count)
            if count gt 0 then data[w] = nanvalue
        endif
        return, data    

<span class="comments">; Come here if there was an IO_ERROR</span>
    
 BAD:   print,!ERROR_STATE.MSG
        if (~unitsupplied) && (N_elements(unit) GT 0) then free_lun, unit
        if N_elements(data) GT 0 then return,data else return, -1

 end 
</code>
    </div>
  </body>
</html>