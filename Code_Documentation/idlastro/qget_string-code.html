<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:57 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>qget_string.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="qget_string.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION qget_string, dummy
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     QGET_STRING</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     To get a string from the keyboard without echoing it to the screen.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;     string = QGET_STRING() </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     None.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     string   The string read from the keyboard.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;     A string variable is created and filled.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;     The IDL GET_KBRD functions is used to get each character in</span>
<span class="comments">;     the string.  Each character is added to the string until a</span>
<span class="comments">;     carriage return is struck.  The carriage return is not appended</span>
<span class="comments">;     to the string.  Striking the delete key or the backspace key</span>
<span class="comments">;     removes the previous character from the string.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;     For a widget password procedure see </span>
<span class="comments">;     http://idlcoyote.com/tip_examples/password.pro</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by Michael R. Greason, STX, 8 January 1991.</span>
<span class="comments">;     Work for Mac and Windows IDL  W. Landsman    September 1995</span>
<span class="comments">;-</span>
 compile_opt idl2

<span class="comments">;                       Variable definitions.</span>
<span class="comments">;</span>
 st = bytarr(1)                                 <span class="comments">; String variable.</span>
 n = 0

 IF !VERSION.OS_FAMILY EQ "unix" THEN dun = 10B $       <span class="comments">; Unix version of CR.</span>
                           ELSE dun = 13B       <span class="comments">; All other version of CR.</span>
wt = 1                                          <span class="comments">; Wait for key to be struck?</span>
del = 127B & bs = 8B                            <span class="comments">; Delete, backspace keys.</span>
<span class="comments">;</span>
<span class="comments">;                       Loop, gathering characters into the string until</span>
<span class="comments">;                       a carriage return has been struck.</span>
<span class="comments">;</span>
REPEAT BEGIN
<span class="comments">;</span>
<span class="comments">;                               Get next character.</span>
<span class="comments">;</span>
        ch = byte(get_kbrd(wt))
        ch = ch[0]
<span class="comments">;</span>
<span class="comments">;                               If it isn't a carriage return, process it.</span>
<span class="comments">;</span>
        IF (ch NE dun) THEN BEGIN
<span class="comments">;</span>
<span class="comments">;                                       If it isn't a delete or backspace,</span>
<span class="comments">;                                       append it to the string.</span>
<span class="comments">;</span>
                IF ((ch NE del) && (ch NE bs)) THEN BEGIN
                        IF (n LE 0) THEN BEGIN
                                st[0] = ch
                                n = 1
                        ENDIF ELSE BEGIN
                                st = [st, ch]
                                n++
                        ENDELSE
                ENDIF ELSE BEGIN
<span class="comments">;</span>
<span class="comments">;                                       It's a delete/backspace.  Remove the</span>
<span class="comments">;                                       previous character.</span>
<span class="comments">;</span>
                        IF (n GT 0) THEN BEGIN
                                n--
                                IF (n GT 0) THEN st = st[0:(n-1)]
                        ENDIF
                ENDELSE
        ENDIF
<span class="comments">;</span>
ENDREP UNTIL (ch EQ dun)
<span class="comments">;</span>
<span class="comments">;                       Finished.</span>
<span class="comments">;</span>
IF (n LE 0) THEN st = '' ELSE st = string(st)
RETURN, st
END
</code>
    </div>
  </body>
</html>