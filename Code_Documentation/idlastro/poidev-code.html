<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:56 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>poidev.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="poidev.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="poidev:source"></a>function poidev, xm, SEED = seed
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;     POIDEV</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;     Generate a Poisson random deviate</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;     Return an integer random deviate drawn from a Poisson distribution with</span>
<span class="comments">;     a specified mean.    Adapted from procedure of the same name in </span>
<span class="comments">;     "Numerical Recipes" by Press et al. (1992), Section 7.3</span>
<span class="comments">;</span>
<span class="comments">;     NOTE: This routine became partially obsolete in V5.0 with the </span>
<span class="comments">;     introduction of the POISSON keyword to the intrinsic functions </span>
<span class="comments">;     RANDOMU and RANDOMN.     However, POIDEV is still useful for adding </span>
<span class="comments">;     Poisson noise to an existing image array, for which the coding is much </span>
<span class="comments">;     simpler than it would be using RANDOMU (see example 1) </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;     result = POIDEV( xm, [ SEED = ] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     xm - numeric scalar, vector or array, specifying the mean(s) of the </span>
<span class="comments">;          Poisson distribution</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;     result - Long integer scalar or vector, same size as xm</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT-OUTPUT:</span>
<span class="comments">;     SEED -  Scalar to be used as the seed for the random distribution.  </span>
<span class="comments">;             For best results, SEED should be a large (>100) integer.</span>
<span class="comments">;             If SEED is undefined, then its value is taken from the system </span>
<span class="comments">;             clock (see RANDOMU).    The value of SEED is always updated </span>
<span class="comments">;             upon output.   This keyword can be used to have POIDEV give </span>
<span class="comments">;             identical results on consecutive runs.     </span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;     (1) Add Poisson noise to an integral image array, im</span>
<span class="comments">;              IDL> imnoise = POIDEV( im)</span>
<span class="comments">;</span>
<span class="comments">;     (2) Verify the expected mean  and sigma for an input value of 81</span>
<span class="comments">;              IDL> p = POIDEV( intarr(10000) + 81)   ;Test for 10,000 points</span>
<span class="comments">;              IDL> print,mean(p),sigma(p)</span>
<span class="comments">;     Mean and sigma of the 10000 points should be close to 81 and 9</span>
<span class="comments">;</span>
<span class="comments">; METHOD: </span>
<span class="comments">;     For small values (&lt; 20) independent exponential deviates are generated </span>
<span class="comments">;     until their sum exceeds the specified mean, the number of events </span>
<span class="comments">;     required is returned as the Poisson deviate.   For large (> 20) values,</span>
<span class="comments">;     uniform random variates are compared with a Lorentzian distribution </span>
<span class="comments">;     function.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;     Negative values in the input array will be returned as zeros.  </span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;      Version 1               Wayne Landsman        July  1992</span>
<span class="comments">;      Added SEED keyword                            September 1992</span>
<span class="comments">;      Call intrinsic LNGAMMA function               November 1994</span>
<span class="comments">;      Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;      Use COMPLEMENT keyword to WHERE()        W. Landsman August 2008</span>
<span class="comments">;-</span>
  On_error,2
  compile_opt idl2

 Npts = N_elements( xm)
 
 case NPTS of 
 0: message,'ERROR - Poisson mean vector (first parameter) is undefined'
 1: output = lonarr(1) 
 else: output = make_array( SIZE = size(xm), /NOZERO ) 
 endcase 
 
   index = where( xm LE 20, Nindex, complement=big, Ncomplement=Nbig)

   if Nindex GT 0 then begin

   g = exp( -xm[ index] )           <span class="comments">;To compare with exponential distribution</span>
   em1 = replicate( -1, Nindex )    <span class="comments">;Counts number of events</span>
   t = replicate( 1., Nindex )          <span class="comments">;Counts (log) of total time</span>

  Ngood = Nindex
  good = lindgen( Nindex)                 <span class="comments">;GOOD indexes the original array</span>
  good1 = good                         <span class="comments">;GOOD1 indexes the GOOD vector</span>

 REJECT:  em1[good] = em1[good] + 1      <span class="comments">;Increment event counter</span>
   t = t[good1]*randomu( seed, Ngood )   <span class="comments">;Add exponential deviate, equivalent</span>
                                         <span class="comments">;to multiplying random deviate</span>
   good1 = where( t GT g[good], Ngood1)  <span class="comments">;Has sum of exponential deviates </span>
                                         <span class="comments">;exceeded specified mean?</span>
   if ( Ngood1 GE 1 ) then begin
           good = good[ good1]
           Ngood = Ngood1
           goto, REJECT
   endif
   output[index] = em1
 endif
     if Nindex EQ Npts then return, output
<span class="comments">; ***************************************</span>

    xbig = xm[big]

    sq = sqrt( 2.*xbig )           <span class="comments">;Sq, Alxm, and g are precomputed</span>
    alxm = alog( xbig )
    g = xbig * alxm - lngamma( xbig + 1.)

    Ngood = Nbig  & Ngood1 = Nbig
    good = lindgen( Ngood)
    good1 = good
    y = fltarr(Ngood, /NOZERO ) & em = y


REJECT1:   y[good] = tan( !PI * randomu( seed, Ngood ) )  
   em[good] = sq[good]*y[good] + xbig[good]
   good2 = where( em[good] LT 0. , Ngood )
   if (Ngood GT 0) then begin
            good = good[good2]
            goto, REJECT1
   endif

   fixem = long( em[good1] )
   test = check_math( 0, 1)         <span class="comments">;Don't want overflow messages</span>
   t = 0.9*(1. + y[good1]^2)*exp( fixem*alxm[good1] - $ 
               lngamma( fixem + 1.) - g[good1] )
   good2 = where( randomu (seed, Ngood1) GT T , Ngood)
   if ( Ngood GT 0 ) then begin
            good1 = good1[good2]
            good = good1
            goto, REJECT1
   endif
   output[ big ] = long(em)

 return, output

 end
</code>
    </div>
  </body>
</html>