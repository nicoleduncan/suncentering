<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:01 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>rinter.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="rinter.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION RINTER, P, X, Y, DFDX, DFDY, INITIALIZE = initialize
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      RINTER</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      Cubic interpolation of an image at a set of reference points.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;      This interpolation program is equivalent to using the intrinsic </span>
<span class="comments">;      INTERPOLATE() function with CUBIC = -0.5.   However,</span>
<span class="comments">;      RINTER() has two advantages: (1) one can optionally obtain the </span>
<span class="comments">;      X and Y derivatives at the reference points, and (2) if repeated</span>
<span class="comments">;      interpolation is to be applied to an array, then some values can</span>
<span class="comments">;      be pre-computed and stored in Common.   RINTER() was originally  </span>
<span class="comments">;      for use with the DAOPHOT procedures, but can also be used for </span>
<span class="comments">;      general cubic interpolation.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      Z = RINTER( P, X, Y, [ DFDX, DFDY ] )</span>
<span class="comments">;               or</span>
<span class="comments">;      Z = RINTER(P, /INIT)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:                 </span>
<span class="comments">;      P  - Two dimensional data array, </span>
<span class="comments">;      X  - Either an N element vector or an N x M element array,</span>
<span class="comments">;               containing X subscripts where cubic interpolation is desired.</span>
<span class="comments">;      Y -  Either an N element vector or an N x M element array, </span>
<span class="comments">;               containing Y subscripts where cubic interpolation is desired.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;      Z -  Result = interpolated vector or array.  If X and Y are vectors,</span>
<span class="comments">;              then so is Z, but if X and Y are arrays then Z will be also.</span>
<span class="comments">;              If P is DOUBLE precision, then so is Z, otherwise Z is REAL.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;      DFDX - Vector or Array, (same size and type as Z), containing the </span>
<span class="comments">;               derivatives with respect to X</span>
<span class="comments">;      DFDY - Array containing derivatives with respect to Y</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;     /INIT - Perform computations associated only with the input array (i.e. </span>
<span class="comments">;             not with X and Y) and store in common.    This can save time if</span>
<span class="comments">;             repeated calls to RINTER are made using the same array.  </span>
<span class="comments">;        </span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;      suppose P is a 256 x 256 element array and X = FINDGEN(50)/2. + 100.</span>
<span class="comments">;      and Y = X.  Then Z will be a 50 element array, containing the</span>
<span class="comments">;      cubic interpolated points.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;      can be time consuming.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTION:</span>
<span class="comments">;      Interpolation is not possible at positions outside the range of </span>
<span class="comments">;       the array (including all negative subscripts), or within 2 pixel</span>
<span class="comments">;       units of the edge.  No error message is given but values of the </span>
<span class="comments">;       output array are meaningless at these positions.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       invokes CUBIC interpolation algorithm to evaluate each element</span>
<span class="comments">;       in Z at virtual coordinates contained in X and Y with the data</span>
<span class="comments">;       in P.                                                          </span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       If repeated interpolation of the same array is to occur, then</span>
<span class="comments">;       one can save time by initializing the common block RINTER.    </span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       March 1988 written W. Landsman STX Co.</span>
<span class="comments">;       Checked for IDL Version 2, J. Isensee, September, 1990</span>
<span class="comments">;       Corrected call to HISTOGRAM, W. Landsman November 1990</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Fix output derivatives for 2-d inputs, added /INIT W. Landsman May 2000</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
 On_error, 2     
 common rinter, c1, c2, c3, init         

 if (N_params() LT 3) and (NOT keyword_set(INIT)) then begin     
        print, 'Syntax:  Z = RINTER( P, X, Y, [ DFDX, DFDY] )  '
        print, '   or    Z = RINTER( P, /INIT)    to initialize common block
        print,'P -  Array to be interpolated' 
        print,'X -  Vector or array of X positions' 
        print,'Y -  Vector or array of Y Positions'
        print,'DFDX, DFDY - Optional output derivatives '
        return,0
 endif 

 c = size(p)
 if c[0] NE 2 then $    
        message,'Input array (first parameter) must be 2 dimensional'

 if keyword_set(initialize) then begin

<span class="comments">; Don't use SHIFT function to avoid wraparound at the end points</span>

      nx = c[1]
      p_1 = p & p1 = p & p2 = p
      p_1[1,0] = p[0:nx-2,*]
      p1[0,0] = p[1:*,*]
      p2[0,0] = p[2:*,*]
      c1 = 0.5*(p1 - p_1)
      c2 = 2.*p1 + p_1 - 0.5*(5.*p + p2)
      c3 = 0.5*(3.*(p-p1) + p2 - p_1)
      init = 1
      if N_params() LT 3 then return,0
 endif
 
 sx = size(x)
 npts = sx[sx[0]+2]
 c[3] = c[3] > 4                        <span class="comments">;Make sure output array at least REAL</span>

 i = long( x[*] ) 
 j = long( y[*] )
 xdist = x[*] - i  
 ydist = y[*] - j
 x_1 = c[1]*(j-1) + i
 x0 = x_1 + c[1] 
 x1 = x0 + c[1] 
 x2 = x1 + c[1]

 if N_elements(init) EQ 0 then init = 0    <span class="comments">;Has COMMON block been initialized?</span>

 if init EQ 0 then begin 

   xgood = [ x_1,x0,x1,x2 ]
   num = histogram( xgood, MIN=0)
   xgood = where( num GE 1 ) 
   p_1 = p[xgood-1] & p0 = p[xgood] & p1 = p[xgood+1] & p2 = p[xgood+2]
   c1 = p*0.  & c2 = c1 & c3 = c1
   c1[xgood] = 0.5*( p1 - p_1)
   c2[xgood] = 2.*p1 + p_1 - 0.5*(5.*p0 + p2)
   c3[xgood] = 0.5*(3.*(p0 - p1) + p2 - p_1)
 endif

 y_1 = xdist*( xdist*( xdist*c3[x_1] +c2[x_1]) + c1[x_1]) + p[x_1]
 y0 =  xdist*( xdist*( xdist*c3[x0] +c2[x0]) + c1[x0]) + p[x0]
 y1 =  xdist*( xdist*( xdist*c3[x1] +c2[x1]) + c1[x1]) + p[x1]
 y2 =  xdist*( xdist*( xdist*c3[x2] +c2[x2]) + c1[x2]) + p[x2]

 if N_params() GT 3 then begin
 
    dy_1 = xdist*(xdist*c3[x_1]*3. + 2.*c2[x_1]) + c1[x_1]
    dy0  = xdist*(xdist*c3[x0 ]*3. + 2.*c2[x0]) + c1[x0]
    dy1  = xdist*(xdist*c3[x1 ]*3. + 2.*c2[x1]) + c1[x1]
    dy2  = xdist*(xdist*c3[x2 ]*3. + 2.*c2[x2]) + c1[x2]
    d1 = 0.5*(dy1 - dy_1)
    d2 = 2.*dy1 + dy_1 - 0.5*(5.*dy0 +dy2)
    d3 = 0.5*( 3.*( dy0-dy1 ) + dy2 - dy_1)
    dfdx =  ydist*( ydist*( ydist*d3 + d2 ) + d1 ) + dy0

 endif

 d1 = 0.5*(y1 - y_1)
 d2 = 2.*y1 + y_1 - 0.5*(5.*y0 +y2)
 d3 = 0.5*(3.*(y0-y1) + y2 - y_1)
 z =  ydist*(ydist*(ydist*d3 + d2) + d1) + y0  
 if N_params() GT 3 then dfdy = ydist*(ydist*d3*3.+2*d2) + d1   
 
 if ( sx[0] EQ 2 ) then begin        <span class="comments">;Convert results to 2-D if desired</span>

    z = reform(z,sx[1],sx[2] ) 
    if N_params() GT 3 then  begin      <span class="comments">;Create output derivative arrays?</span>
          dfdx = reform(dfdx,sx[1],sx[2])
          dfdy = reform(dfdy,sx[1],sx[2])          
     endif

 endif

 return,z
 end                    
</code>
    </div>
  </body>
</html>