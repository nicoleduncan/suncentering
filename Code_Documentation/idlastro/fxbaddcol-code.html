<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:33 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbaddcol.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbaddcol.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXBADDCOL,INDEX,HEADER,ARRAY,TTYPE,COMMENT,TUNIT=TUNIT,	$
		TSCAL=TSCAL,TZERO=TZERO,TNULL=TNULL,TDISP=TDISP,	$
		TDMIN=TDMIN,TDMAX=TDMAX,TDESC=TDESC,TROTA=TROTA,	$
		TRPIX=TRPIX,TRVAL=TRVAL,TDELT=TDELT,TCUNI=TCUNI,	$
		NO_TDIM=NO_TDIM,VARIABLE=VARIABLE,DCOMPLEX=DCOMPLEX,	$
		BIT=BIT,LOGICAL=LOGICAL,ERRMSG=ERRMSG
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXBADDCOL</span>
<span class="comments">; PURPOSE     : </span>
<span class="comments">;	Adds a column to a binary table extension.</span>
<span class="comments">; EXPLANATION : </span>
<span class="comments">;	Modify a basic FITS binary table extension (BINTABLE) header array to</span>
<span class="comments">;	define a column.</span>
<span class="comments">; USE         : </span>
<span class="comments">;	FXBADDCOL, INDEX, HEADER, ARRAY  [, TTYPE [, COMMENT ]]</span>
<span class="comments">; INPUTS      : </span>
<span class="comments">;	HEADER	= String array containing FITS extension header.</span>
<span class="comments">;	ARRAY	= IDL variable used to determine the data size and type</span>
<span class="comments">;		  associated with the column.  If the column is defined as</span>
<span class="comments">;		  containing variable length arrays, then ARRAY must be of the</span>
<span class="comments">;		  maximum size to be stored in the column.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	TTYPE	= Column label.</span>
<span class="comments">;	COMMENT = Comment for TTYPE</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	INDEX	= Index (1-999) of the created column.</span>
<span class="comments">;	HEADER	= The header is modified to reflect the added column.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;	VARIABLE= If set, then the column is defined to contain pointers to</span>
<span class="comments">;		  variable length arrays in the heap area.</span>
<span class="comments">;	DCOMPLEX= If set, and ARRAY is complex, with the first dimension being</span>
<span class="comments">;		  two (real and imaginary parts), then the column is defined as</span>
<span class="comments">;		  double-precision complex (type "M").     This keyword is</span>
<span class="comments">;		  only needed prior to IDL Version 4.0, when the double </span>
<span class="comments">;		  double complex datatype was unavailable in IDL</span>
<span class="comments">;	BIT	= If passed, and ARRAY is of type byte, then the column is</span>
<span class="comments">;		  defined as containg bit mask arrays (type "X"), with the</span>
<span class="comments">;		  value of BIT being equal to the number of mask bits.</span>
<span class="comments">;	LOGICAL	= If set, and array is of type byte, then the column is defined</span>
<span class="comments">;		  as containing logical arrays (type "L").</span>
<span class="comments">;	NO_TDIM	= If set, then the TDIMn keyword is not written out to the</span>
<span class="comments">;		  header.  No TDIMn keywords are written for columns containing</span>
<span class="comments">;		  variable length arrays.</span>
<span class="comments">;	TUNIT	= If passed, then corresponding keyword is added to header.</span>
<span class="comments">;	TSCAL	= Same.</span>
<span class="comments">;	TZERO	= Same.</span>
<span class="comments">;	TNULL	= Same.</span>
<span class="comments">;	TDISP	= Same.</span>
<span class="comments">;	TDMIN	= Same.</span>
<span class="comments">;	TDMAX	= Same.</span>
<span class="comments">;	TDESC	= Same.</span>
<span class="comments">;	TCUNI	= Same.</span>
<span class="comments">;	TROTA	= Same.</span>
<span class="comments">;	TRPIX	= Same.</span>
<span class="comments">;	TRVAL	= Same.</span>
<span class="comments">;	TDELT	= Same.</span>
<span class="comments">;	ERRMSG	= If defined and passed, then any error messages will be</span>
<span class="comments">;		  returned to the user in this parameter rather than</span>
<span class="comments">;		  depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		  encountered, then a null string is returned.  In order to</span>
<span class="comments">;		  use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXBADDCOL, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	FXADDPAR, FXPAR</span>
<span class="comments">; Common      : </span>
<span class="comments">;	None.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	Warning: No checking is done of any of the parameters defining the</span>
<span class="comments">;	values of optional FITS keywords.</span>
<span class="comments">;</span>
<span class="comments">;	FXBHMAKE must first be called to initialize the header.</span>
<span class="comments">;</span>
<span class="comments">;	If ARRAY is of type character, then it must be of the maximum length</span>
<span class="comments">;	expected for this column.  If a character string array, then the</span>
<span class="comments">;	largest string in the array is used to determine the maximum length.</span>
<span class="comments">;</span>
<span class="comments">;	The DCOMPLEX keyword is ignored if ARRAY is not double-precision.</span>
<span class="comments">;	ARRAY must also have a first dimension of two representing the real and</span>
<span class="comments">;	imaginary parts.</span>
<span class="comments">;</span>
<span class="comments">;	The BIT and LOGICAL keywords are ignored if ARRAY is not of type byte.</span>
<span class="comments">;	BIT takes precedence over LOGICAL.</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	If the data array is multidimensional, then a TDIM keyword is added to</span>
<span class="comments">;	the header, unless either NO_TDIM or VARIABLE is set.</span>
<span class="comments">;</span>
<span class="comments">;	No TDIMn keywords are written out for bit arrays (format 'X'), since</span>
<span class="comments">;	the dimensions would refer to bits, not bytes.</span>
<span class="comments">;</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	William Thompson, Jan 1992.</span>
<span class="comments">;	W. Thompson, Feb 1992, changed from function to procedure.</span>
<span class="comments">;	W. Thompson, Feb 1992, modified to support variable length arrays.</span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, January 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 31 May 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;       Version 3, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;	Version 4, William Thompson, GSFC, 30 December 1994</span>
<span class="comments">;		Added keyword TCUNI.</span>
<span class="comments">;	Version 5, Wayne Landsman, GSFC, 12 Aug 1997</span>
<span class="comments">;		Recognize double complex IDL datatype</span>
<span class="comments">;       Version 6, Wayne Landsman, GSFC. C. Yamauchi (ISAS) 23 Feb 2006</span>
<span class="comments">;               Support 64bit integers</span>
<span class="comments">;       Version 7, C. Markwardt, GSFC, Allow unsigned integers, which</span>
<span class="comments">;               have special TSCAL/TZERO values.  Feb 2009</span>
<span class="comments">;       Version 8,  P.Broos (PSU), Wayne Landsman (GSFC) Mar 2010</span>
<span class="comments">;               Do *not* force TTYPE* keyword to uppercase</span>
<span class="comments">; Version     :</span>
<span class="comments">;       Version 8, Mar 2010</span>
<span class="comments">;-</span>
<span class="comments">;</span>
	ON_ERROR,2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters first.</span>
<span class="comments">;</span>
	IF N_PARAMS() LT 3 THEN BEGIN
		MESSAGE = 'Syntax: FXBADDCOL, INDEX, HEADER, ARRAY ' +	$
			'[, TTYPE [, COMMENT]]'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Get the next column number.</span>
<span class="comments">;</span>
	INDEX = FXPAR(HEADER,'TFIELDS') + 1
<span class="comments">;</span>
<span class="comments">;  Determine the data type and size of the data array.  Use this to</span>
<span class="comments">;  calculate the parameters needed for the binary table.</span>
<span class="comments">;</span>
	S = SIZE(ARRAY)			<span class="comments">;obtain size of array.</span>
	TYPE = S[S[0]+1]		<span class="comments">;type of data.</span>
	N_ELEM = N_ELEMENTS(ARRAY)	<span class="comments">;Number of elements</span>
<span class="comments">;</span>
	CASE TYPE OF
		0:  BEGIN
			MESSAGE = 'Data parameter is not defined'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
			END
<span class="comments">;</span>
<span class="comments">;  If the array is of type byte, then check to see if either the BIT or LOGICAL</span>
<span class="comments">;  keywords were passed.</span>
<span class="comments">;</span>
		1:  BEGIN
			IF N_ELEMENTS(BIT) EQ 1 THEN BEGIN
				N_BYTES = LONG((BIT+7)/8)
				IF N_BYTES NE N_ELEM THEN BEGIN
					MESSAGE = 'Number of bits does ' + $
						'not match array size.'
					IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
						ERRMSG = MESSAGE
						RETURN
					END ELSE MESSAGE, MESSAGE
				ENDIF
				N_ELEM = BIT
				TFORM = "X"
				TF_COMMENT = 'Bit array'
			END ELSE IF KEYWORD_SET(LOGICAL) THEN BEGIN
				N_BYTES = N_ELEM
				TFORM = "L"
				TF_COMMENT = 'Logical array'
			END ELSE BEGIN
				N_BYTES = N_ELEM
				TFORM = "B"
				TF_COMMENT = 'Integer*1 (byte)'
			ENDELSE
			END
<span class="comments">;</span>
<span class="comments">;  If complex, then check to see if the DCOMPLEX keyword was set, and if the</span>
<span class="comments">;  first dimension is two.</span>
<span class="comments">;</span>
		5:  BEGIN
			IF KEYWORD_SET(DCOMPLEX) THEN BEGIN
				IF  S[1] NE 2 THEN BEGIN
					MESSAGE = 'The first dimension ' + $
						'of ARRAY must be two'
					IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
						ERRMSG = MESSAGE
						RETURN
					END ELSE MESSAGE, MESSAGE
				ENDIF
				N_BYTES = 8*N_ELEM
				N_ELEM = N_ELEM / 2
				TFORM = "M"
				TF_COMMENT = 'Complex*16 (double-' +	$
					'precision complex)'
				S = [S[0]-1,S[2:*]]
			END ELSE BEGIN
				N_BYTES = 8*N_ELEM
				TFORM = "D"
				TF_COMMENT = 'Real*8 (double precision)'
			ENDELSE
			END
<span class="comments">;</span>
<span class="comments">;  Note that character string arrays are considered to have an extra first</span>
<span class="comments">;  dimension, namely the (maximum) number of characters.</span>
<span class="comments">;</span>
		7:  BEGIN
			STR_LEN = MAX(STRLEN(ARRAY))
			N_BYTES = STR_LEN*N_ELEM
			N_ELEM = N_BYTES
			TFORM = "A"
			TF_COMMENT = 'Character string'
			S = [S[0]+1, STR_LEN, S[1:*]]	<span class="comments">;Add extra dimension</span>
			END
<span class="comments">;</span>
<span class="comments">;  All other types are straightforward.</span>
<span class="comments">;</span>
		2:  BEGIN
			N_BYTES = 2*N_ELEM
			TFORM = "I"
			TF_COMMENT = 'Integer*2 (short integer)'
			END
		3:  BEGIN
			N_BYTES = 4*N_ELEM
			TFORM = "J"
			TF_COMMENT = 'Integer*4 (long integer)'
			END
		4:  BEGIN
			N_BYTES = 4*N_ELEM
			TFORM = "E"
			TF_COMMENT = 'Real*4 (floating point)'
			END
		6:  BEGIN
			N_BYTES = 8*N_ELEM
			TFORM = "C"
			TF_COMMENT = 'Complex*8 (complex)'
			END
		8:  BEGIN
			MESSAGE = "Can't write structures to FITS files"
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
			END
		9: BEGIN
			N_BYTES = 16*N_ELEM
			TFORM = "M"
			TF_COMMENT = 'Complex*16 (double-' +	$
					'precision complex)'
			END

                12: BEGIN  
                        <span class="comments">;; Unsigned 16-bit integers are stored as signed</span>
                        <span class="comments">;; integers with a TZERO offset.</span>
                        N_BYTES = 2*N_ELEM
                        TFORM = "I"
                        TF_COMMENT = 'Unsigned Integer*2 (short integer)'
                        IF N_ELEMENTS(TSCAL) EQ 0 THEN TSCAL = 1
                        IF N_ELEMENTS(TZERO) EQ 0 THEN TZERO = 32768
                        IF TSCAL[0] NE 1 OR TZERO[0] NE 32768 THEN BEGIN
                           MESSAGE = 'For 2-byte unsigned type, TSCAL/TZERO must be 1/32768'
                           IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                              ERRMSG = MESSAGE
                              RETURN
                           END ELSE MESSAGE, MESSAGE
                        ENDIF
                     END
                           
                13: BEGIN
                        <span class="comments">;; Unsigned 32-bit integers are stored as signed</span>
                        <span class="comments">;; integers with a TZERO offset.</span>
                        N_BYTES = 4*N_ELEM
                        TFORM = "J"
                        TF_COMMENT = 'Unsigned Integer*4 (long integer)'
                        IF N_ELEMENTS(TSCAL) EQ 0 THEN TSCAL = 1
                        IF N_ELEMENTS(TZERO) EQ 0 THEN TZERO = 2147483648D
                        IF TSCAL[0] NE 1 OR TZERO[0] NE 2147483648D THEN BEGIN
                           MESSAGE = 'For 4-byte unsigned type, TSCAL/TZERO must be 1/2147483648'
                           IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                              ERRMSG = MESSAGE
                              RETURN
                           END ELSE MESSAGE, MESSAGE
                        ENDIF
                     END

		14: BEGIN
			N_BYTES = 8*N_ELEM
			TFORM = "K"
			TF_COMMENT = 'Integer*8 (long long ' +	$
					'integer)'
			END
	               		


	ENDCASE
<span class="comments">;</span>
<span class="comments">;  If the column is to contain variable length data, then the number of bytes</span>
<span class="comments">;  is 8, and TFORM has "1P" in the front, and "(&lt;n_elem>)" in the back.</span>
<span class="comments">;</span>
	IF KEYWORD_SET(VARIABLE) THEN BEGIN
		N_BYTES = 8
		TFORM = '1P' + TFORM + '(' + STRTRIM(N_ELEM,2) + ')'
		TF_COMMENT = TF_COMMENT + ', variable length'
<span class="comments">;</span>
<span class="comments">;  Otherwise, TFORM has "&lt;n_elem>" in the front.</span>
<span class="comments">;</span>
	END ELSE TFORM = STRTRIM(N_ELEM,2) + TFORM
<span class="comments">;</span>
<span class="comments">;  Update the mandatory keywords in the header.</span>
<span class="comments">;</span>
	NAXIS1 = FXPAR(HEADER,'NAXIS1')
	FXADDPAR,HEADER,'NAXIS1',NAXIS1+N_BYTES
	FXADDPAR,HEADER,'TFIELDS',INDEX
<span class="comments">;</span>
<span class="comments">;  Add the keyword defining this column.</span>
<span class="comments">;</span>
	COL = STRTRIM(INDEX,2)		<span class="comments">;ASCII form of column index</span>
	FXADDPAR, HEADER, 'TFORM'+COL, TFORM, TF_COMMENT
<span class="comments">;</span>
<span class="comments">;  If the TTYPE parameter has been passed, then add this keyword to the header.</span>
<span class="comments">;</span>
	IF N_PARAMS() GE 4 THEN BEGIN
		If N_PARAMS() EQ 4 THEN COMMENT="Label for column "+COL
		FXADDPAR,HEADER,'TTYPE'+COL,TTYPE,COMMENT
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If the number of dimensions of the data array are greater than one, then add</span>
<span class="comments">;  the TDIM keyword.  Don't add this keyword if either the NO_TDIM, VARIABLE or</span>
<span class="comments">;  BIT keyword is set.</span>
<span class="comments">;</span>
	IF (S[0] GT 1) AND NOT (KEYWORD_SET(NO_TDIM) OR KEYWORD_SET(BIT) OR $
			KEYWORD_SET(VARIABLE)) THEN BEGIN
		TDIM = "(" + STRTRIM(S[1],2)
		FOR I = 2,S[0] DO TDIM = TDIM + "," + STRTRIM(S[I],2)
		TDIM = TDIM + ')'
		FXADDPAR,HEADER,'TDIM'+COL,TDIM,	$
			'Array dimensions for column '+COL
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If the various keywords were passed, then add them to the header.</span>
<span class="comments">;</span>
	IF N_ELEMENTS(TUNIT) EQ 1 THEN FXADDPAR,HEADER,'TUNIT'+COL,TUNIT, $
		'Units of column '+COL
	IF N_ELEMENTS(TSCAL) EQ 1 THEN FXADDPAR,HEADER,'TSCAL'+COL,TSCAL, $
		'Scale parameter for column '+COL
	IF N_ELEMENTS(TZERO) EQ 1 THEN FXADDPAR,HEADER,'TZERO'+COL,TZERO, $
		'Zero offset for column '+COL
	IF N_ELEMENTS(TNULL) EQ 1 THEN FXADDPAR,HEADER,'TNULL'+COL,TNULL, $
		'Null value for column '+COL
	IF N_ELEMENTS(TDISP) EQ 1 THEN FXADDPAR,HEADER,'TDISP'+COL,TDISP, $
		'Display format for column '+COL
<span class="comments">;</span>
	IF N_ELEMENTS(TDMIN) EQ 1 THEN FXADDPAR,HEADER,'TDMIN'+COL,TDMIN, $
		'Minimum value in column '+COL
	IF N_ELEMENTS(TDMAX) EQ 1 THEN FXADDPAR,HEADER,'TDMAX'+COL,TDMAX, $
		'Maximum value in column '+COL
	IF N_ELEMENTS(TDESC) EQ 1 THEN FXADDPAR,HEADER,'TDESC'+COL,TDESC, $
		'Axis labels for column '+COL
	IF N_ELEMENTS(TCUNI) EQ 1 THEN FXADDPAR,HEADER,'TCUNI'+COL,TCUNI, $
		'Axis units for column '+COL
	IF N_ELEMENTS(TROTA) EQ 1 THEN FXADDPAR,HEADER,'TROTA'+COL,TROTA, $
		'Rotation angles for column '+COL
	IF N_ELEMENTS(TRPIX) EQ 1 THEN FXADDPAR,HEADER,'TRPIX'+COL,TRPIX, $
		'Reference pixel for column '+COL
	IF N_ELEMENTS(TRVAL) EQ 1 THEN FXADDPAR,HEADER,'TRVAL'+COL,TRVAL, $
		'Reference position for column '+COL
	IF N_ELEMENTS(TDELT) EQ 1 THEN FXADDPAR,HEADER,'TDELT'+COL,TDELT, $
		'Axis increments for column '+COL
<span class="comments">;</span>
	IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
	RETURN
	END
</code>
    </div>
  </body>
</html>