<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:29 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>find.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="find.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="find:source"></a>pro find, image, x, y, flux, sharp, roundness, hmin, fwhm, roundlim, sharplim,$
                      PRINT = print, SILENT=silent, MONITOR= monitor
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	FIND</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Find positive brightness perturbations (i.e stars) in an image </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;	Also returns centroids and shape parameters (roundness & sharpness).</span>
<span class="comments">;	Adapted from 1991 version of DAOPHOT, but does not allow for bad pixels</span>
<span class="comments">;       and uses a slightly different centroid algorithm.</span>
<span class="comments">;</span>
<span class="comments">;       Modified in March 2008 to use marginal Gaussian fits to find centroids       </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	FIND, image, [ x, y, flux, sharp, round, hmin, fwhm, roundlim, sharplim </span>
<span class="comments">;		PRINT= , /SILENT, /MONITOR]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	image - 2 dimensional image array (integer or real) for which one</span>
<span class="comments">;		wishes to identify the stars present</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;	FIND will prompt for these parameters if not supplied</span>
<span class="comments">;</span>
<span class="comments">;	hmin -  Threshold intensity for a point source - should generally </span>
<span class="comments">;		be 3 or 4 sigma above background RMS</span>
<span class="comments">;	fwhm  - FWHM (in pixels) to be used in the convolve filter</span>
<span class="comments">;	sharplim - 2 element vector giving low and high cutoff for the</span>
<span class="comments">;		sharpness statistic (Default: [0.2,1.0] ).   Change this</span>
<span class="comments">;		default only if the stars have significantly larger or </span>
<span class="comments">;		or smaller concentration than a Gaussian</span>
<span class="comments">;	roundlim - 2 element vector giving low and high cutoff for the</span>
<span class="comments">;		roundness statistic (Default: [-1.0,1.0] ).   Change this </span>
<span class="comments">;		default only if the stars are significantly elongated.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       /MONITOR - Normally, FIND will display the results for each star </span>
<span class="comments">;                only if no output variables are supplied.   Set /MONITOR</span>
<span class="comments">;                to always see the result of each individual star.</span>
<span class="comments">;	/SILENT - set /SILENT keyword to suppress all output display </span>
<span class="comments">;	PRINT - if set and non-zero then FIND will also write its results to</span>
<span class="comments">;		a file find.prt.   Also one can specify a different output file </span>
<span class="comments">;		name by setting PRINT = 'filename'.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;	x - vector containing x position of all stars identified by FIND</span>
<span class="comments">;	y-  vector containing y position of all stars identified by FIND</span>
<span class="comments">;	flux - vector containing flux of identified stars as determined</span>
<span class="comments">;		by a Gaussian fit.  Fluxes are NOT converted to magnitudes.</span>
<span class="comments">;	sharp - vector containing sharpness statistic for identified stars</span>
<span class="comments">;	round - vector containing roundness statistic for identified stars</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;	(1) The sharpness statistic compares the central pixel to the mean of </span>
<span class="comments">;       the surrounding pixels.   If this difference is greater than the </span>
<span class="comments">;       originally estimated height of the Gaussian or less than 0.2 the height of the</span>
<span class="comments">;	Gaussian (for the default values of SHARPLIM) then the star will be</span>
<span class="comments">;	rejected. </span>
<span class="comments">;</span>
<span class="comments">;       (2) More recent versions of FIND in DAOPHOT allow the possibility of</span>
<span class="comments">;       ignoring bad pixels.    Unfortunately, to implement this in IDL</span>
<span class="comments">;       would preclude the vectorization made possible with the CONVOL function</span>
<span class="comments">;       and would run extremely slowly.</span>
<span class="comments">;</span>
<span class="comments">;       (3) Modified in March 2008 to use marginal Gaussian distributions to </span>
<span class="comments">;       compute centroid.   (Formerly, find.pro determined centroids by locating</span>
<span class="comments">;       where derivatives went to zero -- see cntrd.pro for this algorithm.   </span>
<span class="comments">;       This was the method used in very old (~1984) versions of DAOPHOT. )   </span>
<span class="comments">;       As discussed in more  detail in the comments to the code, the  centroid</span>
<span class="comments">;       computation here is  the same as in IRAF DAOFIND but differs slightly </span>
<span class="comments">;       from the current DAOPHOT.</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;	GETOPT()</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;	Written W. Landsman, STX  February, 1987</span>
<span class="comments">;	ROUND now an internal function in V3.1   W. Landsman July 1993</span>
<span class="comments">;	Change variable name DERIV to DERIVAT    W. Landsman Feb. 1996</span>
<span class="comments">;	Use /PRINT keyword instead of TEXTOUT    W. Landsman May  1996</span>
<span class="comments">;	Changed loop indices to type LONG       W. Landsman Aug. 1997</span>
<span class="comments">;       Replace DATATYPE() with size(/TNAME)   W. Landsman Nov. 2001</span>
<span class="comments">;       Fix problem when PRINT= filename   W. Landsman   October 2002</span>
<span class="comments">;       Fix problems with >32767 stars   D. Schlegel/W. Landsman Sep. 2004</span>
<span class="comments">;       Fix error message when no stars found  S. Carey/W. Landsman Sep 2007</span>
<span class="comments">;       Rewrite centroid computation to use marginal Gaussians W. Landsman </span>
<span class="comments">;                 Mar 2008</span>
<span class="comments">;       Added Monitor keyword, /SILENT now suppresses all output </span>
<span class="comments">;                   W. Landsman    Nov 2008</span>
<span class="comments">;       Work when threshold is negative (difference images) W. Landsman May 2010</span>
<span class="comments">;-</span>
<span class="comments">;</span>
 On_error,2                         <span class="comments">;Return to caller</span>
 compile_opt idl2

 npar   = N_params()
 if npar EQ 0 then begin
    print,'Syntax - FIND, image,' + $
          '[ x, y, flux, sharp, round, hmin, fwhm, roundlim, sharplim'
    print,'                      PRINT= , /SILENT, /MONITOR ]'
    return
 endif
<span class="comments">;Determine if hardcopy output is desired</span>
 doprint = keyword_set( PRINT)
 silent =  keyword_set( SILENT )
 if N_elements(monitor) EQ 0 then $
      monitor = (not silent) and (not arg_present(flux) ) 

 maxbox = 13 	<span class="comments">;Maximum size of convolution box in pixels </span>

<span class="comments">; Get information about the input image </span>

 type = size(image)
 if ( type[0] NE 2 ) then message, $
     'ERROR - Image array (first parameter) must be 2 dimensional'
 n_x  = type[1] & n_y = type[2]
 message, NoPrint=Silent, $
    'Input Image Size is '+strtrim(n_x,2) + ' by '+ strtrim(n_y,2),/INF

 if ( N_elements(fwhm) NE 1 ) then $
           read, 'Enter approximate FWHM: ', fwhm
  if fwhm LT 0.5 then message, $
        'ERROR - Supplied FWHM must be at least 0.5 pixels'	   

 radius = 0.637*FWHM > 2.001             <span class="comments">;Radius is 1.5 sigma</span>
 radsq = radius^2
 nhalf = fix(radius) &lt<span class="comments">; (maxbox-1)/2   	;</span>
 nbox = 2*nhalf + 1	<span class="comments">;# of pixels in side of convolution box </span>
 middle = nhalf          <span class="comments">;Index of central pixel</span>

 lastro = n_x - nhalf
 lastcl = n_y - nhalf
 sigsq = ( fwhm/2.35482 )^2
 mask = bytarr( nbox, nbox )   <span class="comments">;Mask identifies valid pixels in convolution box </span>
 g = fltarr( nbox, nbox )      <span class="comments">;g will contain Gaussian convolution kernel</span>

 dd = indgen(nbox-1) + 0.5 - middle	<span class="comments">;Constants need to compute ROUND</span>
 dd2 = dd^2

 row2 = (findgen(Nbox)-nhalf)^2

 for i = 0, nhalf do begin
	temp = row2 + i^2
	g[0,nhalf-i] = temp         
        g[0,nhalf+i] = temp                           
 endfor


 mask = fix(g LE radsq)     <span class="comments">;MASK is complementary to SKIP in Stetson's Fortran</span>
 good = where( mask, pixels)  <span class="comments">;Value of c are now equal to distance to center</span>

<span class="comments">;  Compute quantities for centroid computations that can be used for all stars</span>
 g = exp(-0.5*g/sigsq)

<span class="comments">;  In fitting Gaussians to the marginal sums, pixels will arbitrarily be </span>
<span class="comments">; assigned weights ranging from unity at the corners of the box to </span>
<span class="comments">; NHALF^2 at the center (e.g. if NBOX = 5 or 7, the weights will be</span>
<span class="comments">;</span>
<span class="comments">;                                 1   2   3   4   3   2   1</span>
<span class="comments">;      1   2   3   2   1          2   4   6   8   6   4   2</span>
<span class="comments">;      2   4   6   4   2          3   6   9  12   9   6   3</span>
<span class="comments">;      3   6   9   6   3          4   8  12  16  12   8   4</span>
<span class="comments">;      2   4   6   4   2          3   6   9  12   9   6   3</span>
<span class="comments">;      1   2   3   2   1          2   4   6   8   6   4   2</span>
<span class="comments">;                                 1   2   3   4   3   2   1</span>
<span class="comments">;</span>
<span class="comments">; respectively).  This is done to desensitize the derived parameters to </span>
<span class="comments">; possible neighboring, brighter stars.</span>


 xwt = fltarr(nbox,nbox)
 wt = nhalf - abs(findgen(nbox)-nhalf ) + 1
 for i=0,nbox-1 do xwt[0,i] = wt
 ywt = transpose(xwt) 
  sgx = total(g*xwt,1)
 p = total(wt)
 sgy = total(g*ywt,2)
 sumgx = total(wt*sgy)
 sumgy = total(wt*sgx)
 sumgsqy = total(wt*sgy*sgy)
 sumgsqx = total(wt*sgx*sgx)
 vec = nhalf - findgen(nbox) 
 dgdx = sgy*vec
 dgdy = sgx*vec
 sdgdxs = total(wt*dgdx^2)
 sdgdx = total(wt*dgdx) 
 sdgdys = total(wt*dgdy^2)
 sdgdy = total(wt*dgdy) 
 sgdgdx = total(wt*sgy*dgdx)
 sgdgdy = total(wt*sgx*dgdy)

 
 c = g*mask          <span class="comments">;Convolution kernel now in c      </span>
 sumc = total(c)
 sumcsq = total(c^2) - sumc^2/pixels
 sumc = sumc/pixels
 c[good] = (c[good] - sumc)/sumcsq
 c1 = exp(-.5*row2/sigsq)
 sumc1 = total(c1)/nbox
 sumc1sq = total(c1^2) - sumc1
 c1 = (c1-sumc1)/sumc1sq

 message,/INF,Noprint=Silent, $
    'RELATIVE ERROR computed from FWHM ' + strtrim(sqrt(total(c[good]^2)),2)
 if N_elements(hmin) NE 1 then read, $
    'Enter minimum value above background for threshold detection: ',hmin

 if N_elements(sharplim) NE 2 then begin
      print,'Enter low and high cutoffs, press [RETURN] for defaults:'
GETSHARP:   
      ans = ''
      read, 'Image Sharpness Statistic (DEFAULT = 0.2,1.0): ', ans   
      if ans EQ '' then sharplim = [0.2,1.0] else begin
         sharplim = getopt(ans,'F')
          if N_elements(sharplim) NE 2 then begin  
              message, 'ERROR - Expecting 2 scalar values',/CON
              goto, GETSHARP     
          endif
      endelse                                                      

GETROUND: 
  ans = ''
  read, 'Image Roundness Statistic [DEFAULT = -1.0,1.0]: ',ans
  if ans EQ '' then roundlim = [-1.,1.] else begin
      roundlim = getopt( ans, 'F' )
      if N_elements( roundlim ) NE 2 then begin
           message,'ERROR - Expecting 2 scalar values',/CON
           goto, GETROUND   
      endif
 endelse
 endif 

 message,'Beginning convolution of image', /INF, NoPrint=Silent

 h = convol(float(image),c)    <span class="comments">;Convolve image with kernel "c"</span>

    minh = min(h)
    h[0:nhalf-1,*] = minh & h[n_x-nhalf:n_x-1,*] = minh
    h[*,0:nhalf-1] = minh & h[*,n_y-nhalf:n_y-1] = minh

 message,'Finished convolution of image', /INF, NoPrint=Silent

 mask[middle,middle] = 0	<span class="comments">;From now on we exclude the central pixel</span>
 pixels = pixels -1      <span class="comments">;so the number of valid pixels is reduced by 1</span>
 good = where(mask)      <span class="comments">;"good" identifies position of valid pixels</span>
 xx= (good mod nbox) - middle	<span class="comments">;x and y coordinate of valid pixels </span>
 yy = fix(good/nbox) - middle    <span class="comments">;relative to the center</span>
 offset = yy*n_x + xx
SEARCH: 			    <span class="comments">;Threshold dependent search begins here</span>

 index = where( h GE hmin, nfound)  <span class="comments">;Valid image pixels are greater than hmin</span>
 if nfound EQ 0 then begin          <span class="comments">;Any maxima found?</span>

    message,'ERROR - No maxima exceed input threshold of ' + $
             string(hmin,'(F9.1)'),/CON
    goto,FINISH    

 endif

 for i= 0L, pixels-1 do begin                             

	stars = where (h[index] GE h[index+offset[i]], nfound)
        if nfound EQ 0 then begin  <span class="comments">;Do valid local maxima exist?</span>
             message,'ERROR - No maxima exceed input threshold of ' + $
                     string(hmin,'(F9.1)'),/CON
             goto,FINISH  
        endif
	index = index[stars]

 endfor 
 
 ix = index mod n_x              <span class="comments">;X index of local maxima</span>
 iy = index/n_x                  <span class="comments">;Y index of local maxima</span>
 ngood = N_elements(index)       
 message,/INF,Noprint=Silent, $
    strtrim(ngood,2)+' local maxima located above threshold'

 nstar = 0L       	<span class="comments">;NSTAR counts all stars meeting selection criteria</span>
 badround = 0L & badsharp=0L  &  badcntrd=0L
 if (npar GE 2) or (doprint) then begin 	<span class="comments">;Create output X and Y arrays? </span>
  	x = fltarr(ngood) & y = x
 endif

 if (npar GE 4) or (doprint) then begin   <span class="comments">;Create output flux,sharpness arrays?</span>
 	flux = x & sharp = x & roundness = x
 endif

 if doprint then begin	<span class="comments">;Create output file?</span>

         if ( size(print,/TNAME) NE 'STRING' ) then file = 'find.prt' $
                                         else file = print
         message,'Results will be written to a file ' + file,/INF,Noprint=Silent
         openw,lun,file,/GET_LUN
	printf,lun,' Program: FIND '+ systime()
	printf,lun,format='(/A,F7.1)',' Threshold above background:',hmin
	printf,lun,' Approximate FWHM:',fwhm
	printf,lun,format='(2(A,F6.2))',' Sharpness Limits: Low', $
                sharplim[0], '  High',sharplim[1]
	printf,lun,format='(2(A,F6.2))',' Roundness Limits: Low', $
                roundlim[0],'  High',roundlim[1]
	printf,lun,format='(/A,i6)',' No of sources above threshold',ngood

 endif                      

 if (not SILENT) and MONITOR then $
  print,format='(/8x,a)','     STAR      X      Y     FLUX     SHARP    ROUND'

<span class="comments">;  Loop over star positions; compute statistics</span>

 for i = 0L,ngood-1 do begin   
     temp = float(image[ix[i]-nhalf:ix[i]+nhalf,iy[i]-nhalf:iy[i]+nhalf])
     d = h[ix[i],iy[i]]                  <span class="comments">;"d" is actual pixel intensity        </span>

<span class="comments">;  Compute Sharpness statistic</span>

     sharp1 = (temp[middle,middle] - (total(mask*temp))/pixels)/d
     if ( sharp1 LT sharplim[0] ) or ( sharp1 GT sharplim[1] ) then begin
	badsharp = badsharp + 1
	goto, REJECT             <span class="comments">;Does not meet sharpness criteria</span>
     endif

<span class="comments">;   Compute Roundness statistic</span>

     dx = total( total(temp,2)*c1)   
     dy = total( total(temp,1)*c1)
     if (dx LE 0) or (dy LE 0) then begin
         badround = badround + 1
	 goto, REJECT           <span class="comments">;Cannot compute roundness</span>
     endif

     around = 2*(dx-dy) / ( dx + dy )    <span class="comments">;Roundness statistic</span>
     if ( around LT roundlim[0] ) or ( around GT roundlim[1] ) then begin
	badround = badround + 1
	goto,REJECT           <span class="comments">;Does not meet roundness criteria</span>
     endif

<span class="comments">;</span>
<span class="comments">; Centroid computation:   The centroid computation was modified in Mar 2008 and</span>
<span class="comments">; now differs from DAOPHOT which multiplies the correction dx by 1/(1+abs(dx)). </span>
<span class="comments">; The DAOPHOT method is more robust (e.g. two different sources will not merge)</span>
<span class="comments">; especially in a package where the centroid will be subsequently be </span>
<span class="comments">; redetermined using PSF fitting.   However, it is less accurate, and introduces</span>
<span class="comments">; biases in the centroid histogram.   The change here is the same made in the </span>
<span class="comments">; IRAF DAOFIND routine (see </span>
<span class="comments">; http://iraf.net/article.php?story=7211&query=daofind )</span>
<span class="comments">;    </span>

 sd = total(temp*ywt,2)

 sumgd = total(wt*sgy*sd)
 sumd = total(wt*sd)
 sddgdx = total(wt*sd*dgdx)

 hx = (sumgd - sumgx*sumd/p) / (sumgsqy - sumgx^2/p)

<span class="comments">; HX is the height of the best-fitting marginal Gaussian.   If this is not</span>
<span class="comments">; positive then the centroid does not make sense </span>

  if (hx LE 0) then begin
    	badcntrd = badcntrd + 1
	 goto, REJECT
  endif

 skylvl = (sumd - hx*sumgx)/p
 dx = (sgdgdx - (sddgdx-sdgdx*(hx*sumgx + skylvl*p)))/(hx*sdgdxs/sigsq)
 if abs(dx) GE nhalf then begin 
	badcntrd = badcntrd + 1
	 goto, REJECT
  endif

 xcen = ix[i] + dx    <span class="comments">;X centroid in original array</span>

<span class="comments">; Find Y centroid                 </span>

 sd = total(temp*xwt,1)
 
 sumgd = total(wt*sgx*sd)
 sumd = total(wt*sd)

 sddgdy = total(wt*sd*dgdy)

 hy = (sumgd - sumgy*sumd/p) / (sumgsqx - sumgy^2/p)

  if (hy LE 0) then begin
	badcntrd = badcntrd + 1
	 goto, REJECT
  endif

 skylvl = (sumd - hy*sumgy)/p
 dy = (sgdgdy - (sddgdy-sdgdy*(hy*sumgy + skylvl*p)))/(hy*sdgdys/sigsq)
 if abs(dy) GE nhalf then begin 
	badcntrd = badcntrd + 1
	 goto, REJECT
  endif
      
 ycen = iy[i] +dy    <span class="comments">;Y centroid in original array</span>
 

<span class="comments">;  This star has met all selection criteria.  Print out and save results</span>

   if monitor then $
      print,FORM = '(12x,i5,2f7.1,f9.1,2f9.2)', $ 
            nstar, xcen, ycen, d, sharp1, around

   if (npar GE 2) or (doprint) then begin
              x[nstar] = xcen & y[nstar] = ycen
   endif

   if ( npar GE 4 ) or (doprint) then begin
	flux[nstar] = d & sharp[nstar] = sharp1 & roundness[nstar] = around
   endif
   
   nstar = nstar+1

REJECT: 
 endfor

 nstar = nstar-1		<span class="comments">;NSTAR is now the index of last star found</span>

 if doprint then begin
  printf,lun,' No. of sources rejected by SHARPNESS criteria',badsharp
  printf,lun,' No. of sources rejected by ROUNDNESS criteria',badround
  printf,lun,' No. of sources rejected by CENTROID  criteria',badcntrd
 endif
 
if (not SILENT) and (MONITOR) then begin 
  print,' No. of sources rejected by SHARPNESS criteria',badsharp
  print,' No. of sources rejected by ROUNDNESS criteria',badround
  print,' No. of sources rejected by CENTROID  criteria',badcntrd
endif 

  if nstar LT 0 then return               <span class="comments">;Any stars found?</span>

  if (npar GE 2) or (doprint) then begin
	x=x[0:nstar]  & y = y[0:nstar]
  endif

  if (npar GE 4) or (doprint) then begin
	flux= flux[0:nstar] & sharp=sharp[0:nstar]  
        roundness = roundness[0:nstar]
  endif

 if doprint then begin                
   printf,lun, $
      format = '(/8x,a)','     STAR       X       Y     FLUX     SHARP    ROUND'
	for i = 0L, nstar do $
	   printf,lun,format='(12x,i5,2f8.2,f9.1,2f9.2)', $
	              i+1, x[i], y[i], flux[i], sharp[i], roundness[i]
        free_lun, lun
 endif

FINISH:

 if SILENT or (not MONITOR) then return

 print,form='(A,F8.1)',' Threshold above background for this pass was',hmin
 ans = ''
 read,'Enter new threshold or [RETURN] to exit: ',ans
 ans = getopt(ans,'F')              
 if ans GT 0. then begin
       hmin = ans
       goto, SEARCH   
 endif

 return                                      
 end
</code>
    </div>
  </body>
</html>