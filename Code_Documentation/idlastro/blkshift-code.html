<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:20 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>blkshift.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="blkshift.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   BLKSHIFT</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Shift a block of data to a new position in a file (possibly overlapping)</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;   BLKSHIFT, UNIT, POS, [ DELTA, TO=TO, /NOZERO, ERRMSG=ERRMSG, </span>
<span class="comments">;             BUFFERSIZE=BUFFERSIZE ]</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;  BLKSHIFT moves a block of data forward or backward, to a new</span>
<span class="comments">;  position in a data file.  The old and new positions of the block</span>
<span class="comments">;  can overlap safely.</span>
<span class="comments">;</span>
<span class="comments">;  The new position can be specified with either the DELTA parameter,</span>
<span class="comments">;  which gives the number of bytes to move forward (positive delta) or</span>
<span class="comments">;  backward (negative delta); or the TO keyword, which give the new</span>
<span class="comments">;  absolute starting position of the block.</span>
<span class="comments">;</span>
<span class="comments">;  The block can be moved beyond the current end of file point, in</span>
<span class="comments">;  which case the intervening gap is filled with zeros (optionally).</span>
<span class="comments">;  The gap left at the old position of the block is also optionally</span>
<span class="comments">;  zero-filled.    If a set of data up to the end of the file is being</span>
<span class="comments">;  moved forward (thus making the file smaller) then</span>
<span class="comments">;  the file is truncated at the new end.using TRUNCATE_LUN.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a logical unit number, opened for reading and writing.</span>
<span class="comments">;</span>
<span class="comments">;   POS - POS[0] is the position of the block in the file, in bytes,</span>
<span class="comments">;         before moving.  POS[1], if present, is the size of the block</span>
<span class="comments">;         in bytes.  If POS[1] is not given, then the block is from</span>
<span class="comments">;         POS[0] to the end of the file.</span>
<span class="comments">;</span>
<span class="comments">;   DELTA - the (optional) offset in bytes between the old and new</span>
<span class="comments">;           positions, from the start of the block.  Positive values</span>
<span class="comments">;           indicate moving the data forward (toward the end of file),</span>
<span class="comments">;           and negative values indicate moving the data backward</span>
<span class="comments">;           (toward the beginning of the file).  One of DELTA and TO</span>
<span class="comments">;           must be specified; DELTA overrides the TO keyword.</span>
<span class="comments">;</span>
<span class="comments">;           Attempts to move the block beyond the end of the file will</span>
<span class="comments">;           succeed.  A block can never be moved beyond the beginning</span>
<span class="comments">;           of the file; it will be moved to the beginning instead.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   TO - the absolute file offset in bytes for the new start of the</span>
<span class="comments">;        block.  One of DELTA and TO must be specified; DELTA</span>
<span class="comments">;        overrides the TO keyword.</span>
<span class="comments">;</span>
<span class="comments">;   /NOZERO - if set, then newly created gaps will not be explicitly</span>
<span class="comments">;            zeroed.   Note that in same systems (e.g. MacOS) the gaps will</span>
<span class="comments">;            always be zeroed whether or not /NOZERO is set.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - If defined and passed, then any error messages will be</span>
<span class="comments">;            returned to the user in this parameter rather than</span>
<span class="comments">;            depending on the MESSAGE routine in IDL.  If no errors</span>
<span class="comments">;            are encountered, then a null string is returned.  </span>
<span class="comments">;</span>
<span class="comments">;			BLKSHIFT, UNIT, POS, DElTA, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">;   BUFFERSIZE - the maximum buffer size for transfers, in bytes.</span>
<span class="comments">;                Larger values of this keyword impose larger memory</span>
<span class="comments">;                requirements on the application; smaller values will</span>
<span class="comments">;                lead to more transfer operations.</span>
<span class="comments">;                Default: 32768 (bytes)</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;</span>
<span class="comments">;   Written, CM, Apr 2000</span>
<span class="comments">;   Documented and re-written, CM, 20 Jul 2000</span>
<span class="comments">;   Renamed from FXSHIFT to BLKSHIFT, CM, 21 Jul 2000</span>
<span class="comments">;   Documentation, CM, 12 Dec 2002</span>
<span class="comments">;   Truncate if moving data block forward from  the end of file </span>
<span class="comments">;             using TRUNCATE_LUN   W. Landsman Feb. 2005 </span>
<span class="comments">;   Assume since V5.5, remove VMS support  W. Landsman  Sep 2006</span>
<span class="comments">;   Assume since V5.6, TRUNCATE_LUN available  W. Landsman Sep 2006</span>
<span class="comments">;   MacOS can point beyond EOF    W. Landsman   Aug 2009</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000, 2002, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy and distribute unmodified copies for</span>
<span class="comments">; non-commercial purposes, and to modify and use for personal or</span>
<span class="comments">; internal use, is granted.  All other rights are reserved.</span>
<span class="comments">;-</span>
PRO BLKSHIFT, UNIT, POS0, DELTA0, NOZERO=NOZERO0, ERRMSG=ERRMSG, $
              BUFFERSIZE=BUFFERSIZE0, TO=TO0

  <span class="comments">;; Default error handling</span>
  compile_opt idl2
  on_error, 2
  on_ioerror, IO_FINISH
  if n_params() LT 3 then begin
      message = 'BLKSHIFT, UNIT, POS, DELTA'
      goto, ERRMSG_OUT
  endif

  <span class="comments">;; Make sure file is open for writing, and begin parameter</span>
  <span class="comments">;; processing</span>
  fs = fstat(unit)
  if fs.open EQ 0 OR fs.write EQ 0 then begin
      message = 'File '+fs.name+' is not open for writing'
      goto, ERRMSG_OUT
  endif
  nozero = keyword_set(nozero0)
  pos_beg = floor(pos0[0])
  if n_elements(pos0) GT 1 then pos_fin = floor(pos0[1])
  if n_elements(pos_fin) EQ 0 then pos_fin = fs.size - 1L

  if pos_beg GE fs.size then goto, GOOD_FINISH
  if n_elements(to0) EQ 0 AND n_elements(delta0) EQ 0 then begin
      message = 'Must specify DELTA or TO'
      goto, ERRMSG_OUT
  endif

  <span class="comments">;; Parse the delta value, and enforce the file positioning</span>
  if n_elements(delta0) GT 0 then begin
      delta = floor(delta0[0])
      <span class="comments">;; Can't move beyond beginning of file</span>
      delta = ((pos_beg + delta) > 0L) - pos_beg 
  endif else begin
      delta = (floor(to0[0]) > 0L) - pos_beg
  endelse
      
  if delta EQ 0 then goto, GOOD_FINISH
  if pos_fin GE fs.size then pos_fin = fs.size - 1L
  if pos_fin LT pos_beg then goto, GOOD_FINISH

  if n_elements(buffersize0) EQ 0 then buffersize0 = 32768L
  buffersize = long(buffersize0[0])
  if buffersize LE 0 then buffersize = 32768L

  <span class="comments">;; Seek to end of file and add zeroes (if needed)</span>
  pos_fin = pos_fin + 1L

  <span class="comments">;; Unless /Nozero set, the zeroes will be explicitly written</span>
  if (delta GT 0) && (nozero EQ 0) && (pos_fin+delta GT fs.size) then begin
      point_lun, unit, fs.size
      nleft = (pos_fin-fs.size) + delta
      while nleft GT 0 do begin
          ntrans = nleft &lt<span class="comments">; buffersize</span>
          if n_elements(bb0) NE ntrans then bb0 = bytarr(ntrans)
          writeu, unit, bb0, transfer_count=cc
          if cc EQ 0 then goto, IO_FINISH
          nleft = nleft - cc
      endwhile
  endif

  <span class="comments">;; Now shift the data forward or backward</span>
  if delta GT 0 then begin

      <span class="comments">;; Shift forward (toward end of file)</span>
      edat = pos_fin    <span class="comments">;; End of to-be-copied data segment</span>
      while edat GT pos_beg do begin
          ntrans = (edat - pos_beg) &lt<span class="comments">; buffersize</span>
          if n_elements(bb0) NE ntrans then bb0 = bytarr(ntrans)
          point_lun, unit, edat - ntrans
          readu, unit, bb0, transfer_count=cc
          if cc NE ntrans then goto, IO_FINISH
          point_lun, unit, edat - ntrans + delta
          writeu, unit, bb0, transfer_count=cc
          if cc NE ntrans then goto, IO_FINISH
          edat = edat - ntrans
      endwhile
  endif else begin

      <span class="comments">;; Shift backward (toward beginning of file)</span>
      bdat = pos_beg   <span class="comments">;; Beginning of to-be-copied data segment</span>
      while bdat LT pos_fin do begin
          ntrans = (pos_fin - bdat) &lt<span class="comments">; buffersize</span>
          if n_elements(bb0) NE ntrans then bb0 = bytarr(ntrans)
          point_lun, unit, bdat
          readu, unit, bb0, transfer_count=cc
          if cc NE ntrans then goto, IO_FINISH
          point_lun, unit, bdat - abs(delta)
          writeu, unit, bb0, transfer_count=cc
          if cc NE ntrans then goto, IO_FINISH
          bdat = bdat + ntrans
      endwhile
      if pos_fin EQ fs.size  then begin 
                  Truncate_Lun, unit
                  goto, GOOD_FINISH
      endif
  endelse
  bb0 = [0b] & dummy = temporary(bb0)

  <span class="comments">;; Finally, zero out the gap we created</span>
  if nozero EQ 0 then begin
      if delta GT 0 then begin
          point_lun, unit, pos_beg  <span class="comments">;; also, to be sure data is flushed</span>
          z_fin = pos_fin &lt<span class="comments">; (pos_beg + delta)</span>
          nleft = (z_fin - pos_beg)
      endif else begin
          z_beg = (pos_fin - abs(delta)) > pos_beg
          nleft = (pos_fin - z_beg)
          point_lun, unit, z_beg
      endelse
      while nleft GT 0 do begin
          i = nleft &lt<span class="comments">; buffersize</span>
          if n_elements(bb0) NE i then bb0 = bytarr(i)
          writeu, unit, bb0, transfer_count=cc
          if cc EQ 0 then goto, IO_FINISH
          nleft = nleft - cc
      endwhile
  endif
  point_lun, unit, pos_beg  <span class="comments">;; again, to be sure data is flushed</span>

  GOOD_FINISH:
  if arg_present(errmsg) then errmsg = ''
  return

  IO_FINISH:
  on_ioerror, NULL
  message = 'ERROR: BLKSHIFT operation failed because of an I/O error'
  <span class="comments">;; fallthrough...</span>

  <span class="comments">;; Error message processing.  Control does not pass through here.</span>
  ERRMSG_OUT:
  if arg_present(errmsg) then begin
      errmsg = message
      return
  endif
  message, message
END

</code>
    </div>
  </body>
</html>