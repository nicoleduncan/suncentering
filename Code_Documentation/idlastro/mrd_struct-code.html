<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:49 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mrd_struct.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mrd_struct.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MRD_STRUCT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return a structure as defined in the names and values data.</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       struct = MRD_STRUCT(NAMES, VALUES, NROW, STRUCTYP='name' )</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;       NAMES   = A string array of names of structure fields.</span>
<span class="comments">;       VALUES  = A string array giving the values of the structure</span>
<span class="comments">;                 fields.  See examples below.</span>
<span class="comments">;       NROW    = The number of elements in the structure array.</span>
<span class="comments">;       </span>
<span class="comments">; RETURNS:</span>
<span class="comments">;       A structure as described in the parameters or 0 if an error</span>
<span class="comments">;       is detected.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD PARAMETERS:</span>
<span class="comments">;       /NO_EXECUTE - If set then the use of the EXECUTE() statement is avoided.</span>
<span class="comments">;                  By default, the NO_EXECUTE pathway is used if IDL is </span>
<span class="comments">;                  running under the Virtual Machine.    Note if  /NO_EXECUTE</span>
<span class="comments">;                  is set, then the user cannot supply arbitary values, but</span>
<span class="comments">;                  all possible values used by MRDFITS will be allowed.</span>
<span class="comments">;       STRUCTYP = The structure type.  Since IDL does not allow the</span>
<span class="comments">;                  redefinition of a named structure it is an error</span>
<span class="comments">;                  to call MRD_STRUCT with different parameters but</span>
<span class="comments">;                  the same STRUCTYP in the same session.  If this</span>
<span class="comments">;                  keyword is not set an anonymous structure is created.</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       MRD_COMMON</span>
<span class="comments">; SIDE EFFECTS:                                                            </span>
<span class="comments">;       May create a temporary file if the structure definition is too long </span>
<span class="comments">;       for the EXECUTE function and using old style structures</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       By default, the program defines the structure in a long string</span>
<span class="comments">;       which is executed with CREATE_STRUCT within a single EXECUTE statement.</span>
<span class="comments">;</span>
<span class="comments">;       If program is being run in the IDL Virtual machine (EXECUTE statement</span>
<span class="comments">;       not allowed), then a separate CREATE_STRUCT statement is called</span>
<span class="comments">;       for each tag.   This mode does not have the full capabilities of the</span>
<span class="comments">;       normal mode, but should be sufficient for use with MRDFITS().</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       A structure definition is created using the parameter values.</span>
<span class="comments">;       MRD_NSTRUCT is called  and generates the structure in pieces using the</span>
<span class="comments">;       execute and create_struct keywords.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       (1) str = mrd_struct(['fld1', 'fld2'], ['0','dblarr(10,10)'],3)</span>
<span class="comments">;           print, str(0).fld2(3,3)</span>
<span class="comments">;       Note that "0" is always considered short integer even if the default</span>
<span class="comments">;       integer is set to long.</span>
<span class="comments">;          </span>
<span class="comments">;</span>
<span class="comments">;       (2) str = mrd_struct(['a','b','c','d'],['1', '1.', '1.d0', "'1'"],1)</span>
<span class="comments">;               ; returns a structure with integer, float, double and string</span>
<span class="comments">;               ; fields.</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       GETTOK() - needed for virtual machine mode only</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Created by T. McGlynn October, 1994.</span>
<span class="comments">;       Modified by T. McGlynn September, 1995.</span>
<span class="comments">;          Added capability to create substructures so that structure</span>
<span class="comments">;          may contain up to 4096 distinct elements.  [This can be</span>
<span class="comments">;          increased by futher iteration of the process used if needed.]</span>
<span class="comments">;       Removed V4.0 reference to common block  October 1997</span>
<span class="comments">;       Allowed unlimited number of structure elements if the version</span>
<span class="comments">;       is greater than 5.0.  Put back in code to handle prior versions.</span>
<span class="comments">;       The [] will need to be translated back to () for this to</span>
<span class="comments">;       work.  T. McGlynn December 15 1998.</span>
<span class="comments">;       Add MRD_NSTRUCT since IDL has mysterious problems compiling</span>
<span class="comments">;       very large structures.</span>
<span class="comments">;       Removed TEMPDIR and OLD_STRUCT keywords  W. Landsman October 2003   </span>
<span class="comments">;       Alternate pathway without EXECUTE for V6.0 virtual machine, D. Lindler</span>
<span class="comments">;       Removed limit on EXECUTE statement.  W. Landsman  October 2003</span>
<span class="comments">;       Restore EXECUTE limit (sigh...), added NO_EXECUTE keyword</span>
<span class="comments">;                         W. Landsman July 2004</span>
<span class="comments">;       Fix use of STRUCTYP with /NO_EXECUTE  W. Landsman June 2005</span>
<span class="comments">;       Assume since V6.0 (lmgr function available), remove 131 string length</span>
<span class="comments">;             limit for execute    W. Landsman Jun 2009 </span>
<span class="comments">;       Restore EXECUTE limit (sigh...)   W. Landsman July 2009 </span>
<span class="comments">;       Make sure "0" is a short integer even with compile_opt idl2  July 2010</span>
<span class="comments">;       Added "0.0", "0.0d", "0u", "0ul", and "0ull" as valid tags</span>
<span class="comments">;             for /NO_EXECUTE  E. Rykoff May 2012</span>
<span class="comments">;-</span>

<span class="comments">; Check that the number of names is the same as the number of values.</span>

<a id="mrd_struct:source"></a>function mrd_struct, names, values, nrow, no_execute = no_execute,  $
    structyp=structyp,  tempdir=tempdir, silent=silent, old_struct=old_struct

compile_opt idl2

<span class="comments">; Keywords TEMPDIR, SILENT and OLD_STRUCT no longer do anything but are kept</span>
<span class="comments">; for backward compatibility.</span>


 noexecute = keyword_set(no_execute) or lmgr(/vm) 

 if noexecute then begin

    ntags = n_elements(names)
    for i=0,ntags-1 do begin
<span class="comments">;</span>
<span class="comments">; create variable with the specified data type</span>
<span class="comments">;</span>
	case strlowcase(values[i]) of 
<span class="comments">;</span>
<span class="comments">; scalar values</span>
<span class="comments">;</span>
	    '0b': v = 0B
	    '0' : v = 0S
            '0u' : v = 0US
            '0us': v = 0US
	    '0l': v = 0L
	    '0ll' : v = 0LL
            '0ul' : v = 0UL
            '0ull' : v = 0ULL
	    '0.': v = 0.0
            '0.0': v = 0.0
            '0.0d': v = 0.0d0
	    '0.0d0': v = 0.0d0
 	    '0.d0': v = 0.0d0
             '" "': v = " "          <span class="comments">;Added July 2004</span>
	    'complex(0.,0.)': v = complex(0.,0.)
	    'dcomplex(0.d0,0.d0)': v = dcomplex(0.d0,0.d0)
<span class="comments">;</span>
<span class="comments">; strings and arrays</span>
<span class="comments">;`</span>
	    else: begin	     
	        value = values[i]
		remchar,value,"'"
		remchar,value,'"'   
		if strlen(value) EQ 1 then v= value else begin 
	        type = gettok(value,'(')
		if type eq 'string' then $
			junk = gettok(value,',')      <span class="comments">;remove "replicate(32b"</span>
		dimen_string = gettok(value,')')	
		dimen = long(strsplit(dimen_string,',',/extract))
		case type of
		    'bytarr': v = make_array(dimen=dimen,/byte)
		    'intarr': v = make_array(dimen=dimen,/int)
		    'fltarr': v = make_array(dimen=dimen,/float)
		    'lonarr': v = make_array(dimen=dimen,/long)
		    'lon64arr': v = make_array(dimen=dimen,/long64)
		    'dblarr': v = make_array(dimen=dimen,/double)
		    'complexarr': v = make_array(dimen=dimen,/complex)
		    'dcomplexarr': v = make_array(dimen=dimen,/dcomplex)
                    'ptr_new': v = ptr_new()
		    'string': begin
		    		ndimen = n_elements(dimen)-1
				if ndimen gt 0 then begin
					v = make_array(dimen=dimen[1:*],/string)
					v[*] = string(replicate(32B,dimen[0]))
		    		end else v = string(replicate(32B,dimen[0]))
			      end
	            else: message,'ERROR - Invalid field value: ' + values[i]		      
		endcase
		        endelse 

	    end
	endcase     	
	if i eq 0 then struct = create_struct(names[i],v) $
		  else struct = create_struct(temporary(struct),names[i],v)
    end<span class="comments">; for i    </span>

endif else begin

<span class="comments">; Build up the structure use a combination of execute and</span>
<span class="comments">; create_struct calls.  Basically we build as many rows as</span>
<span class="comments">; will fit in an execute call and create that structure.  Then</span>
<span class="comments">; we append that structure to whatever we've done before using</span>
<span class="comments">; create_struct</span>

nel = N_elements(names)
strng = "a={"

comma = ' '
for i=0,nel-1 do  begin
    fval = values[i]
    if (fval eq '0') then fval = '0s'
  
   <span class="comments">; Now for each element put in a name/value pair.</span>
    tstrng = strng + comma+names[i] + ':' + fval
    
    <span class="comments">; The nominal max length of the execute is 131</span>
    <span class="comments">; We need one chacacter for the "}"</span>
    if strlen(tstrng) gt 130 then begin
        strng = strng + "}"
        res = execute(strng)
	if  res eq 0 then return, 0
        struct = n_elements(struct) eq 0 ? a: $
	         create_struct(temporary(struct), a)
	strng = "a={" + names[i] + ":" + fval
	
    endif else strng = tstrng
    comma = ","

endfor
	

if strlen(strng) gt 3 then begin
    strng = strng + "}"
    res = execute(strng)
     if  res eq 0 then return, 0
     struct = n_elements(struct) eq 0 ? a : create_struct(temporary(struct), a)
 endif
 
endelse
if keyword_set(structyp) then $
     struct = create_struct(temporary(struct), name=structyp)


if nrow le 1 then return, struct $
             else return, replicate(struct, nrow)

end

</code>
    </div>
  </body>
</html>