<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbreadm.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbreadm.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FXBREADM</span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;       Read multiple columns/rows from a disk FITS binary table file.</span>
<span class="comments">; EXPLANATION : </span>
<span class="comments">;       A call to FXBREADM will read data from multiple rows and</span>
<span class="comments">;       multiple columns in a single procedure call.  Up to forty-nine</span>
<span class="comments">;       columns may be read in a single pass; the number of rows is</span>
<span class="comments">;       limited essentially by available memory.  The file should have</span>
<span class="comments">;       already been opened with FXBOPEN.  FXBREADM optimizes reading</span>
<span class="comments">;       multiple columns by first reading a large chunk of data from</span>
<span class="comments">;       the FITS file directly, and then slicing the data into columns</span>
<span class="comments">;       within memory.  FXBREADM can read variable-length arrays (see</span>
<span class="comments">;       below).</span>
<span class="comments">;</span>
<span class="comments">;       The number of columns is limited to 49 if data are passed by</span>
<span class="comments">;       positional argument.  However, this limitation can be overcome</span>
<span class="comments">;       by having FXBREADM return the data in an array of pointers.</span>
<span class="comments">;       The user should set the PASS_METHOD keyword to 'POINTER', and an </span>
<span class="comments">;       array of pointers to the data will be returned in the POINTERS keyword.</span>
<span class="comments">;       The  user is responsible for freeing the pointers; however,</span>
<span class="comments">;       FXBREADM will reuse any pointers  passed into the procedure, and </span>
<span class="comments">;       hence any pointed-to data will be destroyed.</span>
<span class="comments">;</span>
<span class="comments">;       FXBREADM can also read variable-length columns from FITS</span>
<span class="comments">;       binary tables.  Since such data is not of a fixed size, it is</span>
<span class="comments">;       returned as a structure.  The structure has the following</span>
<span class="comments">;       elements:</span>
<span class="comments">;</span>
<span class="comments">;              VARICOL:    ;; Flag: variable length column (= 1)</span>
<span class="comments">;              N_ELEMENTS: ;; Total number of elements returned</span>
<span class="comments">;              TYPE:       ;; IDL data type code (integer)</span>
<span class="comments">;              N_ROWS:     ;; Number of rows read from table (integer)</span>
<span class="comments">;              INDICES:    ;; Indices of each row's data (integer array)</span>
<span class="comments">;              DATA:       ;; Raw data elements (variable type array)</span>
<span class="comments">;</span>
<span class="comments">;       In order to gain access to the Ith row's data, one should</span>
<span class="comments">;       examine DATA(INDICES(I):INDICES(I+1)-1), which is similar in</span>
<span class="comments">;       construct to the REVERSE_INDICES keyword of the HISTOGRAM</span>
<span class="comments">;       function.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: </span>
<span class="comments">;       FXBREADM, UNIT, COL, DATA1, [ DATA2, ... DATA48, ROW=, BUFFERSIZE = ]</span>
<span class="comments">;           /NOIEEE, /NOSCALE, /VIRTUAL, NANVALUE=, PASS_METHOD = POINTERS=, </span>
<span class="comments">;           ERRMSG = , WARNMSG = , STATUS = , /DEFAULT_FLOAT]</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS : </span>
<span class="comments">;       UNIT    = Logical unit number corresponding to the file containing the</span>
<span class="comments">;                 binary table.</span>
<span class="comments">;       COL     = An array of columns in the binary table to read data</span>
<span class="comments">;                 from, either as character strings containing column</span>
<span class="comments">;                 labels (TTYPE), or as numerical column indices</span>
<span class="comments">;                 starting from column one.</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;       DATA1, DATA2...DATA48 = A named variable to accept the data values, one</span>
<span class="comments">;                 for each column.  The columns are stored in order of the</span>
<span class="comments">;                 list in COL.  If the read operation fails for a</span>
<span class="comments">;                 particular column, then the corresponding output Dn</span>
<span class="comments">;                 variable is not altered.  See the STATUS keyword.</span>
<span class="comments">;                 Ignored if PASS_METHOD is 'POINTER'.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS: </span>
<span class="comments">;       ROW     = Either row number in the binary table to read data from,</span>
<span class="comments">;                 starting from row one, or a two element array containing a</span>
<span class="comments">;                 range of row numbers to read.  If not passed, then the entire</span>
<span class="comments">;                 column is read in.</span>
<span class="comments">;       /DEFAULT_FLOAT = If set, then scaling with TSCAL/TZERO is done with</span>
<span class="comments">;                 floating point rather than double precision.</span>
<span class="comments">;       /NOIEEE = If set, then then IEEE floating point data will not</span>
<span class="comments">;                be converted to the host floating point format (and</span>
<span class="comments">;                this by definition implies NOSCALE).  The user is</span>
<span class="comments">;                responsible for their own floating point conversion.</span>
<span class="comments">;       /NOSCALE = If set, then the output data will not be scaled using the</span>
<span class="comments">;                 optional TSCAL and TZERO keywords in the FITS header.</span>
<span class="comments">;                 Default is to scale.</span>
<span class="comments">;       VIRTUAL = If set, and COL is passed as a name rather than a number,</span>
<span class="comments">;                 then if the program can't find a column with that name, it</span>
<span class="comments">;                 will then look for a keyword with that name in the header.</span>
<span class="comments">;                 Such a keyword would then act as a "virtual column", with the</span>
<span class="comments">;                 same value for every row.</span>
<span class="comments">;       DIMENSIONS = FXBREADM ignores this keyword.  It is here for</span>
<span class="comments">;	          compatibility only.</span>
<span class="comments">;       NANVALUE= Value signalling data dropout.  All points corresponding to</span>
<span class="comments">;                 IEEE NaN (not-a-number) are converted to this number.</span>
<span class="comments">;                 Ignored unless DATA is of type float, double-precision or</span>
<span class="comments">;                 complex.</span>
<span class="comments">;       PASS_METHOD = A scalar string indicating method of passing</span>
<span class="comments">;                 data from FXBREADM.  Either 'ARGUMENT' (indicating</span>
<span class="comments">;                 pass by positional argument), or 'POINTER' (indicating</span>
<span class="comments">;                 passing an array of pointers by the POINTERS</span>
<span class="comments">;                 keyword).</span>
<span class="comments">;                 Default: 'ARGUMENT'</span>
<span class="comments">;       POINTERS = If PASS_METHOD is 'POINTER' then an array of IDL</span>
<span class="comments">;                 pointers is returned in this keyword, one for each</span>
<span class="comments">;                 requested column.    Any pointers passed into FXBREADM will </span>
<span class="comments">;                 have their pointed-to data destroyed.  Ultimately the</span>
<span class="comments">;                 user is responsible for deallocating pointers. </span>
<span class="comments">;       BUFFERSIZE = Raw data are transferred from the file in chunks</span>
<span class="comments">;                 to conserve memory.  This is the size in bytes of</span>
<span class="comments">;                 each chunk.  If a value of zero is given, then all</span>
<span class="comments">;                 of the data are transferred in one pass.  Default is</span>
<span class="comments">;                 32768 (32 kB).</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       ERRMSG  = If defined and passed, then any error messages will be</span>
<span class="comments">;                 returned to the user in this parameter rather than</span>
<span class="comments">;                 depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;                 encountered, then a null string is returned.  In order to</span>
<span class="comments">;                 use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;                       ERRMSG = ''</span>
<span class="comments">;                       FXBREAD, ERRMSG=ERRMSG, ...</span>
<span class="comments">;                       IF ERRMSG NE '' THEN ...</span>
<span class="comments">;       WARNMSG = Messages which are considered to be non-fatal</span>
<span class="comments">;                 "warnings" are returned in this output string.</span>
<span class="comments">;                 Note that if some but not all columns are</span>
<span class="comments">;                 unreadable, this is considered to be non-fatal.</span>
<span class="comments">;       STATUS  = An output array containing the status for each</span>
<span class="comments">;                 column read, 1 meaning success and 0 meaning failure.</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;       IEEE_TO_HOST, FXPAR(), WHERENAN()</span>
<span class="comments">; Common      : </span>
<span class="comments">;       Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;       information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;       The binary table file must have been opened with FXBOPEN.</span>
<span class="comments">;</span>
<span class="comments">;       The data must be consistent with the column definition in the binary</span>
<span class="comments">;       table header.</span>
<span class="comments">;</span>
<span class="comments">;       The row number must be consistent with the number of rows stored in the</span>
<span class="comments">;       binary table header.</span>
<span class="comments">;</span>
<span class="comments">;       Generaly speaking, FXBREADM will be faster than iterative</span>
<span class="comments">;       calls to FXBREAD when (a) a large number of columns is to be</span>
<span class="comments">;       read or (b) the size in bytes of each cell is small, so that</span>
<span class="comments">;       the overhead of the FOR loop in FXBREAD becomes significant.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS: </span>
<span class="comments">;       If there are no elements to read in (the number of elements is zero),</span>
<span class="comments">;       then the program sets !ERR to -1, and DATA is unmodified.</span>
<span class="comments">;</span>
<span class="comments">; Category    : </span>
<span class="comments">;       Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;       C. Markwardt, based in concept on FXBREAD version 12 from</span>
<span class="comments">;                              IDLASTRO, but with significant and</span>
<span class="comments">;                              major changes to accomodate the</span>
<span class="comments">;                              multiple row/column technique.  Mostly</span>
<span class="comments">;                              the parameter checking and general data</span>
<span class="comments">;                              flow remain.</span>
<span class="comments">;       C. Markwardt, updated to read variable length arrays, and to</span>
<span class="comments">;                              pass columns by handle or pointer.</span>
<span class="comments">;                              20 Jun 2001</span>
<span class="comments">;       C. Markwardt, try to conserve memory when creating the arrays</span>
<span class="comments">;                              13 Oct 2001</span>
<span class="comments">;   Handle case of GE 50 columns, C. Markwardt, 18 Apr 2002</span>
<span class="comments">;   Handle case where TSCAL/TZERO changes type of column,</span>
<span class="comments">;       C. Markwardt, 23 Feb 2003</span>
<span class="comments">;   Fix bug in handling of FOUND and numeric columns, </span>
<span class="comments">;       C. Markwardt 12 May 2003</span>
<span class="comments">;   Removed pre-V5.0 HANDLE options  W. Landsman July 2004</span>
<span class="comments">;   Fix bug when HANDLE options were removed, July 2004</span>
<span class="comments">;   Handle special cases of TSCAL/TZERO which emulate unsigned</span>
<span class="comments">;      integers, Oct 2003</span>
<span class="comments">;   Add DEFAULT_FLOAT keyword to select float values instead of double</span>
<span class="comments">;      for TSCAL'ed, June 2004</span>
<span class="comments">;   Read 64bit integer columns, E. Hivon, Mar 2008</span>
<span class="comments">;   Add support for columns with TNULLn keywords, C. Markwardt, Apr 2010</span>
<span class="comments">;   Add support for files larger than 2 GB, C. Markwardt, 2012-04-17</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;</span>


<span class="comments">;; This is a utility routine which converts the data from raw bytes to</span>
<span class="comments">;; IDL variables.</span>
PRO FXBREADM_CONV, BB, DD, CTYPE, PERROW, NROWS, $
                   NOIEEE=NOIEEE, NOSCALE=NOSCALE, VARICOL=VARICOL, $
                   NANVALUE=NANVALUE, TZERO=TZERO, TSCAL=TSCAL, $
                   TNULL_VALUE=TNULL, TNULL_FLAG=TNULLQ, $
                   DEFAULT_FLOAT=DF

  COMMON FXBREADM_CONV_COMMON, DTYPENAMES
  IF N_ELEMENTS(DTYPENAMES) EQ 0 THEN $
    DTYPENAMES = [ '__BAD', 'BYTE', 'FIX', 'LONG', $
                   'FLOAT', 'DOUBLE', 'COMPLEX', 'STRING', $
                   '__BAD', 'DCOMPLEX', '__BAD', '__BAD', '__BAD', '__BAD', 'LONG64' ]
  
  TYPENAME = DTYPENAMES[CTYPE]

  IF CTYPE EQ 7 THEN BEGIN
      DD = STRING(TEMPORARY(BB))
  ENDIF ELSE BEGIN
      DD = CALL_FUNCTION(TYPENAME, TEMPORARY(BB), 0, PERROW*NROWS)
  ENDELSE
  IF N_ELEMENTS(DD) EQ 1 THEN DD = [DD]
  DD = REFORM(DD, PERROW, NROWS, /OVERWRITE)

  <span class="comments">;; Now perform any type-specific conversions, etc.</span>
  COUNT = 0L
  CASE 1 OF
      <span class="comments">;; Integer types</span>
      (CTYPE EQ 2 OR CTYPE EQ 3 or ctype eq 14): BEGIN
          IF NOT KEYWORD_SET(NOIEEE) OR KEYWORD_SET(VARICOL) THEN $
            IEEE_TO_HOST, DD 
          <span class="comments">;; Check for TNULL values</span>
          <span class="comments">;; We will convert to NAN values later (or if the user</span>
          <span class="comments">;; requested a different value we will use that)</span>
          IF KEYWORD_SET(TNULLQ) THEN BEGIN
              W = WHERE(DD EQ TNULL,COUNT)
              IF N_ELEMENTS(NANVALUE) EQ 0 THEN NANVALUE = !VALUES.D_NAN
          ENDIF
      END

      <span class="comments">;; Floating and complex types</span>
      (CTYPE GE 4 OR CTYPE LE 6 OR CTYPE EQ 9): BEGIN
          IF NOT KEYWORD_SET(NOIEEE) THEN BEGIN
              IF N_ELEMENTS(NANVALUE) GT 0 THEN W=WHERENAN(DD,COUNT)
              IEEE_TO_HOST, DD
          ENDIF
      END

      <span class="comments">;; String types (CTYPE EQ 7) have already been converted</span>
      <span class="comments">;; in the above CALL_FUNCTION.  No further conversion</span>
      <span class="comments">;; is necessary here.</span>
  ENDCASE

<span class="comments">;</span>
<span class="comments">;  If the parameters TZERO and TSCAL are non-trivial, then adjust the array by</span>
<span class="comments">;  these values.</span>
<span class="comments">;</span>
  IF ((NOT KEYWORD_SET(NOIEEE) AND NOT KEYWORD_SET(NOSCALE)) AND $
      (NOT KEYWORD_SET(VARICOL)) AND $
      (N_ELEMENTS(TZERO) EQ 1 AND N_ELEMENTS(TSCAL) EQ 1)) THEN BEGIN

      IF KEYWORD_SET(DF) THEN BEGIN
          <span class="comments">;; Default to float</span>
          TSCAL = FLOAT(TSCAL)
          TZERO = FLOAT(TZERO)
      ENDIF

      FORWARD_FUNCTION UINT, ULONG
      IF CTYPE EQ 2 AND TSCAL[0] EQ 1 AND TZERO[0] EQ 32768 THEN BEGIN
          <span class="comments">;; SPECIAL CASE: Unsigned 16-bit integer</span>
          DD = UINT(DD) - UINT(32768)
      ENDIF ELSE IF CTYPE EQ 3 AND TSCAL[0] EQ 1 AND $
        TZERO[0] EQ 2147483648D THEN BEGIN
          <span class="comments">;; SPECIAL CASE: Unsigned 32-bit integer</span>
          DD = ULONG(DD) - ULONG(2147483648)
      ENDIF ELSE BEGIN
          IF (TSCAL[0] NE 0) AND (TSCAL[0] NE 1) THEN DD = TSCAL[0]*DD
          IF TZERO[0] NE 0 THEN DD = DD + TZERO[0]
      ENDELSE
  ENDIF

<span class="comments">;</span>
<span class="comments">;  Store NANVALUE everywhere where the data corresponded to IEEE NaN.</span>
<span class="comments">;</span>
  IF COUNT GT 0 AND N_ELEMENTS(NANVALUE) GT 0 THEN DD[W] = NANVALUE
  
END

PRO FXBREADM, UNIT, COL, $
              D0,  D1,  D2,  D3,  D4,  D5,  D6,  D7,  D8,  D9, $
              D10, D11, D12, D13, D14, D15, D16, D17, D18, D19, $
              D20, D21, D22, D23, D24, D25, D26, D27, D28, D29, $
              D30, D31, D32, D33, D34, D35, D36, D37, D38, D39, $
              D40, D41, D42, D43, D44, D45, D46, D47, $
              ROW=ROW, VIRTUAL=VIR, DIMENSIONS=DIM, $
              NOSCALE=NOSCALE, NOIEEE=NOIEEE, DEFAULT_FLOAT=DEFAULT_FLOAT, $
              PASS_METHOD=PASS_METHOD, POINTERS=POINTERS, $
              NANVALUE=NANVALUE, BUFFERSIZE=BUFFERSIZE, $
              ERRMSG=ERRMSG, WARNMSG=WARNMSG, STATUS=OUTSTATUS

@fxbintable
        ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 2 THEN BEGIN
                MESSAGE = 'Syntax:  FXBREADM, UNIT, COL, D0, D1, ... [, ROW= ]'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF
        IF N_ELEMENTS(BUFFERSIZE) EQ 0 THEN BUFFERSIZE = 32768L

<span class="comments">;</span>
<span class="comments">;  COL may be one of several descriptors:</span>
<span class="comments">;     * a list of column numbers, beginning with 1</span>
<span class="comments">;     * a list of column names</span>
<span class="comments">;</span>
        MYCOL = [ COL ]    <span class="comments">; Make sure it is an array</span>

        SC = SIZE(MYCOL)
        NUMCOLS = N_ELEMENTS(MYCOL)
        OUTSTATUS = LONARR(NUMCOLS)
        COLNAMES = 'D'+STRTRIM(LINDGEN(NUMCOLS),2)

<span class="comments">;</span>
<span class="comments">;  Determine whether the data is to be extracted as pointers or arguments</span>
<span class="comments">;</span>
        IF N_ELEMENTS(PASS_METHOD) EQ 0 THEN PASS_METHOD = 'ARGUMENT'
        PASS = STRUPCASE(STRTRIM(PASS_METHOD[0],2))
        IF PASS NE 'ARGUMENT' AND PASS NE 'POINTER' THEN BEGIN
            MESSAGE = 'ERROR: PASS_METHOD must be ARGUMENT or POINTER'
            IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                ERRMSG = MESSAGE
                RETURN
            END ELSE MESSAGE, MESSAGE
        ENDIF

        NP = N_ELEMENTS(POINTERS)
        IF PASS EQ 'POINTER' THEN BEGIN
            IF NP EQ 0 THEN POINTERS = PTRARR(NUMCOLS, /ALLOCATE_HEAP)
            NP = N_ELEMENTS(POINTERS)
            SZ = SIZE(POINTERS)
            IF SZ[SZ[0]+1] NE 10 THEN BEGIN
                MESSAGE = 'ERROR: POINTERS must be an array of pointers'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF

<span class="comments">;</span>
<span class="comments">;  Expand the pointer array if necessary</span>
<span class="comments">;</span>
            IF NP LT NUMCOLS THEN $
              POINTERS = [POINTERS[*], PTRARR(NUMCOLS-NP, /ALLOCATE_HEAP)]
            NP = N_ELEMENTS(POINTERS)

<span class="comments">;</span>
<span class="comments">;  Make sure there are no null pointers, which cannot be assigned to.</span>
<span class="comments">;</span>
            WH = WHERE(PTR_VALID(POINTERS) EQ 0, CT)
            IF CT GT 0 THEN POINTERS[WH] = PTRARR(CT, /ALLOCATE_HEAP)
                
        ENDIF


<span class="comments">;</span>
<span class="comments">;  Find the logical unit number in the FXBINTABLE common block.</span>
<span class="comments">;</span>
        ILUN = WHERE(LUN EQ UNIT,NLUN)
        ILUN = ILUN[0]
        IF NLUN EQ 0 THEN BEGIN
                MESSAGE = 'Unit ' + STRTRIM(UNIT,2) +   $
                        ' not opened properly'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF

<span class="comments">;</span>
<span class="comments">;  Check the number of columns.  It should be fewer than 49</span>
<span class="comments">;</span>
        IF PASS EQ 'ARGUMENT' THEN BEGIN
            IF NUMCOLS GT 49 THEN BEGIN
                MESSAGE = 'Maximum of 49 columns exceeded'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF
            IF N_PARAMS()-2 LT NUMCOLS AND N_ELEMENTS(ERRMSG) EQ 0 THEN BEGIN
                MESSAGE, 'WARNING: number of data parameters less than columns', $
                  /INFO
            ENDIF
        ENDIF
            
        ICOL    = LONARR(NUMCOLS)
        VIRTUAL = BYTARR(NUMCOLS)
        VIRTYPE = LONARR(NUMCOLS)
        FOUND   = BYTARR(NUMCOLS)
        VARICOL = BYTARR(NUMCOLS)
        NOTFOUND = ''
        NNOTFOUND = 0L
        IF N_ELEMENTS(WARNMSG) NE 0 THEN WARNMSG = ''

<span class="comments">;</span>
<span class="comments">;  If COL is of type string, then search for a column with that label.</span>
<span class="comments">;</span>
        IF SC[SC[0]+1] EQ 7 THEN BEGIN
            MYCOL = STRUPCASE(STRTRIM(MYCOL,2))
            FOR I = 0, NUMCOLS-1 DO BEGIN
                XCOL = WHERE(TTYPE[*,ILUN] EQ MYCOL[I], NCOL)
                ICOL[I] = XCOL[0]
<span class="comments">;</span>
<span class="comments">;  If the column was not found, and VIRTUAL was set, then search for a keyword</span>
<span class="comments">;  by that name.</span>
<span class="comments">;</span>
                IF NCOL GT 0 THEN FOUND[I] = 1
                IF NOT FOUND[I] AND KEYWORD_SET(VIR) THEN BEGIN
                    HEADER = HEAD[*,ILUN]
                    VALUE = FXPAR(HEADER,MYCOL[I], Count = N_VALUE)
                    IF N_VALUE GE 0 THEN BEGIN
                        RESULT = EXECUTE(COLNAMES[I]+' = VALUE')
                        SV = SIZE(VALUE)
                        VIRTYPE[I] = SV[SV[0]+1]
                        VIRTUAL[I] = 1
                        FOUND[I] = 1
                    ENDIF
                ENDIF ELSE IF NOT FOUND[I] THEN BEGIN
                    IF NOTFOUND EQ '' THEN NOTFOUND = MYCOL[I] $
                    ELSE NOTFOUND = NOTFOUND +', ' + MYCOL[I]
                    NNOTFOUND = NNOTFOUND + 1
                ENDIF

            ENDFOR

            IF NNOTFOUND EQ NUMCOLS THEN BEGIN
                MESSAGE = 'ERROR: None of the requested columns were found'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF ELSE IF NNOTFOUND GT 0 THEN BEGIN
                MESSAGE = 'WARNING: Columns ' + NOTFOUND + ' were not found'
                IF N_ELEMENTS(WARNMSG) NE 0 THEN WARNMSG = MESSAGE $
                ELSE MESSAGE, MESSAGE, /INFO
            ENDIF
                
<span class="comments">;</span>
<span class="comments">;  Otherwise, a numerical column was passed.  Check its value.</span>
<span class="comments">;</span>
        ENDIF ELSE BEGIN
            ICOL[*] = LONG(MYCOL) - 1
            FOUND[*] = 1
        ENDELSE

<span class="comments">;  Step through each column index</span>
        MESSAGE = ''
        FOR I = 0, NUMCOLS-1 DO BEGIN
            IF NOT FOUND[I] THEN GOTO, LOOP_END_COLCHECK
            IF VIRTUAL[I] THEN GOTO, LOOP_END_COLCHECK

            IF (ICOL[I] LT 0) OR (ICOL[I] GE TFIELDS[ILUN]) THEN BEGIN
                MESSAGE = MESSAGE + '; COL "'+STRTRIM(MYCOL[I],2)+$
                  '" must be between 1 and ' +  $
                  STRTRIM(TFIELDS[ILUN],2)
                FOUND[I] = 0
            ENDIF
<span class="comments">;</span>
<span class="comments">;  If there are no elements in the array, then set !ERR to -1.</span>
<span class="comments">;</span>
            IF FOUND[I] AND N_ELEM[ICOL[I],ILUN] EQ 0 THEN BEGIN
                FOUND[I] = 0
                MESSAGE = MESSAGE + '; Number of elements to read in "'+$
                  STRTRIM(MYCOL[I],2)+'" is zero'
<span class="comments">;                !ERR = -1</span>
<span class="comments">;                RETURN</span>
            ENDIF

<span class="comments">;</span>
<span class="comments">;  Flag variable-length columns</span>
<span class="comments">;</span>
            IF MAXVAL[ICOL[I],ILUN] GT 0 THEN BEGIN
                FOUND[I] = 1
                VARICOL[I] = 1
            ENDIF

            LOOP_END_COLCHECK:

        ENDFOR

<span class="comments">;</span>
<span class="comments">;  Check to be sure that there are columns to be read</span>
<span class="comments">;</span>
        W  = WHERE(FOUND EQ 1, COUNT)
        WV = WHERE(FOUND EQ 1 OR VARICOL EQ 1, WVCOUNT)
        IF WVCOUNT EQ 0 THEN BEGIN
            STRPUT, MESSAGE, ':', 0
            MESSAGE = 'ERROR: No requested columns could be read'+MESSAGE
            IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                ERRMSG = MESSAGE
                RETURN
            END ELSE MESSAGE, MESSAGE
        ENDIF ELSE IF MESSAGE NE '' THEN BEGIN
            STRPUT, MESSAGE, ':', 0
            MESSAGE = 'WARNING: Some columns could not be read'+MESSAGE
            IF N_ELEMENTS(WARNMSG) NE 0 THEN WARNMSG = MESSAGE $
            ELSE MESSAGE, MESSAGE, /INFO
        ENDIF
            
<span class="comments">;</span>
<span class="comments">;  If ROW was not passed, then set it equal to the entire range.  Otherwise,</span>
<span class="comments">;  extract the range.</span>
<span class="comments">;</span>
        IF N_ELEMENTS(ROW) EQ 0 THEN ROW = [1LL, NAXIS2[ILUN]]
        CASE N_ELEMENTS(ROW) OF
                1:  ROW2 = LONG64(ROW[0])
                2:  ROW2 = LONG64(ROW[1])
                ELSE:  BEGIN
                        MESSAGE = 'ROW must have one or two elements'
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                        END
        ENDCASE
        ROW1 = LONG64(ROW[0])
<span class="comments">;</span>
<span class="comments">;  If ROW represents a range, then make sure that the row range is legal, and</span>
<span class="comments">;  that reading row ranges is allowed (i.e., the column is not variable length.</span>
<span class="comments">;</span>
        IF ROW1 NE ROW2 THEN BEGIN
                MAXROW = NAXIS2[ILUN]
                IF (ROW1 LT 1) OR (ROW1 GT MAXROW) THEN BEGIN
                        MESSAGE = 'ROW[0] must be between 1 and ' +     $
                                STRTRIM(MAXROW,2)
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                END ELSE IF (ROW2 LT ROW1) OR (ROW2 GT MAXROW) THEN BEGIN
                        MESSAGE = 'ROW[1] must be between ' +   $
                                STRTRIM(ROW1,2) + ' and ' + STRTRIM(MAXROW,2)
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                ENDIF
<span class="comments">;</span>
<span class="comments">;  Otherwise, if ROW is a single number, then just make sure it's valid.</span>
<span class="comments">;</span>
        END ELSE BEGIN
                IF (ROW1 LT 1) OR (ROW1 GT NAXIS2[ILUN]) THEN BEGIN
                        MESSAGE = 'ROW must be between 1 and ' +        $
                                STRTRIM(NAXIS2[ILUN],2)
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                ENDIF
        ENDELSE

<span class="comments">;</span>
<span class="comments">;  Compose information about the output</span>
<span class="comments">;</span>
        HEADER = HEAD[*,ILUN]
        COLNDIM = LONARR(NUMCOLS)
        COLDIM  = LONARR(NUMCOLS, 20) <span class="comments">;; Maximum of 20 dimensions in output</span>
        COLTYPE = LONARR(NUMCOLS)
        BOFF1   = LONARR(NUMCOLS)
        BOFF2   = LONARR(NUMCOLS)
        TNULL_FLG = INTARR(NUMCOLS) <span class="comments">;; 1 if TNULLn column is present</span>
        TNULL_VAL = DBLARR(NUMCOLS) <span class="comments">;; value of TNULLn column if present</span>
        NROWS = ROW2-ROW1+1
        FOR I = 0L, NUMCOLS-1 DO BEGIN

            IF NOT FOUND[I] THEN GOTO, LOOP_END_DIMS
            <span class="comments">;;  Data type of the input.</span>
            IF VIRTUAL[I] THEN BEGIN
                <span class="comments">; Virtual column: read from keyword itself</span>
                COLTYPE[I] = VIRTYPE[I] 
                GOTO, LOOP_END_DIMS
            ENDIF ELSE IF VARICOL[I] THEN BEGIN
                <span class="comments">; Variable length column: 2-element long</span>
                COLTYPE[I] = 3
                DIMS = [1L, 2L]
            ENDIF ELSE BEGIN
                COLTYPE[I] = IDLTYPE[ICOL[I],ILUN]
                DIMS = N_DIMS[*,ICOL[I],ILUN]
            ENDELSE
            
            NDIMS = DIMS[0]
            DIMS  = DIMS[1:NDIMS]

            IF NDIMS EQ 1 AND DIMS[0] EQ 1 THEN BEGIN

                <span class="comments">;; Case of only one output element, try to return a</span>
                <span class="comments">;; scalar.  Otherwise, it is a vector equal to the</span>
                <span class="comments">;; number of rows to be read</span>

                COLNDIM[I] = 1L
                COLDIM[I,0] = NROWS
            ENDIF ELSE BEGIN

                COLNDIM[I] = NDIMS
                COLDIM[I,0:(NDIMS-1)] = DIMS
                IF NROWS GT 1 THEN BEGIN
                    COLDIM[I,NDIMS] = NROWS
                    COLNDIM[I] = COLNDIM[I]+1
                ENDIF

            ENDELSE
            
            <span class="comments">;; For strings, the number of characters is the first</span>
            <span class="comments">;; dimension.  This information is useless to us now,</span>
            <span class="comments">;; since the STRING() type cast which will appear below</span>
            <span class="comments">;; handles the array conversion automatically.</span>
            IF COLTYPE[I] EQ 7 THEN BEGIN
                IF COLNDIM[I] GT 1 THEN BEGIN
                    COLDIM[I,0:COLNDIM[I]-2] = COLDIM[I,1:COLNDIM[I]-1]
                    COLDIM[I,COLNDIM[I]-1]   = 0
                    COLNDIM[I] = COLNDIM[I] - 1
                ENDIF ELSE BEGIN  <span class="comments">;; Case of a single row</span>
                    COLNDIM[I] = 1L
                    COLDIM[I,0] = NROWS
                ENDELSE
            ENDIF

            <span class="comments">;; Byte offsets</span>
            BOFF1[I] = BYTOFF[ICOL[I],ILUN]
            IF ICOL[I] EQ TFIELDS[ILUN]-1 THEN $
              BOFF2[I] = NAXIS1[ILUN]-1 $
            ELSE $
              BOFF2[I] = BYTOFF[ICOL[I]+1,ILUN]-1

            <span class="comments">;; TNULLn keywords for integer type columns</span>
            IF (COLTYPE[I] GE 1 AND COLTYPE[I] LE 3) OR $
              (COLTYPE[I] GE 12 AND COLTYPE[I] LE 15) THEN BEGIN
                TNULLn = 'TNULL'+STRTRIM(ICOL[I]+1,2)
                VALUE = FXPAR(HEADER,TNULLn, Count = N_VALUE)
                IF N_VALUE GT 0 THEN BEGIN
                    TNULL_FLG[I] = 1
                    TNULL_VAL[I] = VALUE
                ENDIF
            ENDIF
            
            LOOP_END_DIMS:

        ENDFOR

<span class="comments">;</span>
<span class="comments">;  Construct any virtual columns first</span>
<span class="comments">;</span>
        WC = WHERE(FOUND EQ 1 AND VIRTUAL EQ 1, WCCOUNT)
        FOR I = 0L, WCCOUNT-1 DO BEGIN
            <span class="comments">;; If it's virtual, then the value only needs to be</span>
            <span class="comments">;; replicated</span>
            EXTCMD = COLNAMES[WC[I]]+'= REPLICATE(D'+COLNAMES[WC[I]]+',NROWS)'
            <span class="comments">;; Run the command that selects the data</span>
            RESULT = EXECUTE(EXTCMD)
            IF RESULT EQ 0 THEN BEGIN
                MESSAGE = 'ERROR: Could not extract data (column '+$
                  STRTRIM(MYCOL[WC[I]],2)+')'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                ENDIF ELSE MESSAGE, MESSAGE
            ENDIF
            OUTSTATUS[I] = 1
        ENDFOR


<span class="comments">;  Skip to processing variable-length columns if all other columns are virtual</span>
        WC = WHERE(FOUND EQ 1 AND VIRTUAL EQ 0, WCCOUNT)
        IF WCCOUNT EQ 0 THEN GOTO, PROC_CLEANUP

<span class="comments">;  Create NANVALUES, the template to use when a NAN is found</span>
        IF N_ELEMENTS(NANVALUE) GE NUMCOLS THEN BEGIN
            NANVALUES = NANVALUE[0:NUMCOLS-1]
        ENDIF ELSE IF N_ELEMENTS(NANVALUE) GT 0 THEN BEGIN
            NANVALUES = REPLICATE(NANVALUE[0], NUMCOLS)
            NANVALUES[0] = NANVALUE
            I = N_ELEMENTS(NANVALUE)
            IF I LT NUMCOLS THEN $
              NANVALUES[I:*] = NANVALUE[0]
        ENDIF

<span class="comments">;</span>
<span class="comments">;  Find the position of the first byte of the data array in the file.</span>
<span class="comments">;</span>
        OFFSET0 = NHEADER[ILUN] + NAXIS1[ILUN]*(ROW1-1LL)
        POS = 0LL
        NROWS0 = NROWS
        J = 0LL
        FIRST = 1
        <span class="comments">;; Here, we constrain the buffer to be at least 16 rows long.</span>
        <span class="comments">;; If we fill up 32 kB with fewer than 16 rows, then there</span>
        <span class="comments">;; must be a lot of (big) columns in this table.  It's</span>
        <span class="comments">;; probably a candidate for using FXBREAD instead.</span>
        BUFFROWS = LONG((BUFFERSIZE/NAXIS1[ILUN]) > 16L)
        IF BUFFERSIZE LE 0 THEN BUFFROWS = NROWS0

<span class="comments">;</span>
<span class="comments">;  Loop through the data in chunks</span>
<span class="comments">;</span>
        WHILE NROWS GT 0 DO BEGIN
        J = J + 1
        NR  = NROWS &lt<span class="comments">; BUFFROWS</span>
        OFFSET1 = NAXIS1[ILUN]*POS

<span class="comments">;</span>
<span class="comments">;  Proceed by reading a byte array from the input data file</span>
<span class="comments">;  FXBREADM reads all columns from the specified rows, and</span>
<span class="comments">;  sorts out the details of which bytes belong to which columns</span>
<span class="comments">;  in the next FOR loop.</span>
<span class="comments">;</span>
        BB = BYTARR(NAXIS1[ILUN], NR)
        POINT_LUN, UNIT, OFFSET0+OFFSET1
        READU, UNIT, BB
<span class="comments">;        FXGSEEK, UNIT, OFFSET0+OFFSET1</span>
<span class="comments">;        FXGREAD, UNIT, BB</span>

<span class="comments">;</span>
<span class="comments">;  Now select out the desired columns</span>
<span class="comments">;</span>
        FOR I = 0, NUMCOLS-1 DO BEGIN
           
            <span class="comments">;; Extract the proper rows and columns</span>
            IF NOT FOUND[I] THEN GOTO, LOOP_END_STORE
            IF VIRTUAL[I]   THEN GOTO, LOOP_END_STORE

            <span class="comments">;; Extract the data from the byte array and convert it</span>
            <span class="comments">;; The inner CALL_FUNCTION is to one of the coercion</span>
            <span class="comments">;; functions, such as FIX(), DOUBLE(), STRING(), etc.,</span>
            <span class="comments">;; which is called with an offset to force a conversion</span>
            <span class="comments">;; from bytes to the data type.</span>
            <span class="comments">;; The outer CALL_FUNCTION is to REFORM(), which makes</span>
            <span class="comments">;; sure that the data structure is correct.</span>
            <span class="comments">;;</span>
            DIMS = COLDIM[I,0:COLNDIM[I]-1]
            PERROW = ROUND(PRODUCT(DIMS)/NROWS0)
            
            IF N_ELEMENTS(NANVALUES) GT 0 THEN $
              EXTRA={NANVALUE: NANVALUES[I]}

            FXBREADM_CONV, BB[BOFF1[I]:BOFF2[I], *], DD, COLTYPE[I], PERROW, NR,$
              NOIEEE=KEYWORD_SET(NOIEEE), NOSCALE=KEYWORD_SET(NOSCALE), $
              TZERO=TZERO[ICOL[I], ILUN], TSCAL=TSCAL[ICOL[I], ILUN], $
              VARICOL=VARICOL[I], DEFAULT_FLOAT=DEFAULT_FLOAT, $
              TNULL_VALUE=TNULL_VAL[I], TNULL_FLAG=TNULL_FLG[I], $
              _EXTRA=EXTRA

            <span class="comments">;; Initialize the output variable on the first chunk</span>
            IF FIRST THEN BEGIN
                SZ = SIZE(DD)
                <span class="comments">;; NOTE: type could have changed if TSCAL/TZERO were used</span>
                COLTYPEI = SZ(SZ[0]+1)  
                RESULT = EXECUTE(COLNAMES[I]+' = 0')
                RESULT = EXECUTE(COLNAMES[I]+' = '+$
                                 'MAKE_ARRAY(PERROW, NROWS0, TYPE=COLTYPEI)')
                RESULT = EXECUTE(COLNAMES[I]+' = '+$
                         'REFORM('+COLNAMES[I]+', PERROW, NROWS0,/OVERWRITE)')
            ENDIF

            <span class="comments">;; Finally, store this in the output variable</span>
            RESULT = EXECUTE(COLNAMES[I]+'[0,POS] = DD')
            DD = 0
            IF RESULT EQ 0 THEN BEGIN
                MESSAGE = 'ERROR: Could not compose output data '+COLNAMES[I]
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                ENDIF ELSE MESSAGE, MESSAGE
            ENDIF

            OUTSTATUS[I] = 1

            LOOP_END_STORE:
        ENDFOR

        FIRST = 0
        NROWS = NROWS - NR
        POS   = POS + NR
        ENDWHILE

<span class="comments">;</span>
<span class="comments">;  Read the variable-length columns from the heap.  Adjacent data are</span>
<span class="comments">;  coalesced into one read operation.  Note: this technique is thus</span>
<span class="comments">;  optimal for extensions with only one variable-length column.  If</span>
<span class="comments">;  there are more than one then coalescence will not occur.</span>
<span class="comments">;</span>

        <span class="comments">;; Width of the various data types in bytes</span>
        WIDARR = [0L, 1L, 2L, 4L, 4L, 8L, 8L, 1L, 0L,16L, 0L]
        WV = WHERE(OUTSTATUS EQ 1 AND VARICOL EQ 1, WVCOUNT)
        FOR J = 0, WVCOUNT-1 DO BEGIN
            I = WV[J]
            RESULT = EXECUTE('PDATA = '+COLNAMES[I])
            NVALS = PDATA[0,*]          <span class="comments">;; Number of values in each row</span>
            NTOT  = ROUND(TOTAL(NVALS)) <span class="comments">;; Total number of values</span>
            IF NTOT EQ 0 THEN BEGIN
                DD = {N_ELEMENTS: 0L, N_ROWS: NROWS0, $
                      INDICES: LON64ARR(NROWS0+1), DATA: 0L}
                GOTO, FILL_VARICOL
            ENDIF

            <span class="comments">;; Compute the width in bytes of the data value</span>
            TYPE = IDLTYPE[ICOL[I], ILUN]
            WID = LONG64(WIDARR[TYPE &lt<span class="comments">; 10])</span>
            IF WID EQ 0 THEN BEGIN
                OUTSTATUS[I] = 0
                MESSAGE = 'ERROR: Column '+COLNAMES[I]+' has unknown data type'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF

            <span class="comments">;; Coalesce the data pointers</span>
            BOFF1 = LONG64(PDATA[1,*])
            BOFF2 = BOFF1 + NVALS*WID
            WH = WHERE(BOFF1[1:*] NE BOFF2, CT)
            IF CT GT 0 THEN BI = [-1LL, WH, N_ELEMENTS(BOFF1)-1] $
            ELSE            BI = [-1LL,     N_ELEMENTS(BOFF1)-1]
            CT = CT + 1

            <span class="comments">;; Create the output array</span>
            BC = BOFF2[BI[1:*]] - BOFF1[BI[0:CT-1]+1] <span class="comments">;; Byte count</span>
            NB = ROUND(TOTAL(BC))                     <span class="comments">;; Total # bytes</span>
            BB = BYTARR(NB)                           <span class="comments">;; Byte array</span>

            <span class="comments">;; Initialize the counter variables used in the read-loop</span>
            CC = 0LL & CC1 = 0LL & K = 0LL
            BUFFROWS = ROUND(BUFFERSIZE/WID) > 128L
            BASE = LONG64(NHEADER[ILUN]+HEAP[ILUN])

            <span class="comments">;; Read data from file</span>
            WHILE CC LT NB DO BEGIN
                NB1 = (BC[K]-CC1) &lt<span class="comments">; BUFFROWS</span>
                BB1 = BYTARR(NB1)

                POINT_LUN, UNIT, BASE+BOFF1[BI[K]+1]+CC1
                READU, UNIT, BB1
<span class="comments">;                FXGSEEK, UNIT, BASE+BOFF1[BI[K]+1]+CC1</span>
<span class="comments">;                FXGREAD, UNIT, BB1</span>
                BB[CC] = TEMPORARY(BB1)

                CC  = CC  + NB1
                CC1 = CC1 + NB1
                IF CC1 EQ BC[K] THEN BEGIN
                    K = K + 1
                    CC1 = 0L
                ENDIF
            ENDWHILE

            <span class="comments">;; Convert the data</span>
            IF N_ELEMENTS(NANVALUES) GT 0 THEN $
              EXTRA={NANVALUE: NANVALUES[I]}

            FXBREADM_CONV, BB, DD, TYPE, NTOT, 1L, $
              NOIEEE=KEYWORD_SET(NOIEEE), NOSCALE=KEYWORD_SET(NOSCALE), $
              TZERO=TZERO[ICOL[I], ILUN], TSCAL=TSCAL[ICOL[I], ILUN], $
              DEFAULT_FLOAT=DEFAULT_FLOAT, _EXTRA=EXTRA
            
            <span class="comments">;; Ensure the correct dimensions, now that we know them</span>
            COLNDIM[I] = 1
            COLDIM[I,0] = NTOT
            
            <span class="comments">;; Construct the indices; unfortunately we need to make an</span>
            <span class="comments">;; accumulant with a FOR loop</span>
            INDICES = LON64ARR(NROWS0+1)
            FOR K = 1LL, NROWS0 DO $
              INDICES[K] = INDICES[K-1] + NVALS[K-1]

            <span class="comments">;; Construct a structure with additional data</span>
            DD = {N_ELEMENTS: NTOT, N_ROWS: NROWS0, TYPE: TYPE, $
                  INDICES: INDICES, DATA: TEMPORARY(DD)}

            FILL_VARICOL:
            RESULT = EXECUTE(COLNAMES[I] +' = TEMPORARY(DD)')
        ENDFOR

<span class="comments">;</span>
<span class="comments">;  Compose the output columns, which might need reforming</span>
<span class="comments">;</span>
        FOR I = 0, NUMCOLS-1 DO BEGIN
            IF OUTSTATUS[I] NE 1 THEN GOTO, LOOP_END_FINAL

            <span class="comments">;; Extract the dimensions and name of the column data</span>
            DIMS = COLDIM[I,0:COLNDIM[I]-1]
            NEL  = PRODUCT(DIMS)
            CNAME = COLNAMES[I]
            IF VARICOL[I] THEN CNAME = CNAME + '.DATA'

            <span class="comments">;; Compose the reforming part</span>
            IF NEL EQ 1 THEN $
              CMD = CNAME+'[0]' $
            ELSE $
              CMD = 'REFORM(TEMPORARY('+CNAME+'),DIMS,/OVERWRITE)'

            <span class="comments">;; Variable-length columns return extra information</span>
            IF VARICOL[I] THEN BEGIN
                CMD = ('{VARICOL:    1,'+$
                       ' N_ELEMENTS: '+COLNAMES[I]+'.N_ELEMENTS, '+$
                       ' TYPE:       '+COLNAMES[I]+'.TYPE, '+$
                       ' N_ROWS:     '+COLNAMES[I]+'.N_ROWS, '+$
                       ' INDICES:    '+COLNAMES[I]+'.INDICES, '+$
                       ' DATA:       '+CMD+'}')
            ENDIF

            <span class="comments">;; Assign to pointer, or re-assign to column</span>
            IF PASS EQ 'ARGUMENT' THEN $
              CMD = COLNAMES[I]+' = ' + CMD $
            ELSE IF PASS EQ 'POINTER' THEN $
              CMD = '*(POINTERS[I]) = ' + CMD 

            RESULT = EXECUTE(CMD)
            LOOP_END_FINAL:
        ENDFOR

        PROC_CLEANUP:
<span class="comments">;</span>
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
        RETURN
        
        END
</code>
    </div>
  </body>
</html>