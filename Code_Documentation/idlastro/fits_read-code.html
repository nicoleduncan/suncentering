<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:30 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fits_read.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fits_read.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="fits_read:source"></a>pro fits_read,file_or_fcb,data,header,group_par,noscale=noscale, $
                exten_no=exten_no, extname=extname, $
                extver=extver, extlevel=extlevel, xtension=xtension, $
                no_abort=no_abort, message=message, first=first, last=last, $
                group=group, header_only=header_only,data_only=data_only, $
                no_pdu=no_pdu, enum = enum, no_unsigned = no_unsigned, pdu=pdu

<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FITS_READ</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       To read a FITS file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       FITS_READ, filename_or_fcb, data [,header, group_par]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       FILENAME_OR_FCB - this parameter can be the FITS Control Block (FCB)</span>
<span class="comments">;               returned by FITS_OPEN or the file name of the FITS file.  If</span>
<span class="comments">;               a file name is supplied, FITS_READ will open the file with</span>
<span class="comments">;               FITS_OPEN and close the file with FITS_CLOSE before exiting.</span>
<span class="comments">;               When multiple extensions are to be read from the file, it is</span>
<span class="comments">;               more efficient for the user to call FITS_OPEN and leave the</span>
<span class="comments">;               file open until all extensions are read. FPACK </span>
<span class="comments">;               ( http://heasarc.gsfc.nasa.gov/fitsio/fpack/ ) compressed FITS </span>
<span class="comments">;               files can be read provided that the FPACK software is installed.  </span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       DATA - data array.  If /NOSCALE is specified, BSCALE and BZERO</span>
<span class="comments">;               (if present in the header) will not be used to scale the data.</span>
<span class="comments">;               If Keywords FIRST and LAST are used to read a portion of the</span>
<span class="comments">;               data or the heap portion of an extension, no scaling is done</span>
<span class="comments">;               and data is returned as a 1-D vector. The user can use the IDL</span>
<span class="comments">;               function REFORM to convert the data to the correct dimensions</span>
<span class="comments">;               if desired.  If /DATA_ONLY is specified, no scaling is done.</span>
<span class="comments">;       HEADER - FITS Header.  The STScI inheritance convention is recognized</span>
<span class="comments">;               http://fits.gsfc.nasa.gov/registry/inherit/fits_inheritance.txt</span>
<span class="comments">;               If an extension is read, and the INHERIT keyword exists with a </span>
<span class="comments">;               value of T, and the /NO_PDU keyword keyword is not supplied, </span>
<span class="comments">;               then the primary data unit header and the extension header will</span>
<span class="comments">;                be combined.  The header will have the form:</span>
<span class="comments">;</span>
<span class="comments">;                       &lt;required keywords for the extension: XTENSION, BITPIX,</span>
<span class="comments">;                               NAXIS, ...></span>
<span class="comments">;                       BEGIN MAIN HEADER --------------------------------</span>
<span class="comments">;                       &lt;PDU header keyword and history less required keywords:</span>
<span class="comments">;                               SIMPLE, BITPIX, NAXIS, ...></span>
<span class="comments">;                       BEGIN EXTENSION HEADER ---------------------------</span>
<span class="comments">;                       &lt;extension header less required keywords that were</span>
<span class="comments">;                               placed at the beginning of the header.</span>
<span class="comments">;                       END</span>
<span class="comments">;               </span>
<span class="comments">;               The structure of the header is such that if a keyword is</span>
<span class="comments">;               duplicated in both the PDU and extension headers, routine</span>
<span class="comments">;               SXPAR will print a warning and return the extension value of</span>
<span class="comments">;               the keyword. </span>
<span class="comments">;</span>
<span class="comments">;       GROUP_PAR - Group parameter block for FITS random groups format files</span>
<span class="comments">;               or the heap area for variable length binary tables.</span>
<span class="comments">;               Any scale factors in the header (PSCALn and PZEROn) are not</span>
<span class="comments">;               applied to the group parameters.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       /NOSCALE: Set to return the FITS data without applying the scale</span>
<span class="comments">;               factors BZERO and BSCALE.</span>
<span class="comments">;       /HEADER_ONLY: set to read the header only.</span>
<span class="comments">;       /DATA_ONLY: set to read the data only.  If set, if any scale factors</span>
<span class="comments">;               are present (BSCALE or BZERO), they will not be applied.</span>
<span class="comments">;       /NO_PDU: By default, FITS_READ will add the primary data unit header </span>
<span class="comments">;               keywords to the output header, *if* the header includes </span>
<span class="comments">;               INHERIT = T.   Set /NO_PDU to never append the primary header.</span>
<span class="comments">;       /NO_ABORT: Set to return to calling program instead of a RETALL</span>
<span class="comments">;               when an I/O error is encountered.  If set, the routine will</span>
<span class="comments">;               return  a non-null string (containing the error message) in the</span>
<span class="comments">;               keyword MESSAGE.    (For backward compatibility, the obsolete </span>
<span class="comments">;               system variable !ERR is also set to -1 in case of an error.)   </span>
<span class="comments">;               If /NO_ABORT not set, then FITS_READ will print the message and</span>
<span class="comments">;               issue a RETALL</span>
<span class="comments">;       /NO_UNSIGNED - By default, if  the header indicates an unsigned integer</span>
<span class="comments">;              (BITPIX = 16, BZERO=2^15, BSCALE=1) then FITS_READ will output </span>
<span class="comments">;               an IDL unsigned integer data type (UINT).   But if /NO_UNSIGNED</span>
<span class="comments">;               is set, then the data is converted to type LONG.  </span>
<span class="comments">;       /PDU - If set, then always add the primary data unit header keywords</span>
<span class="comments">;              to the output header, even if the INHERIT=T keyword is not found</span>
<span class="comments">;              This was the default behavior of FITS_READ prior to April 2007</span>
<span class="comments">;       EXTEN_NO - extension number to read.  If not set, the next extension</span>
<span class="comments">;               in the file is read.  Set to 0 to read the primary data unit.</span>
<span class="comments">;       XTENSION - string name of the xtension to read</span>
<span class="comments">;       EXTNAME - string name of the extname to read</span>
<span class="comments">;       EXTVER - integer version number to read</span>
<span class="comments">;       EXTLEVEL - integer extension level to read</span>
<span class="comments">;       FIRST - set this keyword to only read a portion of the data.  It gives</span>
<span class="comments">;               the first word of the data to read</span>
<span class="comments">;       LAST - set this keyword to only read a portion of the data.  It gives</span>
<span class="comments">;               the last word number of the data to read</span>
<span class="comments">;       GROUP - group number to read for GCOUNT>1.  (Default=0, the first group)</span>
<span class="comments">;       </span>
<span class="comments">; OUTPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       ENUM - Output extension number that was read.  </span>
<span class="comments">;       MESSAGE = value: Output error message</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       Determination or which extension to read.</span>
<span class="comments">;               case 1: EXTEN_NO specified. EXTEN_NO will give the number of the</span>
<span class="comments">;                       extension to read.  The primary data unit is refered</span>
<span class="comments">;                       to as extension 0. If EXTEN_NO is specified, XTENSION,</span>
<span class="comments">;                       EXTNAME, EXTVER, and EXTLEVEL parameters are ignored.</span>
<span class="comments">;               case 2: if EXTEN_NO is not specified, the first extension</span>
<span class="comments">;                       with the specified XTENSION, EXTNAME, EXTVER, and</span>
<span class="comments">;                       EXTLEVEL will be read.  If any of the 4 parameters</span>
<span class="comments">;                       are not specified, they will not be used in the search.</span>
<span class="comments">;                       Setting EXTLEVEL=0, EXTVER=0, EXTNAME='', or</span>
<span class="comments">;                       XTENSION='' is the same as not supplying them.</span>
<span class="comments">;               case 3: if none of the keyword parameters, EXTEN_NO, XTENSION,</span>
<span class="comments">;                       EXTNAME, EXTVER, or EXTLEVEL are supplied.  FITS_READ</span>
<span class="comments">;                       will read the next extension in the file.  If the</span>
<span class="comments">;                       primary data unit (PDU), extension 0, is null, the</span>
<span class="comments">;                       first call to FITS_READ will read the first extension</span>
<span class="comments">;                       of the file.</span>
<span class="comments">;</span>
<span class="comments">;               The only way to read a null PDU is to use EXTEN_NO = 0.</span>
<span class="comments">;</span>
<span class="comments">;       If FIRST and LAST are specified, the data is returned without applying</span>
<span class="comments">;       any scale factors (BSCALE and BZERO) and the data is returned in a</span>
<span class="comments">;       1-D vector.  This will allow you to read any portion of a multiple</span>
<span class="comments">;       dimension data set.  Once returned, the IDL function REFORM can be</span>
<span class="comments">;       used to place the correct dimensions on the data.</span>
<span class="comments">;</span>
<span class="comments">;       IMPLICIT IMAGES: FITS_READ will construct an implicit image</span>
<span class="comments">;               for cases where NAXIS=0 and the NPIX1, NPIX2, and PIXVALUE</span>
<span class="comments">;               keywords are present.  The output image will be:</span>
<span class="comments">;                       image = replicate(PIXVALUE,NPIX1,NPIX2)</span>
<span class="comments">;</span>
<span class="comments">;      FPACK compressed files are always closed and reopened when exiting </span>
<span class="comments">;      FITS_READ so that the pointer is set to the beginning of the file. (Since </span>
<span class="comments">;      FPACK files are opened with a bidirectional pipe rather than OPEN, one </span>
<span class="comments">;      cannot use POINT_LUN to move to a specified position in the file.)</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       Read the primary data unit of a FITS file, if it is null read the</span>
<span class="comments">;       first extension:</span>
<span class="comments">;               FITS_READ, 'myfile.fits', data, header</span>
<span class="comments">;</span>
<span class="comments">;       Read the first two extensions of a FITS file and the extension with</span>
<span class="comments">;       EXTNAME = 'FLUX' and EXTVER = 4</span>
<span class="comments">;               FITS_OPEN, 'myfile.fits', fcb</span>
<span class="comments">;               FITS_READ, fcb,data1, header2, exten_no = 1</span>
<span class="comments">;               FITS_READ, fcb,data1, header2, exten_no = 2</span>
<span class="comments">;               FITS_READ, fcb,data3, header3, extname='flux', extver=4</span>
<span class="comments">;               FITS_CLOSE, fcb</span>
<span class="comments">;       </span>
<span class="comments">;       Read the sixth image in a data cube for the fourth extension.</span>
<span class="comments">;</span>
<span class="comments">;               FITS_OPEN, 'myfile.fits', fcb</span>
<span class="comments">;               image_number = 6</span>
<span class="comments">;               ns = fcb.axis(0,4)</span>
<span class="comments">;               nl = fcb.axis(1,4)</span>
<span class="comments">;               i1 = (ns*nl)*(image_number-1)</span>
<span class="comments">;               i2 = i2 + ns*nl-1</span>
<span class="comments">;               FITS_READ,fcb,image,header,first=i1,last=i2</span>
<span class="comments">;               image = reform(image,ns,nl,/overwrite)</span>
<span class="comments">;               FITS_CLOSE</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       FITS_CLOSE, FITS_OPEN</span>
<span class="comments">;       SXADDPAR, SXDELPAR, SXPAR()</span>
<span class="comments">; WARNINGS:</span>
<span class="comments">;       In Sep 2006, FITS_OPEN was modified to open FITS files using the</span>
<span class="comments">;       /SWAP_IF_LITTLE_ENDIAN keyword to OPEN, so that subsequent routines </span>
<span class="comments">;       (FITS_READ, FITS_WRITE) did not require any byte swapping.    An error</span>
<span class="comments">;       may result if an pre-Sep 2006 version of FITS_OPEN is used with a </span>
<span class="comments">;       post Sep 2006 version of FITS_READ, FITS_WRITE or MODFITS.</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Written by:     D. Lindler, August 1995</span>
<span class="comments">;       Avoid use of !ERR       W. Landsman   August 1999</span>
<span class="comments">;       Read unsigned datatypes, added /no_unsigned   W. Landsman December 1999</span>
<span class="comments">;       Don't call FITS_CLOSE unless fcb is defined   W. Landsman January 2000</span>
<span class="comments">;       Set BZERO = 0 for unsigned integer data   W. Landsman  January 2000</span>
<span class="comments">;       Only call IEEE_TO_HOST if needed          W. Landsman February 2000</span>
<span class="comments">;       Ensure EXTEND keyword in primary header   W. Landsman April 2001</span>
<span class="comments">;       Don't erase ERROR message when closing file  W. Landsman April 2002</span>
<span class="comments">;       Assume at least V5.1 remove NANValue keyword  W. Landsman November 2002</span>
<span class="comments">;       Work with compress files (read file size from fcb),</span>
<span class="comments">;       requires updated (Jan 2003) version of FITS_OPEN W. Landsman Jan 2003</span>
<span class="comments">;       Do not modify BSCALE/BZERO for  unsigned integers W. Landsman April 2006</span>
<span class="comments">;       Asuume FITS_OPEN has opened the file with /SWAP_IF_LITTLE_ENDIAN</span>
<span class="comments">;                         W. Landsman   September 2006</span>
<span class="comments">;       Fix problem with /DATA_ONLY keyword  M.Buie/W.Landsman  October 2006</span>
<span class="comments">;       Only append primary header if INHERIT=T  W. Landsman  April 2007</span>
<span class="comments">;       Make ndata 64bit for very large files E. Hivon/W. Landsman May 2007</span>
<span class="comments">;       Added /PDU keyword to always append primary header W. Landsman June 2007</span>
<span class="comments">;       Use PRODUCT to compute # of data points   W. Landsman  May 2009</span>
<span class="comments">;       Make sure FIRST is long64 when computing position W.L. October 2009</span>
<span class="comments">;       Read FPACK compressed files, W.L.  December 2010</span>
<span class="comments">;       Don't assume FCB has a FCOMPRESS tag  W.L./Satori UeNO   September 2012</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
       compile_opt idl2
<span class="comments">; print calling sequence</span>
<span class="comments">;</span>
        if N_params() eq 0 then begin
          print,'Syntax - FITS_READ,file_or_fcb,data,header,group_par'
          print,' Input Keywords: /noscale, exten_no=, extname=, '
          print,'               extver=, extlevel=, xtension=, /no_abort, '
          print,'               first, last, group, /header_only, /no_pdu, /pdu'
          print,' Output Keywords: enum =, message='
          return
        endif
<span class="comments">;</span>
<span class="comments">; I/O error processing</span>
<span class="comments">;</span>
        on_ioerror,ioerror
<span class="comments">;</span>
<span class="comments">; set defaults</span>
<span class="comments">;</span>
        message = ''
        if n_elements(noscale) eq 0 then noscale = 0
        if n_elements(exten_no) eq 0 then exten_no = -1
        if n_elements(extname) eq 0 then extname = ''
        if n_elements(extver) eq 0 then extver = 0
        if n_elements(extlevel) eq 0 then extlevel = 0
        if n_elements(first) eq 0 then first = 0
        if n_elements(last) eq 0 then last = 0
        if n_elements(no_abort) eq 0 then no_abort = 0
        if n_elements(group) eq 0 then group = 0
        if n_elements(header_only) eq 0 then header_only = 0
        if n_elements(data_only) eq 0 then data_only = 0
        if n_elements(no_pdu) eq 0 then no_pdu = 0
        if n_elements(pdu) eq 0 then pdu = 0
        if n_elements(xtension) eq 0 then xtension = ''
<span class="comments">;</span>
<span class="comments">; Open file if file name is supplied</span>
<span class="comments">;</span>
        fcbtype = size(file_or_fcb,/type)
        fcbsize = n_elements(file_or_fcb)
        if (fcbsize ne 1) or ((fcbtype ne 7) and (fcbtype ne 8)) then begin
                message = 'Invalid Filename or FCB supplied'
                goto,error_exit
        end

        if fcbtype eq 7 then begin
                fits_open,file_or_fcb,fcb,no_abort=no_abort,message=message
                if message NE '' then goto,error_exit
           end else fcb = file_or_fcb
<span class="comments">;</span>
<span class="comments">; determine which extension to read ==========================================</span>
<span class="comments">;</span>
<span class="comments">; case 1: exten_no specified</span>
<span class="comments">;</span>

        enum = exten_no
        if exten_no le -1 then begin
<span class="comments">;</span>
<span class="comments">; case 2: extname, extver, or extlevel specified</span>
<span class="comments">;</span>
           if (extname ne '') || (extlevel ne 0) || (extver ne 0) || $
              (xtension ne '') then begin
<span class="comments">;</span>
<span class="comments">; find extensions with supplied extname, extver, extlevel, and xtension</span>
<span class="comments">;</span>
                good = replicate(1b,fcb.nextend+1)
                if extname ne '' then good = good and $
                         (strtrim(strupcase(extname)) eq strupcase(fcb.extname))
                if xtension ne '' then good = good and $
                       (strtrim(strupcase(xtension)) eq strupcase(fcb.xtension))
                if extver ne 0 then good = good and (extver eq fcb.extver)
                if extlevel ne 0 then good = good and (extlevel eq fcb.extlevel)
                good = where(good,ngood)
<span class="comments">;</span>
<span class="comments">; select first one</span>
<span class="comments">;</span>
                if ngood le 0 then begin
                    message='No extension for given extname, extver, and/or' + $
                            ' extlevel found'
                    goto,error_exit
                endif
                enum = good[0]
              end else begin
<span class="comments">;</span>
<span class="comments">;       case 3: read next extension</span>
<span class="comments">;</span>
                enum = fcb.last_extension + 1
                if (enum eq 0) && (fcb.naxis[0] eq 0) then enum = 1
            end
        end
<span class="comments">;</span>
<span class="comments">; check to see if it is a valid extension</span>
<span class="comments">;</span>
        if enum gt fcb.nextend then begin
                message='EOF encountered'
                goto,error_exit
        end
<span class="comments">;</span>
<span class="comments">; extract information from FCB for the extension</span>
<span class="comments">;</span>
        bitpix = fcb.bitpix[enum]
        naxis = fcb.naxis[enum]
        if naxis gt 0 then axis = fcb.axis[0:naxis-1,enum]
        gcount = fcb.gcount[enum]
        pcount = fcb.pcount[enum]
        xtension = fcb.xtension[enum]
	fcompress = tag_exist(fcb,'fcompress') ? fcb.fcompress : 0
<span class="comments">;</span>
<span class="comments">; read header ================================================================</span>
<span class="comments">;</span>
        if data_only then goto,read_data
        h = bytarr(80,36,/nozero)
        nbytes_in_file = fcb.nbytes
        position = fcb.start_header[enum]
	
        if fcompress then mrd_skip,fcb.unit,position else $
	                 point_lun,fcb.unit,position
        first_block = 1         <span class="comments">; first block in header flag</span>
        repeat begin
             if position ge nbytes_in_file then begin
                 message = 'EOF encountered while reading header'
                 goto,error_exit
             endif

             readu,fcb.unit,h
             position +=  2880
             hdr = string(h>32b)
             endline = where(strcmp(hdr,'END     ',8),nend)
             if nend gt 0 then hdr = hdr[0:endline[0]]
             if first_block then header = hdr else header = [header,hdr]
             first_block = 0
        end until (nend gt 0)
<span class="comments">;</span>
<span class="comments">; extract some header information</span>
<span class="comments">;</span>
        bscale = sxpar(header,'bscale', Count = N_bscale)
        bzero = sxpar(header,'bzero', Count = N_bzero)
        if bscale eq 0.0 then bscale = 1.0
        unsgn_int = (bitpix EQ 16) && (Bzero EQ 32768) && (bscale EQ 1)
        unsgn_lng = (bitpix EQ 32) && (Bzero EQ 2147483648) && (bscale EQ 1)
        if (unsgn_int || unsgn_lng) then $
	        if ~keyword_set(no_unsigned) then noscale = 1
        if (N_bscale gt 0) &&(noscale eq 0) && (data_only eq 0) && $
           (last eq 0) && (header_only eq 0) then sxaddpar,header,'bscale',1.0
        if (N_bzero gt 0) && (noscale eq 0) && (data_only eq 0) && $
           (last eq 0) && (header_only eq 0) then sxaddpar,header,'bzero',0.0
        groups = sxpar(header,'groups')
<span class="comments">;</span>
<span class="comments">; create header with form:</span>
<span class="comments">;       ! Required Keywords</span>
<span class="comments">;       ! BEGIN MAIN HEADER ------------------------------------------</span>
<span class="comments">;       ! Primary data unit header keywords</span>
<span class="comments">;       ! BEGIN EXTENSION HEADER -------------------------------------</span>
<span class="comments">;       ! Extension header keywords</span>
<span class="comments">;       ! END           </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; add Primary Data Unit header to it portion of the header to it, unless the</span>
<span class="comments">; NO_PDU keyword is set, or the INHERIT keyword is not found or set to false</span>
<span class="comments">;</span>
	       
	if no_pdu EQ 0 then no_pdu = 1 - (sxpar(header,'INHERIT') > 0)
        if pdu then no_pdu = 0
        if (no_pdu eq 0) && (enum gt 0) then begin
	
<span class="comments">;</span>
<span class="comments">; delete required keywords</span>
<span class="comments">;</span>
        sxdelpar,header,['SIMPLE','BITPIX','NAXIS','NAXIS1', $
                         'NAXIS2','NAXIS3','NAXIS4','NAXIS5', $
                         'NAXIS6','NAXIS7','NAXIS8','EXTEND', $
                         'PCOUNT','GCOUNT','GROUPS', $
                         'XTENSION']
	

<span class="comments">; create required keywords</span>
<span class="comments">;</span>
        hreq = strarr(20)
        hreq[0] = 'END     '

        if enum eq 0 then $
                sxaddpar,hreq,'SIMPLE','T','image conforms to FITS standard' $
           else sxaddpar,hreq,'XTENSION',xtension,'extension type'

        sxaddpar,hreq,'bitpix',bitpix,'bits per data value'
        sxaddpar,hreq,'naxis',naxis,'number of axes'
        if naxis gt 0 then for i=1,naxis do $
                sxaddpar,hreq,'naxis'+strtrim(i,2),axis[i-1]
        if (enum eq 0) && (fcb.nextend GE 1) then $
                sxaddpar,hreq,'EXTEND','T','file may contain extensions'
        if groups then sxaddpar,hreq,'GROUPS','T','Group format'
        if (enum gt 0) || (pcount gt 0) then $
                     sxaddpar,hreq,'PCOUNT',pcount,'Number of group parameters'
        if (enum gt 0) || (gcount gt 0) then $
                    sxaddpar,hreq,'GCOUNT',gcount,'Number of groups'
       n0 = where(strcmp(hreq,'END     ',8)) & n0=n0[0]
            hpdu = fcb.hmain
            n1 = n_elements(hpdu)
            if n1 gt 1 then begin               
                hreq = [hreq[0:n0-1], $
                        'BEGIN MAIN HEADER ---------------------------------', $
                        hpdu[0:n1-2], $
                        'BEGIN EXTENSION HEADER ----------------------------', $
                        'END     ']
                n0 = n0 + n1 + 1
            end
<span class="comments">;</span>
<span class="comments">; add extension header</span>
<span class="comments">;</span>
        header = [hreq[0:n0-1],header]
        end
        if header_only then begin
                data = 0
                goto,done
        endif
<span class="comments">;</span>
<span class="comments">; Read Data ===================================================================</span>
<span class="comments">;</span>
read_data:
        if naxis eq 0 then begin        <span class="comments">;null image?</span>
                data = 0
<span class="comments">;</span>
<span class="comments">; check for implicit data specified by NPIX1, NPIX2, and PIXVALUE (provided</span>
<span class="comments">; the header was red, i.e. data_only was not specified)</span>
<span class="comments">;</span>
                if data_only eq 0 then begin
                        NPIX1 = sxpar(header,'NPIX1')
                        NPIX2 = sxpar(header,'NPIX2')
                        PIXVALUE = sxpar(header,'PIXVALUE')
                        if (NPIX1*NPIX2) gt 0 then $
                                data = replicate(pixvalue,npix1,npix2)
                end
                goto,done
        endif

        case BITPIX of
           8:   IDL_type = 1          <span class="comments">; Byte</span>
          16:   IDL_type = 2          <span class="comments">; Integer*2</span>
          32:   IDL_type = 3          <span class="comments">; Integer*4</span>
         -32:   IDL_type = 4          <span class="comments">; Real*4</span>
         -64:   IDL_type = 5          <span class="comments">; Real*8</span>
        else:   begin
                message = 'ERROR - Illegal value of BITPIX (= ' +  $
                               strtrim(bitpix,2) + ') in FITS header'
                goto,error_exit
                end
        endcase

        ndata = product( axis, /integer )
        bytes_per_word = (abs(bitpix)/8)
        nbytes_per_group = bytes_per_word * (pcount + ndata)
        nbytes = (gcount>1) * nbytes_per_group
        nwords = nbytes / bytes_per_word
<span class="comments">;</span>
<span class="comments">; starting data position</span>
<span class="comments">;</span>

	skip = fcb.start_data[enum] - position
        position = fcb.start_data[enum]
<span class="comments">;</span>
<span class="comments">; find correct group</span>
<span class="comments">;</span>
        if last eq 0 then begin
                if group ge (gcount>1) then begin
                        message='INVALID group number specified'
                        goto,error_exit
                end
		skip += long64(group) * nbytes_per_group 
                position += skip
        end
<span class="comments">;</span>
<span class="comments">; read group parameters</span>
<span class="comments">;</span>
        if (enum eq 0) && (fcb.random_groups eq 1) && (pcount gt 0) && $
           (last eq 0) then begin
            if N_params() gt 3 then begin
                group_par = make_array( dim = [pcount], type = idl_type, /nozero)
               
             if fcompress then mrd_skip,fcb.unit,skip else $
	                  point_lun,fcb.unit,position
 
                readu,fcb.unit,group_par
            endif
	    skip  =  long64(pcount) * bytes_per_word
            position += skip
        endif
<span class="comments">;</span>
<span class="comments">; create data array</span>
<span class="comments">;</span>
        if last gt 0 then begin
<span class="comments">;</span>
<span class="comments">; user specified first and last</span>
<span class="comments">;</span>
                if (first lt 0) || (last le 1) || (first gt last) || $
                   (last gt nwords-1) then begin
                        message = 'INVALID value for parameters FIRST & LAST'
                        goto,error_exit
                endif
                data = make_array(dim = [last-first+1], type=idl_type, /nozero)
                skip +=  long64(first) * bytes_per_word
                position += skip
            endif else begin
<span class="comments">;</span>
<span class="comments">; full array</span>
<span class="comments">;</span>
                if ndata eq 0 then begin
                        data = 0
                        goto,done
                endif 
                if naxis gt 8 then begin
                        message = 'Maximum value of NAXIS allowed is 8'
                        goto,error_exit
                endif
                data = make_array(dim = axis, type = idl_type, /nozero)
        endelse
<span class="comments">;</span>
<span class="comments">; read array</span>
<span class="comments">;</span>
        if fcompress then mrd_skip,fcb.unit,skip else $
	                 point_lun,fcb.unit,position
        readu,fcb.unit,data
	if fcompress then swap_endian_inplace,data,/swap_if_little
        if ~keyword_set(No_Unsigned) && (~data_only) then begin
        if unsgn_int then begin 
                data =  uint(data) - uint(32768) 
        endif else if unsgn_lng then begin 
                data = ulong(data) - ulong(2147483648)
        endif
	endif
<span class="comments">;</span>
<span class="comments">; scale data if header was read and first and last not used.   Do a special</span>
<span class="comments">; check of an unsigned integer (BZERO = 2^15) or unsigned long (BZERO = 2^31) </span>
<span class="comments">;</span>
        if (data_only eq 0) && (last eq 0) && (noscale eq 0) then begin

                if bitpix lt 32 then begin      <span class="comments">;use real*4 for bitpix&lt;32</span>
                        bscale = float(bscale)
                        bzero = float(bzero)
                endif
                if bscale ne 1.0 then data *= bscale
                if bzero ne 0.0 then data +=  bzero
 	endif
<span class="comments">;</span>
<span class="comments">; done</span>
<span class="comments">;</span>
done:   
        if fcompress then begin 
	        free_lun,fcb.unit 
		ff = strmid(fcb.filename,1,strlen(fcb.filename)-2)	
		spawn,ff,unit=unit,/sh, stderr = stderr		
		fcb.unit = unit
        endif else $		
        if fcbtype eq 7 then fits_close,fcb else file_or_fcb.last_extension=enum
        !err = 1
        return

<span class="comments">;</span>
<span class="comments">; error exit</span>
<span class="comments">;</span>
ioerror:
        message = !ERROR_STATE.MSG
error_exit:
        if (fcbtype eq 7) && (N_elements(fcb) GT 0) then  $
                   fits_close,fcb, no_abort=no_abort
        !err = -1
        if keyword_set(no_abort) then return
        print,'FITS_READ ERROR: '+message
        retall
end
</code>
    </div>
  </body>
</html>