<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:18 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>adstring.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="adstring.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">Function adstring,ra_dec,dec,precision, TRUNCATE = truncate,PRECISION=prec
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       ADSTRING</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return RA and Dec as character string(s) in sexagesimal format.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       RA and Dec may be entered as either a 2 element vector or as</span>
<span class="comments">;       two separate vectors (or scalars).  One can also specify the precision </span>
<span class="comments">;       of the declination in digits after the decimal point.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE</span>
<span class="comments">;       result = ADSTRING( ra_dec, precision, /TRUNCATE )           </span>
<span class="comments">;               or</span>
<span class="comments">;       result = ADSTRING( ra,dec,[ precision, /TRUNCATE ] )</span>
<span class="comments">;               or</span>
<span class="comments">;       result = ADSTRING( dec, [ PRECISION= ]   </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       RA_DEC - 2 element vector giving the Right Ascension and declination</span>
<span class="comments">;               in decimal degrees.</span>
<span class="comments">;                     or</span>
<span class="comments">;       RA     - Right ascension in decimal degrees, numeric scalar or vector</span>
<span class="comments">;       DEC    - Declination in decimal degrees, numeric scalar or vector</span>
<span class="comments">;</span>
<span class="comments">;     If only parameter is supplied then it must be either a scalar (which</span>
<span class="comments">;     is converted to sexagesimal) or a two element [RA, Dec] vector.</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;       PRECISION  - Integer scalar (0-4) giving the number of digits after the </span>
<span class="comments">;               decimal of DEClination.   The RA is automatically 1 digit more.</span>
<span class="comments">;               This parameter may either be the third parameter after RA,DEC </span>
<span class="comments">;               or the second parameter after [RA,DEC].  If only DEC is supplied </span>
<span class="comments">;               then precision must be supplied as a keyword parameter.   If no</span>
<span class="comments">;               PRECISION parameter or keyword is passed, a  precision of 1 for</span>
<span class="comments">;               both RA and DEC is returned to maintain  compatibility with past</span>
<span class="comments">;               ADSTRING versions.    Values of  precision larger than 4 will </span>
<span class="comments">;               be truncated to 4.    If PRECISION is 3 or 4, then RA and Dec </span>
<span class="comments">;               should be input as double precision.</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       /TRUNCATE - if set, then the last displayed digit in the output is </span>
<span class="comments">;               truncated in precision rather than rounded.   This option is</span>
<span class="comments">;               useful if ADSTRING() is used to form an official IAU name </span>
<span class="comments">;               (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with </span>
<span class="comments">;               coordinate specification.   The IAU name will typically be</span>
<span class="comments">;               be created by applying STRCOMPRESS/REMOVE) after the ADSTRING()</span>
<span class="comments">;               call, e.g. </span>
<span class="comments">;              strcompress( adstring(ra,dec,0,/truncate), /remove)   ;IAU format</span>
<span class="comments">;        PRECISION = Alternate method of supplying the precision parameter, </span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       RESULT - Character string(s) containing HR,MIN,SEC,DEC,MIN,SEC formatted</span>
<span class="comments">;               as ( 2I3,F5.(p+1),2I3,F4.p ) where p is the PRECISION </span>
<span class="comments">;               parameter.    If only a single scalar is supplied it is </span>
<span class="comments">;               converted to a sexagesimal string (2I3,F5.1).</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       (1) Display CRVAL coordinates in a FITS header, H</span>
<span class="comments">;</span>
<span class="comments">;       IDL> crval = sxpar(h,'CRVAL*')  ;Extract 2 element CRVAL vector (degs)</span>
<span class="comments">;       IDL> print, adstring(crval)     ;Print CRVAL vector sexagesimal format</span>
<span class="comments">;</span>
<span class="comments">;       (2)  print,adstring(30.42,-1.23,1)  ==>  ' 02 01 40.80  -01 13 48.0'</span>
<span class="comments">;            print,adstring(30.42,+0.23)    ==>  ' 02 01 40.8   +00 13 48.0'    </span>
<span class="comments">;            print,adstring(+0.23)          ==>  '+00 13 48.0'</span>
<span class="comments">;</span>
<span class="comments">;       (3) The first two calls in (2) can be combined in a single call using</span>
<span class="comments">;           vector input</span>
<span class="comments">;              print,adstring([30.42,30.42],[-1.23,0.23], 1)</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       RADEC, SIXTY()</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written   W. Landsman                      June 1988</span>
<span class="comments">;       Addition of variable precision and DEC seconds precision fix. </span>
<span class="comments">;       ver.  Aug. 1990 [E. Deutsch]</span>
<span class="comments">;       Output formatting spiffed up       October 1991 [W. Landsman]</span>
<span class="comments">;       Remove ZPARCHECK call, accept 1 element vector  April 1992 [W. Landsman]</span>
<span class="comments">;       Call ROUND() instead of NINT()    February 1996  [W. Landsman]</span>
<span class="comments">;       Check roundoff past 60s           October 1997   [W. Landsman]</span>
<span class="comments">;       Work for Precision =4             November 1997  [W. Landsman]</span>
<span class="comments">;       Major rewrite to allow vector inputs   W. Landsman  February 2000</span>
<span class="comments">;       Fix possible error in seconds display when Precision=0 </span>
<span class="comments">;                               P. Broos/W. Landsman April 2002</span>
<span class="comments">;       Added /TRUNCATE keyword, put leading zeros in seconds display</span>
<span class="comments">;                               P. Broos/W. Landsman September 2002</span>
<span class="comments">;       Fix declination zero values under vector processing W.Landsman Feb 2004</span>
<span class="comments">;       Fix possible problem in leading zero display W. Landsman June 2004</span>
<span class="comments">;       Assume since V5.4, omit fstring() call  W. Landsman April 2006</span>
<span class="comments">;       Fix significant bug when round a declination with -1&lt;dec&lt;0 </span>
<span class="comments">;          Add PRECISION keyword    W.L. Aug 2008</span>
<span class="comments">;       Use formatting for "+" and "0"  W. L.    May 2009</span>
<span class="comments">;       Allow formatting of longitudes >99.99  W. L.  Sep 2012</span>
<span class="comments">;-</span>
  On_error,2
  compile_opt idl2

  Npar = N_params()
 

  case N_elements(ra_dec) of 

     1: if ( Npar EQ 1 ) then dec = ra_dec else ra = ra_dec
     2: begin
        if (N_elements(dec) LT 2) then begin 
              ra = ra_dec[0] mod 360.
              if N_elements(dec) EQ 1 then begin 
              precision = dec & Npar=3 & endif
              dec = ra_dec[1]
        endif else ra = ra_dec
        end
   else: begin
        If (Npar Eq 1) then message, $
	'ERROR - first parameter must be either a scalar or 2 element vector'
        ra = ra_dec 
        end
   endcase

  if N_elements(prec) EQ 1 then precision = prec
  
  if ( Npar GE 2 ) then $
        if N_elements(dec) NE N_elements(ra) then message, $
      'ERROR - RA and Declination do not have equal number of elements'

  if N_elements(ra) EQ N_elements(dec) then begin

    badrange = where( (dec LT -90.) or (dec GT 90.), Nbad)
    if Nbad GT 0 then message, /INF, $
      'WARNING - Some declination values are out of valid range (-90 &lt; dec &lt;90)'
     radec, ra, dec, ihr, imin, xsec, ideg, imn, xsc
     if N_elements(precision) EQ 0 then precision = 0
     precision = precision > 0 &lt<span class="comments">; 4         ;No more than 4 decimal places</span>
 if ~keyword_set(truncate) then begin
     roundsec = [59.5,59.95,59.995,59.9995,59.99995,59.999995]
     carry = where(xsec GT roundsec[precision+1], Ncarry)
     if Ncarry GT 0 then begin
        imin[carry] = imin[carry] + 1
        xsec[carry] = 0.0
        mcarry = where(imin[carry] EQ 60, Nmcarry)
        if Nmcarry GT 0 then begin
                ic = carry[mcarry]
                ihr[ic] = (ihr[ic] + 1) mod 24
                imin[ic] = 0
        endif
     endif
  endif else xsec = (long(xsec*10L^(precision+1)))/10.0d^(precision+1)

     secfmt = '(F0' + string( 3+precision+1,'(I1)' ) + '.' + $
                     string(   precision+1,'(I1)' ) + ')'
     result = string(ihr,'(I3.2)') + string(imin,'(I3.2)') + ' ' +$
              strtrim(string(xsec,secfmt),2) + '  ' 
    if N_elements(precision) EQ 0 then precision = 1

  endif else begin

     x = sixty(dec)
     if N_elements(precision) EQ 0 then precision = 1
     ideg = fix(x[0]) & imn = fix(x[1]) & xsc = x[2]
     result = ''

  endelse

   imn = abs(imn)  & xsc = abs(xsc)
   if ( precision EQ 0 ) then begin 
           secfmt = '(I03.2)' 
           if ~keyword_set(truncate) then begin
           xsc = round(xsc)
           carry = where(xsc EQ 60, Ncarry)
           if Ncarry GT 0 then begin                 <span class="comments">;Updated April 2002</span>
                  xsc[carry] = 0
                  imn[carry] = imn[carry] + 1
           endif
           endif
   endif else begin

         secfmt = '(F0' + string( 3+precision,'(I1)') + '.' + $
                         string(   precision,'(I1)') + ')'
			 
         if ~keyword_set(truncate) then begin
         ixsc = fix(xsc + 0.5/10^precision)
         carry = where(ixsc GE 60, Ncarry)
         if Ncarry GT 0 then begin
             xsc[carry] = 0.
             imn[carry] = imn[carry] + 1
         endif
         endif else $
              xsc = (long(xsc*10^precision))/10.0d^precision
  endelse

   pos = dec GE 0 
   carry = where(imn EQ 60, Ncarry)
   if Ncarry GT 0  then begin
       ideg[carry] = ideg[carry] -1 + 2*pos[carry]
        imn[carry] = 0
   endif
 
   deg = string(ideg,'(I+3.2)')
   big = where(abs(ideg) ge 100, Nbig)
   if Nbig GT 0 then deg[big] = string(ideg[big],'(I+4.3)')
   zero = where(ideg EQ 0, Nzero)
   if Nzero GT 0 then begin
       negzero = where( dec[zero] LT 0, Nneg)
       if Nneg GT 0 then deg[zero[negzero]] = '-00' 
    endif

    
   return, result + deg + string(imn,'(I3.2)') + ' ' +  $
            strtrim(string(xsc,secfmt),2)

   end
</code>
    </div>
  </body>
</html>