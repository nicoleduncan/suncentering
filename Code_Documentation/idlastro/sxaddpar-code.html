<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:03 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sxaddpar.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sxaddpar.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">Pro sxaddpar, Header, Name, Value, Comment, Location, before=before, $
                 savecomment = savecom, after=after , format=format, pdu = pdu
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       SXADDPAR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Add or modify a parameter in a FITS header array.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       SXADDPAR, Header, Name, Value, [ Comment,  Location, /SaveComment, </span>
<span class="comments">;                               BEFORE =, AFTER = , FORMAT= , /PDU]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Header = String array containing FITS or STSDAS header.    The</span>
<span class="comments">;               length of each element must be 80 characters.    If not </span>
<span class="comments">;               defined, then SXADDPAR will create an empty FITS header array.</span>
<span class="comments">;</span>
<span class="comments">;       Name = Name of parameter. If Name is already in the header the value </span>
<span class="comments">;               and possibly comment fields are modified.  Otherwise a new </span>
<span class="comments">;               record is added to the header.  If name is equal to 'COMMENT'</span>
<span class="comments">;               or 'HISTORY' or a blank string then the value will be added to </span>
<span class="comments">;               the record without replacement.  For these cases, the comment </span>
<span class="comments">;               parameter is ignored.</span>
<span class="comments">;</span>
<span class="comments">;       Value = Value for parameter.  The value expression must be of the </span>
<span class="comments">;               correct type, e.g. integer, floating or string.  String values</span>
<span class="comments">;                of 'T' or 'F' are considered logical values.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT PARAMETERS:</span>
<span class="comments">;       Comment = String field.  The '/' is added by this routine.  Added </span>
<span class="comments">;               starting in position 31.    If not supplied, or set equal to </span>
<span class="comments">;               '', or /SAVECOMMENT is set, then the previous comment field is </span>
<span class="comments">;               retained (when found) </span>
<span class="comments">;</span>
<span class="comments">;       Location = Keyword string name.  The parameter will be placed before the</span>
<span class="comments">;               location of this keyword.    This parameter is identical to</span>
<span class="comments">;               the BEFORE keyword and is kept only for consistency with</span>
<span class="comments">;               earlier versions of SXADDPAR.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       BEFORE  = Keyword string name.  The parameter will be placed before the</span>
<span class="comments">;               location of this keyword.  For example, if BEFORE='HISTORY'</span>
<span class="comments">;               then the parameter will be placed before the first history</span>
<span class="comments">;               location.  This applies only when adding a new keyword;</span>
<span class="comments">;               keywords already in the header are kept in the same position.</span>
<span class="comments">;</span>
<span class="comments">;       AFTER   = Same as BEFORE, but the parameter will be placed after the</span>
<span class="comments">;               location of this keyword.  This keyword takes precedence over</span>
<span class="comments">;               BEFORE.</span>
<span class="comments">;</span>
<span class="comments">;       FORMAT  = Specifies FORTRAN-like format for parameter, e.g. "F7.3".  A</span>
<span class="comments">;               scalar string should be used.  For complex numbers the format</span>
<span class="comments">;               should be defined so that it can be applied separately to the</span>
<span class="comments">;               real and imaginary parts.  If not supplied then the default is</span>
<span class="comments">;               'G19.12' for double precision, and 'G14.7' for floating point.</span>
<span class="comments">;</span>
<span class="comments">;       /PDU    = specifies keyword is to be added to the primary data unit</span>
<span class="comments">;               header. If it already exists, it's current value is updated in</span>
<span class="comments">;               the current position and it is not moved.</span>
<span class="comments">;       /SAVECOMMENT = if set, then any existing comment is retained, i.e. the</span>
<span class="comments">;               COMMENT parameter only has effect if the keyword did not </span>
<span class="comments">;               previously exist in the header.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Header = updated FITS header array.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Add a keyword 'TELESCOP' with the value 'KPNO-4m' and comment 'Name</span>
<span class="comments">;       of Telescope' to an existing FITS header h.</span>
<span class="comments">;</span>
<span class="comments">;       IDL> sxaddpar, h, 'TELESCOPE','KPNO-4m','Name of Telescope'</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The functions SXADDPAR() and FXADDPAR() are nearly identical, with the</span>
<span class="comments">;       major difference being that FXADDPAR forces required FITS keywords</span>
<span class="comments">;       BITPIX, NAXISi, EXTEND, PCOUNT, GCOUNT to appear in the required order</span>
<span class="comments">;       in the header, and FXADDPAR supports the OGIP LongString convention.   </span>
<span class="comments">;       There is no particular reason for having two nearly identical </span>
<span class="comments">;       procedures, but both are too widely used to drop either one.</span>
<span class="comments">;</span>
<span class="comments">;       All HISTORY records are inserted in order at the end of the header.</span>
<span class="comments">;</span>
<span class="comments">;       All COMMENT records are also inserted in order at the end of the header</span>
<span class="comments">;       header, but before the HISTORY records.  The BEFORE and AFTER keywords</span>
<span class="comments">;       can override this.</span>
<span class="comments">;</span>
<span class="comments">;       All records with no keyword (blank) are inserted in order at the end of</span>
<span class="comments">;       the header, but before the COMMENT and HISTORY records.  The BEFORE and</span>
<span class="comments">;       AFTER keywords can override this.</span>

<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       Warning -- Parameters and names are not checked</span>
<span class="comments">;               against valid FITS parameter names, values and types.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       DMS, RSI, July, 1983.</span>
<span class="comments">;       D. Lindler Oct. 86  Added longer string value capability</span>
<span class="comments">;       Converted to NEWIDL  D. Lindler April 90</span>
<span class="comments">;       Added Format keyword, J. Isensee, July, 1990</span>
<span class="comments">;       Added keywords BEFORE and AFTER. K. Venkatakrishna, May '92</span>
<span class="comments">;       Pad string values to at least 8 characters   W. Landsman  April 94</span>
<span class="comments">;       Aug 95: added /PDU option and changed routine to update last occurence</span>
<span class="comments">;               of an existing keyword (the one SXPAR reads) instead of the</span>
<span class="comments">;               first occurence.</span>
<span class="comments">;       Comment for string data can start after column 32 W. Landsman June 97</span>
<span class="comments">;       Make sure closing quote supplied with string value  W. Landsman  June 98</span>
<span class="comments">;       Converted to IDL V5.0    W. Landsman   June 98</span>
<span class="comments">;       Increase precision of default formatting of double precision floating</span>
<span class="comments">;               point values.   C. Gehman, JPL  September 1998</span>
<span class="comments">;       Mar 2000, D. Lindler, Modified to use capital E instead of lower case</span>
<span class="comments">;               e for exponential formats.</span>
<span class="comments">;       Apr 2000, Make user-supplied format upper-case  W. Landsman </span>
<span class="comments">;       Oct 2001, Treat COMMENT or blank string like HISTORY keyword W. Landsman</span>
<span class="comments">;       Jan 2002, Allow BEFORE, AFTER to apply to COMMENT keywords W. Landsman</span>
<span class="comments">;       June 2003, Added SAVECOMMENT keyword    W. Landsman</span>
<span class="comments">;       Jan 2004, If END is missing, then add it at the end W. Landsman</span>
<span class="comments">;       May 2005 Fix SAVECOMMENT error with non-string values W. Landsman</span>
<span class="comments">;       Oct 2005 Jan 2004 change made SXADDPAR fail for empty strings W.L.</span>
<span class="comments">;       May 2011 Fix problem with slashes in string values W.L. </span>
<span class="comments">;       </span>
<span class="comments">;-</span>
 compile_opt idl2
 if N_params() LT 3 then begin             <span class="comments">;Need at least 3 parameters</span>
      print,'Syntax - Sxaddpar, Header, Name,  Value, [Comment, Postion'
      print,'                      BEFORE = ,AFTER = , FORMAT =, /SAVECOMMENT]'
      return
 endif

<span class="comments">; Define a blank line and the END line</span>

 ENDLINE = 'END' +string(replicate(32b,77))     <span class="comments">;END line</span>
 BLANK = string(replicate(32b,80))             <span class="comments">;BLANK line</span>
<span class="comments">;</span>
<span class="comments">;  If Location parameter not defined, set it equal to 'END     '</span>
<span class="comments">;</span>
 if ( N_params() GT 4 ) then loc = strupcase(location) else $
 if keyword_set( BEFORE) then loc = strupcase(before) else $
 if keyword_set( AFTER)  then loc = strupcase(after) else $
 if keyword_set( PDU) then loc = 'BEGIN EX' else $
                             loc = 'END'

 while strlen(loc) lt 8 do loc = loc + ' '

 if N_params() lt 4 then comment = ''      <span class="comments">;Is comment field specified?</span>

 n = N_elements(header)                  <span class="comments">;# of lines in FITS header</span>
 if (n EQ 0) then begin                  <span class="comments">;header defined?</span>
          header=strarr(10)              <span class="comments">;no, make it.</span>
          header[0]=ENDLINE
          n=10
 endif else begin
          s = size(header)               <span class="comments">;check for string type</span>
              if (s[0] ne 1) or (s[2] ne 7) then $
                  message,'FITS Header (first parameter) must be a string array'
 endelse

<span class="comments">;  Make sure Name is 8 characters long</span>

        nn = string(replicate(32b,8))   <span class="comments">;8 char name</span>
        strput,nn,strupcase(name) <span class="comments">;insert name</span>

<span class="comments">;  Extract first 8 characters of each line of header, and locate END line</span>

 keywrd = strmid(header,0,8)                 <span class="comments">;Header keywords</span>
 iend = where(keywrd eq 'END     ',nfound)
<span class="comments">;</span>
<span class="comments">;  If no END, then add it.  Either put it after the last non-null string, or</span>
<span class="comments">;  append it to the end.</span>
<span class="comments">;</span>
        if nfound EQ 0 then begin
                ii = where(strtrim(header) ne '',nfound)
                ii = max(ii) + 1
                if ii eq n_elements(header) then begin
                        header = [header,endline]
                        n = n+1 
                endif else header[ii] = endline
                keywrd = strmid(header,0,8)
                iend = where(keywrd eq 'END     ',nfound)
        endif
<span class="comments">;</span>
        iend = iend[0] > 0                      <span class="comments">;make scalar</span>

<span class="comments">;  History, comment and "blank" records are treated differently from the</span>
<span class="comments">;  others.  They are simply added to the header array whether there are any</span>
<span class="comments">;  already there or not.</span>

 if (nn EQ 'HISTORY ') || (nn EQ 'COMMENT ') || $
    (nn EQ '        ')  then begin             <span class="comments">;add history record?</span>
<span class="comments">;</span>
<span class="comments">;  If the header array needs to grow, then expand it in increments of 5 lines.</span>
<span class="comments">;</span>

     if iend GE (n-1) then begin
                 header = [header,replicate(blank,5)] <span class="comments">;yes, add 5.</span>
                 n = N_elements(header)
      endif

<span class="comments">; Format the record</span>

      newline = blank
      strput,newline,nn+string(value),0

<span class="comments">;</span>
<span class="comments">;  If a history record, then append to the record just before the end.</span>
<span class="comments">;</span>
      if nn EQ 'HISTORY ' then begin
             header[iend] = newline             <span class="comments">;add history rec.</span>
             header[iend+1] = endline
<span class="comments">;</span>
<span class="comments">;  The comment record is placed immediately after the last previous comment</span>
<span class="comments">;  record, or immediately before the first history record, unless overridden by</span>
<span class="comments">;  either the BEFORE or AFTER keywords.</span>
<span class="comments">;</span>
      endif else if nn EQ 'COMMENT ' then begin
            if loc EQ 'END     ' then loc = 'COMMENT '
            iloc = where(keywrd EQ loc, nloc)
            if nloc EQ 0 then iloc = where(keywrd EQ 'HISTORY ', nloc)
            if nloc gt 0 then begin
               i = iloc[nloc-1]
               if keyword_set(after) or (loc EQ 'COMMENT ') then i = i+1 &lt<span class="comments">; iend </span>
               if i gt 0 then header=[header[0:i-1],newline,header[i:n-1]] $
                        else header=[newline,header[0:n-1]]
            endif else begin
                header[iend] = newline
                header[iend+1] = endline
            endelse

<span class="comments">;</span>
<span class="comments">;  The "blank" record is placed immediately after the last previous "blank"</span>
<span class="comments">;  record, or immediately before the first comment or history record, unless</span>
<span class="comments">;  overridden by either the BEFORE or AFTER keywords.</span>
<span class="comments">;</span>
          ENDIF ELSE BEGIN
            if loc EQ 'END     ' then loc = '       '
            iloc = where(keywrd[0:iend] EQ loc, nloc)
            if nloc gt 0 then begin
               i = iloc[0]
               if keyword_set(after) and loc ne 'HISTORY ' then i = i+1 &lt<span class="comments">; iend </span>
               if i gt 0 then header=[header[0:i-1],newline,header[i:n-1]] $
                        else header=[newline,header[0:n-1]]
            endif else begin
                iloc = where(keywrd EQ 'COMMENT ', nloc)
                if nloc Eq 0 then iloc = where(keywrd EQ 'HISTORY ', nloc)
                if nloc GT 0 then begin
                   i = iloc[0]
                   if i gt 0 then header=[header[0:i-1],newline,header[i:n-1]] $
                        else header=[newline,header[0:n-1]]
                endif else begin
                  header[iend] = newline
                  header[iend+1] = endline
            endelse
            endelse
           endelse
            RETURN
 endif

<span class="comments">; Find location to insert keyword.   Save the existing comment if user did</span>
<span class="comments">; not supply a new one.   Comment starts after column 32 for numeric data,</span>
<span class="comments">; after the slash (but at least after final quote) for string data. </span>

 ncomment = comment
 ipos  = where(keywrd eq nn,nfound)
 if nfound gt 0 then begin
         i = ipos[nfound-1]
         if comment eq '' or keyword_set(savecom) then begin  <span class="comments">;save comment?</span>
         if strmid(header[i],10,1) NE "'" then $
                 ncomment=strmid(header[i],32,48) else begin
		 quote = strpos(header[i],"'",11)
		
                 if quote EQ -1 then slash = -1 else $
		       slash = strpos(header[i],'/',quote)  		
                 if slash NE -1 then $
                        ncomment =  strmid(header[i], slash+1, 80) else $
                        ncomment = string(replicate(32B,80))
                endelse
        endif 
         goto, REPLACE    
 endif

 if loc ne '' then begin
          iloc =  where(keywrd eq loc,nloc)
          if nloc gt 0 then begin
             i = iloc[0]
             if keyword_set(after) and loc ne 'HISTORY ' then i = i+1 &lt<span class="comments">; iend </span>
             if i gt 0 then header=[header[0:i-1],blank,header[i:n-1]] $
                        else header=[blank,header[0:n-1]]
             goto, REPLACE  
          endif
 endif

<span class="comments">; At this point keyword and location parameters were not found, so a new</span>
<span class="comments">; line is added at the end of the FITS header</span>

        if iend lt (n-1) then begin     <span class="comments">;Not found, add more?</span>
                header[iend+1] = ENDLINE        <span class="comments">;no, already long enough.</span>
                i = iend                <span class="comments">;position to add.</span>
           endif else begin             <span class="comments">;must lengthen.</span>
                header = [header,replicate(blank,5)] <span class="comments">;add an element on the end</span>
                header[n]=ENDLINE               <span class="comments">;save "END"</span>
                i =n-1                  <span class="comments">;add to end</span>
        end

<span class="comments">; Now put value into keyword at line i</span>

REPLACE:    
        h=blank                 <span class="comments">;80 blanks</span>
        strput,h,nn+'= '        <span class="comments">;insert name and =.</span>
        apost = "'"             <span class="comments">;quote a quote</span>
        type = size(value)      <span class="comments">;get type of value parameter</span>
        if type[0] ne 0 then $
                message,'Keyword Value (third parameter) must be scalar'

        case type[1] of         <span class="comments">;which type?</span>

7:      begin
          upval = strupcase(value)      <span class="comments">;force upper case.</span>
          if (upval eq 'T') || (upval eq 'F') then begin
                strput,h,upval,29  <span class="comments">;insert logical value.</span>
            end else begin              <span class="comments">;other string?</span>
                if strlen(value) gt 18 then begin       <span class="comments">;long string</span>
                    strput, h, apost + strmid(value,0,68) + apost + $
                        ' /' + ncomment,10
                    header[i] = h
                    return
                endif
                strput, h, apost + value,10       <span class="comments">;insert string val</span>
                strput, h, apost, 11 + (strlen(value)>8)   <span class="comments">;pad string vals</span>
          endelse                                          <span class="comments">;to at least 8 chars</span>
          endcase

5:      BEGIN
        IF (N_ELEMENTS(format) EQ 1) THEN $             <span class="comments">; use format keyword</span>
            v = string(value, FORMAT='('+strupcase(format)+')') $
        ELSE v = STRING(value, FORMAT='(G19.12)')
        s = strlen(v)                                   <span class="comments">; right justify</span>
        strput, h, v, (30-s)>10
        END

 else:  begin
        if (N_elements(format) eq 1) then $            <span class="comments">;use format keyword</span>
            v = string(value, FORMAT='('+strupcase(format)+')' ) else $
            v = strtrim(strupcase(value),2)      
                                      <span class="comments">;convert to string, default format</span>
        s = strlen(v)                 <span class="comments">;right justify</span>
        strput,h,v,(30-s)>10          <span class="comments">;insert</span>
        end
 endcase

 strput,h,' /',30       <span class="comments">;add ' /'</span>
 strput, h, ncomment, 32 <span class="comments">;add comment</span>
 header[i] = h          <span class="comments">;save line</span>

 return
 end
</code>
    </div>
  </body>
</html>