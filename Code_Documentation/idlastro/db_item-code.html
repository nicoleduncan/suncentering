<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:24 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>db_item.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="db_item.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="db_item:source"></a>pro db_item,items,itnum,ivalnum,idltype,sbyte,numvals,nbytes,errmsg=errmsg
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;       DB_ITEM</span>
<span class="comments">; PURPOSE:      </span>
<span class="comments">;       Returns the item numbers and other info. for an item name.</span>
<span class="comments">; EXPLANATION:  </span>
<span class="comments">;       Procedure to return the item numbers and other information</span>
<span class="comments">;       of a specified item name</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:     </span>
<span class="comments">;       db_item, items, itnum, ivalnum, idltype, sbyte, numvals, nbytes</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:       </span>
<span class="comments">;       items - item name or number</span>
<span class="comments">;               form 1  scalar string giving item(s) as list of names</span>
<span class="comments">;                       separated by commas</span>
<span class="comments">;               form 2  string array giving list of item names</span>
<span class="comments">;               form 3  string of form '$filename' giving name</span>
<span class="comments">;                       of text file containing items (one item per</span>
<span class="comments">;                       line)</span>
<span class="comments">;               form 4  integer scalar giving single item number or</span>
<span class="comments">;                         integer vector list of item numbers</span>
<span class="comments">;               form 5  Null string specifying interactive selection</span>
<span class="comments">;                       Upon return items will contain selected items</span>
<span class="comments">;                       in form 1</span>
<span class="comments">;               form 6  '*'     select all items</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:      </span>
<span class="comments">;       itnum - item number</span>
<span class="comments">;       ivalnum - value(s) number from multiple valued item</span>
<span class="comments">;       idltype - data type(s) (1=string,2=byte,4=i*4,...)</span>
<span class="comments">;       sbyte - starting byte(s) in entry</span>
<span class="comments">;       numvals - number of data values for item(s)</span>
<span class="comments">;               It is the full length of a vector item unless</span>
<span class="comments">;               a subscript was supplied</span>
<span class="comments">;       nbytes - number of bytes for each value</span>
<span class="comments">;    All outputs are vectors even if a single item is requested</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:      </span>
<span class="comments">;       ERRMSG   = If defined and passed, then any error messages will</span>
<span class="comments">;               be returned to the user in this parameter rather than depending</span>
<span class="comments">;               on the MESSAGE routine in IDL.  If no errors are encountered, </span>
<span class="comments">;               then a null string is returned.  In order to use this feature, </span>
<span class="comments">;               ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;                               ERRMSG = ''</span>
<span class="comments">;                               DB_ITEM, ERRMSG=ERRMSG, ...</span>
<span class="comments">;                               IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       DB_INFO, GETTOK, SELECT_W</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written:   D. Lindler, GSFC/HRS, October 1987</span>
<span class="comments">;       Version 2, William Thompson, GSFC, 17-Mar-1997</span>
<span class="comments">;                       Added keyword ERRMSG</span>
<span class="comments">;       Use STRSPLIT instead of GETTOK to parse form 1, W. Landsman July 2002</span>
<span class="comments">;       Assume since V5.4 use FILE_EXPAND_PATH() instead of SPEC_DIR()</span>
<span class="comments">;               W. Landsman April 2006</span>
<span class="comments">;       Support new DB format allowing entry lengths > 32767 bytes WL Oct 2010</span>
<span class="comments">;       Ignore blank lines in .items file WL February 2011</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">;------------------------------------------------------------------------</span>
 compile_opt idl2
 On_error,2
 if N_params() LT 2 then begin
    print,'Syntax - DB_ITEM,items,itnum,ivalnum,idltype,sbyte,numvals,nbytes'
    return
 endif 
<span class="comments">; data base common block</span>
<span class="comments">;</span>
common db_com,QDB,QITEMS,QLINK
<span class="comments">;</span>
<span class="comments">; QDB(*,i) contains the following for each data base opened</span>
<span class="comments">;</span>
<span class="comments">;       bytes</span>
<span class="comments">;         0-18   data base name character*19</span>
<span class="comments">;         19-79  data base title character*61</span>
<span class="comments">;         80-81  number of items (integer*2)</span>
<span class="comments">;         82-83  record length of DBF file (integer*2) old DB format</span>
<span class="comments">;         84-87  number of entries in file (integer*4)</span>
<span class="comments">;         88-89  position of first item for this file in QITEMS (I*2)</span>
<span class="comments">;         90-91  position of last item for this file (I*2)</span>
<span class="comments">;         92-95  Last Sequence number used (item=SEQNUM) (I*4)</span>
<span class="comments">;         96     Unit number of .DBF file</span>
<span class="comments">;         97     Unit number of .dbx file (0 if none exists)</span>
<span class="comments">;         98-99  Index number of item pointing to this file (0 for first db)</span>
<span class="comments">;         100-103 Number of entries with space allocated</span>
<span class="comments">;         104    Update flag (0 open for read only, 1 open for update)</span>
<span class="comments">;         105-108  record length of DBF file (integer*4) </span>
<span class="comments">;         118    Equals 1 if database can store records larger than 32767 bytes</span>
<span class="comments">;         119    Equals 1 if external data representation (IEEE) is used</span>
<span class="comments">;</span>
<span class="comments">;  QITEMS(*,i) contains decription of item number i with following</span>
<span class="comments">;  byte assignments:</span>
<span class="comments">;</span>
<span class="comments">;       0-19    item name (character*20)</span>
<span class="comments">;       20-21   IDL data type (integet*2)</span>
<span class="comments">;       22-23   Number of values for item (1 for scalar) (integer*2)</span>
<span class="comments">;       24-25   Starting byte position in original DBF record (integer*2)</span>
<span class="comments">;       26-27   Number of bytes per data value (integer*2)</span>
<span class="comments">;       28      Index type</span>
<span class="comments">;       29-97   Item description</span>
<span class="comments">;       98-99   Print field length</span>
<span class="comments">;       100     Flag set to one if pointer item</span>
<span class="comments">;       101-119 Data base this item points to</span>
<span class="comments">;       120-125 Print format</span>
<span class="comments">;       126-170 Print headers</span>
<span class="comments">;       171-172 Starting byte in record returned by DBRD, old DB format</span>
<span class="comments">;       173-174 Data base number in QDB</span>
<span class="comments">;       175-176 Data base number this item points to</span>
<span class="comments">;       177-178 Item number within the specific data base</span>
<span class="comments">;       179-182 Number of values for item (1 for scalar) (integer*4)</span>
<span class="comments">;       183-186 Starting byte position in original DBF record (integer*4)</span>
<span class="comments">;       187-190 Starting byte in record returned by DBRD</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; QLINK(i) contains the entry number in the second data base</span>
<span class="comments">;       corresponding to entry i in the first data base.</span>
<span class="comments">;-------------------------------------------------------------------------</span>
if n_elements(items) eq 0 then items = ''
<span class="comments">;</span>
<span class="comments">; check if data base open</span>
<span class="comments">;</span>
if n_elements(qdb) lt 120 then begin
        message = 'data base file not open'
        goto, handle_error
endif

<span class="comments">;</span>
<span class="comments">; determine type of item list -------------------------------------------</span>
<span class="comments">;</span>
vector=1                                        <span class="comments">;vector output flag</span>
newdb = qdb[118,0] EQ 1
s=size(items,/str)
ndim = s.n_dimensions
if s.type_name eq 'STRING' then begin                     <span class="comments">;string(s)</span>
        if ndim eq 0 then begin                         <span class="comments">;string scalar?</span>
            if strtrim(items) eq '' then form=5 else $  <span class="comments">;null string   - form 5</span>
            if strmid(items,0,1) eq '$' then form=3  $  <span class="comments">;filename      - form 3</span>
                else form=1                             <span class="comments">;scalar list   - form 1</span>
            if strtrim(items) eq '*' then form=6        <span class="comments">;all items '*' - form 6</span>
         end else form=2                                <span class="comments">;string vector - form 2</span>
   end else begin                                       <span class="comments">;non-string</span>
        form=4                                          <span class="comments">;integer       - form 4</span>
end
s=size(qitems)
if s[0] ne 2 then begin
        message = 'No data base opened'
        goto, handle_error
endif
qnumit=s[2]

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">;       CONVERT INPUT ITEMS TO INTEGER LIST OR STRING LIST</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; Form 4 ------------------ Integer</span>
<span class="comments">;</span>
If form eq 4 then begin
        if ndim eq 0 then begin
                itnum=intarr(1)+items
                ivalnum=intarr(1)
                ivalflag=intarr(1)
                goto,scalar                     <span class="comments">;speedy method</span>
            end else begin
                itnum=items
                nitems=n_elements(itnum)
                ivalflag=bytarr(nitems)
                ivalnum=intarr(nitems)
                if (min(itnum) lt 0) or (max(itnum) ge qnumit) then begin
                        message = 'Invalid item number specified'
                        goto, handle_error
                endif
                goto,vector
        end
end

<span class="comments">;</span>
<span class="comments">; Form 3 ----------------- File name</span>
<span class="comments">;</span>
if form eq 3 then begin
        item_names=strarr(200)          <span class="comments">;input buffer</span>
        if strlen(items) gt 1 then filename=strmid(items,1,strlen(items)-1) $
                               else filename=strtrim(db_info('name',0))+'.items'
        if ~file_test(filename) then begin
            message = 'Unable to locate file ' + FILE_EXPAND_PATH(filename) +  $
                    ' with item list'
            goto, handle_error
        endif
 	nlines = file_lines(filename)
        item_names = strarr(nlines)
        openr,unit,filename,/get_lun    <span class="comments">;open file</span>
        readf,unit,item_names
	free_lun,unit
	item_names = strtrim(item_names,2) 
<span class="comments">; Remove any blank lines 	</span>
	good = where(strlen(item_names) GT 0, Nitems) 
	if Nitems LT Nlines then item_names = item_names[good]	
end
<span class="comments">;</span>
<span class="comments">; form 1 ----------------- scalar string list  'item1,item2,item3...'</span>
<span class="comments">;</span>
 if form eq 1 then begin
     item_names = strsplit(items,',',/EXTRACT) 
     nitems = N_elements(item_names)                     
 endif
<span class="comments">;</span>
<span class="comments">; form 2 -------------------------- string array</span>
<span class="comments">;</span>
if form eq 2 then begin
        item_names=items
        nitems = N_elements(items)
endif
<span class="comments">;</span>
<span class="comments">; form 5 -------------------------- null string (interactive input)</span>
<span class="comments">;</span>
if form eq 5 then begin
        names=strtrim(qitems[0:19,*],2)
        desc=string(qitems[29:78,*])
        select_w,names,itnum,desc,'Select List of Items',count=count
        if count le 0 then begin
                message = 'No items selected'
                goto, handle_error
        endif
<span class="comments">;</span>
        nitems=n_elements(itnum)
        items = strtrim(names[itnum[0]],2)
        if nitems gt 1 then for i=1,nitems-1 do $
                  items = items +','+strtrim(names[itnum[i]],2)
        ivalflag=bytarr(nitems)
        ivalnum=intarr(nitems)   
        goto,vector
end
<span class="comments">;</span>
<span class="comments">; Form 4 ------------------ '*'  select all items</span>
<span class="comments">;</span>
If form eq 6 then begin
        nitems=db_info('items')         <span class="comments">;number of items</span>
        itnum=indgen(nitems)
        ivalflag=bytarr(nitems)
        ivalnum=intarr(nitems)
        goto,vector
end
<span class="comments">;</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;   CONVERT STRING LIST TO INTEGER LIST AND PULL OFF SUBSCRIPT IF SUPPLIED</span>
<span class="comments">;</span>
<span class="comments">;</span>
        names=strtrim(qitems[0:19,*],2) <span class="comments">;all possible item names</span>
        ivalnum=intarr(nitems)          <span class="comments">;selection of multi-value items</span>
        ivalflag=bytarr(nitems)         <span class="comments">;Flag for subscripted items</span>
        itnum=intarr(nitems)            <span class="comments">;integer item numbers</span>
<span class="comments">;</span>
<span class="comments">; loop on item names supplied</span>
<span class="comments">;</span>
        for i=0,nitems-1 do begin       <span class="comments">;loop on items</span>
            st=strtrim(item_names[i],2)         <span class="comments">;get item</span>
            name=gettok(st,'(')         <span class="comments">;get name</span>
<span class="comments">;</span>
<span class="comments">;     subscript supplied</span>
<span class="comments">;</span>
            if st ne '' then begin      <span class="comments">;number supplied?</span>
                ivalnum[i]=fix(gettok(st,')'))  <span class="comments">;get number</span>
                ivalflag[i]=1
            end<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;     data base name supplied</span>
<span class="comments">;</span>
            if strpos(name,'.') ge 0 then begin <span class="comments">;data base name supplied</span>
                dbname=gettok(name,'.')         <span class="comments">;  form is 'dbname.itemname'</span>
                i1=db_info('item1',dbname)      <span class="comments">;first item for the db</span>
                i2=db_info('item2',dbname)      <span class="comments">;last item for the db</span>
             end else begin                     <span class="comments">;search all items</span>
                i1=0 & i2=qnumit-1
            end
<span class="comments">;</span>
<span class="comments">;    search for item name</span>
<span class="comments">;</span>
            name=strupcase(name)                <span class="comments">;convert to upper case</span>
            j = where(names[i1:i2] eq name,nmatch)
            if nmatch eq 0 then begin
                    message = 'Item '+ name +' is invalid'
                    goto, handle_error
            endif
itnum[i] =j[0] +i1                              <span class="comments">;save item number</span>
endfor<span class="comments">;i loop on items</span>
if nitems eq 1 then goto,scalar                 <span class="comments">;speedy method</span>

<span class="comments">;</span>
<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;  We now have</span>
<span class="comments">;       1) integer list of item numbers of length nitems</span>
<span class="comments">;       2) we have list of ivalnum (subscripts) with</span>
<span class="comments">;               flag(s) ivalflag if subscript supplied</span>
<span class="comments">; EXTRACT OTHER PARAMETERS</span>
<span class="comments">;</span>

vector:                                         <span class="comments">;---- vector processing</span>
 idltype = fix(qitems[20:21,*],0,qnumit)
 numvals = newdb ? long(qitems[179:182,*],0,qnumit) : $
                  fix(qitems[22:23,*],0,qnumit)
 sbyte =  newdb ? long(qitems[187:190,*],0,qnumit) : $
                  fix(qitems[171:172,*],0,qnumit)
 nbytes = fix(qitems[26:27,*],0,qnumit)
 idltype = idltype[itnum]
 numvals = numvals[itnum]
 sbyte = sbyte[itnum]
 nbytes = nbytes[itnum]
<span class="comments">;</span>
<span class="comments">; add offset for subscripted variables</span>
<span class="comments">;</span>
sbyte=sbyte+ivalnum*nbytes
<span class="comments">;</span>
<span class="comments">; if ivalflag is set we have subscripted item and don't want all</span>
<span class="comments">;  values in vector</span>
<span class="comments">;</span>
pos=where(ivalflag, Npos)
if Npos GT 0 then numvals[pos]=1
return
<span class="comments">;</span>
<span class="comments">; -----------------------</span>
scalar:                                         <span class="comments">;------- scalar processing</span>
it=itnum[0]
if (it lt 0) or (it ge qnumit) then begin
        message = 'Invalid item number '+strtrim(it,2)+' specified'
        goto, handle_error
endif
<span class="comments">;</span>
idltype = fix(qitems[20:21,it],0,1)
numvals = newdb ? long(qitems[179:182,it],0,1) : $
                  fix(qitems[22:23,it],0,1)
sbyte = newdb ? long(qitems[187:190,it],0,1) : $
             fix(qitems[171:172,it],0,1)
nbytes = fix(qitems[26:27,it],0,1)
sbyte = sbyte+nbytes*ivalnum
if ivalflag[0] then numvals[0]=1
return
<span class="comments">;</span>
<span class="comments">;  Error handling point.</span>
<span class="comments">;</span>
HANDLE_ERROR:
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = 'DB_ITEM: ' + MESSAGE $
                ELSE MESSAGE, MESSAGE
end
</code>
    </div>
  </body>
</html>