<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:43 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jplephinterp.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jplephinterp.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   JPLEPHINTERP</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;   UPDATED VERSIONs can be found on my WEB PAGE: </span>
<span class="comments">;      http://cow.physics.wisc.edu/~craigm/idl/idl.html</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Interpolate position and motion of planetary bodies (JPL Ephemeris)</span>
<span class="comments">;</span>
<span class="comments">; MAJOR TOPICS:</span>
<span class="comments">;   Planetary Orbits, Interpolation</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   JPLEPHINTERP, INFO, RAWDATA, T, X, Y, Z, [VX, VY, VZ, /EARTH, /SUN,</span>
<span class="comments">;         OBJECTNAME=, CENTER=, TBASE=, POSUNITS=, VELUNITS= ]</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;   JPLEPHINTERP interpolates the JPL DE200 or DE405 planetary</span>
<span class="comments">;   ephemeris to find the positions and motions of planetary bodies.</span>
<span class="comments">;</span>
<span class="comments">;   This routine is the second stage of a two-stage process to</span>
<span class="comments">;   interpolate the JPL ephemeris.  In this first stage, the file is</span>
<span class="comments">;   opened using JPLEPHREAD, and the relevant portions of the table</span>
<span class="comments">;   are read and stored into the two variables INFO and RAWDATA.  In</span>
<span class="comments">;   the second stage, the user actually interpolates the ephemeris for</span>
<span class="comments">;   the desired bodies and to the desired ephemeris time using</span>
<span class="comments">;   JPLEPHINTERP.</span>
<span class="comments">;</span>
<span class="comments">;   The only independent variable which must be specified is T, the</span>
<span class="comments">;   ephemeris time.  For low to moderate accuracy applications, T is</span>
<span class="comments">;   simply the conventional calendar date, expressed in Julian days.</span>
<span class="comments">;   See below for high precision applications.</span>
<span class="comments">;</span>
<span class="comments">;   Upon output, the position components of the desired body are</span>
<span class="comments">;   returned in parameters X, Y and Z, and if requested velocity</span>
<span class="comments">;   components are returned in parameters VX, VY and VZ.  Coordinates</span>
<span class="comments">;   are referred to the ephemeris's coordinate system: FK5 for</span>
<span class="comments">;   JPL-DE200 and ICRS for JPL-DE405.  By default, the origin of</span>
<span class="comments">;   coordinates is the solar system barycenter (SSB), unless another</span>
<span class="comments">;   origin is selected using the CENTER keyword.</span>
<span class="comments">;</span>
<span class="comments">;   Users must set the VELOCITY keyword to generate body velocities.</span>
<span class="comments">;   By default they are not generated.</span>
<span class="comments">;</span>
<span class="comments">;   Users can select the desired body by using either the EARTH or SUN</span>
<span class="comments">;   keywords, or the OBJECTNAME keyword.</span>
<span class="comments">;</span>
<span class="comments">;   By default, positions are returned in units of KM and velocities</span>
<span class="comments">;   in units of KM/DAY.  However, the output units are selectable by</span>
<span class="comments">;   setting the POSUNITS and VELUNITS keywords.</span>
<span class="comments">;</span>
<span class="comments">; High Precision Applications</span>
<span class="comments">;</span>
<span class="comments">;   If the required precision is finer than a few hundred meters, the</span>
<span class="comments">;   user must be aware that the formal definition of the ephemeris</span>
<span class="comments">;   time is the coordinate time of a clock placed at the solar system</span>
<span class="comments">;   barycenter (SSB).  If the user's time is measured by a clock</span>
<span class="comments">;   positioned elsewhere, then various corrections must be applied.</span>
<span class="comments">;   Usually, the most significant correction is that from the</span>
<span class="comments">;   geocenter to the SSB (see Fairhead & Bretagnon 1990; Fukushima</span>
<span class="comments">;   1995).  Not applying this correction creates an error with</span>
<span class="comments">;   amplitude ~170 nano-light-seconds ( = 50 m) on the earth's</span>
<span class="comments">;   position.  (see TDB2TDT)</span>
<span class="comments">;</span>
<span class="comments">;   For high precision, the user should also specify the TBASE</span>
<span class="comments">;   keyword.  TBASE should be considered a fixed epoch with respect to</span>
<span class="comments">;   which T is measured; T should be small compared to TBASE.</span>
<span class="comments">;   Internally, subtraction of large numbers occurs with TBASE first,</span>
<span class="comments">;   so truncation error is minimized by specifying TBASE.</span>
<span class="comments">;</span>
<span class="comments">; Nutations and Librations</span>
<span class="comments">;</span>
<span class="comments">;   This routine also provides information about earth nutations and</span>
<span class="comments">;   lunar librations, which are stored in the JPL ephemeris tables.</span>
<span class="comments">;   The POSUNITS and VELUNITS keywords do not affect these</span>
<span class="comments">;   computations.</span>
<span class="comments">;</span>
<span class="comments">;   Lunar librations in the form of three Euler angles are returned in</span>
<span class="comments">;   X, Y, Z, in units of radians, and their time derivatives are</span>
<span class="comments">;   returned in VX, VY, and VZ in units of radians per day.</span>
<span class="comments">;</span>
<span class="comments">;   The earth nutation angles psi (nutation in longitude) and epsilon</span>
<span class="comments">;   (nutation in obliquity) are returned in X and Y, in units of</span>
<span class="comments">;   radians.  Their time derivatives are returned in VX and VY</span>
<span class="comments">;   respectively.  The quantities returned in Z and VZ are undefined.</span>
<span class="comments">;</span>
<span class="comments">; Verification</span>
<span class="comments">;</span>
<span class="comments">;   The precision routine has been verified using JPLEPHTEST, which is</span>
<span class="comments">;   similar to the original JPL program EPHTEST.  For years 1950 to</span>
<span class="comments">;   2050, JPLEPHINTERP reproduces the original JPL ephemeris to within</span>
<span class="comments">;   1 centimeter.</span>
<span class="comments">;</span>
<span class="comments">; Custom Ephemerides</span>
<span class="comments">;</span>
<span class="comments">;   It is possible to make custom ephemerides using JPLEPHMAKE, or to</span>
<span class="comments">;   augmented an existing ephemeris with additional data.  In the</span>
<span class="comments">;   former case JPLEPHINTERP should automatically choose the correct</span>
<span class="comments">;   object from the table and interpolate it appropriately.</span>
<span class="comments">;</span>
<span class="comments">;   For augmented ephemerides, the object can be specified by name,</span>
<span class="comments">;   which works as expected, or by number, which has a special</span>
<span class="comments">;   behavior.  For augmented files only, the new objects begin at</span>
<span class="comments">;   number 100.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PARAMETERS: </span>
<span class="comments">;</span>
<span class="comments">;   INFO - structure returned by JPLEPHREAD.  Users should not modify</span>
<span class="comments">;          this structure.</span>
<span class="comments">;</span>
<span class="comments">;   RAWDATA - raw data array returned by JPLEPHREAD.  Users should not</span>
<span class="comments">;             modify this data array.</span>
<span class="comments">;</span>
<span class="comments">;   T - ephemeris time(s) of interest, relative to TBASE (i.e. the</span>
<span class="comments">;       actual interpolation time is (T+TBASE)).  May be a scalar or</span>
<span class="comments">;       vector.</span>
<span class="comments">;</span>
<span class="comments">;   X, Y, Z - upon return, the x-, y- and z-components of the body</span>
<span class="comments">;             position are returned in these parameters.  For</span>
<span class="comments">;             nutations and librations see above.</span>
<span class="comments">;</span>
<span class="comments">;   VX, VY, VZ - upon return, the x-, y- and z-components of the body</span>
<span class="comments">;                velocity are returned in these parameters, if the</span>
<span class="comments">;                VELOCITY keyword is set.  For nutations and</span>
<span class="comments">;                librations see above.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   EARTH, SUN - set one of these keywords if the desired body is the</span>
<span class="comments">;                earth or the sun.  One of EARTH, SUN or OBJECTNAME</span>
<span class="comments">;                must be specified.</span>
<span class="comments">;</span>
<span class="comments">;   OBJECTNAME - a scalar string or integer, specifies the planetary</span>
<span class="comments">;                body of interest.  May take any one of the following</span>
<span class="comments">;                integer or string values.</span>
<span class="comments">;</span>
<span class="comments">;                   1 - 'MERCURY'     9 - 'PLUTO'</span>
<span class="comments">;                   2 - 'VENUS'      10 - 'MOON'  (earth's moon)</span>
<span class="comments">;                   3 - 'EARTH'      11 - 'SUN'</span>
<span class="comments">;                   4 - 'MARS'       12 - 'SOLARBARY' or 'SSB' (solar system barycenter)</span>
<span class="comments">;                   5 - 'JUPITER'    13 - 'EARTHBARY' or 'EMB' (earth-moon barycenter)</span>
<span class="comments">;                   6 - 'SATURN'     14 - 'NUTATIONS' (see above)</span>
<span class="comments">;                   7 - 'URANUS'     15 - 'LIBRATIONS' (see above)</span>
<span class="comments">;                   8 - 'NEPTUNE' </span>
<span class="comments">;</span>
<span class="comments">;                For custom ephemerides, the user should specify the</span>
<span class="comments">;                object name or number.</span>
<span class="comments">;</span>
<span class="comments">;                For augmented ephemerides, the user should specify</span>
<span class="comments">;                the name.  If the number is specified, then numbers</span>
<span class="comments">;                1-15 have the above meanings, and new objects are</span>
<span class="comments">;                numbered starting at 100.</span>
<span class="comments">;</span>
<span class="comments">;   CENTER - a scalar string or integer, specifies the origin of</span>
<span class="comments">;            coordinates.  See OBJECTNAME for allowed values.</span>
<span class="comments">;            Default: 12 (Solar system barycenter)</span>
<span class="comments">;</span>
<span class="comments">;   VELOCITY - if set, body velocities are generated and returned in</span>
<span class="comments">;              VX, VY and VZ.</span>
<span class="comments">;              Default: unset (no velocities)</span>
<span class="comments">;</span>
<span class="comments">;   POSUNITS - a scalar string specifying the desired units for X, Y,</span>
<span class="comments">;              and Z.  Allowed values:</span>
<span class="comments">;                 'KM' - kilometers  (default)</span>
<span class="comments">;                 'CM' - centimeters</span>
<span class="comments">;                 'AU' - astronomical units</span>
<span class="comments">;                 'LT-S' - light seconds</span>
<span class="comments">;               If angles are requested, this keyword is ignored and</span>
<span class="comments">;               the units are always 'RADIANS'.</span>
<span class="comments">;</span>
<span class="comments">;   VELUNITS - a scalar string specifying the desired units for VX, VY</span>
<span class="comments">;              and VZ.  Allowed values:</span>
<span class="comments">;                 'KM/DAY' - kilometers per day  (default)</span>
<span class="comments">;                 'KM/S' - kilometers per second</span>
<span class="comments">;                 'CM/S' - centimeters per second</span>
<span class="comments">;                 'LT-S/S' - light seconds per second</span>
<span class="comments">;                 'AU/DAY' - astronomical units per day</span>
<span class="comments">;</span>
<span class="comments">;   TBASE - a scalar or vector, specifies a fixed epoch against wich T</span>
<span class="comments">;           is measured.  The ephemeris time will be (T+TBASE).  Use</span>
<span class="comments">;           this keyword for maximum precision.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   Find position of earth at ephemeris time 2451544.5 JD.  Units are</span>
<span class="comments">;   in Astronomical Units.</span>
<span class="comments">;</span>
<span class="comments">;   JPLEPHREAD, 'JPLEPH.200', pinfo, pdata, [2451544D, 2451545D]</span>
<span class="comments">;</span>
<span class="comments">;   JPLEPHINTERP, pinfo, pdata, 2451544.5D, xearth, yearth, zearth, $</span>
<span class="comments">;                 /EARTH, posunits='AU'</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">; REFERENCES:</span>
<span class="comments">;</span>
<span class="comments">;   AXBARY, Arnold Rots.</span>
<span class="comments">;      ftp://heasarc.gsfc.nasa.gov/xte/calib_data/clock/bary/</span>
<span class="comments">;</span>
<span class="comments">;   HORIZONS, JPL Web-based ephermis calculator (Ephemeris DE406)</span>
<span class="comments">;      http://ssd.jpl.nasa.gov/horizons.html</span>
<span class="comments">;   </span>
<span class="comments">;   Fairhead, L. & Bretagnon, P. 1990, A&A, 229, 240</span>
<span class="comments">;</span>
<span class="comments">;   Fukushima, T. 1995, A&A, 294, 895</span>
<span class="comments">;</span>
<span class="comments">;   Standish, E.M. 1982, "Orientation of the JPL Ephemerides,</span>
<span class="comments">;      DE200/LE200, to the Dynamical Equinox of J2000", Astronomy &</span>
<span class="comments">;      Astrophysics, vol. 114, pp. 297-302.</span>
<span class="comments">;</span>
<span class="comments">;   Standish, E.M.: 1990, "The Observational Basis for JPL's DE200,</span>
<span class="comments">;      the planetary ephemeris of the Astronomical Almanac", Astronomy</span>
<span class="comments">;      & Astrophysics, vol. 233, pp. 252-271.    </span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO</span>
<span class="comments">;   JPLEPHREAD, JPLEPHINTERP, JPLEPHTEST, TDB2TDT, JPLEPHMAKE</span>
<span class="comments">;   </span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written and Documented, CM, Jun 2001</span>
<span class="comments">;   Corrected bug in name conversion of NUTATIONS and LIBRATIONS, 18</span>
<span class="comments">;     Oct 2001, CM</span>
<span class="comments">;   Added code to handle custom-built ephemerides, 04 Mar 2002, CM</span>
<span class="comments">;   Fix bug in evaluation of velocity (only appears in highest order</span>
<span class="comments">;     polynomial term); JPLEPHTEST verification tests still pass;</span>
<span class="comments">;     change is of order &lt; 0.5 cm in position, 22 Nov 2004, CM</span>
<span class="comments">;   Perform more validity checking on inputs; and more informative</span>
<span class="comments">;     outputs, 09 Oct 2008, CM</span>
<span class="comments">;   Allow SSB and EMB as shortcuts for solar system and earth-moon</span>
<span class="comments">;     bary center, 15 Oct 2008, CM</span>
<span class="comments">;   TBASE now allowed to be a vector or scalar, 01 Jan 2009, CM</span>
<span class="comments">;   VELFAC keyword gives scale factor between POSUNITS and VELUNITS, </span>
<span class="comments">;     12 Jan 2009, CM</span>
<span class="comments">;</span>
<span class="comments">;  $Id: jplephinterp.pro,v 1.18 2009/01/13 04:53:26 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2001, 2002, 2004, 2008, 2009, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy and distribute unmodified copies for</span>
<span class="comments">; non-commercial purposes, and to modify and use for personal or</span>
<span class="comments">; internal use, is granted.  All other rights are reserved.</span>
<span class="comments">;-</span>

<a id="jplephinterp_calc:source"></a>pro jplephinterp_calc, info, raw, obj, t, x, y, z, vx, vy, vz, $
                       velocity=vel, tbase=tbase

  <span class="comments">; '$Id: jplephinterp.pro,v 1.18 2009/01/13 04:53:26 craigm Exp $'</span>

  if n_elements(tbase) EQ 0 then tbase = 0D
  <span class="comments">;; Number of coefficients (x3), number of subintervals, num of rows</span>
  nc = info.ncoeff[obj]
  ns = info.nsub[obj]
  dt = info.timedel
  nr = info.jdrows
  jd0 = info.jdlimits[0] - tbase
  jd1 = info.jdlimits[1] - tbase

  <span class="comments">;; Extract coefficient data from RAW</span>
  if obj EQ 11 then begin
      <span class="comments">;; Nutations have two components</span>
      ii1 = info.ptr[obj]-1
      ii2 = ii1 + nc*ns*2L - 1
      coeffs = reform(dblarr(nc,3,ns,nr), nc,3,ns,nr, /overwrite)
      coeffs[0,0,0,0] = reform(raw[ii1:ii2,*],nc,2,ns,nr, /overwrite)
  endif else begin
      <span class="comments">;; All other bodies are done with three components</span>
      ii1 = info.ptr[obj]-1
      ii2 = ii1 + nc*ns*3L - 1
      coeffs = reform(raw[ii1:ii2,*],nc,3,ns,nr, /overwrite)
  endelse

  <span class="comments">;; Decide which interval and subinterval we are in</span>
  tint = (t-jd0)/dt        <span class="comments">;; Interval number (real)</span>
  ieph = floor(tint)       <span class="comments">;; Interval number (index = int)</span>
  tint = (tint-ieph)*ns    <span class="comments">;; Subinterval number (real)</span>
  nseg = floor(tint)       <span class="comments">;; Subinterval number (index = int)</span>
  <span class="comments">;; Chebyshev "x" (rescaled to range = [-1,1] over subinterval)</span>
  tseg = 2D*(tint - nseg) - 1  

  <span class="comments">;; Below is an optimization.  If the time interval doesn't span an</span>
  <span class="comments">;; ephemeris subinterval, then we can index the coefficient array by</span>
  <span class="comments">;; a scalar, which is much faster.  Otherwise we maintain the full</span>
  <span class="comments">;; vector-level indexing.</span>
  mini = minmax(ieph) & minn = minmax(nseg)
  if mini[0] EQ mini[1] AND minn[0] EQ minn[1] then begin
      ieph = ieph[0]
      nseg = nseg[0]
  endif

  <span class="comments">;; Initialize the first two Chebyshev polynomials, which are P_0 = 1</span>
  <span class="comments">;; and P_1(x) = x</span>
  p0 = 1D
  p1 = tseg
  <span class="comments">;; Initial polynomials for Chebyshev derivatives, V_0 = 0, V_1(x) =</span>
  <span class="comments">;; 1, V_2(x) = 4*x</span>
  v0 = 0D
  v1 = 1D
  v2 = 4D*tseg
  tt = 2D*temporary(tseg)

  x  = 0D & y  = 0D & z  = 0D
  vx = 0D & vy = 0D & vz = 0D
  i0 = ieph*0 & i1 = i0 + 1 & i2 = i1 + 1

  <span class="comments">;; Compute Chebyshev functions two at a time for efficiency</span>
  for i = 0, nc-1, 2 do begin
      if i EQ nc-1 then begin
          p1 = 0
          v1 = 0
      endif
      ii = i0 + i
      jj = i0 + ((i+1) &lt<span class="comments">; (nc-1))</span>
      
      x = x + coeffs[ii,i0,nseg,ieph]*p0 + coeffs[jj,i0,nseg,ieph]*p1
      y = y + coeffs[ii,i1,nseg,ieph]*p0 + coeffs[jj,i1,nseg,ieph]*p1
      z = z + coeffs[ii,i2,nseg,ieph]*p0 + coeffs[jj,i2,nseg,ieph]*p1

      if keyword_set(vel) then begin
          vx = vx + coeffs[ii,i0,nseg,ieph]*v0 + coeffs[jj,i0,nseg,ieph]*v1
          vy = vy + coeffs[ii,i1,nseg,ieph]*v0 + coeffs[jj,i1,nseg,ieph]*v1
          vz = vz + coeffs[ii,i2,nseg,ieph]*v0 + coeffs[jj,i2,nseg,ieph]*v1

          <span class="comments">;; Advance to the next set of Chebyshev polynomials. For</span>
          <span class="comments">;; velocity we need to keep the next orders around</span>
          <span class="comments">;; momentarily.</span>
          p2 = tt*p1 - p0
          p3 = tt*p2 - p1
          v2 = tt*v1 - v0 + 2*p1
          v3 = tt*v2 - v1 + 2*p2
          
          p0 = temporary(p2) & p1 = temporary(p3)
          v0 = temporary(v2) & v1 = temporary(v3)
      endif else begin
          <span class="comments">;; Advance to the next set of Chebyshev polynomials.  For no</span>
          <span class="comments">;; velocity, we can re-use old variables.</span>
          p0 = tt*p1 - temporary(p0)
          p1 = tt*p0 - temporary(p1)
      endelse
  endfor

  if keyword_set(vel) then begin
      vfac = 2D*ns/dt
      vx = vx * vfac
      vy = vy * vfac
      vz = vz * vfac
  endif

  return
end

<a id="jplephinterp_denew:source"></a>pro jplephinterp_denew, info, raw, obj, t, x, y, z, vx, vy, vz, $
                        velocity=vel, tbase=tbase

  if n_elements(tbase) EQ 0 then tbase = 0D
  dt = info.timedel
  nr = info.jdrows
  jd0 = info.jdlimits[0]
  jd1 = info.jdlimits[1]
  c = info.c / 1000D
  cday = 86400D*info.c/1000D

  <span class="comments">;; Renormalize to fractional and whole days, so fractional</span>
  <span class="comments">;; component is between -.5 and +.5, as needed by barycentering</span>
  <span class="comments">;; approximation code.</span>
  ti  = round(t)      <span class="comments">;; Delta Time: integer</span>
  tbi = round(tbase)  <span class="comments">;; Base: integer</span>
  
  tc = ti + tbi             <span class="comments">;; Total time: integer</span>
  tt = (t-ti) + (tbase-tbi) <span class="comments">;; Total time: fractional</span>

  tc = tc + round(tt)       <span class="comments">;; Re-round: integer</span>
  tt = tt - round(tt)       <span class="comments">;; Re-round: fractional</span>
  t2 = tt*tt                <span class="comments">;; Quadratic and cubic terms</span>
  t3 = t2*tt

  ieph = tc - round(jd0)
  <span class="comments">;; Below is an optimization.  If the time interval doesn't span an</span>
  <span class="comments">;; ephemeris subinterval, then we can index the coefficient array by</span>
  <span class="comments">;; a scalar, which is much faster.  Otherwise we maintain the full</span>
  <span class="comments">;; vector-level indexing.</span>
  mini = minmax(ieph)
  if mini[0] EQ mini[1] then ieph = ieph[0]

  if obj EQ 3 then begin
      <span class="comments">;; Earth, stored as Taylor series coefficients per day</span>
      x = (raw[0,ieph] + raw[3,ieph]*tt + 0.5D*raw[6,ieph]*t2 + $
           (raw[9,ieph]/6D)*t3)
      y = (raw[1,ieph] + raw[4,ieph]*tt + 0.5D*raw[7,ieph]*t2 + $
           (raw[10,ieph]/6D)*t3)
      z = (raw[2,ieph] + raw[5,ieph]*tt + 0.5D*raw[8,ieph]*t2 + $
           (raw[11,ieph]/6D)*t3)
      if keyword_set(vel) then begin
          vx = raw[3,ieph] + raw[6,ieph]*tt + 0.5D*raw[9 ,ieph]*t2
          vy = raw[4,ieph] + raw[7,ieph]*tt + 0.5D*raw[10,ieph]*t2
          vz = raw[5,ieph] + raw[8,ieph]*tt + 0.5D*raw[11,ieph]*t2
      endif
      x = reform(x, /overwrite)
      y = reform(y, /overwrite)
      z = reform(z, /overwrite)
 
  endif else if obj EQ 11 then begin
      <span class="comments">;; Sun, stored as daily components only</span>
      
      x = reform(raw[12,ieph] + tt*0)
      y = reform(raw[13,ieph] + tt*0)
      z = reform(raw[14,ieph] + tt*0)
      if keyword_set(vel) then $
        message, 'ERROR: DENEW format does not provide solar velocity'

  endif else if obj EQ 1000 then begin

      tt = t - (jd0+jd1)/2D
      x = spl_interp(raw[15,*], raw[16,*], raw[17,*], tt)
      return
      
  endif else begin
      message, 'ERROR: DENEW format does not contain body '+strtrim(obj,2)
  endelse
end

<a id="jplephinterp:source"></a>pro jplephinterp, info, raw, t, x, y, z, vx, vy, vz, earth=earth, sun=sun, $
                  objectname=obj0, velocity=vel, center=cent, tbase=tbase, $
                  posunits=outunit0, velunits=velunit0, $
                  pos_vel_factor=velfac, $
                  xobjnum=objnum, decode_obj=decode

  if n_params() EQ 0 then begin
      message, 'USAGE: JPLEPHINTERP, info, rawdata, teph, x, y, z, '+$
        'vx, vy, vz, OBJECTNAME="body", /VELOCITY, CENTER="body", '+$
        'POSUNITS="units", VELUNITS="units", /EARTH, /SUN', /info
      return
  endif
  
  <span class="comments">;; The numbering convention for ntarg and ncent is:</span>
  <span class="comments">;;   1 = Mercury            8 = Neptune</span>
  <span class="comments">;;   2 = Venus              9 = Pluto</span>
  <span class="comments">;;   3 = Earth             10 = Moon</span>
  <span class="comments">;;   4 = Mars              11 = Sun</span>
  <span class="comments">;;   5 = Jupiter           12 = Solar system barycenter</span>
  <span class="comments">;;   6 = Saturn            13 = Earth-Moon barycenter</span>
  <span class="comments">;;   7 = Uranus            14 = Nutations (longitude and obliquity; untested)</span>
  <span class="comments">;;                         15 = Librations </span>
  <span class="comments">;; This numbering scheme is 1-relative, to be consistent with the</span>
  <span class="comments">;; Fortran version.  (units are seconds; derivative units are seconds/day)</span>
  <span class="comments">;;1000 = TDB to TDT offset (s), returned in X component</span>

  sz = size(info)
  if sz[sz[0]+1] NE 8 then message, 'ERROR: INFO must be a structure'
  if ((info.format NE 'JPLEPHMAKE') AND $
      (info.format NE 'BINEPH2FITS') AND $
      (info.format NE 'DENEW')) then begin
      message, 'ERROR: ephemeris type "'+info.format+'" is not recognized'
  endif

  <span class="comments">;; Handle case of custom ephemerides</span>
  if info.format EQ 'JPLEPHMAKE' then begin
      if n_elements(obj0) GT 0 then begin
          sz = size(obj0)
          if sz[sz[0]+1] EQ 7 then begin
              obj = strupcase(strtrim(obj0[0],2))
              wh = where(info.objname EQ obj, ct)
              if ct EQ 0 then $
                message, 'ERROR: '+obj+' is an unknown object'
              obj = wh[0] + 1
          endif else begin
              obj = floor(obj0[0])
              if obj LT 1 OR obj GT n_elements(info.objname) then $
                message, 'ERROR: Numerical OBJNAME is out of bounds'
          endelse

          <span class="comments">;; Interpolate the ephemeris here</span>
          jplephinterp_calc, info, raw, obj-1, t, velocity=vel, $
            tbase=tbase, x, y, z, vx, vy, vz

          goto, COMPUTE_CENTER
      endif
      message, 'ERROR: Must specify OBJNAME for custom ephemerides'
  endif


  <span class="comments">;; ----------------------------------------------------------</span>
  <span class="comments">;; Determine which body or system we will compute</span>
  if n_elements(obj0) GT 0 then begin
      sz = size(obj0)
      if sz[sz[0]+1] EQ 7 then begin
          obj = strupcase(strtrim(obj0[0],2))
          case obj of 
              'EARTH':      obj = 3
              'SOLARBARY':  obj = 12
              'SSB':        obj = 12
              'EARTHBARY':  obj = 13
              'EMB':        obj = 13
              'NUTATIONS':  obj = 14
              'LIBRATIONS': obj = 15
              'TDB2TDT':    obj = 1000
              ELSE: begin
                  wh = where(info.objname EQ obj, ct)
                  if ct EQ 0 then $
                    message, 'ERROR: '+obj+' is an unknown object'
                  obj = wh[0] + 1
                  if obj GT 11 then obj = obj + 100 - 14
              end
          endcase
      endif else begin
          obj = floor(obj0[0])
      endelse
  endif else begin
      if NOT keyword_set(earth) AND NOT keyword_set(sun) then $
        message, 'ERROR: Must specify OBJNAME, EARTH or SUN'
  endelse
  if keyword_set(earth) then obj = 3
  if keyword_set(sun)   then obj = 11

  <span class="comments">;; If the caller is merely asking us to decode the objectnumber,</span>
  <span class="comments">;; then return it now.</span>
  objnum = obj
  if keyword_set(decode) then return
  
  jdlimits = info.jdlimits

  <span class="comments">;; -------------------------------------------------------</span>
  <span class="comments">;; Handle case of de200_new.fits format</span>
  if info.format EQ 'DENEW' then begin
      if objnum NE 3 AND objnum NE 11 AND objnum NE 1000 then $
        message, 'ERROR: DENEW ephemeris table does not support body #'+$
        strtrim(objnum,2)
      
      jplephinterp_denew, info, raw, objnum, t, x, y, z, vx, vy, vz, $
        velocity=vel, tbase=tbase

      if objnum GE 1000 then return
      goto, DO_UNIT
  endif

  <span class="comments">;; -------------------------------------------------------</span>
  <span class="comments">;; Otherwise, construct the ephemeris using the Chebyshev expansion</span>
  case obj of
      3: begin <span class="comments">;; EARTH (translate from earth-moon barycenter to earth)</span>
          <span class="comments">;; Interpolate the earth-moon and moon ephemerides</span>
          jplephinterp_calc, info, raw, 2, velocity=vel, tbase=tbase, $
            t, xem, yem, zem, vxem, vyem, vzem
          jplephinterp_calc, info, raw, 9, velocity=vel, tbase=tbase, $
            t, xmo, ymo, zmo, vxmo, vymo, vzmo
          emrat = info.emrat
          
          <span class="comments">;; Translate from the earth-moon barycenter to earth</span>
          x = xem - emrat * xmo
          y = yem - emrat * ymo
          z = zem - emrat * zmo
          if keyword_set(vel) then begin
              vx = vxem - emrat * vxmo
              vy = vyem - emrat * vymo
              vz = vzem - emrat * vzmo
          endif
          
      end

      10: begin <span class="comments">;; MOON (translate from earth-moon barycenter to moon)</span>
          jplephinterp_calc, info, raw, 9, t, velocity=vel, tbase=tbase, $
            x, y, z, vx, vy, vz
          <span class="comments">;; Moon ephemeris is geocentered.  If the center is</span>
          <span class="comments">;; explicitly earth then return immediately.  Otherwise</span>
          <span class="comments">;; follow the standard path via the solar barycenter.</span>
          if n_elements(cent) GT 0 then begin
              jplephinterp, info, objectname=cent[0], tbase=tbase, $
                xobjnum=cent1, /decode_obj
              if cent1 EQ 3 then goto, DO_UNIT
          endif

          <span class="comments">;; Use solar barycenter via the earth-moon barycenter</span>
          jplephinterp_calc, info, raw, 2, t, velocity=vel, tbase=tbase, $
            xem, yem, zem, vxem, vyem, vzem
          emrat = 1d - info.emrat
          x = xem + emrat * x
          y = yem + emrat * y
          z = zem + emrat * z
          if keyword_set(vel) then begin
              vx = vxem + emrat * vx
              vy = vyem + emrat * vy
              vz = vzem + emrat * vz
          endif              
      end

      12: begin <span class="comments">;; SOLARBARY</span>
          x = t*0D & y = x & z = x
          vx = x   & vy = x & vz = x
      end

      13: begin <span class="comments">;; EARTHBARY</span>
          jplephinterp_calc, info, raw, 2, velocity=vel, tbase=tbase, $
            t, x, y, z, vx, vy, vz
      end
      
      14: begin <span class="comments">;; NUTATIONS</span>
          <span class="comments">;; X = PSI, Y = EPSILON, VX = PSI DOT, VY = EPSILON DOT </span>
          jplephinterp_calc, info, raw, 11, velocity=vel, tbase=tbase, $
            t, x, y, z, vx, vy, vz
          goto, CLEAN_RETURN
      end

      15: begin <span class="comments">;; LIBRATIONS</span>
          jplephinterp_calc, info, raw, 12, velocity=vel, tbase=tbase, $
            t, x, y, z, vx, vy, vz
          goto, CLEAN_RETURN
      end

      1000: begin <span class="comments">;; TDT to TDB conversion</span>
          x = tdb2tdt(t, deriv=vx, tbase=tbase)
          if n_elements(velunit0) GT 0 then begin
             <span class="comments">;; Special case of unit conversion when user asks for </span>
             <span class="comments">;; "per second"</span>
             if strpos(strupcase(velunit0[0]),'/S') GE 0 then $
                vx = vx / 86400d
          endif

          goto, CLEAN_RETURN
      end

      else: begin
          <span class="comments">;; Default objects are derived from the index OBJNUM</span>
          if obj GE 1 AND obj LE 11 then begin
              RESTART_OBJ:
              jplephinterp_calc, info, raw, obj-1, t, velocity=vel, $
                tbase=tbase, $
                x, y, z, vx, vy, vz
          endif else begin
              if info.edited AND obj GT 11 then begin
                  <span class="comments">;; Handle case of edited JPL ephemerides - they</span>
                  <span class="comments">;; start at a value of 100, so shift them to the end</span>
                  <span class="comments">;; of the JPL ephemeris columns</span>
                  obj = obj - 100 + 14
                  if obj LE n_elements(info.objname) then $
                    goto, RESTART_OBJ
              endif
              message, 'ERROR: body '+strtrim(obj,2)+' is not supported'
          endelse
      end
  endcase

  <span class="comments">;; -------------------------------------------------------</span>
  <span class="comments">;; Compute ephemeris of center, and compute displacement vector</span>
  COMPUTE_CENTER:
  if n_elements(cent) GT 0 then begin
      jplephinterp, info, raw, t, x0, y0, z0, vx0, vy0, vz0, tbase=tbase, $
        objectname=cent, velocity=vel, posunits='KM', velunits='KM/DAY'
      x = temporary(x) - temporary(x0)
      y = temporary(y) - temporary(y0)
      z = temporary(z) - temporary(z0)
      if keyword_set(vel) then begin
          vx = temporary(vx) - temporary(vx0)
          vy = temporary(vy) - temporary(vy0)
          vz = temporary(vz) - temporary(vz0)
      endif
  endif

  DO_UNIT:
  
  velfac = 1d

  <span class="comments">;; -------------------------------------------------------</span>
  <span class="comments">;; Convert positional units</span>
  if n_elements(outunit0) GT 0 then begin
      pu = strupcase(strtrim(outunit0[0],2))
      case pu of
          'KM': km = 1 <span class="comments">;; Dummy statement</span>
          'CM': begin
              x = x * 1D5
              y = y * 1D5
              z = z * 1D5
              velfac = velfac * 1D5
          end
          'AU': begin
              au = info.au*info.c/1000d
              x = x / au
              y = y / au
              z = z / au
              velfac = velfac / au
          end
          'LT-S': begin
              c = info.c / 1000d
              x = x / c
              y = y / c
              z = z / c
              velfac = velfac / c
          end
          ELSE: message, 'ERROR: Unrecognized position units "'+pu+'"'
      endcase
  endif

  <span class="comments">;; -------------------------------------------------------</span>
  <span class="comments">;; Convert velocity units</span>
  if n_elements(velunit0) GT 0 AND keyword_set(vel) then begin
      vu = strupcase(strtrim(velunit0[0],2))
      case vu of 
          'CM/S': begin
              vx = vx * (1D5/86400D)
              vy = vy * (1D5/86400D)
              vz = vz * (1D5/86400D)
              velfac = velfac / (1D5/86400D)
          end
          'KM/S': begin
              vx = vx * (1D/86400D)
              vy = vy * (1D/86400D)
              vz = vz * (1D/86400D)
              velfac = velfac / (1D/86400D)
          end
          'LT-S/S': begin
              c = info.c / 1000D
              vx = vx / (c*86400D)
              vy = vy / (c*86400D)
              vz = vz / (c*86400D)
              velfac = velfac / (c*86400D)
          end
          'KM/DAY': km = 1 <span class="comments">;; Dummy statement</span>
          'AU/DAY': begin
              au = info.au*info.c/1000d
              vx = vx / au
              vy = vy / au
              vz = vz / au
              velfac = velfac * au
          end
          ELSE: message, 'ERROR: Unrecognized velocity units "'+vu+'"'
      endcase
  endif

CLEAN_RETURN:  
  return
end
</code>
    </div>
  </body>
</html>