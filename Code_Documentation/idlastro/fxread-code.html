<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:37 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxread.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxread.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXREAD, FILENAME, DATA, HEADER, P1, P2, P3, P4, P5,     $
		NANVALUE=NANVALUE, PROMPT=PROMPT, AVERAGE=AVERAGE,	$
		YSTEP=Y_STEP, NOSCALE=NOSCALE, NOUPDATE=NOUPDATE,	$
		ERRMSG=ERRMSG, NODATA=NODATA, COMPRESS = COMPRESS,      $
		EXTENSION=EXTENSION0
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXREAD</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;	Read basic FITS files.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;	Read an image array from a disk FITS file.  Optionally allows the</span>
<span class="comments">;	user to read in only a subarray and/or every Nth pixel.</span>
<span class="comments">; Use         : </span>
<span class="comments">;	FXREAD, FILENAME, DATA  [, HEADER  [, I1, I2  [, J1, J2 ]]  [, STEP]]</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;	FILENAME = String containing the name of the file to be read.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	I1,I2	 = Data range to read in the first dimension.  If passed, then</span>
<span class="comments">;		   HEADER must also be passed.  If not passed, or set to -1,-1,</span>
<span class="comments">;		   then the entire range is read.</span>
<span class="comments">;	J1,J2	 = Data range to read in the second dimension.  If passed, then</span>
<span class="comments">;		   HEADER and I1,J2 must also be passed.  If not passed, or set</span>
<span class="comments">;		   to -1,-1, then the entire range is read.</span>
<span class="comments">;	STEP	 = Step size to use in reading the data.  If passed, then</span>
<span class="comments">;		   HEADER must also be passed.  Default value is 1.  Ignored if</span>
<span class="comments">;		   less than 1.</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	DATA	 = Data array to be read from the file.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	HEADER	 = String array containing the header for the FITS file.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;       /COMPRESS - If this keyword is set and non-zero, then then treat</span>
<span class="comments">;                the file as gzip compressed.    By default FXREAD assumes</span>
<span class="comments">;                the file is gzip compressed if it ends in ".gz"</span>
<span class="comments">;	NANVALUE = Value signalling data dropout.  All points corresponding to</span>
<span class="comments">;		   IEEE NaN (not-a-number) are set to this value.  Ignored</span>
<span class="comments">;		   unless DATA is of type float or double-precision.</span>
<span class="comments">;       EXTENSION = FITS extension.  It can be a scalar integer,</span>
<span class="comments">;                indicating the extension number (extension number 0</span>
<span class="comments">;                is the primary HDU).  It can also be a scalar string,</span>
<span class="comments">;                indicating the extension name (EXTNAME keyword).</span>
<span class="comments">;                Default: 0 (primary HDU)</span>
<span class="comments">;	PROMPT	 = If set, then the optional parameters are prompted for at the</span>
<span class="comments">;		   keyboard.</span>
<span class="comments">;	AVERAGE	 = If set, then the array size is reduced by averaging pixels</span>
<span class="comments">;		   together rather than by subselecting pixels.  Ignored unless</span>
<span class="comments">;		   STEP is nontrivial.  Note:  this is much slower.</span>
<span class="comments">;	YSTEP	 = If passed, then STEP is the step size in the 1st dimension,</span>
<span class="comments">;		   and YSTEP is the step size in the 2nd dimension.  Otherwise,</span>
<span class="comments">;		   STEP applies to both directions.</span>
<span class="comments">;	NOSCALE	 = If set, then the output data will not be scaled using the</span>
<span class="comments">;		   optional BSCALE and BZERO keywords in the FITS header.</span>
<span class="comments">;		   Default is to scale, if and only if BSCALE and BZERO are</span>
<span class="comments">;		   present and nontrivial.</span>
<span class="comments">;	NOUPDATE = If set, then the optional BSCALE and BZERO keywords in the</span>
<span class="comments">;		   optional HEADER array will not be changed.  The default is</span>
<span class="comments">;		   to reset these keywords to BSCALE=1, BZERO=0.  Ignored if</span>
<span class="comments">;		   NOSCALE is set.</span>
<span class="comments">;	ERRMSG   = If defined and passed, then any error messages will be</span>
<span class="comments">;		   returned to the user in this parameter rather than</span>
<span class="comments">;		   depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		   encountered, then a null string is returned.  In order to</span>
<span class="comments">;		   use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXREAD, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;       NODATA   = If set, then the array is not read in, but the</span>
<span class="comments">;                  primary header is read.</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	GET_DATE, IEEE_TO_HOST, FXADDPAR, FXHREAD, FXPAR, WHERENAN</span>
<span class="comments">; Common      : </span>
<span class="comments">;	None.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	Groups are not supported.</span>
<span class="comments">;</span>
<span class="comments">;	The optional parameters I1, I2, and STEP only work with one or</span>
<span class="comments">;	two-dimensional arrays.  J1 and J2 only work with two-dimensional</span>
<span class="comments">;	arrays.</span>
<span class="comments">;</span>
<span class="comments">;	Use of the AVERAGE keyword is not compatible with arrays with missing</span>
<span class="comments">;	pixels.</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	If the keywords BSCALE and BZERO are present in the FITS header, and</span>
<span class="comments">;	have non-trivial values, then the returned array DATA is formed by the</span>
<span class="comments">;	equation</span>
<span class="comments">;</span>
<span class="comments">;			DATA = BSCALE*original + BZERO</span>
<span class="comments">;</span>
<span class="comments">;	However, this behavior can overridden by using the /NOSCALE keyword.</span>
<span class="comments">;</span>
<span class="comments">;	If the data is scaled, then the optional HEADER array is changed so</span>
<span class="comments">;	that BSCALE=1 and BZERO=0.  This is so that these scaling parameters</span>
<span class="comments">;	are not applied to the data a second time by another routine.  Also,</span>
<span class="comments">;	history records are added storing the original values of these</span>
<span class="comments">;	constants.  Note that only the returned array is modified--the header</span>
<span class="comments">;	in the FITS file itself is untouched.</span>
<span class="comments">;</span>
<span class="comments">;	If the /NOUPDATE keyword is set, however, then the BSCALE and BZERO</span>
<span class="comments">;	keywords are not changed.  It is then the user's responsibility to</span>
<span class="comments">;	ensure that these parameters are not reapplied to the data.  In</span>
<span class="comments">;	particular, these keywords should not be present in any header when</span>
<span class="comments">;	writing another FITS file, unless the user wants their values to be</span>
<span class="comments">;	applied when the file is read back in.  Otherwise, FITS readers will</span>
<span class="comments">;	read in the wrong values for the data array.</span>
<span class="comments">;	</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	W. Thompson, May 1992, based in part on READFITS by W. Landsman, and</span>
<span class="comments">;			       STSUB by M. Greason and K. Venkatakrishna.</span>
<span class="comments">;	W. Thompson, Jun 1992, added code to interpret BSCALE and BZERO</span>
<span class="comments">;			       records, and added NOSCALE and NOUPDATE</span>
<span class="comments">;			       keywords.</span>
<span class="comments">;	W. Thompson, Aug 1992, changed to call FXHREAD, and to add history</span>
<span class="comments">;			       records for BZERO, BSCALE.</span>
<span class="comments">; Minimium IDL Version:</span>
<span class="comments">;       V5.3 (uses COMPRESS keyword to OPEN) </span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, May 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 17 November 1993.</span>
<span class="comments">;		Corrected bug with AVERAGE keyword on non-IEEE compatible</span>
<span class="comments">;		machines.</span>
<span class="comments">;		Corrected bug with subsampling on VAX machines.</span>
<span class="comments">;	Version 3, William Thompson, GSFC, 31 May 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;       Version 4, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;       Version 5, Zarro (SAC/GSFC), 14 Feb 1997 </span>
<span class="comments">;               Added I/O error checking</span>
<span class="comments">;       Version 6, 20-May-1998, David Schlegel/W. Thompson</span>
<span class="comments">;               Allow a single pixel to be read in.</span>
<span class="comments">;               Change the signal to read in the entire array to be -1</span>
<span class="comments">;       Version 7 C. Markwardt 22 Sep 2003</span>
<span class="comments">;               If the image is empty (NAXIS EQ 0), or NODATA is set, then</span>
<span class="comments">;               return only the header.  </span>
<span class="comments">;       Version 8 W. Landsman  29 June 2004</span>
<span class="comments">;               Added COMPRESS keyword, check for .gz extension  </span>
<span class="comments">;       Version 9, William Thompson, 19-Aug-2004</span>
<span class="comments">;               Make sure COMPRESS is treated as a scalar</span>
<span class="comments">;       Version 10, Craig Markwardt, 01 Mar 2004</span>
<span class="comments">;               Add EXTENSION keyword and ability to read different</span>
<span class="comments">;               extensions than the primary one.</span>
<span class="comments">;       Version 11,  W. Landsamn   September 2006 </span>
<span class="comments">;               Assume since V5.5, remove VMS support</span>
<span class="comments">;       Version 11.1,  W. Landsamn   November 2007</span>
<span class="comments">;               Allow for possibility number of bytes requires 64 bit integer</span>
<span class="comments">;       Version 12, William Thompson, 18-Jun-2010, update BLANK value.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
	ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  This parameter will be used later in conjunction with the average keyword.</span>
<span class="comments">;</span>
	ALREADY_CONVERTED = 0
        READ_OK=0
<span class="comments">;</span>
<span class="comments">;  Parse the input parameters.</span>
<span class="comments">;</span>
	CASE N_PARAMS() OF
		2:  BEGIN & I1=-1 & I2=-1 & J1=-1 & J2=-1 & STEP=1  & END
		3:  BEGIN & I1=-1 & I2=-1 & J1=-1 & J2=-1 & STEP=1  & END
		4:  BEGIN & I1=-1 & I2=-1 & J1=-1 & J2=-1 & STEP=P1 & END
		5:  BEGIN & I1=P1 & I2=P2 & J1=-1 & J2=-1 & STEP=1  & END
		6:  BEGIN & I1=P1 & I2=P2 & J1=-1 & J2=-1 & STEP=P3 & END
		7:  BEGIN & I1=P1 & I2=P2 & J1=P3 & J2=P4 & STEP=1  & END
		8:  BEGIN & I1=P1 & I2=P2 & J1=P3 & J2=P4 & STEP=P5 & END
		ELSE:  BEGIN
			MESSAGE = 'Syntax:  FXREAD, FILENAME, DATA ' + $
				'[, HEADER [, I1, I2 [, J1, J2 ] [, STEP ]]'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
			END
	ENDCASE

	<span class="comments">;; Extension number	</span>
	IF N_ELEMENTS(EXTENSION0) EQ 0 THEN EXTENSION = 0L $
	ELSE EXTENSION = EXTENSION0[0]

	SZ = SIZE(EXTENSION)
	ETYPE = SZ[SZ[0]+1]
	IF ETYPE EQ 8 THEN BEGIN
		MESSAGE = 'EXTENSION must not be a structure'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF


<span class="comments">;</span>
<span class="comments">;  Determine if file is compressed, get the UNIT number, and open the file.</span>
<span class="comments">;</span>
        IF NOT KEYWORD_SET(COMPRESS) THEN $
         COMPRESS = STRLOWCASE( STRMID(FILENAME, STRLEN(FILENAME)-3,3)) EQ '.gz'
	OPENR, UNIT, FILENAME, /GET_LUN, ERROR=ERROR,COMPRESS=COMPRESS[0]
        IF ERROR NE 0 THEN BEGIN
	    MESSAGE='Error opening '+FILENAME
	    IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
		ERRMSG = MESSAGE
		RETURN
	    END ELSE MESSAGE, MESSAGE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Read in the FITS header.</span>
<span class="comments">;</span>

	<span class="comments">;; Starting extension number is zero</span>
	I_EXT = 0L
	FOUND_EXT = 0

        WHILE NOT FOUND_EXT DO BEGIN
            FXHREAD,UNIT,HEADER,STATUS
            IF STATUS NE 0 THEN BEGIN
               FREE_LUN,UNIT
                MESSAGE = 'Unable to read requested FITS header extension'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF
<span class="comments">;</span>
<span class="comments">;  Extract the keywords BITPIX, NAXIS, NAXIS1, ...</span>
<span class="comments">;</span>
            START = 0L
            BITPIX = FXPAR(HEADER,'BITPIX', START=START)
            NAXIS = FXPAR(HEADER,'NAXIS', START=START)
            GCOUNT = FXPAR(HEADER,'GCOUNT', START=START)
            IF GCOUNT EQ 0 THEN GCOUNT = 1
            PCOUNT = FXPAR(HEADER,'PCOUNT', START=START)
            IF NAXIS GT 0 THEN BEGIN 
                DIMS = FXPAR(HEADER,'NAXIS*') <span class="comments">;Read dimensions</span>
                NDATA = DIMS[0]
                IF NAXIS GT 1 THEN FOR I=2,NAXIS DO NDATA = NDATA*DIMS[I-1]
            ENDIF ELSE NDATA = 0
            NBYTES = LONG64(ABS(BITPIX) / 8) * GCOUNT * (PCOUNT + NDATA)
            NREC = (NBYTES + 2879) / 2880
            
            IF ETYPE EQ 7 THEN BEGIN
                EXTNAME = STRTRIM(STRUPCASE(FXPAR(HEADER,'EXTNAME', $
                                                  START=START)),2)
                IF EXTNAME EQ EXTENSION THEN FOUND_EXT = 1
            END ELSE IF I_EXT EQ EXTENSION THEN FOUND_EXT = 1

            IF NOT FOUND_EXT THEN BEGIN
                <span class="comments">;; Check to be sure there are extensions</span>
                IF I_EXT EQ 0 THEN BEGIN
                    IF NOT FXPAR(HEADER,'EXTEND', START=START) THEN BEGIN
		        FREE_LUN,UNIT
                        MESSAGE = 'Requested extension not found, and file ' + $
                          FILENAME + ' does not contain extensions'
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                            ERRMSG = MESSAGE
                            RETURN
                        END ELSE MESSAGE, MESSAGE
                    ENDIF
                ENDIF

	        POINT_LUN, -UNIT, POINTLUN		<span class="comments">;Current position</span>
                MHEAD0 = POINTLUN + NREC*2880L
	        POINT_LUN, UNIT, MHEAD0			<span class="comments">;Next FITS extension</span>

                I_EXT = I_EXT + 1
            ENDIF
        ENDWHILE

        <span class="comments">;;</span>
        <span class="comments">;; If we got here, then we have arrived at the requested</span>
        <span class="comments">;; extension.  We still need to be sure that it is an image</span>
        <span class="comments">;; and not a table (for extensions beyond the primary one,</span>
        <span class="comments">;; that is).</span>
        <span class="comments">;;</span>
        IF I_EXT GT 0 THEN BEGIN
            XTENSION = STRTRIM(STRUPCASE(FXPAR(HEADER,'XTENSION', START=START)),2)
            IF (XTENSION NE 'IMAGE') THEN BEGIN
		FREE_LUN,UNIT
                MESSAGE = 'Extension ' + STRTRIM(EXTENSION,2) +		$
                  ' is not an image'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF
        ENDIF
            
        <span class="comments">;; Handle case of empty image, or no data requested</span>
        IF NAXIS EQ 0 OR KEYWORD_SET(NODATA) THEN BEGIN
            <span class="comments">;; Make DATA an undefined variable, reflecting no data</span>
            DATA = 0 & DUMMY = TEMPORARY(DATA)

            ERRMSG = ''
            FREE_LUN,UNIT
            RETURN
        ENDIF

	DIMS = FXPAR(HEADER,'NAXIS*')
	N1 = DIMS[0]
	IF NAXIS EQ 2 THEN N2 = DIMS[1] ELSE N2 = 1
<span class="comments">;</span>
<span class="comments">;  Determine the array type from the keyword BITPIX.</span>
<span class="comments">;</span>
	CASE BITPIX OF
		  8:	IDLTYPE = 1	<span class="comments">; Byte</span>
		 16:	IDLTYPE = 2	<span class="comments">; Integer*2</span>
		 32:	IDLTYPE = 3	<span class="comments">; Integer*4</span>
		-32:	IDLTYPE = 4	<span class="comments">; Real*4</span>
		-64:	IDLTYPE = 5	<span class="comments">; Real*8</span>
	ENDCASE
<span class="comments">;</span>
<span class="comments">;  Set the default values for the optional parameters.</span>
<span class="comments">;</span>
	IF (I1 EQ -1) AND (I2 EQ -1) THEN BEGIN
           I1 = 0
           I2 = N1-1
        ENDIF
	IF (J1 EQ -1) AND (J2 EQ -1) THEN BEGIN
           J1 = 0
           J2 = N2-1
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If the prompt keyword was set, the prompt for the parameters.</span>
<span class="comments">;</span>
	IF KEYWORD_SET(PROMPT) THEN BEGIN
		ANSWER = ''
		READ,'Enter lower limit for X ['+STRTRIM(I1,2)+']: ', ANSWER
		IF ANSWER NE '' THEN I1 = (ANSWER)
<span class="comments">;</span>
		ANSWER = ''
		READ,'Enter upper limit for X ['+STRTRIM(I2,2)+']: ', ANSWER
		IF ANSWER NE '' THEN I2 = LONG(ANSWER)
<span class="comments">;</span>
		ANSWER = ''
		READ,'Enter lower limit for Y ['+STRTRIM(J1,2)+']: ', ANSWER
		IF ANSWER NE '' THEN J1 = LONG(ANSWER)
<span class="comments">;</span>
		ANSWER = ''
		READ,'Enter upper limit for Y ['+STRTRIM(J2,2)+']: ', ANSWER
		IF ANSWER NE '' THEN J2 = LONG(ANSWER)
<span class="comments">;</span>
		ANSWER = ''
		READ,'Enter step size ['+STRTRIM(STEP,2)+']: ', ANSWER
		IF ANSWER NE '' THEN STEP = LONG(ANSWER)
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Differentiate between XSTEP and YSTEP.</span>
<span class="comments">;</span>
	XSTEP = STEP > 1
	IF N_ELEMENTS(Y_STEP) EQ 1 THEN YSTEP = Y_STEP ELSE YSTEP = XSTEP
<span class="comments">;</span>
<span class="comments">;  If any of the optional parameters were passed, then update the dimensions</span>
<span class="comments">;  accordingly.  First check I1 and I2.</span>
<span class="comments">;</span>
	IF (I1 NE 0) OR (I2 NE N1-1) THEN BEGIN
		IF NAXIS GT 2 THEN BEGIN
			FREE_LUN,UNIT
			MESSAGE = 'Range parameters can only be set for ' + $
				'one or two-dimensional arrays'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
		IF (MIN([I1,I2]) LT 0) OR (MAX([I1,I2]) GE DIMS[0]) THEN BEGIN
			FREE_LUN,UNIT
			MESSAGE = 'I1,I2 must be in the range 0 to ' +	$
				STRTRIM(DIMS[0]-1,2)
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		END ELSE IF I1 GT I2 THEN BEGIN
			MESSAGE = 'I2 must be >= I1'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
		DIMS[0] = I2 - I1 + 1
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Next, check J1 and J2.</span>
<span class="comments">;</span>
	IF (J1 NE 0) OR (J2 NE N2-1) THEN BEGIN
		IF NAXIS NE 2 THEN BEGIN
			FREE_LUN,UNIT
			MESSAGE = 'J1, J2 can only be set for ' +	$
				'two-dimensional arrays'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
		IF (MIN([J1,J2]) LT 0) OR (MAX([J1,J2]) GE DIMS[1]) THEN BEGIN
			FREE_LUN,UNIT
			MESSAGE = 'J1,J2 must be in the range 0 to ' +	$
				STRTRIM(DIMS[1]-1,2)
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		END ELSE IF J1 GT J2 THEN BEGIN
			MESSAGE = 'J2 must be >= J1'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
		DIMS[1] = J2 - J1 + 1
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Next, check XSTEP.  Note that the dimensions of the final result are</span>
<span class="comments">;  somewhat differ depending on whether the keyword AVERAGE is set or not.</span>
<span class="comments">;</span>
	IF XSTEP GT 1 THEN BEGIN
	    IF NAXIS GT 2 THEN BEGIN
		FREE_LUN,UNIT
	        MESSAGE = 'STEP can only be set for one or ' +	$
	            'two-dimensional arrays'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	    END ELSE IF XSTEP NE LONG(XSTEP) THEN BEGIN
		FREE_LUN,UNIT
	        MESSAGE = 'STEP must be an integer value'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	    END ELSE IF KEYWORD_SET(AVERAGE) THEN BEGIN
	        DIMS[0] = DIMS[0] / LONG(XSTEP)
	    END ELSE BEGIN
	        DIMS[0] = LONG(DIMS[0] + XSTEP - 1) / LONG(XSTEP)
	        INDEX = LINDGEN(DIMS[0])*XSTEP
	    ENDELSE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Finally, check YSTEP.  This parameter is ignored for anything other than</span>
<span class="comments">;  two-dimensional arrays.</span>
<span class="comments">;</span>
	IF (NAXIS EQ 2) AND (YSTEP GT 1) THEN BEGIN
	    IF YSTEP NE LONG(YSTEP) THEN BEGIN
		FREE_LUN,UNIT
	        MESSAGE = 'YSTEP must be an integer value'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	    END ELSE IF KEYWORD_SET(AVERAGE) THEN BEGIN
	        DIMS[1] = DIMS[1] / LONG(YSTEP)
	    END ELSE BEGIN
	        DIMS[1] = LONG(DIMS[1]+YSTEP-1) / LONG(YSTEP)
	    ENDELSE
	END ELSE YSTEP = 1
<span class="comments">;</span>
<span class="comments">;  Make the array.</span>
<span class="comments">;</span>
	DATA = MAKE_ARRAY(DIMENSION=DIMS,TYPE=IDLTYPE,/NOZERO)
<span class="comments">;</span>
<span class="comments">;  Find the start of the data to be read in.</span>
<span class="comments">;</span>
	POINT_LUN,-UNIT,OFFSET		<span class="comments">;Current position</span>
	DELTA = N1*ABS(BITPIX)/8
	IF J1 NE 0 THEN BEGIN
		OFFSET = OFFSET + J1*DELTA
		POINT_LUN,UNIT,OFFSET
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If the I range, XSTEP or YSTEP is non-trivial, then read in the file line by</span>
<span class="comments">;  line.  If pixel averaging, then read in YSTEP lines.</span>
<span class="comments">;</span>
        ON_IOERROR,QUIT
	IF (DIMS[0] NE N1) OR (XSTEP GT 1) OR (YSTEP GT 1) THEN BEGIN
	    IF NAXIS EQ 1 THEN NJ = 1 ELSE NJ = DIMS[1]
	    FOR J = 0,NJ-1 DO BEGIN
	        IF YSTEP GT 1 THEN POINT_LUN,UNIT,OFFSET+J*YSTEP*DELTA
	        IF (YSTEP GT 1) AND KEYWORD_SET(AVERAGE) AND (NAXIS EQ 2) $
	            THEN LINE = MAKE_ARRAY(N1,YSTEP,TYPE=IDLTYPE,/NOZERO) $
	            ELSE LINE = MAKE_ARRAY(N1,TYPE=IDLTYPE,/NOZERO)
	        READU,UNIT,LINE
<span class="comments">;</span>
<span class="comments">;  If I1,I2 do not match the array size, then extract the relevant subarray.</span>
<span class="comments">;</span>
	        IF (I1 NE 0) OR (I2 NE N1-1) THEN LINE = LINE[I1:I2,*]
<span class="comments">;</span>
<span class="comments">;  Suppose that the step size is non-trivial.  If AVERAGE was set, then convert</span>
<span class="comments">;  to the host format, and use REBIN to average the data.  (Note that missing</span>
<span class="comments">;  pixels are not correctly handled in this case.)  Otherwise, select out the</span>
<span class="comments">;  relevant portion of the data.</span>
<span class="comments">;</span>
	        IF (XSTEP GT 1) OR (YSTEP GT 1) THEN BEGIN
	            IF KEYWORD_SET(AVERAGE) THEN BEGIN
			IEEE_TO_HOST, LINE
			ALREADY_CONVERTED = 1
	                IF NAXIS EQ 1 THEN BEGIN
	                    DATA[0,J] = REBIN(LINE[0:XSTEP*DIMS[0]]-1,DIMS[0])
	                END ELSE BEGIN
	                    DATA[0,J] = REBIN(LINE[0:XSTEP*DIMS[0]-1,*],DIMS[0],1)
	                ENDELSE
		    END ELSE DATA[0,J] = LINE[INDEX]
<span class="comments">;</span>
<span class="comments">;  Otherwise, if the step size is trivial, then simply store the line in the</span>
<span class="comments">;  data array.</span>
<span class="comments">;</span>
	        END ELSE BEGIN
	            DATA[0,J] = LINE
	        ENDELSE
	    ENDFOR
<span class="comments">;</span>
<span class="comments">;  Otherwise, if the file doesn't have to be read in line by line, then just</span>
<span class="comments">;  read the data array.</span>
<span class="comments">;</span>
	END ELSE READU,UNIT,DATA
<span class="comments">;</span>
<span class="comments">;  Convert the data from IEEE to host format, keeping track of any IEEE NaN</span>
<span class="comments">;  values.  Don't do this if the conversion has already taken place.</span>
<span class="comments">;</span>
	IF NOT ALREADY_CONVERTED THEN BEGIN
		IF (N_ELEMENTS(NANVALUE) EQ 1) AND (IDLTYPE GE 4) AND	$
			(IDLTYPE LE 6) THEN W = WHERENAN(DATA,COUNT) ELSE $
			COUNT = 0
		IEEE_TO_HOST,DATA
	END ELSE COUNT = 0
<span class="comments">;</span>
<span class="comments">;  If the parameters BZERO and BSCALE are non-trivial, then adjust the array by</span>
<span class="comments">;  these values.  Also update the BLANK keyword, if present.</span>
<span class="comments">;</span>
	IF NOT KEYWORD_SET(NOSCALE) THEN BEGIN
		BZERO  = FXPAR(HEADER,'BZERO')
		BSCALE = FXPAR(HEADER,'BSCALE')
                BLANK  = FXPAR(HEADER,'BLANK',COUNT=NBLANK)
		GET_DATE,DTE
		IF (BSCALE NE 0) AND (BSCALE NE 1) THEN BEGIN
			DATA = BSCALE*DATA
			IF NOT KEYWORD_SET(NOUPDATE) THEN BEGIN
                            FXADDPAR,HEADER,'BSCALE',1.
                            FXADDPAR,HEADER,'HISTORY',DTE +		$
                              ' applied BSCALE = '+ STRTRIM(BSCALE,2)
                            IF NBLANK EQ 1 THEN BEGIN
                                print, bscale, blank
                                BLANK = BSCALE*BLANK
                                FXADDPAR,HEADER,'BLANK',BLANK
                            ENDIF
			ENDIF
		ENDIF
		IF BZERO NE 0 THEN BEGIN
			DATA = DATA + BZERO
			IF NOT KEYWORD_SET(NOUPDATE) THEN BEGIN
                            FXADDPAR,HEADER,'BZERO',0.
                            FXADDPAR,HEADER,'HISTORY',DTE +		$
                              ' applied BZERO = '+ STRTRIM(BZERO,2)
                            IF NBLANK EQ 1 THEN BEGIN
                                BLANK = BLANK + BZERO
                                FXADDPAR,HEADER,'BLANK',BLANK
                            ENDIF
			ENDIF
		ENDIF
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Store NANVALUE everywhere where the data corresponded to IEE NaN.</span>
<span class="comments">;</span>
	IF COUNT GT 0 THEN DATA[W] = NANVALUE
<span class="comments">;</span>
<span class="comments">;  Close the file and return.</span>
<span class="comments">;</span>
        READ_OK=1
QUIT:   ON_IOERROR,NULL
	FREE_LUN, UNIT
        IF NOT READ_OK THEN BEGIN
	    MESSAGE='Error reading file '+FILENAME
	    IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
		ERRMSG = MESSAGE
		RETURN
	    END ELSE MESSAGE, MESSAGE
	ENDIF
	IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
	RETURN
	END
</code>
    </div>
  </body>
</html>