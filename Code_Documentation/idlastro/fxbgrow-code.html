<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:34 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbgrow.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbgrow.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">        PRO FXBGROW, UNIT, HEADER, NROWS, ERRMSG=ERRMSG, NOZERO=NOZERO, $
                     BUFFERSIZE=BUFFERSIZE0
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;        FXBGROW</span>
<span class="comments">; PURPOSE     : </span>
<span class="comments">;       Increase the number of rows in a binary table.</span>
<span class="comments">; EXPLANATION : </span>
<span class="comments">;       Call FXBGROW to increase the size of an already-existing FITS</span>
<span class="comments">;       binary table.  The number of rows increases to NROWS; however</span>
<span class="comments">;       the table cannot shrink by this operation.  This procedure is</span>
<span class="comments">;       useful when a table with an unknown number of rows must be</span>
<span class="comments">;       created.  The caller would then call FXBCREATE to construct a</span>
<span class="comments">;       table of some base size, and follow with calls to FXBGROW to</span>
<span class="comments">;       lengthen the table as needed.  The extension being enlarged</span>
<span class="comments">;       need not be the last extension in the file.  If subsequent</span>
<span class="comments">;       extensions exist in the file, they will be shifted properly.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE :</span>
<span class="comments">;       FXBGROW, UNIT, HEADER, NROWS[, ERRMSG= , NOZERO= , BUFFERSIZE= ]</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS :</span>
<span class="comments">;       UNIT     = Logical unit number of an already-opened file.</span>
<span class="comments">;       HEADER   = String array containing the FITS binary table extension</span>
<span class="comments">;                  header.  The header is modified in place.</span>
<span class="comments">;       NROWS    = New number of rows, always more than the previous</span>
<span class="comments">;                  number.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       NOZERO   = when set, FXBGROW will not zero-pad the new data if</span>
<span class="comments">;                  it doesn't have to.</span>
<span class="comments">;       ERRMSG    = If defined and passed, then any error messages will be</span>
<span class="comments">;                   returned to the user in this parameter rather than</span>
<span class="comments">;                   depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;                   encountered, then a null string is returned.  In order to</span>
<span class="comments">;                   use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;                       ERRMSG = ''</span>
<span class="comments">;                       FXBGROW, ERRMSG=ERRMSG, ...</span>
<span class="comments">;                       IF ERRMSG NE '' THEN ...</span>
<span class="comments">;       BUFFERSIZE = Size in bytes for intermediate data transfers</span>
<span class="comments">;                    (default 32768)</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;       FXADDPAR, FXHREAD, BLKSHIFT</span>
<span class="comments">; Common      : </span>
<span class="comments">;       Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;       information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;       The file must be open with write permission.</span>
<span class="comments">;</span>
<span class="comments">;       The binary table extension in question must already by written</span>
<span class="comments">;       to the file (using FXBCREATE).</span>
<span class="comments">;</span>
<span class="comments">;       A table can never shrink via this operation.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS: </span>
<span class="comments">;       The FITS file will grow in size, and heap areas are</span>
<span class="comments">;       preserved by moving them to the end of the file.</span>
<span class="comments">;</span>
<span class="comments">;       The header is modified to reflect the new number of rows.</span>
<span class="comments">; CATEGORY    : </span>
<span class="comments">;       Data Handling, I/O, FITS, Generic.</span>
<span class="comments">;       Initially written, C. Markwardt, GSFC, Nov 1998</span>
<span class="comments">;       Added ability to enlarge arbitrary extensions and tables with</span>
<span class="comments">;         variable sized rows, not just the last extension in a file,</span>
<span class="comments">;         CM, April 2000</span>
<span class="comments">;       Fix bug in the zeroing of the output file, C. Markwardt, April 2005</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;</span>
@fxbintable
        ON_ERROR, 0
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() NE 3 THEN BEGIN
                MESSAGE = 'Syntax:  FXBGROW, UNIT, HEADER, NROWS'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF

<span class="comments">;</span>
<span class="comments">;  Find the index of the file.</span>
<span class="comments">;</span>
        ILUN = WHERE(LUN EQ UNIT,NLUN)
        ILUN = ILUN[0]
        IF NLUN EQ 0 THEN BEGIN
                MESSAGE = 'Unit ' + STRTRIM(UNIT,2) +   $
                        ' not opened properly'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Don't shrink the file.</span>
<span class="comments">;</span>
        IF NAXIS2[ILUN] GE NROWS THEN GOTO, FINISH
<span class="comments">;</span>
<span class="comments">;  Make sure the file was opened for write access.</span>
<span class="comments">;</span>
        IF STATE[ILUN] NE 2 THEN BEGIN
                MESSAGE = 'Unit ' + STRTRIM(UNIT,2) +   $
                        ' not opened for write access'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Compute number of bytes and buffer size</span>
<span class="comments">;</span>

        NBYTES = (NROWS-NAXIS2[ILUN])*NAXIS1[ILUN]
        IF N_ELEMENTS(BUFFERSIZE0) EQ 0 THEN BUFFERSIZE0 = 32768L
        BUFFERSIZE = LONG(BUFFERSIZE0[0])
        BUFFERSIZE = FLOOR(BUFFERSIZE/NAXIS1[ILUN])*NAXIS1[ILUN]
        IF BUFFERSIZE LE 0 THEN BUFFERSIZE = NAXIS1[ILUN]

<span class="comments">;</span>
<span class="comments">;  First, shift the following extensions by block multiples</span>
<span class="comments">;</span>
        <span class="comments">;; Current beginning of next extension</span>
        N_EXT  = NHEADER[ILUN] + HEAP[ILUN] + DHEAP[ILUN] 
        <span class="comments">;; New beginning of next extension, after shifting</span>
        N_EXT1 = N_EXT + NBYTES
        <span class="comments">;; Round to nearest block size</span>
        IF N_EXT  MOD 2880 NE 0 THEN N_EXT  = N_EXT  + 2880 - (N_EXT  MOD 2880)
        IF N_EXT1 MOD 2880 NE 0 THEN N_EXT1 = N_EXT1 + 2880 - (N_EXT1 MOD 2880)
        NBYTES1 = N_EXT1 - N_EXT

        ERRMSG1 = ''
        IF NBYTES1 GT 0 THEN BEGIN
            BLKSHIFT, UNIT, N_EXT, NBYTES1, ERRMSG=ERRMSG1, $
              NOZERO=KEYWORD_SET(NOZERO), BUFFERSIZE=BUFFERSIZE
            IF ERRMSG1 NE '' THEN GOTO, RETMESSAGE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Next, shift the data between the end of the table and the next</span>
<span class="comments">;  extension, if any.</span>
<span class="comments">;</span>
        <span class="comments">;; End of table data (but before variable-sized heap data)</span>
        ETAB = NHEADER[ILUN] + NAXIS1[ILUN]*NAXIS2[ILUN]
        IF N_EXT GT ETAB THEN BEGIN
            BLKSHIFT, UNIT, [ETAB, N_EXT1-NBYTES-1L], NBYTES, ERRMSG=ERRMSG1, $
              NOZERO=KEYWORD_SET(NOZERO), BUFFERSIZE=BUFFERSIZE
        ENDIF

        RETMESSAGE:
        IF ERRMSG1 NE '' THEN BEGIN
            MESSAGE = ERRMSG1
            IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                ERRMSG = MESSAGE
                RETURN
            END ELSE MESSAGE, MESSAGE
        ENDIF


<span class="comments">;</span>
<span class="comments">;  Zero-fill if necessary (if the original table had no trailing</span>
<span class="comments">;  extensions)</span>
<span class="comments">;</span>

        FS = FSTAT(UNIT)
        
        IF FS.SIZE LT N_EXT1 AND NOT KEYWORD_SET(NOZERO) THEN BEGIN
            POINT_LUN, UNIT, ETAB
            NLEFT = N_EXT1 - ETAB
            NBUFF = BUFFERSIZE &lt<span class="comments">; NLEFT</span>
            BB = BYTARR(NBUFF)

            WHILE NLEFT GT 0 DO BEGIN
                WRITEU, UNIT, BB
                NLEFT = NLEFT - N_ELEMENTS(BB)
                IF (NLEFT LT NBUFF) AND (NLEFT GT 0) THEN BB = BB[0:NLEFT-1]
            ENDWHILE
        ENDIF

<span class="comments">;</span>
<span class="comments">;  Update the internal state.</span>
<span class="comments">;</span>
        HEAP[ILUN] = HEAP[ILUN] + NBYTES
        NAXIS2[ILUN] = NROWS

<span class="comments">;</span>
<span class="comments">;  Modify passed copy of header</span>
<span class="comments">;</span>
        IF N_ELEMENTS(HEADER) GT 0 THEN BEGIN
            FXADDPAR, HEADER, 'NAXIS2', LONG(NROWS), 'Number of rows (grown)'
            THEAP = FXPAR(HEADER, 'THEAP', COUNT=COUNT)
            IF COUNT GT 0 THEN BEGIN
                THEAP = THEAP + NBYTES
                FXADDPAR, HEADER, 'THEAP', THEAP, 'Offset of heap'
            ENDIF
        ENDIF


<span class="comments">;</span>
<span class="comments">;  Modify internal copy of HEADER</span>
<span class="comments">;</span>
        XHEADER = HEAD[*,ILUN]
        FXADDPAR, XHEADER, 'NAXIS2', LONG(NROWS), 'Number of rows (grown)'
        THEAP = FXPAR(XHEADER, 'THEAP', COUNT=COUNT)
        IF COUNT GT 0 THEN BEGIN
            THEAP = THEAP + NBYTES
            FXADDPAR, XHEADER, 'THEAP', THEAP, 'Offset of heap'
        ENDIF
        HEAD[*,ILUN] = XHEADER

<span class="comments">;</span>
<span class="comments">;  Modify disk copy of HEADER</span>
<span class="comments">;</span>
        POINT_LUN, UNIT, MHEADER[ILUN]
        FXHREAD, UNIT, DHEADER, STATUS
        IF STATUS NE 0 THEN BEGIN
            MESSAGE = 'Could not load header from file'
            IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                ERRMSG = MESSAGE
                RETURN
            END ELSE MESSAGE, MESSAGE
        ENDIF
        FXADDPAR, DHEADER, 'NAXIS2', LONG(NROWS), 'Number of rows (grown)'
        THEAP = FXPAR(DHEADER, 'THEAP', COUNT=COUNT)
        IF COUNT GT 0 THEN BEGIN
            THEAP = THEAP + NBYTES
            FXADDPAR, DHEADER, 'THEAP', THEAP, 'Offset of heap'
        ENDIF
        <span class="comments">;; Don't worry about the header increasing in size, since</span>
        <span class="comments">;; every binary table has to have NAXIS2 already.</span>
        SLEN = STRLEN(DHEADER[0])
        FULL = STRING(REPLICATE(32B, 80))
        <span class="comments">;; Pad with spaces</span>
        IF SLEN LT 80 THEN DHEADER[0] = DHEADER[0] + STRMID(FULL,0,80-SLEN)
        BHDR = BYTE(DHEADER)
        BHDR = BHDR[0:79,*]
        POINT_LUN, UNIT, MHEADER[ILUN]
        WRITEU, UNIT, BHDR

FINISH:
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
        RETURN
        END
</code>
    </div>
  </body>
</html>