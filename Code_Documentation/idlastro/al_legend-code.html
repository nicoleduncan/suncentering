<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:18 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>al_legend.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="al_legend.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       AL_LEGEND</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Create an annotation legend for a plot.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This procedure was originally named LEGEND, but a distinct LEGEND() </span>
<span class="comments">;       function was introduced into IDL V8.0.   Therefore, the      </span>
<span class="comments">;       original LEGEND procedure in the Astronomy Library is renamed to</span>
<span class="comments">;       AL_LEGEND.    </span>
<span class="comments">;           </span>
<span class="comments">;       This procedure makes a legend for a plot.  The legend can contain</span>
<span class="comments">;       a mixture of symbols, linestyles, Hershey characters (vectorfont),</span>
<span class="comments">;       and filled polygons (usersym).  A test procedure, legendtest.pro,</span>
<span class="comments">;       shows legend's capabilities.  Placement of the legend is controlled</span>
<span class="comments">;       with keywords like /right, /top, and /center or by using a position</span>
<span class="comments">;       keyword for exact placement (position=[x,y]) or via mouse (/position).</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       AL_LEGEND [,items][,keyword options]</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       The call:</span>
<span class="comments">;               al_legend,['Plus sign','Asterisk','Period'],psym=[1,2,3]</span>
<span class="comments">;         produces:</span>
<span class="comments">;               -----------------</span>
<span class="comments">;               |               |</span>
<span class="comments">;               |  + Plus sign  |</span>
<span class="comments">;               |  * Asterisk   |</span>
<span class="comments">;               |  . Period     |</span>
<span class="comments">;               |               |</span>
<span class="comments">;               -----------------</span>
<span class="comments">;         Each symbol is drawn with a cgPlots command, so they look OK.</span>
<span class="comments">;         Other examples are given in optional output keywords.</span>
<span class="comments">;</span>
<span class="comments">;       lines = indgen(6)                       ; for line styles</span>
<span class="comments">;       items = 'linestyle '+strtrim(lines,2)   ; annotations</span>
<span class="comments">;       al_legend,items,linestyle=lines         ; vertical legend---upper left</span>
<span class="comments">;       items = ['Plus sign','Asterisk','Period']</span>
<span class="comments">;       sym = [1,2,3]</span>
<span class="comments">;       al_legend,items,psym=sym                   ; ditto except using symbols</span>
<span class="comments">;       al_legend,items,psym=sym,/horizontal       ; horizontal format</span>
<span class="comments">;       al_legend,items,psym=sym,box=0             ; sans border</span>
<span class="comments">;       al_legend,items,psym=sym,delimiter='='     ; embed '=' betw psym & text</span>
<span class="comments">;       al_legend,items,psym=sym,margin=2          ; 2-character margin</span>
<span class="comments">;       al_legend,items,psym=sym,position=[x,y]    ; upper left in data coords</span>
<span class="comments">;       al_legend,items,psym=sym,pos=[x,y],/norm   ; upper left in normal coords</span>
<span class="comments">;       al_legend,items,psym=sym,pos=[x,y],/device ; upper left in device coords</span>
<span class="comments">;       al_legend,items,psym=sym,/position         ; interactive position</span>
<span class="comments">;       al_legend,items,psym=sym,/right            ; at upper right</span>
<span class="comments">;       al_legend,items,psym=sym,/bottom           ; at lower left</span>
<span class="comments">;       al_legenditems,psym=sym,/center           ; approximately near center</span>
<span class="comments">;       al_legend,items,psym=sym,number=2          ; plot two symbols, not one</span>
<span class="comments">;     Plot 3 filled colored squares</span>
<span class="comments">;       al_legend,items,/fill,psym=[8,8,8],colors=['red','green','blue']</span>
<span class="comments">;</span>
<span class="comments">;        Another example of the use of AL_LEGEND can be found at </span>
<span class="comments">;        http://www.idlcoyote.com/cg_tips/al_legend.php</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       items = text for the items in the legend, a string array.</span>
<span class="comments">;               For example, items = ['diamond','asterisk','square'].</span>
<span class="comments">;               You can omit items if you don't want any text labels.</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       linestyle = array of linestyle numbers  If linestyle[i] &lt; 0, then omit</span>
<span class="comments">;               ith symbol or line to allow a multi-line entry.     If </span>
<span class="comments">;               linestyle = -99 then text will be left-justified.  </span>
<span class="comments">;       psym = array of plot symbol numbers or names.  If psym[i] is negative, </span>
<span class="comments">;               then a line connects pts for ith item.  If psym[i] = 8, then the</span>
<span class="comments">;               procedure USERSYM is called with vertices defined in the</span>
<span class="comments">;               keyword usersym.   If psym[i] = 88, then use the previously</span>
<span class="comments">;               defined user symbol.    If 11 &lt;= psym[i] &lt;= 46 then David</span>
<span class="comments">;               Fanning's function CGSYMCAT() will be used for additional </span>
<span class="comments">;               symbols.   Note that</span>
<span class="comments">;               PSYM=10 (histogram plot mode) is not allowed since it </span>
<span class="comments">;               cannot be used with the cgPlots command.</span>
<span class="comments">;       vectorfont = vector-drawn characters for the sym/line column, e.g.,</span>
<span class="comments">;               ['!9B!3','!9C!3','!9D!3'] produces an open square, a checkmark,</span>
<span class="comments">;               and a partial derivative, which might have accompanying items</span>
<span class="comments">;               ['BOX','CHECK','PARTIAL DERIVATIVE'].</span>
<span class="comments">;               There is no check that !p.font is set properly, e.g., -1 for</span>
<span class="comments">;               X and 0 for PostScript.  This can produce an error, e.g., use</span>
<span class="comments">;               !20 with PostScript and !p.font=0, but allows use of Hershey</span>
<span class="comments">;               *AND* PostScript fonts together.</span>
<span class="comments">;       N. B.: Choose any of linestyle, psym, and/or vectorfont.  If none is</span>
<span class="comments">;               present, only the text is output.  If more than one</span>
<span class="comments">;               is present, all need the same number of elements, and normal</span>
<span class="comments">;               plot behaviour occurs.</span>
<span class="comments">;               By default, if psym is positive, you get one point so there is</span>
<span class="comments">;               no connecting line.  If vectorfont[i] = '',</span>
<span class="comments">;               then cgPlots is called to make a symbol or a line, but if</span>
<span class="comments">;               vectorfont[i] is a non-null string, then cgText is called.</span>
<span class="comments">;       /help = flag to print header</span>
<span class="comments">;       /horizontal = flag to make the legend horizontal</span>
<span class="comments">;       /vertical = flag to make the legend vertical (D=vertical)</span>
<span class="comments">;       background_color - color name or number to fill the legend box.</span>
<span class="comments">;              Automatically sets /clear.    (D = -1)</span>
<span class="comments">;       box = flag to include/omit box around the legend (D=include)</span>
<span class="comments">;		  outline_color = color of box outline (D = !P.color)</span>
<span class="comments">;       bthick = thickness of the legend box (D = !P.thick)</span>
<span class="comments">;       charsize = just like !p.charsize for plot labels</span>
<span class="comments">;       charthick = just like !p.charthick for plot labels</span>
<span class="comments">;       clear = flag to clear the box area before drawing the legend</span>
<span class="comments">;       colors = array of colors names or numbers for plot symbols/lines </span>
<span class="comments">;          See cgCOLOR for list of color names.   Default is 'Opposite'</span>
<span class="comments">;          If you are using index colors (0-255), then supply color as a byte,</span>
<span class="comments">;          integer or string, but not as a long, which will be interpreted as </span>
<span class="comments">;          a decomposed color. See http://www.idlcoyote.com/cg_tips/legcolor.php</span>
<span class="comments">;       delimiter = embedded character(s) between symbol and text (D=none)</span>
<span class="comments">;       font = scalar font graphics keyword (-1,0 or 1) for text</span>
<span class="comments">;       linsize = Scale factor for line length (0-1), default = 1</span>
<span class="comments">;                 Set to 0 to give a dot, 0.5 give half default line length   </span>
<span class="comments">;       margin = margin around text measured in characters and lines</span>
<span class="comments">;       number = number of plot symbols to plot or length of line (D=1)</span>
<span class="comments">;       spacing = line spacing (D=bit more than character height)</span>
<span class="comments">;       position = data coordinates of the /top (D) /left (D) of the legend</span>
<span class="comments">;       pspacing = psym spacing (D=3 characters) (when number of symbols is</span>
<span class="comments">;             greater than 1)</span>
<span class="comments">;       textcolors = array of color names or numbers for text.  See cgCOLOR</span>
<span class="comments">;          for a list of color names.   Default is 'Opposite' of background</span>
<span class="comments">;       thick = array of line thickness numbers (D = !P.thick), if used, then </span>
<span class="comments">;               linestyle must also be specified</span>
<span class="comments">;       normal = use normal coordinates for position, not data</span>
<span class="comments">;       device = use device coordinates for position, not data</span>
<span class="comments">;       /window - if set then send legend to a resizeable graphics window</span>
<span class="comments">;       usersym = 2-D array of vertices, cf. usersym in IDL manual. </span>
<span class="comments">;             (/USERSYM =square, default is to use existing USERSYM definition)</span>
<span class="comments">;       /fill = flag to fill the usersym</span>
<span class="comments">;       /left_legend = flag to place legend snug against left side of plot</span>
<span class="comments">;                 window (D)</span>
<span class="comments">;       /right_legend = flag to place legend snug against right side of plot</span>
<span class="comments">;               window.    If /right,pos=[x,y], then x is position of RHS and</span>
<span class="comments">;               text runs right-to-left.</span>
<span class="comments">;       /top_legend = flag to place legend snug against top of plot window (D)</span>
<span class="comments">;       /bottom = flag to place legend snug against bottom of plot window</span>
<span class="comments">;               /top,pos=[x,y] and /bottom,pos=[x,y] produce same positions.</span>
<span class="comments">;</span>
<span class="comments">;       If LINESTYLE, PSYM, VECTORFONT, SYMSIZE, THICK, COLORS, or </span>
<span class="comments">;       TEXTCOLORS are supplied as scalars, then the scalar value is set for </span>
<span class="comments">;       every line or symbol in the legend.</span>
<span class="comments">; Outputs:</span>
<span class="comments">;       legend to current plot device</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       corners = 4-element array, like !p.position, of the normalized</span>
<span class="comments">;         coords for the box (even if box=0): [llx,lly,urx,ury].</span>
<span class="comments">;         Useful for multi-column or multi-line legends, for example,</span>
<span class="comments">;         to make a 2-column legend, you might do the following:</span>
<span class="comments">;           c1_items = ['diamond','asterisk','square']</span>
<span class="comments">;           c1_psym = [4,2,6]</span>
<span class="comments">;           c2_items = ['solid','dashed','dotted']</span>
<span class="comments">;           c2_line = [0,2,1]</span>
<span class="comments">;           al_legend,c1_items,psym=c1_psym,corners=c1,box=0</span>
<span class="comments">;           al_legend,c2_items,line=c2_line,corners=c2,box=0,pos=[c1[2],c1[3]]</span>
<span class="comments">;           c = [c1[0]&lt;c2[0],c1[1]&lt;c2[1],c1[2]>c2[2],c1[3]>c2[3]]</span>
<span class="comments">;         cgplots,[c[0],c[0],c[2],c[2],c[0]],[c[1],c[3],c[3],c[1],c[1]],/norm</span>
<span class="comments">;</span>
<span class="comments">;         Useful also to place the legend.  Here's an automatic way to place</span>
<span class="comments">;         the legend in the lower right corner.  The difficulty is that the</span>
<span class="comments">;         legend's width is unknown until it is plotted.  In this example,</span>
<span class="comments">;         the legend is plotted twice: the first time in the upper left, the</span>
<span class="comments">;         second time in the lower right.</span>
<span class="comments">;</span>
<span class="comments">;         al_legend,['1','22','333','4444'],linestyle=indgen(4),corners=corners</span>
<span class="comments">;                       ; BOGUS LEGEND---FIRST TIME TO REPORT CORNERS</span>
<span class="comments">;           xydims = [corners[2]-corners[0],corners[3]-corners[1]]</span>
<span class="comments">;                       ; SAVE WIDTH AND HEIGHT</span>
<span class="comments">;           chdim=[!d.x_ch_size/float(!d.x_size),!d.y_ch_size/float(!d.y_size)]</span>
<span class="comments">;                       ; DIMENSIONS OF ONE CHARACTER IN NORMALIZED COORDS</span>
<span class="comments">;           pos = [!x.window[1]-chdim[0]-xydims[0] $</span>
<span class="comments">;                       ,!y.window[0]+chdim[1]+xydims[1]]</span>
<span class="comments">;                       ; CALCULATE POSITION FOR LOWER RIGHT</span>
<span class="comments">;           cgplot,findgen(10)    ; SIMPLE PLOT; YOU DO WHATEVER YOU WANT HERE.</span>
<span class="comments">;           al_legend,['1','22','333','4444'],linestyle=indgen(4),pos=pos</span>
<span class="comments">;                       ; REDO THE LEGEND IN LOWER RIGHT CORNER</span>
<span class="comments">;         You can modify the pos calculation to place the legend where you</span>
<span class="comments">;         want.  For example to place it in the upper right:</span>
<span class="comments">;           pos = [!x.window[1]-chdim[0]-xydims[0],!y.window[1]-xydims[1]]</span>
<span class="comments">; Common blocks:</span>
<span class="comments">;       none</span>
<span class="comments">; Procedure:</span>
<span class="comments">;       If keyword help is set, call doc_library to print header.</span>
<span class="comments">;       See notes in the code.  Much of the code deals with placement of the</span>
<span class="comments">;       legend.  The main problem with placement is not being</span>
<span class="comments">;       able to sense the length of a string before it is output.  Some crude</span>
<span class="comments">;       approximations are used for centering.</span>
<span class="comments">; Restrictions:</span>
<span class="comments">;       Here are some things that aren't implemented.</span>
<span class="comments">;       - An orientation keyword would allow lines at angles in the legend.</span>
<span class="comments">;       - An array of usersyms would be nice---simple change.</span>
<span class="comments">;       - An order option to interchange symbols and text might be nice.</span>
<span class="comments">;       - Somebody might like double boxes, e.g., with box = 2.</span>
<span class="comments">;       - Another feature might be a continuous bar with ticks and text.</span>
<span class="comments">;       - There are no guards to avoid writing outside the plot area.</span>
<span class="comments">;       - There is no provision for multi-line text, e.g., '1st line!c2nd line'</span>
<span class="comments">;         Sensing !c would be easy, but !c isn't implemented for PostScript.</span>
<span class="comments">;         A better way might be to simply output the 2nd line as another item</span>
<span class="comments">;         but without any accompanying symbol or linestyle.  A flag to omit</span>
<span class="comments">;         the symbol and linestyle is linestyle[i] = -1.</span>
<span class="comments">;       - There is no ability to make a title line containing any of titles</span>
<span class="comments">;         for the legend, for the symbols, or for the text.</span>
<span class="comments">; Side Effects:</span>
<span class="comments">; Modification history:</span>
<span class="comments">;       write, 24-25 Aug 92, F K Knight (knight@ll.mit.edu)</span>
<span class="comments">;       allow omission of items or omission of both psym and linestyle, add</span>
<span class="comments">;         corners keyword to facilitate multi-column legends, improve place-</span>
<span class="comments">;         ment of symbols and text, add guards for unequal size, 26 Aug 92, FKK</span>
<span class="comments">;       add linestyle(i)=-1 to suppress a single symbol/line, 27 Aug 92, FKK</span>
<span class="comments">;       add keyword vectorfont to allow characters in the sym/line column,</span>
<span class="comments">;         28 Aug 92, FKK</span>
<span class="comments">;       add /top, /bottom, /left, /right keywords for automatic placement at</span>
<span class="comments">;         the four corners of the plot window.  The /right keyword forces</span>
<span class="comments">;         right-to-left printing of menu. 18 Jun 93, FKK</span>
<span class="comments">;       change default position to data coords and add normal, data, and</span>
<span class="comments">;         device keywords, 17 Jan 94, FKK</span>
<span class="comments">;       add /center keyword for positioning, but it is not precise because</span>
<span class="comments">;         text string lengths cannot be known in advance, 17 Jan 94, FKK</span>
<span class="comments">;       add interactive positioning with /position keyword, 17 Jan 94, FKK</span>
<span class="comments">;       allow a legend with just text, no plotting symbols.  This helps in</span>
<span class="comments">;         simply describing a plot or writing assumptions done, 4 Feb 94, FKK</span>
<span class="comments">;       added thick, symsize, and clear keyword Feb 96, W. Landsman HSTX</span>
<span class="comments">;               David Seed, HR Wallingford, d.seed@hrwallingford.co.uk</span>
<span class="comments">;       allow scalar specification of keywords, Mar 96, W. Landsman HSTX</span>
<span class="comments">;       added charthick keyword, June 96, W. Landsman HSTX</span>
<span class="comments">;       Made keyword names  left,right,top,bottom,center longer,</span>
<span class="comments">;                                 Aug 16, 2000, Kim Tolbert</span>
<span class="comments">;       Added ability to have regular text lines in addition to plot legend </span>
<span class="comments">;       lines in legend.  If linestyle is -99 that item is left-justified.</span>
<span class="comments">;       Previously, only option for no sym/line was linestyle=-1, but then text</span>
<span class="comments">;       was lined up after sym/line column.    10 Oct 2000, Kim Tolbert</span>
<span class="comments">;       Make default value of thick = !P.thick  W. Landsman  Jan. 2001</span>
<span class="comments">;       Don't overwrite existing USERSYM definition  W. Landsman Mar. 2002</span>
<span class="comments">;	     Added outline_color BT 24 MAY 2004</span>
<span class="comments">;       Pass font keyword to cgText commands.  M. Fitzgerald, Sep. 2005</span>
<span class="comments">;       Default spacing, pspacing should be relative to charsize. M. Perrin, July 2007</span>
<span class="comments">;       Don't modify position keyword  A. Kimball/ W. Landsman Jul 2007</span>
<span class="comments">;       Small update to Jul 2007 for /NORMAL coords.  W. Landsman Aug 2007</span>
<span class="comments">;       Use SYMCAT() plotting symbols for 11&lt;=PSYM&lt;=46   W. Landsman  Nov 2009</span>
<span class="comments">;       Make a sharper box edge T. Robishaw/W.Landsman July 2010</span>
<span class="comments">;       Added BTHICK keyword W. Landsman October 2010</span>
<span class="comments">;       Added BACKGROUND_COLOR keyword  W. Landsman February 2011</span>
<span class="comments">;       Incorporate Coyote graphics  W. Landsman  February 2011</span>
<span class="comments">;       Added LINSIZE keyword W.L./V.Gonzalez   May 2011</span>
<span class="comments">;       Fixed a small problem with Convert_Coord when the Window keyword is set. </span>
<span class="comments">;                         David Fanning, May 2011.</span>
<span class="comments">;       Fixed problem when /clear and /Window are set J. Bailin/WL   May 2011</span>
<span class="comments">;       CGQUERY was called instead of CGCONTROL   W.L.  June 2011</span>
<span class="comments">;       Fixed typo preventing BTHICK keyword from working W.L. Dec 2011</span>
<span class="comments">;       Remove call to SYMCAT() W.L. Dec 2011</span>
<span class="comments">;       Changed the way the WINDOW keyword adds commands to cgWindow, and</span>
<span class="comments">;       now default to BACKGROUND for background color. 1 Feb 2012 David Fanning</span>
<span class="comments">;       Allow 1 element SYMSIZE for vector input, WL Apr 2012.</span>
<span class="comments">;       Allow to specify symbols by cgSYMCAT() name WL Aug 2012 </span>
<span class="comments">;-</span>
<a id="al_legend:source"></a>pro al_legend, items, BOTTOM_LEGEND=bottom, BOX = box, CENTER_LEGEND=center, $
    CHARTHICK=charthick, CHARSIZE = charsize, CLEAR = clear, COLORS = colorsi, $
    CORNERS = corners, DATA=data, DELIMITER=delimiter, DEVICE=device, $
    FILL=fill, HELP = help, HORIZONTAL=horizontal,LEFT_LEGEND=left, $
    LINESTYLE=linestylei, MARGIN=margin, NORMAL=normal, NUMBER=number, $
    POSITION=position,PSPACING=pspacing, PSYM=psymi, RIGHT_LEGEND=right, $
    SPACING=spacing, SYMSIZE=symsizei, TEXTCOLORS=textcolorsi, THICK=thicki, $
    TOP_LEGEND=top, USERSYM=usersym,  VECTORFONT=vectorfonti, $
    VERTICAL=vertical,OUTLINE_COLOR = outline_color, FONT = font, $
    BTHICK=bthick, background_color = bgcolor, WINDOW=window,LINSIZE = linsize
<span class="comments">;</span>
<span class="comments">;       =====>> HELP</span>
<span class="comments">;</span>
compile_opt idl2
<span class="comments">;On_error,2</span>
if keyword_set(help) then begin & doc_library,'al_legend' & return & endif
<span class="comments">; Should this commnad be added to a resizeable graphics window?</span>
IF (Keyword_Set(window)) && ((!D.Flags AND 256) NE 0) THEN BEGIN
    
        cgWindow, 'al_legend', items, BOTTOM_LEGEND=bottom, BOX = box, CENTER_LEGEND=center, $
            CHARTHICK=charthick, CHARSIZE = charsize, CLEAR = clear, COLORS = colorsi, $
            CORNERS = corners, DATA=data, DELIMITER=delimiter, DEVICE=device, $
            FILL=fill, HELP = help, HORIZONTAL=horizontal,LEFT_LEGEND=left, $
            LINESTYLE=linestylei, MARGIN=margin, NORMAL=normal, NUMBER=number, $
            POSITION=position,PSPACING=pspacing, PSYM=psymi, RIGHT_LEGEND=right, $
            SPACING=spacing, SYMSIZE=symsizei, TEXTCOLORS=textcolorsi, THICK=thicki, $
            TOP_LEGEND=top, USERSYM=usersym,  VECTORFONT=vectorfonti, $
            VERTICAL=vertical,OUTLINE_COLOR = outline_color, FONT = font, $
            BTHICK=thick, background_color = bgcolor, LINSIZE = linsize, ADDCMD=1
                            
         RETURN
    ENDIF
    <span class="comments">;</span>

<span class="comments">;</span>
<span class="comments">;       =====>> SET DEFAULTS FOR SYMBOLS, LINESTYLES, AND ITEMS.</span>
<span class="comments">;</span>
 ni = n_elements(items)
 np = n_elements(psymi)
 nl = n_elements(linestylei)
 nth = n_elements(thicki)
 nsym = n_elements(symsizei)
 nv = n_elements(vectorfonti)
 nlpv = max([np,nl,nv])
 n = max([ni,np,nl,nv])                                  <span class="comments">; NUMBER OF ENTRIES</span>
strn = strtrim(n,2)                                     <span class="comments">; FOR ERROR MESSAGES</span>
if n eq 0 then message,'No inputs!  For help, type al_legend,/help.'
if ni eq 0 then begin
  items = replicate('',n)                               <span class="comments">; DEFAULT BLANK ARRAY</span>
endif else begin
  if size(items,/TNAME) NE 'STRING' then message, $
      'First parameter must be a string array.  For help, type al_legend,/help.'
  if ni ne n then message,'Must have number of items equal to '+strn
endelse
symline = (np ne 0) || (nl ne 0)                        <span class="comments">; FLAG TO PLOT SYM/LINE</span>
 if (np ne 0) && (np ne n) && (np NE 1) then message, $
        'Must have 0, 1 or '+strn+' elements in PSYM array.'
 if (nl ne 0) && (nl ne n) && (nl NE 1) then message, $
         'Must have 0, 1 or '+strn+' elements in LINESTYLE array.'
 if (nth ne 0) && (nth ne n) && (nth NE 1) then message, $
         'Must have 0, 1 or '+strn+' elements in THICK array.'

 case nl of 
 0: linestyle = intarr(n)              <span class="comments">;Default = solid</span>
 1: linestyle = intarr(n)  + linestylei
 else: linestyle = linestylei
 endcase 
 
  case nsym of 
 0: symsize = replicate(!p.symsize,n)      <span class="comments">;Default = !P.SYMSIZE</span>
 1: symsize = intarr(n) + symsizei
 else: symsize = symsizei
 endcase 

 
 case nth of 
 0: thick = replicate(!p.thick,n)      <span class="comments">;Default = !P.THICK</span>
 1: thick = intarr(n) + thicki
 else: thick = thicki
 endcase
 
 if size(psymi,/TNAME) EQ 'STRING' then begin
    psym = intarr(n)
    for i=0,N_elements(psymi)-1 do psym[i] = cgsymcat(psymi[i])
 endif else begin    
     
 case np of             <span class="comments">;Get symbols</span>
 0: psym = intarr(n)    <span class="comments">;Default = solid</span>
 1: psym = intarr(n) + psymi
 else: psym = psymi
 endcase 
 endelse

 case nv of 
 0: vectorfont = replicate('',n)
 1: vectorfont = replicate(vectorfonti,n)
 else: vectorfont = vectorfonti
 endcase 
<span class="comments">;</span>
<span class="comments">;       =====>> CHOOSE VERTICAL OR HORIZONTAL ORIENTATION.</span>
<span class="comments">;</span>
if n_elements(horizontal) eq 0 then $              <span class="comments">; D=VERTICAL</span>
  setdefaultvalue, vertical, 1 else $
  setdefaultvalue, vertical, ~horizontal

<span class="comments">;</span>
<span class="comments">;       =====>> SET DEFAULTS FOR OTHER OPTIONS.</span>
<span class="comments">;</span>
 setdefaultvalue, box, 1
 if N_elements(bgcolor) NE 0 then clear = 1
 setdefaultvalue, bgcolor, 'BACKGROUND'
 setdefaultvalue, clear, 0
 setdefaultvalue, linsize, 1.
 setdefaultvalue, margin, 0.5
 setdefaultvalue, delimiter, ''
 setdefaultvalue, charsize, !p.charsize
 setdefaultvalue, charthick, !p.charthick
 if charsize eq 0 then charsize = 1
 setdefaultvalue, number, 1
<span class="comments">; Default color is opposite the background color</span>
 case N_elements(colorsi) of 
 0: colors = replicate('opposite',n)    
 1: colors = replicate(colorsi,n)
 else: colors = colorsi
 endcase 

 case N_elements(textcolorsi) of 
 0: textcolors = replicate('opposite',n)     
 1: textcolors = replicate(textcolorsi,n)
 else: textcolors = textcolorsi
 endcase 
 fill = keyword_set(fill)
if n_elements(usersym) eq 1 then usersym = 2*[[0,0],[0,1],[1,1],[1,0],[0,0]]-1

<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE SPACING</span>
<span class="comments">;</span>
setdefaultvalue, spacing, 1.2*charsize
setdefaultvalue, pspacing , 3*charsize
xspacing = !d.x_ch_size/float(!d.x_size) * (spacing > charsize)
yspacing = !d.y_ch_size/float(!d.y_size) * (spacing > charsize)
ltor = 1                                        <span class="comments">; flag for left-to-right</span>
if n_elements(left) eq 1 then ltor = left eq 1
if n_elements(right) eq 1 then ltor = right ne 1
ttob = 1                                        <span class="comments">; flag for top-to-bottom</span>
if n_elements(top) eq 1 then ttob = top eq 1
if n_elements(bottom) eq 1 then ttob = bottom ne 1
xalign = ltor ne 1                              <span class="comments">; x alignment: 1 or 0</span>
yalign = -0.5*ttob + 1                          <span class="comments">; y alignment: 0.5 or 1</span>
xsign = 2*ltor - 1                              <span class="comments">; xspacing direction: 1 or -1</span>
ysign = 2*ttob - 1                              <span class="comments">; yspacing direction: 1 or -1</span>
if ~ttob then yspacing = -yspacing
if ~ltor then xspacing = -xspacing
<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE POSITIONS: FIRST CALCULATE X OFFSET FOR TEXT</span>
<span class="comments">;</span>
xt = 0
if nlpv gt 0 then begin                         <span class="comments">; SKIP IF TEXT ITEMS ONLY.</span>
if vertical then begin                          <span class="comments">; CALC OFFSET FOR TEXT START</span>
  for i = 0,n-1 do begin
    if (psym[i] eq 0) and (vectorfont[i] eq '') then num = (number + 1) > 3 else num = number
    if psym[i] lt 0 then num = number > 2       <span class="comments">; TO SHOW CONNECTING LINE</span>
    if psym[i] eq 0 then expand = linsize else expand = 2
    thisxt = (expand*pspacing*(num-1)*xspacing)
    if ltor then xt = thisxt > xt else xt = thisxt &lt<span class="comments">; xt</span>
    endfor
endif   <span class="comments">; NOW xt IS AN X OFFSET TO ALIGN ALL TEXT ENTRIES.</span>
endif
<span class="comments">;</span>
<span class="comments">;       =====>> INITIALIZE POSITIONS: SECOND LOCATE BORDER</span>
<span class="comments">;</span>

if !x.window[0] eq !x.window[1] then begin
  cgplot,/nodata,xstyle=4,ystyle=4,[0],/noerase
endif
<span class="comments">;       next line takes care of weirdness with small windows</span>
pos = [min(!x.window),min(!y.window),max(!x.window),max(!y.window)]

case n_elements(position) of
 0: begin
  if ltor then px = pos[0] else px = pos[2]
  if ttob then py = pos[3] else py = pos[1]
  if keyword_set(center) then begin
    if ~keyword_set(right) && ~keyword_set(left) then $
      px = (pos[0] + pos[2])/2. - xt
    if ~keyword_set(top) && ~keyword_set(bottom) then $
      py = (pos[1] + pos[3])/2. + n*yspacing
    endif
  nposition = [px,py] + [xspacing,-yspacing]
  end
 1: begin       <span class="comments">; interactive</span>
  message,/inform,'Place mouse at upper left corner and click any mouse button.'
  cursor,x,y,/normal
  nposition = [x,y]
  end
 2: begin       <span class="comments">; convert upper left corner to normal coordinates</span>
 
  <span class="comments">; if keyword window is set, get the current graphics window.</span>
  if keyword_set(window) then begin
     wid = cgQuery(/current)
     WSet, wid
  endif
  if keyword_set(data) then $
    nposition = convert_coord(position,/to_norm) $
  else if keyword_set(device) then $
    nposition = convert_coord(position,/to_norm,/device) $
  else if ~keyword_set(normal) then $
    nposition = convert_coord(position,/to_norm) else nposition= position
  end
 else: message,'Position keyword can have 0, 1, or 2 elements only. Try al_legend,/help.'
endcase

yoff = 0.25*yspacing*ysign                      <span class="comments">; VERT. OFFSET FOR SYM/LINE.</span>

x0 = nposition[0] + (margin)*xspacing            <span class="comments">; INITIAL X & Y POSITIONS</span>
y0 = nposition[1] - margin*yspacing + yalign*yspacing    <span class="comments">; WELL, THIS WORKS!</span>
<span class="comments">;</span>
<span class="comments">;       =====>> OUTPUT TEXT FOR LEGEND, ITEM BY ITEM.</span>
<span class="comments">;       =====>> FOR EACH ITEM, PLACE SYM/LINE, THEN DELIMITER,</span>
<span class="comments">;       =====>> THEN TEXT---UPDATING X & Y POSITIONS EACH TIME.</span>
<span class="comments">;       =====>> THERE ARE A NUMBER OF EXCEPTIONS DONE WITH IF STATEMENTS.</span>
<span class="comments">;</span>
for iclr = 0,clear do begin
  y = y0                                                <span class="comments">; STARTING X & Y POSITIONS</span>
  x = x0
  if ltor then xend = 0 else xend = 1           <span class="comments">; SAVED WIDTH FOR DRAWING BOX</span>

 if ttob then ii = [0,n-1,1] else ii = [n-1,0,-1]

 for i = ii[0],ii[1],ii[2] do begin
  if vertical then x = x0 else y = y0           <span class="comments">; RESET EITHER X OR Y</span>
  x = x + xspacing                              <span class="comments">; UPDATE X & Y POSITIONS</span>
  y = y - yspacing
  if nlpv eq 0 then goto,TEXT_ONLY              <span class="comments">; FLAG FOR TEXT ONLY</span>
  num = number
  if (psym[i] eq 0) && (vectorfont[i] eq '') then num = (number + 1) > 3 
  if psym[i] lt 0 then num = number > 2         <span class="comments">; TO SHOW CONNECTING LINE</span>
  if psym[i] eq 0 then expand = 1 else expand = 2
  xp = x + expand*pspacing*indgen(num)*xspacing
  if (psym[i] gt 0) && (num eq 1) && vertical then xp = x + xt/2.
  yp = y + intarr(num)
  if vectorfont[i] eq '' then yp +=  yoff
  if psym[i] eq 0 then begin
      xp = [min(xp),max(xp) -(max(xp)-min(xp))*(1.-linsize)]   
      yp = [min(yp),max(yp)]                      <span class="comments">; DITTO</span>
  endif
  if (psym[i] eq 8) && (N_elements(usersym) GT 1) then $
                usersym,usersym,fill=fill,color=colors[i]
<span class="comments">;; extra by djseed .. psym=88 means use the already defined usersymbol</span>
 if psym[i] eq 88 then p_sym =8 else $
 if psym[i] EQ 10 then $
         message,'PSYM=10 (histogram mode) not allowed to al_legend.pro' $
 else p_sym= psym[i]

  if vectorfont[i] ne '' then begin
<span class="comments">;    if (num eq 1) && vertical then xp = x + xt/2      ; IF 1, CENTERED.</span>
     cgText,xp,yp,vectorfont[i],width=width,color=colors[i], $
      size=charsize,align=xalign,charthick = charthick,/norm,font=font
    xt = xt > width
    xp = xp + width/2.
  endif else begin
    if symline and (linestyle[i] ge 0) then cgPlots,xp,yp,color=colors[i] $
      ,/normal,linestyle=linestyle[i],psym=p_sym,symsize=symsize[i], $
      thick=thick[i]
  endelse

  if vertical then x += xt else if ltor then x = max(xp) else x = min(xp)
  if symline then x += xspacing
  
  TEXT_ONLY:
  if vertical && (vectorfont[i] eq '') && symline && (linestyle[i] eq -99) then x=x0 + xspacing
  cgText,x,y,delimiter,width=width,/norm,color=textcolors[i], $
         size=charsize,align=xalign,charthick = charthick,font=font	 
  x += width*xsign
  if width ne 0 then x += 0.5*xspacing
  cgText,x,y,items[i],width=width,/norm,color=textcolors[i],size=charsize, $
            align=xalign,charthick=charthick,font=font
  x += width*xsign
  if ~vertical && (i lt (n-1)) then x += 2*xspacing<span class="comments">; ADD INTER-ITEM SPACE</span>
  xfinal = (x + xspacing*margin)
  if ltor then xend = xfinal > xend else xend = xfinal &lt<span class="comments">; xend   ; UPDATE END X</span>
 endfor

 if (iclr lt clear ) then begin
<span class="comments">;       =====>> CLEAR AREA</span>
        x = nposition[0]
        y = nposition[1]
        if vertical then bottom = n else bottom = 1
        ywidth = - (2*margin+bottom-0.5)*yspacing
        corners = [x,y+ywidth,xend,y]
        cgColorfill,[x,xend,xend,x,x],y + [0,0,ywidth,ywidth,0],/norm, $
	   color=bgcolor
<span class="comments">;       cgPlots,[x,xend,xend,x,x],y + [0,0,ywidth,ywidth,0], $</span>
<span class="comments">;                 thick=2</span>
 endif else begin

<span class="comments">;</span>
<span class="comments">;       =====>> OUTPUT BORDER</span>
<span class="comments">;</span>
        x = nposition[0]
        y = nposition[1]
        if vertical then bottom = n else bottom = 1
        ywidth = - (2*margin+bottom-0.5)*yspacing
        corners = [x,y+ywidth,xend,y]
        if box then cgPlots,[x,xend,xend,x,x,xend],y + [0,0,ywidth,ywidth,0,0],$
	        /norm, color = outline_color,thick=bthick
        return
 endelse
endfor

end

</code>
    </div>
  </body>
</html>