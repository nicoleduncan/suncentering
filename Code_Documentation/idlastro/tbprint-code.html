<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:08 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tbprint.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tbprint.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="tbprint:source"></a>pro tbprint,hdr_or_tbstr,tab,columns,rows,textout=textout,fmt=fmt, $
            num_header_lines=num_header_lines,nval_per_line=nval_per_line
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       TBPRINT</span>
<span class="comments">;  PURPOSE:</span>
<span class="comments">;       Procedure to print specified columns & rows of a FITS binary table</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       TBPRINT, h, tab, columns, [ rows, TEXTOUT =, FMT=, NUM_HEADER= ]</span>
<span class="comments">;               or</span>
<span class="comments">;       TBPRINT,tb_str, tab, columns, [ rows, TEXTOUT =, FMT=, NUM_HEADER =  ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       h - FITS header for table, string array</span>
<span class="comments">;                       or</span>
<span class="comments">;       tb_str - IDL structure extracted from FITS header by TBINFO, useful </span>
<span class="comments">;           when TBPRINT is called many times with the same header</span>
<span class="comments">;       tab - table array </span>
<span class="comments">;       columns - string giving column names, or vector giving</span>
<span class="comments">;               column numbers (beginning with 1).  If string </span>
<span class="comments">;               supplied then column names should be separated by comma's.</span>
<span class="comments">;               If set to '*' then all columns are printed in table format </span>
<span class="comments">;               (1 row per line, binary tables only).</span>
<span class="comments">;       rows - (optional) vector of row numbers to print.  If</span>
<span class="comments">;               not supplied or set to scalar, -1, then all rows</span>
<span class="comments">;               are printed.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       None</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       FMT = Format string for print display.   If not supplied, then any </span>
<span class="comments">;               formats in the TDISP keyword fields of the table will be</span>
<span class="comments">;               used, otherwise IDL default formats.   </span>
<span class="comments">;       NUM_HEADER_LINES - Number of lines to display the column headers </span>
<span class="comments">;               default = 1).  By setting NUM_HEADER_LINES to an integer larger</span>
<span class="comments">;               than 1, one can avoid truncation of the column header labels.  </span>
<span class="comments">;               In addition, setting NUM_HEADER_LINES will display commented </span>
<span class="comments">;               lines indicating a FORMAT for reading the data, and a </span>
<span class="comments">;               suggested call to  readfmt.pro.</span>
<span class="comments">;       NVAL_PER_LINE - The maximum number of values displayed from a multivalued</span>
<span class="comments">;               column when printing in table format.   Default = 6</span>
<span class="comments">;       TEXTOUT - scalar number (0-7) or string (file name) determining</span>
<span class="comments">;               output device (see TEXTOPEN).  Default is TEXTOUT=1, output </span>
<span class="comments">;               to the user's terminal    </span>
<span class="comments">; SYSTEM VARIABLES:</span>
<span class="comments">;       Uses nonstandard system variables !TEXTOUT and !TEXTOPEN</span>
<span class="comments">;       Set !TEXTOUT = 3 to direct output to a disk file.   The system</span>
<span class="comments">;       variable is overriden by the value of the keyword TEXTOUT</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       tab = readfits('test.fits',htab,/ext) ;Read first extension into vars</span>
<span class="comments">;       tbprint,h,tab,'STAR ID,RA,DEC'    ;print id,ra,dec for all stars</span>
<span class="comments">;       tbprint,h,tab,[2,3,4],indgen(100) ;print columns 2-4 for </span>
<span class="comments">;                                          first 100 stars</span>
<span class="comments">;       tbprint,h,tab,text="stars.dat"    ;Convert entire FITS table to</span>
<span class="comments">;                                         ;an ASCII file named 'stars.dat'</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       GETTOK(), STRNUMBER(), TEXTOPEN, TEXTCLOSE, TBINFO</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS: </span>
<span class="comments">;       (1) Program does not check whether output length exceeds output</span>
<span class="comments">;               device capacity (e.g. 80 or 132).</span>
<span class="comments">;       (2) Column heading may be truncated to fit in space defined by</span>
<span class="comments">;               the FORMAT specified for the column.    Use NUM_HEADER_LINES</span>
<span class="comments">;               to avoid truncation.</span>
<span class="comments">;       (3) Program does not check for null values</span>
<span class="comments">;       (4) Does not work with variable length columns</span>
<span class="comments">;       (5) Will only the display the first value of fields with multiple values</span>
<span class="comments">;        (unless there is one row each with the same number of mulitple values)</span>
<span class="comments">;        If printing in table format (column='*') then up to 6 values</span>
<span class="comments">;        can be printed per line.</span>
<span class="comments">;</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       version 1  D. Lindler Feb. 1987</span>
<span class="comments">;       Accept undefined values of rows,columns W. Landsman  August 1997</span>
<span class="comments">;       Use new structure returned by TBINFO    W. Landsman  August 1997</span>
<span class="comments">;       Made formatting more robust    W. Landsman   March 2000</span>
<span class="comments">;       Use STRSPLIT to parse string column listing W. Landsman July 2002</span>
<span class="comments">;       Wasn't always printing last row   W. Landsman  Feb. 2003</span>
<span class="comments">;       Better formatting (space between columns) W. Landsman Oct. 2005</span>
<span class="comments">;       Use case-insensitive match with TTYPE, use STRJOIN W.L. June 2006</span>
<span class="comments">;       Fixed check for multiple values W.L. August 2006</span>
<span class="comments">;       Fixed bad index value in August 2006 fix  W.L Aug 15 2006</span>
<span class="comments">;       Free-up pointers after calling TBINFO  W.L. Mar 2007</span>
<span class="comments">;       Add table format capability  W.L. Mar 2010</span>
<span class="comments">;       Add NUM_HEADER_LINE keyword  P. Broos Apr 2010</span>
<span class="comments">;-</span>
 On_error,2
 compile_opt idl2

 if N_params() LT 2 then begin
   print,'Syntax -  TBPRINT, h, tab, [ columns, rows, device, '
   print,'              TEXTOUT= ,FMT=, NUM_HEADER_LINES= '
   return
 endif

<span class="comments">; set default parameters</span>

 if N_elements(columns) EQ 0 then columns = -1
 if N_elements(rows) EQ 0 then rows= -1
 if not keyword_set(textout) then textout = 1
 if N_elements(nval_per_line) EQ 0 then $
     nval_per_line = 6     <span class="comments">;Number of  values that can be displayed in 'table' format</span>
 
 nbytes = [1,2,4,4,8,8,1,0,16]
 fmt_def = ['','I4','I8','I12','G13.6','G16.8','','A','','','','']

<span class="comments">; make sure rows is a vector</span>

 sz = size(tab)
 nrows = sz[2]
 r = long(rows)
 if r[0] eq -1 then r = lindgen(nrows)          <span class="comments">;default</span>
 n = N_elements(r)
 dotable = n EQ 1         <span class="comments">;Print in table format?</span>

<span class="comments">; Did user supply a FITS header, or a structure (output of tbinfo)?</span>

 case  size(hdr_or_tbstr,/type) of 
 7: tbinfo,hdr_or_tbstr,tb_str
 8: tb_str = hdr_or_tbstr
 else: message,'ERROR - Invalid FITS header or structure supplied' 
 endcase 
 
 tfields = N_elements(tb_str.ttype)

<span class="comments">; if columns is a string, change it to string array</span>

 if size(columns,/tname) eq 'STRING' then begin
        if columns[0] EQ '*' then begin       
	colnum = indgen(tfields) + 1 
	numcol = tfields
	dotable = 1 
	endif else begin 
        colnames = strsplit(columns,',',/extract) 
        numcol = N_elements(colnames) 
        colnum = intarr(numcol)
        field = strupcase(colnames)
        for i = 0,numcol-1 do begin 
        colnum[i] = where(strupcase(tb_str.ttype) EQ field[i],nfound) + 1
        if nfound EQ 0 then $ 
           message,'Field '+ field[i] + ' not found in header'
       endfor
       endelse
   endif else begin                       <span class="comments">;user supplied vector</span>
        colnum = fix(columns)           <span class="comments">;make sure it is integer</span>
        if colnum[0] eq -1 then colnum = indgen(tfields) + 1 
        numcol = N_elements(colnum)     <span class="comments">;number of elements</span>
 endelse

 if ~keyword_set(fmt) then form = tb_str.tdisp[colnum-1] else begin
        if N_elements(fmt) EQ 1 and (numcol GT 1) then begin
                temp = strupcase(strtrim(fmt,2))
                if strmid(temp,0,1) EQ '(' then $
                        temp = strmid(temp,1,strlen(temp)-2)
                        form = strarr(numcol)
                        ifmt = 0
                         while strtrim(temp,2) NE ''  do begin
                                tstform = gettok(temp,',')
                                ndup = 1
                                vtype = strmid(tstform,0,1)
                                if strnumber(vtype,val) then begin
                                        ndup = val
                                        tstform = strmid(tstform,1,100)
                                endif
                                if strpos(tstform,'X') LT 0 then begin
                                     form[ifmt:ifmt+ndup-1]=tstform
                                     ifmt = ifmt + ndup
                                endif
                        endwhile
        endif else form = fmt
 endelse

 default = where(form EQ '',Ndef)
 if Ndef GT 0 then form[default] = fmt_def[ tb_str.idltype[colnum[default]-1] ]
  form = strtrim(form,2)
 row_format = strjoin(form,',1x,')

 num = where(tb_str.idltype[colnum-1] NE 7, Nnumeric)
 if Nnumeric GT 0 then minnumval = min(tb_str.numval[colnum[num]-1]) $
 else minnumval = 1

 if (minnumval GT 1) then begin 
        if rows[0] NE -1 then nrow1 = N_elements(rows)-1 else begin
                rows = lindgen(minnumval)
                nrow1 = minnumval-1
        endelse
        
 endif

 textopen,'TBPRINT', TEXTOUT = textout

 field = tb_str.ttype[colnum-1]
  fieldlen = strlen(field)

<span class="comments">;Print in table format?</span>
  dotable = dotable || (n EQ 1)  && (minnumval LE nval_per_line)   
  if dotable then begin 
  maxlen = max(fieldlen)
  
  for j = 0, n-1 do begin 
  printf,!TEXTUNIT,'ROW: ',r[j]
  for i = 0, numcol-1 do begin
      val =  tbget(tb_str,tab,colnum[i],r[j])
      nval = N_elements(val)
      if nval GT 1 then begin            <span class="comments">;Print up to 5 values</span>
           val = strcompress(strjoin(val[0:(nval-1)&lt<span class="comments">; (nval_per_line-1)],' '))</span>
	   if nval GT nval_per_line then val = val + '...'
      endif	   
      printf,!TEXTUNIT, colnum[i],') ', field[i],strtrim(string(val,/pr),2),$
          f='(i3,A,A-' + strtrim(maxlen+2,2) + ',A)'
  endfor
     printf,!TEXTUNIT, ' '
  endfor

  endif else begin     
 

 varname = 'v' + strtrim(sindgen(numcol)+1,2)
 len = lonarr(numcol)
 varstr = varname + '[0]'
 xform = '(' + form + ')'
 for i = 0,numcol-1 do begin
        result = execute(varname[i] + '= tbget(tb_str,tab,colnum[i],r)' )
        result = execute('len[i] = strlen(string(' + varstr[i] + ',f=xform[i]))')
 endfor
 
 
 if keyword_set(num_header_lines) then begin
   <span class="comments">;; Build a multi-line header showing the column names left-justified.</span>
   header = strarr(num_header_lines+1)
   
<span class="comments">; The printed data columns are separated by a space, so the column widths are actually (len+1).</span>
   column_width = len + 1
   for ii=0,numcol-1 do begin
     header_ind = ii MOD num_header_lines
     
     <span class="comments">; Pad the start of the header lines as needed.</span>
     if ((ii GT 0) && (ii LT num_header_lines)) then header[header_ind] += string(replicate(32B, total(column_width[0:ii-1], /INT)))
     
     if ((ii+num_header_lines) LT numcol) then begin
       <span class="comments">; The space we have to print this label is the width of the next num_header_lines columns, minus one space for the '|' separator..</span>
       <span class="comments">; Put the label at the LEFT end of this space.</span>
       label_length = total(column_width[ii : ii+num_header_lines-1], /INT) - 1
       label_format_code  = string(label_length, F='(%"|%%-%ds")')
     endif else begin
       <span class="comments">; We're at the end of the header line, so print this last label without truncation.</span>
       label_format_code  = '|%s'
     endelse
     header[header_ind] += string(field[ii], F='(%"'+label_format_code+'")')
   endfor <span class="comments">; ii</span>
   
   printf,!TEXTUNIT, "# FORMAT='" + row_format + "'"
   printf,!TEXTUNIT, 3+num_header_lines+1, strjoin(field,','), F='(%"# readfmt, ''table.txt'', SKIPLINE=%d, FORMAT, %s")' 
   printf,!TEXTUNIT, "#"

   header[num_header_lines] = string(replicate(byte('-'), max(strlen(header))))
   strput, header, '#', 0
   forprint, TEXTOUT=5, header, /NoComment
   
 endif else begin
   <span class="comments">;; Build a single-line header showing the column names centered on the columns.</span>
   field = strtrim(tb_str.ttype[colnum-1],2)
   fieldlen = strlen(field)
   for i=0,numcol-1 do begin
          if fieldlen[i] LT len[i] then begin
            space = len[i] - fieldlen[i]
      if space EQ 1 then field[i] = field[i]+ ' ' else begin
                     pad = string(replicate(32b,space/2))
                     field[i] = pad + field[i] + pad
         if space mod 2 EQ 1 then field[i] = field[i] + ' '
      endelse   
          endif else field[i] = strmid(field[i],0,len[i])
   endfor
   printf,!TEXTUNIT,field
 endelse
 
 
 if size(hdr_or_tbstr,/TYPE) NE 8  then begin
       ptr_free, tb_str.tscal
       ptr_free, tb_str.tzero
 endif



<span class="comments">; If there are multiple values then only print the first value....</span>

  if minnumval EQ 1 then begin        
       index = replicate('[i]',numcol)
       g = where( tb_str.numval[colnum-1] GT 1,Ng) 
       if Ng GT 0 then index[g] = '[0,i]'  
       vstring  = strjoin(varname + index,',')
  endif else  vstring = strjoin(varname + '[i]',',') 

 row_format = '(' + row_format + ')'

 if minnumval EQ 1 then $
 result = execute('for i=0,n-1 do printf,!TEXTUNIT,' +  $
                   vstring + ',f=row_format') else $
 result = execute('for i=rows[0],rows[nrow1] do printf,!TEXTUNIT,' +  $
                   vstring + ',f=fmt') 
 endelse		   
 textclose, TEXTOUT = textout
 return
 end
</code>
    </div>
  </body>
</html>