<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:08 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tbinfo.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tbinfo.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="tbinfo:source"></a>pro tbinfo,h,tb_str, errmsg = errmsg, NOSCALE= noscale
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       TBINFO</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Return an informational IDL structure from a FITS binary table header.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       tbinfo, h, tb_str, [ERRMSG = ]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       h - FITS binary table header, e.g. as returned by READFITS()</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       tb_str - IDL structure with extracted info from the FITS binary table</span>
<span class="comments">;               header.   Tags include</span>
<span class="comments">;       .tbcol - starting column position in bytes, integer vector</span>
<span class="comments">;       .width - width of the field in bytes, integer vector</span>
<span class="comments">;       .idltype - idltype of field, byte vector</span>
<span class="comments">;               7 - string, 4- real*4, 3-integer*4, 5-real*8</span>
<span class="comments">;       .numval - repeat count, longword vector</span>
<span class="comments">;       .tunit - string unit numbers, string vector</span>
<span class="comments">;       .tnull - integer null value for the field, stored as a string vector</span>
<span class="comments">;                 so that an empty string indicates that TNULL is not present</span>
<span class="comments">;       .tform - format for the field, string vector</span>
<span class="comments">;       .ttype - field name, string vector</span>
<span class="comments">;       .maxval- maximum number of elements in a variable length array, long</span>
<span class="comments">;               vector</span>
<span class="comments">;       .tscal - pointer array giving the scale factor for converting to </span>
<span class="comments">;                physical values, default 1.0</span>
<span class="comments">;       .tzero - pointer array giving the additive offset for converting to </span>
<span class="comments">;                physical values, default 0.0</span>
<span class="comments">;       .tdisp - recommended output display format</span>
<span class="comments">;</span>
<span class="comments">;       All of the output vectors will have same number of elements, equal</span>
<span class="comments">;       to the number of columns in the binary table.</span>
<span class="comments">;</span>
<span class="comments">;       The .tscal and .tzero values are stored as pointers so as to preserve</span>
<span class="comments">;       the individual data types (e.g. float or double) which may differ </span>
<span class="comments">;       in different columns.   For example, to obtain the value of TSCAL for</span>
<span class="comments">;       the third column use *tab_str.tscal[2]  </span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       /NOSCALE - if set, then the TSCAL* and TZERO* keywords are not extracted</span>
<span class="comments">;            from the FITS header, and the .tscal and .tzero pointers do not</span>
<span class="comments">;            appear in the output structure.</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;        ERRMSG = if present, then error messages are returned in this keyword</span>
<span class="comments">;            rather than displayed using the MESSAGE facility </span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       SXPAR()</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       For variable length ('P' format) column, TBINFO returns values for</span>
<span class="comments">;       reading the 2 element longward array of pointers (numval=2, </span>
<span class="comments">;       idltype = 3, width=4)</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Major rewrite to return a structure      W. Landsman   August 1997</span>
<span class="comments">;       Added "unofficial" 64 bit integer "K" format W. Landsamn Feb. 2003</span>
<span class="comments">;       Store .tscal and .tzero tags as pointers, so as to preserve </span>
<span class="comments">;       type information   W. Landsman          April 2003</span>
<span class="comments">;       Treat repeat count for string as specifying string length, not number</span>
<span class="comments">;          of elements, added ERRMSG    W. Landsman        July 2006</span>
<span class="comments">;       Treat logical as character string 'T' or 'F' W. Landsman  October 2006</span>
<span class="comments">;       Added NOSCALE keyword  W. Landsman   March 2007</span>
<span class="comments">;-</span>
<span class="comments">;----------------------------------------------------------------------------</span>
 On_error,2
 compile_opt idl2
 if N_params() LT 2 then begin
        print,'Syntax - TBINFO, h, tb_str, [ERRMSG=, /NOSCALE]'
        return
 endif
 save_err = arg_present(errmsg)

<span class="comments">; get number of fields</span>

 tfields = sxpar( h, 'TFIELDS', COUNT = N_TFields)
 if N_TFields EQ 0 then begin    <span class="comments">;Legal Binary Table Header?</span>
        errmsg = 'Invalid FITS binary table header. keyword TFIELDS is missing'
	if not save_err then message,errmsg else return
   endif	    

 if tfields EQ 0 then begin     <span class="comments">;Any fields in table?</span>
        errmsg = 'No Columns in FITS binary table, keyword TFIELDS = 0'
	if not save_err then message,errmsg else return
  endif	    
 
<span class="comments">; Create output arrays with default values</span>

 idltype = intarr(tfields) & tnull = idltype
 numval = lonarr(tfields) & tbcol = numval & width = numval & maxval = numval
 tunit = replicate('',tfields) & ttype = tunit & tdisp = tunit & tnull = tunit

 type = sxpar(h,'TTYPE*', COUNT = N_ttype)
 if N_ttype GT 0 then ttype[0] = strtrim(type,2) 

 tform = strtrim( sxpar(h,'tform*', COUNT = N_tform), 2)     <span class="comments">; column format</span>
 if N_tform EQ 0 then $
        message,'Invalid FITS table header -- keyword TFORM not present'

 tform =  strupcase(strtrim(tform,2))
                                                
 unit = strtrim(sxpar(h, 'TUNIT*', COUNT = N_tunit),2)     <span class="comments">;physical units</span>
 if N_tunit GT 0 then tunit[0] = unit

 null = sxpar(h, 'TNULL*', COUNT = N_tnull)      <span class="comments">;null data value</span>
 if N_tnull GT 0 then tnull[0] = null

 if not keyword_set(noscale) then begin
  tscal = ptrarr(tfields,/all)
  tzero = ptrarr(tfields,/all)
  index = strtrim(indgen(tfields)+1,2)
  for i=0,tfields-1 do begin
    scale = sxpar(h,'TSCAL' + index[i], COUNT = N_tscal)     <span class="comments">;Scale factor</span>
    if N_tscal GT 0 then *tscal[i] = scale else *tscal[i] = 1.0
    zero = sxpar(h,'TZERO' + index[i], Count = N_tzero)
    if N_tzero GT 0 then *tzero[i] = zero else *tzero[i] = 0
  endfor
 endif  

 disp = sxpar(h,'TDISP*', COUNT = N_tdisp)       <span class="comments">;Display format string</span>
 if N_tdisp GT 0 then tdisp[0] = disp

<span class="comments">; determine idl data type from format</span>

 len = strlen(tform)

 for i = 0, N_elements(tform)-1 do begin

<span class="comments">; Step through each character in the format, until a non-numerical character</span>
<span class="comments">; is encountered</span>

        ichar = 0
NEXT_CHAR:
        if ichar GE len[i] then message, $
           'Invalid format specification for keyword TFORM ' + strtrim(i+1)
        char = strupcase( strmid(tform[i],ichar,1) )
        if ( (char GE '0') and ( char LE '9')) then begin
                ichar = ichar + 1
                goto, NEXT_CHAR
        endif

        if ichar EQ 0 then numval[i] = 1 else $
        numval[i] = strmid( tform[i], 0, ichar )

        if char EQ "P" then begin            <span class="comments">;Variable length array?</span>
                char = strupcase( strmid(tform[i],ichar+1,1) )
                maxval[i] = long( strmid(tform[i],ichar+3, len[i]-ichar-4) )
                width[i] = 4  & numval[i] = 2  & idltype[i] = 3
        endif else begin

        tform[i] =  char

        case strupcase( tform[i] ) of

        'A' : begin 
	      idltype[i] = 7 &  width[i] = numval[i] & numval[i]=1 
	      end
        'I' : begin & idltype[i] = 2 &  width[i] = 2 &  end
        'J' : begin & idltype[i] = 3 &  width[i] = 4 &  end
        'E' : begin & idltype[i] = 4 &  width[i] = 4 &  end
        'D' : begin & idltype[i] = 5 &  width[i] = 8 &  end
        'L' : begin & idltype[i] = 7 &  width[i] = 1 &  end
        'B' : begin & idltype[i] = 1 &  width[i] = 1 &  end
        'C' : begin & idltype[i] = 6 &  width[i] = 8 &  end
        'M' : begin & idltype[i] = 9 &  width[i] =16 &  end
        'K' : begin & idltype[i] = 14 & width[i] = 8 &  end
<span class="comments">;  Treat bit arrays as byte arrays with 1/8 the number of elements.</span>

        'X' : begin
              idltype[i] = 1
              numval[i] = long((numval[i]+7)/8)
              width[i] = 1
              end

        else : message,'Invalid format specification for keyword ' + $
                        'TFORM'+ strtrim(i+1,2)
 endcase
 endelse

 if i ge 1 then tbcol[i] = tbcol[i-1] + width[i-1]*numval[i-1]

 endfor
 if keyword_set(noscale) then $ 

  tb_str = {TBCOL:tbcol,WIDTH:width,IDLTYPE:idltype,NUMVAL:numval,TUNIT:tunit,$
           TNULL:tnull,TFORM:tform,TTYPE:ttype,MAXVAL:maxval, TDISP:tdisp} $
 else $
 
 tb_str = {TBCOL:tbcol,WIDTH:width,IDLTYPE:idltype,NUMVAL:numval,TUNIT:tunit,$
           TNULL:tnull,TFORM:tform,TTYPE:ttype,MAXVAL:maxval, TSCAL:tscal, $
           TZERO:tzero, TDISP:tdisp}
 return
 end
</code>
    </div>
  </body>
</html>