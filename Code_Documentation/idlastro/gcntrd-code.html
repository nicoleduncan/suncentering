<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:38 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gcntrd.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gcntrd.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="gcntrd:source"></a>pro gcntrd,img,x,y,xcen,ycen,fwhm, maxgood = maxgood, keepcenter=keepcenter, $
                SILENT = silent, DEBUG = debug

<span class="comments">;+</span>
<span class="comments">;  NAME: </span>
<span class="comments">;       GCNTRD</span>
<span class="comments">;  PURPOSE:</span>
<span class="comments">;       Compute the stellar centroid by Gaussian fits to marginal X,Y, sums </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       GCNTRD uses the DAOPHOT "FIND" centroid algorithm by fitting Gaussians</span>
<span class="comments">;       to the marginal X,Y distributions.     User can specify bad pixels </span>
<span class="comments">;       (either by using the MAXGOOD keyword or setting them to NaN) to be</span>
<span class="comments">;       ignored in the fit.    Pixel values are weighted toward the center to</span>
<span class="comments">;       avoid contamination by neighboring stars. </span>
<span class="comments">;</span>
<span class="comments">;  CALLING SEQUENCE: </span>
<span class="comments">;       GCNTRD, img, x, y, xcen, ycen, [ fwhm , /SILENT, /DEBUG, MAXGOOD = ,</span>
<span class="comments">;                            /KEEPCENTER ]</span>
<span class="comments">;</span>
<span class="comments">;  INPUTS:     </span>
<span class="comments">;       IMG - Two dimensional image array</span>
<span class="comments">;       X,Y - Scalar or vector integers giving approximate stellar center</span>
<span class="comments">;</span>
<span class="comments">;  OPTIONAL INPUT:</span>
<span class="comments">;       FWHM - floating scalar; Centroid is computed using a box of half</span>
<span class="comments">;               width equal to 1.5 sigma = 0.637* FWHM.  GCNTRD will prompt</span>
<span class="comments">;               for FWHM if not supplied</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUTS:   </span>
<span class="comments">;       XCEN - the computed X centroid position, same number of points as X</span>
<span class="comments">;       YCEN - computed Y centroid position, same number of points as Y</span>
<span class="comments">;</span>
<span class="comments">;       Values for XCEN and YCEN will not be computed if the computed</span>
<span class="comments">;       centroid falls outside of the box, or if there are too many bad pixels,</span>
<span class="comments">;       or if the best-fit Gaussian has a negative height.   If the centroid </span>
<span class="comments">;       cannot be computed, then a  message is displayed (unless /SILENT is </span>
<span class="comments">;       set) and XCEN and YCEN are set to -1.</span>
<span class="comments">;</span>
<span class="comments">;  OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       MAXGOOD=  Only pixels with values less than MAXGOOD are used to in</span>
<span class="comments">;               Gaussian fits to determine the centroid.    For non-integer</span>
<span class="comments">;               data, one can also flag bad pixels using NaN values.</span>
<span class="comments">;       /SILENT - Normally GCNTRD prints an error message if it is unable</span>
<span class="comments">;               to compute the centroid.   Set /SILENT to suppress this.</span>
<span class="comments">;       /DEBUG - If this keyword is set, then GCNTRD will display the subarray</span>
<span class="comments">;               it is using to compute the centroid.</span>
<span class="comments">;       /KeepCenter  By default, GCNTRD first convolves a small region around </span>
<span class="comments">;              the supplied position with a lowered Gaussian filter, and then </span>
<span class="comments">;              finds the maximum pixel in a box centered on the input X,Y </span>
<span class="comments">;              coordinates, and then extracts a new box about this maximum </span>
<span class="comments">;              pixel.   Set the /KeepCenter keyword  to skip the convolution </span>
<span class="comments">;              and finding the maximum pixel, and instead use a box </span>
<span class="comments">;              centered on the input X,Y coordinates.                          </span>
<span class="comments">;  PROCEDURE: </span>
<span class="comments">;       Unless /KEEPCENTER is set, a small area around the initial X,Y is </span>
<span class="comments">;       convolved with a Gaussian kernel, and the maximum pixel is found.</span>
<span class="comments">;       This pixel is used as the  center of a square, within </span>
<span class="comments">;       which the centroid is computed as the Gaussian least-squares fit</span>
<span class="comments">;       to the  marginal sums in the X and Y directions. </span>
<span class="comments">;</span>
<span class="comments">;  EXAMPLE:</span>
<span class="comments">;       Find the centroid of a star in an image im, with approximate center</span>
<span class="comments">;       631, 48.    Assume that bad (saturated) pixels have a value of 4096 or</span>
<span class="comments">;       or higher, and that the approximate FWHM is 3 pixels.</span>
<span class="comments">;</span>
<span class="comments">;       IDL> GCNTRD, IM, 631, 48, XCEN, YCEN, 3, MAXGOOD = 4096       </span>
<span class="comments">;  MODIFICATION HISTORY:</span>
<span class="comments">;       Written June 2004, W. Landsman  following algorithm used by P. Stetson </span>
<span class="comments">;             in DAOPHOT2.</span>
<span class="comments">;       Modified centroid computation (as in IRAF/DAOFIND) to allow shifts of</span>
<span class="comments">;      more than 1 pixel from initial guess.    March 2008</span>
<span class="comments">;      First perform Gaussian convolution prior to finding maximum pixel </span>
<span class="comments">;      to smooth out noise  W. Landsman  Jan 2009</span>
<span class="comments">;-      </span>
 On_error,2 
 compile_opt idl2

 if N_params() LT 5 then begin
        print,'Syntax: GCNTRD, img, x, y, xcen, ycen, [ fwhm, ' 
        print,'              /KEEPCENTER, /SILENT, /DEBUG, MAXGOOD= ]'
        PRINT,'img - Input image array'
        PRINT,'x,y - Input scalar integers giving approximate X,Y position'
        PRINT,'xcen,ycen - Output scalars giving centroided X,Y position'
        return
 endif else if N_elements(fwhm) NE 1 then $
      read,'Enter approximate FWHM of image in pixels: ',fwhm


 sz_image = size(img)
 if sz_image[0] NE 2 then message, $
   'ERROR - Image array (first parameter) must be 2 dimensional'

 xsize = sz_image[1]
 ysize = sz_image[2]
 dtype = sz_image[3]
 npts = N_elements(x) 
 maxbox = 13
 radius = 0.637*FWHM > 2.001             <span class="comments">;Radius is 1.5 sigma</span>
 radsq = radius^2
 sigsq = ( fwhm/2.35482 )^2
 nhalf = fix(radius) &lt<span class="comments">; (maxbox-1)/2   	;</span>
 nbox = 2*nhalf +1 	<span class="comments">;# of pixels in side of convolution box </span>

 xcen = x*0. - 1 & ycen = y*0 - 1.
 ix = round(x)          <span class="comments">;Central X pixel        </span>
 iy = round(y)          <span class="comments">;Central Y pixel</span>

<span class="comments">;Create the Gaussian convolution kernel in variable "g"</span>
 mask = bytarr( nbox, nbox )   <span class="comments">;Mask identifies valid pixels in convolution box </span>
  g = fltarr( nbox, nbox )      
 row2 = (findgen(Nbox)-nhalf)^2
 g[0,nhalf] = row2
  for i = 1, nhalf do begin
	temp = row2 + i^2
	g[0,nhalf-i] = temp         
        g[0,nhalf+i] = temp
 endfor
 mask = fix(g LE radsq)
 good = where( mask, pixels)  <span class="comments">;Value of c are now equal to distance to center</span>
   g = exp(-0.5*g/sigsq)	<span class="comments">;Make g into a Gaussian kernel</span>

<span class="comments">; In fitting Gaussians to the marginal sums, pixels will arbitrarily be </span>
<span class="comments">; assigned weights ranging from unity at the corners of the box to </span>
<span class="comments">; NHALF^2 at the center (e.g. if NBOX = 5 or 7, the weights will be</span>
<span class="comments">;</span>
<span class="comments">;                                 1   2   3   4   3   2   1</span>
<span class="comments">;      1   2   3   2   1          2   4   6   8   6   4   2</span>
<span class="comments">;      2   4   6   4   2          3   6   9  12   9   6   3</span>
<span class="comments">;      3   6   9   6   3          4   8  12  16  12   8   4</span>
<span class="comments">;      2   4   6   4   2          3   6   9  12   9   6   3</span>
<span class="comments">;      1   2   3   2   1          2   4   6   8   6   4   2</span>
<span class="comments">;                                 1   2   3   4   3   2   1</span>
<span class="comments">;</span>
<span class="comments">; respectively).  This is done to desensitize the derived parameters to </span>
<span class="comments">; possible neighboring, brighter stars.</span>


 x_wt = fltarr(nbox,nbox)
 wt = nhalf - abs(findgen(nbox)-nhalf ) + 1
 for i=0,nbox-1 do x_wt[0,i] = wt
 y_wt = transpose(x_wt) 
 pos = strtrim(x,2) + ' ' + strtrim(y,2)

if ~keyword_set(Keepcenter) then begin 
<span class="comments">; Precompute convolution kernel</span>
 c = g*mask          <span class="comments">;Convolution kernel now in c      </span>
 sumc = total(c)
 sumcsq = total(c^2) - sumc^2/pixels
 sumc = sumc/pixels
 c[good] = (c[good] - sumc)/sumcsq
endif

 for i = 0,npts-1 do begin        <span class="comments">;Loop over number of points to centroid</span>

 if ~keyword_set(keepcenter) then begin
 if ( (ix[i] LT nhalf) || ((ix[i] + nhalf) GT xsize-1) || $
      (iy[i] LT nhalf) || ((iy[i] + nhalf) GT ysize-1) ) then begin
     if ~keyword_set(SILENT) then message,/INF, $
           'Position '+ pos[i] + ' too near edge of image'
     goto, DONE
 endif
 x1 = (ix[i]-nbox) > 0 
 x2 = (ix[i] + nbox) &lt<span class="comments">; (xsize-1)</span>
 y1 = (iy[i]-nbox)  > 0
 y2 = (iy[i] + nbox) &lt<span class="comments">; (ysize-1)  </span>
 h = img[x1:x2, y1:y2]
 h = convol(float(h), c)
 h= h[ nbox-nhalf: nbox + nhalf, nbox -nhalf: nbox + nhalf]
 d= img[ix[i]-nhalf: ix[i]+nhalf, iy[i]-nhalf:iy[i]+nhalf]

 if N_elements(maxgood) GT 0 then begin
     ig = where(d lt maxgood, Ng)
     mx = max(d[ig],/nan)
 endif
 mx = max( h,/nan)     <span class="comments">;Maximum pixel value in BIGBOX</span>

 mx_pos = where(h EQ mx, Nmax) <span class="comments">;How many pixels have maximum value?</span>
 idx = mx_pos mod nbox          <span class="comments">;X coordinate of Max pixel</span>
 idy = mx_pos / nbox          <span class="comments">;Y coordinate of Max pixel</span>
 if NMax GT 1 then begin        <span class="comments">;More than 1 pixel at maximum?</span>
     idx = round(total(idx)/Nmax)
     idy = round(total(idy)/Nmax)
 endif else begin
     idx = idx[0]
     idy = idy[0]
 endelse
  xmax = ix[i] - (nhalf) + idx    <span class="comments">;X coordinate in original image array</span>
  ymax = iy[i] - (nhalf) + idy    <span class="comments">;Y coordinate in original image array</span>
  endif else begin
    xmax = ix[i]
    ymax = iy[i]
 endelse

<span class="comments">; ---------------------------------------------------------------------</span>
<span class="comments">; check *new* center location for range</span>
<span class="comments">; added by Hogg</span>

 if ( (xmax LT nhalf) || ((xmax + nhalf) GT xsize-1) || $
      (ymax LT nhalf) || ((ymax + nhalf) GT ysize-1) ) then begin
     if ~keyword_set(SILENT) then message,/INF, $
           'Position '+ pos[i] + ' moved too near edge of image'
     xcen[i] = -1   & ycen[i] = -1
     goto, DONE
 endif
<span class="comments">; ---------------------------------------------------------------------</span>

<span class="comments">;  Extract  subimage centered on maximum pixel </span>

 d = img[xmax-nhalf : xmax+nhalf, ymax-nhalf : ymax+nhalf]
 

 if keyword_set(DEBUG) then begin
       message,'Subarray used to compute centroid:',/inf
       imlist,img,xmax,ymax,dx = nbox,dy=nbox
 endif  

 if N_elements(maxgood) GT 0 then $ 
           mask = (d lt maxgood) else $
   if (dtype eq 4) || (dtype EQ 5) then mask = finite(d) else $ 
           mask = replicate(1b, nbox, nbox)
  maskx = total(mask,2) GT 0
  masky = total(mask,1) GT 0

<span class="comments">; At least 3 points are needed in the partial sum to compute the Gaussian</span>

  if (total(maskx) LT 3) || (total(masky) LT 3) then begin
  if ~keyword_set(SILENT) then message,/INF, $
	'Position '+ pos[i] + ' has insufficient good points'
	 goto, DONE
  endif
  
  ywt = y_wt*mask
  xwt = x_wt*mask
  wt1 = wt*maskx
  wt2 = wt*masky
  
<span class="comments">; Centroid computation:   The centroid computation was modified in Mar 2008 and</span>
<span class="comments">; now differs from DAOPHOT which multiplies the correction dx by 1/(1+abs(dx)). </span>
<span class="comments">; The DAOPHOT method is more robust (e.g. two different sources will not merge)</span>
<span class="comments">; especially in a package where the centroid will be subsequently be </span>
<span class="comments">; redetermined using PSF fitting.   However, it is less accurate, and introduces</span>
<span class="comments">; biases in the centroid histogram.   The change here is the same made in the </span>
<span class="comments">; IRAF DAOFIND routine (see </span>
<span class="comments">; http://iraf.net/article.php?story=7211&query=daofind )</span>

 sd = total(d*ywt,2,/nan)
 sg = total(g*ywt,2)
 sumg = total(wt1*sg)
 sumgsq = total(wt1*sg*sg)
 
 sumgd = total(wt1*sg*sd)
 sumgx = total(wt1*sg)
 sumd = total(wt1*sd)
 p = total(wt1)
 xvec = nhalf - findgen(nbox) 
 dgdx = sg*xvec
 sdgdxs = total(wt1*dgdx^2)
 sdgdx = total(wt1*dgdx) 
 sddgdx = total(wt1*sd*dgdx)
 sgdgdx = total(wt1*sg*dgdx)

 hx = (sumgd - sumg*sumd/p) / (sumgsq - sumg^2/p)

<span class="comments">; HX is the height of the best-fitting marginal Gaussian.   If this is not</span>
<span class="comments">; positive then the centroid does not make sense </span>

  if (hx LE 0) then begin
  if ~keyword_set(SILENT) then message,/INF, $
	'Position '+ pos[i] + ' cannot be fit by a Gaussian'
	 xcen[i] = -1	& ycen[i] = -1
	 goto, DONE
  endif

 skylvl = (sumd - hx*sumg)/p
 dx = (sgdgdx - (sddgdx-sdgdx*(hx*sumg + skylvl*p)))/(hx*sdgdxs/sigsq)
  if (abs(dx) GE nhalf) then begin
  if ~keyword_set(SILENT) then message,/INF, $
	'Position '+ pos[i] + ' is too far from initial guess'
	 goto, DONE
  endif


 
 xcen[i] = xmax + dx    <span class="comments">;X centroid in original array</span>


<span class="comments">;Now repeat computation for Y centroid</span>

 sd = total(d*xwt,1,/nan)
 sg = total(g*xwt,1)
 sumg = total(wt2*sg)
 sumgsq = total(wt2*sg*sg)
 
 sumgd = total(wt2*sg*sd)
 sumd = total(wt2*sd)
 p = total(wt2)

 yvec = nhalf - findgen(nbox) 
 dgdy = sg*yvec
 sdgdys = total(wt2*dgdy^2)
 sdgdy = total(wt2*dgdy) 
 sddgdy = total(wt2*sd*dgdy)
 sgdgdy = total(wt2*sg*dgdy)

 hy = (sumgd - sumg*sumd/p) / (sumgsq - sumg^2/p)

  if (hy LE 0) then begin
  if ~keyword_set(SILENT) then message,/INF, $
	'Position '+ pos[i] + ' cannot be fit by a Gaussian'
	 goto, DONE
  endif

 skylvl = (sumd - hy*sumg)/p
 dy = (sgdgdy - (sddgdy-sdgdy*(hy*sumg + skylvl*p)))/(hy*sdgdys/sigsq)
  if (abs(dy) GE nhalf) then begin
  if ~keyword_set(SILENT) then message,/INF, $
	'Position '+ pos[i] + ' is too far from initial guess'
	 goto, DONE
  endif
 ycen[i] = ymax + dy    <span class="comments">;Y centroid in original array</span>
DONE:

 endfor

return
end
</code>
    </div>
  </body>
</html>