<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbfind_entry.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbfind_entry.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbfind_entry:source"></a>pro dbfind_entry,type,svals,nentries,values,Count = count
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBFIND_ENTRY</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Subroutine of DBFIND to perform an entry number search </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This is a subroutine of dbfind and is not a standalone procedure</span>
<span class="comments">;       It performs a entry number search.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       dbfind_entry, type, svals, nentries, values, [COUNT = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS: </span>
<span class="comments">;       type - type of search (output from dbfparse)</span>
<span class="comments">;       svals - search values (output from dbfparse)</span>
<span class="comments">;       values - array of values to search</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       good - indices of good values</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       Count - integer scalar giving the number of valid matches</span>
<span class="comments">; SIDE EFFECTS"</span>
<span class="comments">;       The obsolete system variable !err is set to number of good values</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       D. Lindler  July,1987</span>
<span class="comments">;       Fixed test for final entry number  W. Landsman    Sept. 95       </span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Added COUNT keyword, deprecate !ERR  W. Landsman   March 2000</span>
<span class="comments">;       Better checking of out of range values  W. Landsman February 2002</span>
<span class="comments">;-</span>
sv0=long(strtrim(svals[0],2)) & sv1=long(strtrim(svals[1],2))

if values[0] eq -1 then begin           <span class="comments">;start with all entries</span>
    case type of

         0:  begin
                if (sv0 gt 0) and (sv0 le nentries) then begin  <span class="comments">;Update Sep 95</span>
                        values=lonarr(1)+sv0
                        count=1
                   end else count= 0
             end
        -1: begin
                 if nentries LT sv0 then count = 0 else begin
                    values=lindgen(nentries-sv0+1) + sv0   <span class="comments">;value>sv0</span>
                    count=nentries-sv0+1
                 endelse
            end
        -2: begin
                values= lindgen(sv1>1&lt<span class="comments">;nentries)+1       ;value&lt;sv1</span>
                count=sv1>1&lt<span class="comments">;nentries</span>
            end
        -3: begin                                       <span class="comments">;sv0&lt;value&lt;sv1</span>
            if sv1 lt sv0 then begin
                temp=sv0
                sv0=sv1
                sv1=temp
            end
            if (sv1 LT 1) or (sv0 GT nentries) then count = 0 else begin
               sv0=sv0>1
               sv1=sv1&lt<span class="comments">;nentries</span>
               values=lindgen(sv1-sv0+1)+sv0
               count=sv1-sv0+1
            endelse 
            end         
        -5: begin                               <span class="comments">;sv1 is tolerance</span>
            minv=(sv0-abs(sv1))>1
            maxv=(sv0+abs(sv1))&lt<span class="comments">;nentries</span>
            values=lindgen(maxv-minv+1)+minv
            count=maxv-minv+1
            end
        -4:                                     <span class="comments">;non-zero</span>
        else: begin                             <span class="comments">;set of values</span>
              sv=lonarr(type)
              for i=0L,type-1 do sv[i]=long(strtrim(svals[i],2))
              good=where((sv gt 0) and (sv le nentries), count)
              if count gt 0 then values=sv[good]
              end
    endcase
    if count GT 0 then !ERR = count else !ERR = -1
  end else begin                                        <span class="comments">;input list supplied</span>
    case type of
 
        0:  good=where(values eq sv0, count)            <span class="comments">;value=sv0</span>
        -1: good=where(values ge sv0, count)            <span class="comments">;value>sv0</span>
        -2: good=where(values le sv1, count)            <span class="comments">;value&lt;sv1</span>
        -3: begin                               <span class="comments">;sv0&lt;value&lt;sv1</span>
            if sv1 lt sv0 then begin
                temp=sv0
                sv0=sv1
                sv1=temp
            end
            good=where((values ge sv0) and (values le sv1), count)
            end         
        -5: begin                               <span class="comments">;sv1 is tolerance</span>
            minv=sv0-abs(sv1)
            maxv=sv0+abs(sv1)
            good=where((values ge minv) and (values le maxv), count)
            end
        -4: good=where(values, count)                   <span class="comments">;non-zero</span>
        else: begin                             <span class="comments">;set of values  </span>
              count=0                              <span class="comments">;number found</span>
              for i=0L,type-1 do begin          <span class="comments">;loop on possible values    </span>
                g=where(values eq long(strtrim(svals[i],2)), nfound)
                if nfound gt 0 then begin
                        if nf eq 0 then good=g else good=[good,g]
                        count = count +nfound
                end
              end
              !err=count
              end
    endcase
    if count le 0 then return
    values=values[good]
end
return
end
</code>
    </div>
  </body>
</html>