<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbfind.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbfind.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbfind:source"></a>function dbfind,spar,listin,SILENT=silent,fullstring = Fullstring,      $
        errmsg=errmsg, Count = count
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;    DBFIND()</span>
<span class="comments">; PURPOSE:      </span>
<span class="comments">;     Search data base for entries with specified characteristics</span>
<span class="comments">; EXPLANATION:  </span>
<span class="comments">;     Function to search data base for entries with specified</span>
<span class="comments">;     search characteristics.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:     </span>
<span class="comments">;     result = dbfind(spar,[ listin, /SILENT, /FULLSTRING, ERRMSG=, Count = ])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:       </span>
<span class="comments">;     spar - search_parameters (string)...each search parameter </span>
<span class="comments">;               is of the form:</span>
<span class="comments">;</span>
<span class="comments">;               option 1) min_val &lt; item_name &lt; max_val</span>
<span class="comments">;               option 2) item_name = value</span>
<span class="comments">;               option 3) item_name = [value_1, value_10]</span>
<span class="comments">;                       Note: option 3 is also the slowest.</span>
<span class="comments">;               option 4) item_name > value</span>
<span class="comments">;               option 5) item_name &lt; value</span>
<span class="comments">;               option 6) item_name = value(tolerance) ;eg. temp=25.0(5.2)</span>
<span class="comments">;               option 7) item_name                     ;must be non-zero</span>
<span class="comments">;</span>
<span class="comments">;               Multiple search parameters are separated by a comma.</span>
<span class="comments">;               eg.     'cam_no=2,14&lt;ra&lt;20'</span>
<span class="comments">;</span>
<span class="comments">;               Note: &lt; is interpreted as less than or equal.</span>
<span class="comments">;                     > is interpreted as greater than or equal.</span>
<span class="comments">;       </span>
<span class="comments">;               RA and DEC keyfields are stored as floating point numbers </span>
<span class="comments">;               in the data base may be entered as HH:MM:SEC and</span>
<span class="comments">;               DEG:MIN:SEC. Where:</span>
<span class="comments">;</span>
<span class="comments">;                       HH:MM:SEC   equals  HH + MM/60.0  + SEC/3600.</span>
<span class="comments">;                       DEG:MIN:SEC equals DEG + MIN/60.0 + SEC/3600.</span>
<span class="comments">;                       </span>
<span class="comments">;               For example:</span>
<span class="comments">;                       40:34:10.5 &lt; dec &lt; 43:25:19 , 8:22:1.0 &lt; ra &lt; 8:23:23.0</span>
<span class="comments">;</span>
<span class="comments">;               Specially encoded date/time in the data base may</span>
<span class="comments">;               be entered by  CCYY/DAY:hr:min:sec which is</span>
<span class="comments">;               interpreted as  </span>
<span class="comments">;                       CCYY*1000+DAY+hr/24.0+min/24.0/60.+sec/24.0/3600.</span>
<span class="comments">;               If a two digit year is supplied and YY GE 40 then it is </span>
<span class="comments">;               understood to refer to year 1900 +YY;  if YY LT 40 then it is </span>
<span class="comments">;               understood to refer to year 2000 +YY</span>

<span class="comments">;               For example</span>
<span class="comments">;                       1985/201:10:35:30&lt;date_time&lt;1985/302:10:33:33.4</span>
<span class="comments">;               would specify all entries between:</span>
<span class="comments">;                       year 1985 day 201 at 10:35:30 to</span>
<span class="comments">;                       day 302 at 10:33:33.4</span>
<span class="comments">;               The date/time may also be encoded as:</span>
<span class="comments">;                       DD-MMM-YEAR HH::MM:SS.SS        </span>
<span class="comments">;                       eg.  12-JUL-86 10:23:33.45</span>
<span class="comments">;               (this is the format of system variable !stime)</span>
<span class="comments">;</span>
<span class="comments">;               Multiple search parameters may be stored in a string</span>
<span class="comments">;               array (one parameter per array element) instead of</span>
<span class="comments">;               concatenating them with commas in a single string.</span>
<span class="comments">;               Example:</span>
<span class="comments">;                       input_array = strarr(2)</span>
<span class="comments">;                       input_array[0] = '14&lt;ra&lt;16'   ; 14-16 hrs of ra.</span>
<span class="comments">;                       input_array[1] = '8&lt;dec&lt;20'   ; + 8-20 deg. decl.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:       </span>
<span class="comments">;       listin - gives list of entries to be searched.  If not supplied or </span>
<span class="comments">;               set to -1 then all entries are searched.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:       </span>
<span class="comments">;       List of ENTRY numbers satisfying search characteristics</span>
<span class="comments">;               is returned as the function value.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:      </span>
<span class="comments">;       /SILENT  - If the keyword SILENT is set and non-zero, then DBFIND</span>
<span class="comments">;               will not print the number of entries found.</span>
<span class="comments">;</span>
<span class="comments">;       /FULLSTRING - By default, one has a match if a search string is </span>
<span class="comments">;               included in any part of a database value (substring match).   </span>
<span class="comments">;               But if /FULLSTRING is set, then all characters in the database</span>
<span class="comments">;               value must match the search string (excluding leading and </span>
<span class="comments">;               trailing blanks).    Both types of string searches are case</span>
<span class="comments">;               insensitive.</span>
<span class="comments">;</span>
<span class="comments">;       ERRMSG   = If defined and passed, then any error messages will</span>
<span class="comments">;                  be returned to the user in this parameter rather</span>
<span class="comments">;                  than depending on the MESSAGE routine in IDL.  If no</span>
<span class="comments">;                  errors are encountered, then a null string is</span>
<span class="comments">;                  returned.  In order to use this feature, ERRMSG must</span>
<span class="comments">;                  be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;                       ERRMSG = ''</span>
<span class="comments">;                       DB_ITEM, ERRMSG=ERRMSG, ...</span>
<span class="comments">;                       IF ERRMSG NE '' THEN ...;</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       COUNT - Integer scalar giving the number of valid matches</span>
<span class="comments">; PROCEDURE CALLS:</span>
<span class="comments">;       DB_INFO, DB_ITEM, DB_ITEM_INFO, DBEXT, DBEXT_IND, DBFIND_ENTRY,</span>
<span class="comments">;       DBFIND_SORT, DBFPARSE, DBRD, DBSEARCH, ZPARCHECK,IS_IEEE_BIG</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS: </span>
<span class="comments">;       The data base must be previously opened with DBOPEN.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS: </span>
<span class="comments">;       The obsolete system variable !ERR is set to number of entries found</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written     :   D. Lindler, GSFC/HRS, November 1987</span>
<span class="comments">;       Version 2, Wayne Landsman, GSFC/UIT (STX), 1 April 1994</span>
<span class="comments">;                       Added FULLSTRING keyword.</span>
<span class="comments">;       Version 3, William Thompson, GSFC, 1 April 1994</span>
<span class="comments">;                       Added check for empty database</span>
<span class="comments">;       Version 4, William Thompson, GSFC, 5 April 1994</span>
<span class="comments">;                       Changed so that !ERR is zero when database is empty,</span>
<span class="comments">;                       and LISTIN is returned, based on discussion with Wayne</span>
<span class="comments">;                       Landsman.</span>
<span class="comments">;       Version 5, Wayne Landsman, GSFC/UIT (STX), 26 May 1994</span>
<span class="comments">;                       Added error message when database is empty.</span>
<span class="comments">;       Version 6, William Thompson, GSFC, 14 March 1995</span>
<span class="comments">;                       Added FULLSTRING keyword to DBFIND_SORT call</span>
<span class="comments">;       Version 7, Richard Schwartz, GSFC/SDAC 23 August 1996</span>
<span class="comments">;                       Move external to host conversion from DBRD to</span>
<span class="comments">;                       operation on extracted values only.</span>
<span class="comments">;       Version 8, William Thompson, GSFC, 3 December 1996</span>
<span class="comments">;                       Renamed BYTESWAP variable to BSWAP--appeared to be</span>
<span class="comments">;                       conflicting with function of same name.</span>
<span class="comments">;       Version 9, William Thompson, GSFC, 17-Mar-1997</span>
<span class="comments">;                       Added keyword ERRMSG</span>
<span class="comments">;       Version 10, July, 1997  W. Landsman, added CATCH errors</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   October 1997</span>
<span class="comments">;       Update documentation for new Y2K compliant DBFPARSE W. Landsman Nov 1998</span>
<span class="comments">;       Suppress empty database message with /SILENT, W. Landsman Jan 1999</span>
<span class="comments">;       Added COUNT keyword, deprecate !ERR        W. Landsman March 2000</span>
<span class="comments">;       Added new unsigned & 64bit datatypes       W. Landsman July 2001</span>
<span class="comments">;       Fix possible floating illegand operand error W. Landsman July 2009</span>
<span class="comments">;       Change arrays to LONG to support entries >32767 bytes W.L. Oct. 2010</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<span class="comments">; ---------------------------------------------------------------------</span>

On_error,2                          <span class="comments">;return to caller</span>
<span class="comments">;</span>
<span class="comments">; Check parameters.  If LISTIN supplied, make sure all entry values are</span>
<span class="comments">; less than total number of entries.</span>
<span class="comments">;</span>
 count = 0
 zparcheck,'dbfind',spar,1,7,[0,1],'search parameters'

 catch, error_status
 if error_status NE 0 then begin 
        print,!ERR_STRING
        if N_elements(listin) NE 0 then return,listin else return, -1
 endif
 nentries = db_info( 'ENTRIES',0 )              <span class="comments">;number of entries</span>
 if ( N_params() LT 2 ) then listin = -1  else begin
      zparcheck,'dbfind',listin,2,[1,2,3],[0,1],'entry list'
      maxlist = max(listin)
      if ( maxlist GT nentries ) then begin
         message = 'Entry list values (second parameter) must be less than '+ $
                strtrim(nentries,2)
         goto, handle_error
      endif
 endelse
 if nentries eq 0 then begin                    <span class="comments">;Return if database is empty</span>
        !err = 0 
        if not keyword_set(SILENT) then message, $
            'ERROR - No entries in database ' + db_info("NAME",0),/INF
        return,listin
 endif
<span class="comments">;</span>
<span class="comments">; parse search parameter string</span>
<span class="comments">;</span>
 dbfparse,spar,items,stype,search_values
 nitems = N_elements(items)             <span class="comments">;number of items</span>
<span class="comments">;</span>
<span class="comments">; set up initial search list</span>
<span class="comments">;</span>
list  = listin
s=size(list) & ndim=s[0]
if ndim EQ 0 then list=lonarr(1)+list
<span class="comments">;</span>
<span class="comments">; get some item info</span>
<span class="comments">;</span>
db_item,items,it,ivalnum,idltype,sbyte,numvals,nbytes,errmsg=errmsg
IF N_ELEMENTS(ERRMSG) NE 0 THEN IF ERRMSG NE '' THEN BEGIN
        MESSAGE = ERRMSG
        GOTO, HANDLE_ERROR
ENDIF
index = db_item_info('INDEX',it)                        <span class="comments">;index type</span>
dbno = db_item_info('DBNUMBER',it)                      <span class="comments">;data base number</span>
                                                        <span class="comments">; particular db.</span>
<span class="comments">;</span>
<span class="comments">; get info on the need to byteswap item by item</span>
<span class="comments">;</span>
external = db_info('external')                          <span class="comments">;External format?</span>
bswap = external * (not IS_IEEE_BIG() )              <span class="comments">;Need to byteswap?</span>
dbno1  = db_item_info('dbnumber', it)
bswap  = bswap[dbno1]

done=bytarr(nitems)                                     <span class="comments">;flag for completed</span>
                                                        <span class="comments">; items</span>
<span class="comments">;----------------------------------------------------------------------</span>
<span class="comments">; ENTRY number is a search parameter?</span>
<span class="comments">;</span>
for pos = 0,nitems-1 do begin
    if (it[pos] eq 0) then begin
        dbfind_entry,stype[pos],search_values[pos,*],nentries,list,count=count
        done[pos]=1                           <span class="comments">;flag as done</span>
        if count LT 1 then goto, FINI            <span class="comments">;any found</span>
     end
end     
<span class="comments">;----------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; perform search on sorted items in the first db</span>
<span class="comments">;</span>

for pos=0,nitems-1 do begin
     if(not done[pos]) and (dbno[pos] eq 0) and $
        (index[pos] ge 2) then begin
                dbfind_sort,it[pos],stype[pos],search_values[pos,*],list, $
                        fullstring=fullstring, Count = count
                if !err ne -2 then begin
                        if count lt 1 then goto,FINI 
                        done[pos]=1
                end
     end
end
<span class="comments">; ------------------------------------------------------------------------</span>
<span class="comments">; Perform search on items in lookup file (indexed items) in first db</span>
<span class="comments">;</span>
if total(done) eq nitems then goto,FINI
for pos=0,nitems-1 do begin
    if(not done[pos]) and (dbno[pos] eq 0) and (index[pos] ne 0) then begin
            dbext_ind,list,it[pos],0,values
            dbsearch, stype[pos], search_values[pos,*], values, good, $
                Fullstring = fullstring, Count = count
            if !err eq -2 then begin 
                print,'DBFIND - Illegal search value for item ', $
                       db_item_info('name',it[pos])
                       return,listin
            endif
            if count lt 1 then goto, FINI        <span class="comments">;any found</span>
            if list[0] ne -1 then list=list[good] else list=good+1
            done[pos]=1                         <span class="comments">; DONE with that item</span>
    end
end

<span class="comments">;------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; search index items in other opened data bases (if any)</span>
<span class="comments">;</span>
found=where( (index gt 0) and (dbno ne 0 ), Nfound)
if Nfound gt 0 then begin
      db = dbno[ where(dbno NE 0) ]
      for i = 0, n_elements(db)-1 do begin
<span class="comments">;</span>
<span class="comments">; find entry numbers of second database corresponding to entry numbers</span>
<span class="comments">; in the first data base.</span>
<span class="comments">;</span>
        pointer=db_info('pointer',db[i])        <span class="comments">;item which points to it</span>
<span class="comments">;</span>
        dbext,list,pointer,list2        <span class="comments">;extract entry numbers in 2nd db</span>
        good=where(list2 ne 0,ngood)    <span class="comments">;is there a valid pointer</span>
        if ngood lt 1 then goto, FINI 
        if list[0] eq -1 then list=good+1 else list=list[good]
        list2=list2[good]
        for pos=0,nitems-1 do begin
            if (not done[pos]) and (dbno[pos] eq db[i]) and (index[pos] ne 0) $
                              and (index[pos] ne 3) then begin
                    dbext_ind,list2,it[pos],dbno[pos],values
                    dbsearch, stype[pos], search_values[pos,*], values, good, $
                        fullstring = fullstring, count = count
                    if !err eq -2 then begin
                       message = 'Illegal search value for item ' + $
                               db_item_info('name',it[pos])
                       goto, handle_error
                    endif
                    if count lt 1 then goto, FINI        <span class="comments">;any found</span>
                    if list[0] ne -1 then list=list[good] else list=good+1
                    list2=list2[good]
                    done[pos]=1                         <span class="comments">; DONE with that item</span>
            endif
        endfor
     endfor
endif           
<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">; search remaining items</span>
<span class="comments">;</span>

  if list[0] eq -1 then list= lindgen(nentries)+1       <span class="comments">;Fixed WBL Feb. 1989</span>
  count = N_elements(list)
  !err = count
  if total(done) eq nitems then goto, FINI      <span class="comments">;all items searched</span>

  nlist     = N_elements(list)        <span class="comments">;number of entries to search</span>
  if nlist GT 2000 then begin
        print,'Non-indexed search on ',strtrim(nlist,2),' entries'
        print,'Expect Delay'
  end
<span class="comments">;</span>
<span class="comments">; Create array to hold values of all remaining items...a big one.</span>
<span class="comments">;</span>
  left = where( done EQ 0, N_left )           <span class="comments">;items left</span>
  nbytes = nbytes[left]
  sbyte = sbyte[left]
  idltype = idltype[left]
  bswap = bswap[left]
  totbytes  = total(nbytes)           <span class="comments">;total number of bytes to extract</span>
  big  = bytarr(totbytes,nlist)   <span class="comments">;array to store values of the items</span>
<span class="comments">;</span>
<span class="comments">; generate starting position in big for each item</span>
<span class="comments">;</span>
  bpos  = lonarr(N_left)        <span class="comments">;starting byte in bpos of each item</span>
  if N_left GT 1 then for i=1,N_left-1 do bpos[i] = bpos[i-1]+nbytes[i-1]

  index = lonarr(totbytes)      <span class="comments">;indices of bytes to extract</span>
  ipos  = 0                     <span class="comments">;position in index array</span>
  for i = 0,N_left-1 do begin   <span class="comments">;loop on items</span>
    for j=0,nbytes[i]-1 do index[ipos+j]=sbyte[i]+j     <span class="comments">;position in entry</span>
    ipos = ipos + nbytes[i]
  end<span class="comments">;for</span>

<span class="comments">;</span>
<span class="comments">; loop on entries and extract info</span>
<span class="comments">;</span>
  for ii = 0L, nlist-1L do begin
    dbrd,list[ii],entry, /noconvert                 <span class="comments">;read entry</span>
    big[0,ii]= entry[index]
  endfor

<span class="comments">;</span>
<span class="comments">; now extract values for each item and search for valid ones</span>
<span class="comments">;</span>
  stillgood  = lindgen( nlist )

  for i = 0l,N_left-1 do begin
        if i Eq 0 then val = big[ bpos[i]:bpos[i]+nbytes[i]-1, 0:nlist-1 ] else $
        val = big[ bpos[i]:bpos[i]+nbytes[i]-1, stillgood ]
        if bswap[i] then ieee_to_host, val, idltype=idltype[i]
       case idltype[i] of
                1: v = byte(val,0,nlist)        <span class="comments">;byte</span>
                2: v = fix(val,0,nlist)         <span class="comments">;i*2</span>
                3: v = long(val,0,nlist)        <span class="comments">;i*4</span>
                4: v = float(val,0,nlist)       <span class="comments">;r*4</span>
                5: v = double(val,0,nlist)      <span class="comments">;r*8</span>
                7: v = string(val)               <span class="comments">;string</span>
                12: v = uint(val,0,nlist)         <span class="comments">;u*2</span>
               13: v = ulong(val,0,nlist)        <span class="comments">;u*4</span>
               14: v = long64(val,0,nlist)       <span class="comments">;i*8</span>
               15: v = ulong64(val,0,nlist)      <span class="comments">;u*8</span>
         endcase
        dbsearch, stype[left[i]], search_values[left[i],*], v, good, $
                Fullstring = fullstring, count = count
        if count LT 1 then goto, FINI 
        stillgood=stillgood[good]
	nlist = count
  endfor
  list = list[stillgood]
  count = N_elements(list) & !ERR = count

FINI:
if not keyword_set(SILENT) then begin
  print,' ' & print,' '
  if count LE 0  then $
        print,'No entries found by dbfind in '+ db_info('name',0) $
  else $
        print,count,' entries found in '+ db_info('name',0)
endif
if count LE 0 then return,intarr(1) else return,list[sort(list)]
<span class="comments">;</span>
<span class="comments">;  Error handling point.</span>
<span class="comments">;</span>
HANDLE_ERROR:
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = 'DBFIND: ' + MESSAGE $
                ELSE MESSAGE, MESSAGE
end
</code>
    </div>
  </body>
</html>