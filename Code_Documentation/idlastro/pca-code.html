<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:54 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pca.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pca.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO PCA, data, eigenval, eigenvect, percentages, proj_obj, proj_atr, $
      MATRIX=AM,TEXTOUT=textout,COVARIANCE=cov,SSQ=ssq,SILENT=silent
     
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;    PCA</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Carry out a Principal Components Analysis (Karhunen-Loeve Transform)</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;    Results can be directed to the screen, a file, or output variables</span>
<span class="comments">;    See notes below for comparison with the intrinsic IDL function PCOMP.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;    PCA, data, eigenval, eigenvect, percentages, proj_obj, proj_atr, </span>
<span class="comments">;             [MATRIX =, TEXTOUT = ,/COVARIANCE, /SSQ, /SILENT ]</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;     data -  2-d data matrix, data(i,j) contains the jth attribute value</span>
<span class="comments">;               for the ith object in the sample.    If N_OBJ is the total</span>
<span class="comments">;               number of objects (rows) in the sample, and N_ATTRIB is the </span>
<span class="comments">;               total number of attributes (columns) then data should be</span>
<span class="comments">;               dimensioned N_OBJ x N_ATTRIB.         </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;     /COVARIANCE - if this keyword is set, then the PCA will be carried out</span>
<span class="comments">;              on the covariance matrix (rare), the default is to use the</span>
<span class="comments">;              correlation matrix</span>
<span class="comments">;     /SILENT - If this keyword is set, then no output is printed</span>
<span class="comments">;     /SSQ - if this keyword is set, then the PCA will be carried out on</span>
<span class="comments">;               on the sums-of-squares & cross-products matrix (rare)</span>
<span class="comments">;     TEXTOUT - Controls print output device, defaults to !TEXTOUT</span>
<span class="comments">;</span>
<span class="comments">;              textout=1       TERMINAL using /more option</span>
<span class="comments">;              textout=2       TERMINAL without /more option</span>
<span class="comments">;              textout=3       &lt;program>.prt</span>
<span class="comments">;              textout=4       laser.tmp</span>
<span class="comments">;              textout=5      user must open file</span>
<span class="comments">;              textout = filename (default extension of .prt)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT PARAMETERS:</span>
<span class="comments">;     eigenval -  N_ATTRIB element vector containing the sorted eigenvalues</span>
<span class="comments">;     eigenvect - N_ATRRIB x N_ATTRIB matrix containing the corresponding </span>
<span class="comments">;               eigenvectors</span>
<span class="comments">;     percentages - N_ATTRIB element containing the cumulative percentage </span>
<span class="comments">;             variances associated with the principal components</span>
<span class="comments">;     proj_obj - N_OBJ by N_ATTRIB matrix containing the projections of the </span>
<span class="comments">;             objects on the principal components</span>
<span class="comments">;     proj_atr - N_ATTRIB by N_ATTRIB matrix containing the projections of </span>
<span class="comments">;               the attributes on the principal components</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT PARAMETER</span>
<span class="comments">;      MATRIX   = analysed matrix, either the covariance matrix if /COVARIANCE</span>
<span class="comments">;              is set, the "sum of squares and cross-products" matrix if</span>
<span class="comments">;              /SSQ is set, or the (by default) correlation matrix.    Matrix</span>
<span class="comments">;              will have dimensions N_ATTRIB x N_ATTRIB</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;      This procedure performs Principal Components Analysis (Karhunen-Loeve</span>
<span class="comments">;      Transform) according to the method described in "Multivariate Data </span>
<span class="comments">;      Analysis" by Murtagh & Heck [Reidel : Dordrecht 1987], pp. 33-48.</span>
<span class="comments">;      See  http://astro.u-strasbg.fr/~fmurtagh/mda-sw/</span>
<span class="comments">;</span>
<span class="comments">;      Keywords /COVARIANCE and /SSQ are mutually exclusive.</span>
<span class="comments">;</span>
<span class="comments">;      The printout contains only (at most) the first seven principle </span>
<span class="comments">;      eigenvectors.    However, the output variables EIGENVECT contain </span>
<span class="comments">;      all the eigenvectors</span>
<span class="comments">;       </span>
<span class="comments">;      Different authors scale the covariance matrix in different ways.</span>
<span class="comments">;      The eigenvalues output by PCA may have to be scaled by 1/N_OBJ or</span>
<span class="comments">;      1/(N_OBJ-1) to agree with other calculations when /COVAR is set.</span>
<span class="comments">;</span>
<span class="comments">;      PCA uses the non-standard system variables !TEXTOUT and !TEXTUNIT.</span>
<span class="comments">;      These can be added to one's session using the procedure ASTROLIB.</span>
<span class="comments">;</span>
<span class="comments">;      The intrinsic IDL function PCOMP  duplicates most</span>
<span class="comments">;      most of the functionality of PCA, but uses different conventions and</span>
<span class="comments">;      normalizations.   Note the following:</span>
<span class="comments">;</span>
<span class="comments">;   (1) PCOMP requires a N_ATTRIB x N_OBJ input array; this is the transpose</span>
<span class="comments">;         of what PCA expects</span>
<span class="comments">;   (2) PCA uses standardized variables for the correlation matrix:  the input </span>
<span class="comments">;        vectors are set to a  mean of zero and variance of one and divided by </span>
<span class="comments">;        sqrt(n); use the /STANDARDIZE keyword to PCOMP for a direct comparison.</span>
<span class="comments">;   (3) PCA (unlike PCOMP) normalizes the eigenvectors by the square root</span>
<span class="comments">;         of the eigenvalues.</span>
<span class="comments">;   (4) PCA returns cumulative percentages; the VARIANCES keyword of PCOMP</span>
<span class="comments">;         returns the variance in each variable</span>
<span class="comments">;   (5) PCOMP divides the eigenvalues by (1/N_OBJ-1) when the covariance matrix</span>
<span class="comments">;          is used.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;      Perform a PCA analysis on the covariance matrix of a data matrix, DATA,</span>
<span class="comments">;      and write the results to a file</span>
<span class="comments">;</span>
<span class="comments">;      IDL> PCA, data, /COVAR, t = 'pca.dat'</span>
<span class="comments">;</span>
<span class="comments">;      Perform a PCA analysis on the correlation matrix.   Suppress all </span>
<span class="comments">;      printing, and save the eigenvectors and eigenvalues in output variables</span>
<span class="comments">;</span>
<span class="comments">;      IDL> PCA, data, eigenval, eigenvect, /SILENT</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;      TEXTOPEN, TEXTCLOSE</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;      Immanuel Freedman (after Murtagh F. and Heck A.).     December 1993</span>
<span class="comments">;      Wayne Landsman, modified I/O              December 1993</span>
<span class="comments">;      Fix MATRIX output, remove GOTO statements   W. Landsman August 1998      </span>
<span class="comments">;      Changed some index variable to type LONG    W. Landsman March 2000</span>
<span class="comments">;      Fix error in computation of proj_atr, see Jan 1990 fix in </span>
<span class="comments">;       http://astro.u-strasbg.fr/~fmurtagh/mda-sw/pca.f   W. Landsman Feb 2008</span>
<span class="comments">;- </span>
  compile_opt idl2
  On_Error,2     <span class="comments">;return to user if error</span>

<span class="comments">; Constants</span>
  TOLERANCE = 1.0E-5       <span class="comments">; are array elements near-zero ?</span>

<span class="comments">; Dispatch table</span>

 IF N_PARAMS() EQ 0  THEN BEGIN
  print,'Syntax  - PCA, data, [eigenval, eigenvect, percentages, proj_obj, proj_atr,'
  print,'               [MATRIX =, /COVARIANCE, /SSQ, /SILENT, TEXTOUT=]'
  RETURN
 ENDIF 

<span class="comments">;Define nonstandard system variables if not already present</span>

  defsysv, '!TEXTUNIT', exist = exist
     if not exist then  defsysv, '!TEXTUNIT', 0
  defsysv, '!TEXTOUT', exist = exist
     if not exist then defsysv, '!TEXTOUT', 1

  
  if size(data,/N_dimen)  NE 2 THEN BEGIN 
    HELP,data
    MESSAGE,'ERROR - Data matrix is not two-dimensional'
  ENDIF

  dimen = size(data,/dimen) 
  Nobj = dimen[0]   &  Mattr = dimen[1]      <span class="comments">;Number of objects and attributes</span>


  IF KEYWORD_SET(cov) THEN BEGIN
        msg = 'Covariance matrix will be analyzed'
<span class="comments">; form column-means</span>
        column_mean = total( data,1 )/Nobj
	temp = replicate(1.0, Nobj)
        X = (data - temp # transpose(column_mean))
  ENDIF ELSE $
  IF KEYWORD_SET(ssq) THEN BEGIN

        msg = 'Sum-of-squares & cross-products matrix will be analyzed'
        X = data 

   ENDIF ELSE BEGIN
        msg = 'Default: Correlation matrix will be analyzed' 
<span class="comments">; form column-means</span>
        temp = replicate( 1.0, Nobj )
        column_mean = (temp # data)/ Nobj
        X = (data - temp # transpose(column_mean))
        S = sqrt(temp # (X*X)) & X = X/(temp # S)
         
   ENDELSE

 A = transpose(X) # X
 if arg_present(AM) then AM = A

<span class="comments">; Carry out eigenreduction</span>
 trired, A, D, E              <span class="comments">; D contains diagonal, E contains off-diagonal</span>
 triql, D, E, A               <span class="comments">; D contains the eigen-values, A(*,i) -vectors</span>

<span class="comments">; Use TOLERANCE to decide if eigenquantities are sufficiently near zero</span>

 index = where(abs(D) LE TOLERANCE*MAX(abs(D)),count) 
 if count NE 0 THEN D[index]=0
 index = where(abs(A) LE TOLERANCE*MAX(abs(A)),count) 
 if count NE 0 THEN A[index]=0

 index = sort(D)                   <span class="comments">; Order by increasing eigenvalue</span>
 D = D[index] & E=E[index]
 A = A[*,index]

<span class="comments">; Eigenvalues expressed as percentage variance and ...</span>
 W1 = 100.0 * reverse(D)/total(D)

<span class="comments">;... Cumulative percentage variance</span>
 W = total(W1, /cumul)

<span class="comments">;Define returned parameters</span>
 eigenval = reverse(D)
 eigenvect = reverse(transpose(A))
 percentages = W

<span class="comments">; Output eigen-values and -vectors </span>

  if not keyword_set(SILENT) then begin
<span class="comments">;       Open output file </span>
        if not keyword_set( TEXTOUT ) then TEXTOUT = textout
        textopen,'PCA', TEXTOUT = textout
        printf,!TEXTUNIT,'PCA: ' + systime()
        sz1 = strtrim( Nobj,2) & sz2 = strtrim( Mattr, 2 )
        printf,!TEXTUNIT, 'Data  matrix has '+ sz1 + ' objects with up to ' + $
                 sz2 + ' attributes'
        printf,!TEXTUNIT, msg 
        printf,!TEXTUNIT, " "
        printf,!TEXTUNIT, $ 
                '   Eigenvalues     As Percentages       Cumul. percentages'
        for i = 0L, Mattr-1 do $
        printf,!TEXTUNIT, eigenval[i], W1[i], percentages[i] ,f = '(3f15.4)'
        printf,!TEXTUNIT," "
        printf,!TEXTUNIT, 'Corresponding eigenvectors follow...'
        Mprint = Mattr &lt<span class="comments">; 7</span>
        header = ' VBLE  '
        for i = 1, Mprint do header = header + '  EV-' + strtrim(i,2) + '   '
        printf,!TEXTUNIT, header
        for i = 1L, Mattr do printf,!TEXTUNIT, $
                 i, eigenvect[0:Mprint-1,i-1],f='(i4,7f9.4)'
  endif

<span class="comments">; Obtain projection of row-point on principal axes  (Murtagh & Heck convention)</span>
 projx = X # A

<span class="comments">; Use TOLERANCE again...</span>
 index = where(abs(projx) LE TOLERANCE*MAX(abs(projx)),count)
 if count NE 0 THEN projx[index]=0
 proj_obj = reverse( transpose(projx) )

 if not keyword_set( SILENT ) then begin
         printf,!TEXTUNIT,' '
         printf,!TEXTUNIT, 'Projection of objects on principal axes ...'
         printf,!TEXTUNIT,' '
         header = ' VBLE  '
         for i = 1, Mprint do header = header + 'PROJ-' + strtrim(i,2) + '   '
         printf,!TEXTUNIT, header 
         for i = 0L, Nobj-1 do printf,!TEXTUNIT, $
                i+1, proj_obj[0:Mprint-1,i], f='(i4,7f9.4)'
 endif

<span class="comments">; Obtain projection of column-points on principal axes</span>
 projy = transpose(projx)#X

<span class="comments">; Use TOLERANCE again...</span>
 index = where(abs(projy) LE TOLERANCE*MAX(abs(projy)),count)
 if count NE 0 THEN projy[index] = 0

<span class="comments">; scale by square root of eigenvalues...</span>
 temp = replicate( 1.0, Mattr )
 proj_atr = reverse(projy)/(sqrt(eigenval)#temp)

 if not keyword_set( SILENT ) then begin
        printf,!TEXTUNIT,' '
        printf,!TEXTUNIT,'Projection of attributes on principal axes ...'
        printf,!TEXTUNIT,' '
        printf,!TEXTUNIT, header
        for i = 0L, Mattr-1 do printf,!TEXTUNIT, $
                i+1, proj_atr[0:Mprint-1,i], f='(i4,7f9.4)'
         textclose, TEXTOUT = textout           <span class="comments">; Close output file  </span>
 endif

 RETURN
 END
</code>
    </div>
  </body>
</html>