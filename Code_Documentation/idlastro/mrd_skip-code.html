<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:49 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mrd_skip.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mrd_skip.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="mrd_skip:source"></a>pro mrd_skip, unit, nskip
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MRD_SKIP</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Skip a number of bytes from the current location in a file or a pipe</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       First tries using POINT_LUN and if this doesn't work, perhaps because</span>
<span class="comments">;       the unit is a pipe or a socket, MRD_SKIP will just read in the </span>
<span class="comments">;       requisite number  of bytes.    </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       MRD_SKIP, Unit, Nskip</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Unit - File unit for the file or pipe in question, integer scalar</span>
<span class="comments">;       Nskip - Number of bytes to be skipped, positive integer</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       This routine should be used in place of POINT_LUN wherever a pipe</span>
<span class="comments">;       or socket may be the input unit (see the procedure FXPOSIT for an </span>
<span class="comments">;       example).   Note that it assumes that it can only work with nskip >= 0 </span>
<span class="comments">;       so it doesn't even try for negative values.      </span>
<span class="comments">;</span>
<span class="comments">;       For reading a pipe, MRD_SKIP currently uses a maximum buffer size</span>
<span class="comments">;       of 8 MB.   This chunk value can be increased for improved efficiency</span>
<span class="comments">;       (or decreased if you really have little memory.)</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written, Thomas A. McGlynn    July 1995</span>
<span class="comments">;	Don't even try to skip bytes on a pipe with POINT_LUN, since this</span>
<span class="comments">;	might reset the current pointer     W. Landsman        April 1996</span>
<span class="comments">;       Increase buffer size, check fstat.compress W. Landsman  Jan 2001</span>
<span class="comments">;       Only a warning if trying read past EOF   W. Landsman   Sep 2001</span>
<span class="comments">;       Use 64bit longword for skipping in very large files W. Landsman Sep 2003</span>
<span class="comments">;       Assume since V5.4, fstat.compress available W. Landsman April 2006</span>
<span class="comments">;       POINT_LUN for compressed files is as fast as any W. Landsman Oct 2006</span>
<span class="comments">;       Don't try to use POINT_LUN on compressed files W. Landsman Dec. 2006</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
        On_error,2

	if nskip le 0 then return
        compress = (fstat(unit)).compress

<span class="comments">; We try to use POINT_LUN but if an error ocurrs, we just read in the bytes </span>

          if ~compress then begin
 	  On_IOerror, byte_read
	  point_lun, -unit, curr_pos
	  On_IOerror, null
          if curr_pos NE -1 then point_lun, unit, long64(curr_pos) + nskip
           return
	  endif 

<span class="comments">; Otherwise, we have to explictly read the number of bytes to skip</span>
<span class="comments">; If the number is very large we don't want to create a array so skip</span>
<span class="comments">; in chunks of 8 Megabyte</span>

byte_read:

        chunk = 8000000L
	buf = bytarr(nskip&lt<span class="comments">;chunk, /nozero)</span>
	nleft = nskip
	on_ioerror, DONE
	while (nleft gt 0) do begin
		readu, unit, buf
		nleft = nleft - chunk
	        if (nleft gt 0) && (nleft lt chunk) then buf = buf[0:nleft-1]	
	endwhile
	return
DONE:  message,'Warning - Byte padding in FITS file may not be correct',/CON
       return		
end

</code>
    </div>
  </body>
</html>