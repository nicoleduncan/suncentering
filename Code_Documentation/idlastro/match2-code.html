<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:46 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>match2.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="match2.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MATCH2</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Routine to cross-match values in two vectors (including non-matches)</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This procedure *appears* similar to MATCH of the IDL astronomy</span>
<span class="comments">;       library.  However, this routine is quite different in that it</span>
<span class="comments">;       reports an index value for each element of the input arrays.</span>
<span class="comments">;       In other words, while MATCH reports the *existence* of</span>
<span class="comments">;       matching elements in each array, MATCH2 reports explicitly</span>
<span class="comments">;       *which* elements match.</span>
<span class="comments">;</span>
<span class="comments">;       Furthermore, while MATCH reports only unique matching</span>
<span class="comments">;       elements, MATCH2 will always report a cross-match for every</span>
<span class="comments">;       element in each array, even if it is a repeat.</span>
<span class="comments">;</span>
<span class="comments">;       In cases where no match was found, an index of -1 is</span>
<span class="comments">;       reported.  </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       match2, a, b, suba, subb</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       a,b - two vectors to match elements, numeric or string data types</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       suba - vector with same number of elements as A, such that</span>
<span class="comments">;              A EQ B[SUBA], except non-matches which are indicated</span>
<span class="comments">;              by SUBA EQ -1</span>
<span class="comments">;       subb - vector with same number of elements as B, such that</span>
<span class="comments">;              B EQ A[SUBB], except non-matches which are indicated</span>
<span class="comments">;              by SUBB EQ -1</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">; </span>
<span class="comments">;       The vectors A and B are allowed to have duplicates in them,</span>
<span class="comments">;       but for matching purposes, only the first one found will</span>
<span class="comments">;       be reported.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;      A = [0,7,14,23,24,30]</span>
<span class="comments">;      B = [7,8,14,25,14]</span>
<span class="comments">;      IDL> match2, a, b, suba, subb</span>
<span class="comments">;     --> suba = [ -1 ,  0,  4,  -1, -1, -1 ]</span>
<span class="comments">;     (indicates that A[1] matches B[1] and A[3] matches B[2])</span>
<span class="comments">;     --> subb = [  1 , -1,  2,  -1,  2 ]</span>
<span class="comments">;     (indicates that B[1] matches A[1] and B[2] matches A[3])</span>
<span class="comments">;</span>
<span class="comments">;  Compare to the results of the original MATCH procedure,</span>
<span class="comments">;    </span>
<span class="comments">;      IDL> match, a, b, suba, subb</span>
<span class="comments">;     --> suba = [  1,  3]</span>
<span class="comments">;  (indicates that A[1] and A[3] match elements in B, but not which ones)</span>
<span class="comments">;     --> subb = [  1,  2]</span>
<span class="comments">;  (indicates that B[1] and B[2] match elements in A, but not which ones)</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY</span>
<span class="comments">;   Derived from the IDL Astronomy Library MATCH, 14 Feb 2007</span>
<span class="comments">;   Updated documentation, 17 Jul 2007</span>
<span class="comments">;   More updated documentation (example), 03 Sep 2007</span>
<span class="comments">; </span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<a id="match2:source"></a>pro match2, a, b, suba, subb

 On_error,2
 compile_opt idl2

 if N_params() LT 3 then begin
     print,'Syntax - match2, a, b, suba, subb'
     print,'    a,b -- input vectors for which to match elements'
     print,'    suba,subb -- match index lists'
     return
 endif

 da = size(a,/type) & db =size(b,/type)
 
 na = N_elements(a)              <span class="comments">;number of elements in a</span>
 nb = N_elements(b)             <span class="comments">;number of elements in b</span>
 suba = lonarr(na)-1 & subb = lonarr(nb)-1

<span class="comments">; Check for a single element array</span>

 if (na EQ 1) or (nb EQ 1) then begin
        if (nb GT 1) then begin
            wh = where(b EQ a[0], nw)
            if nw GT 0 then begin
                subb[wh] = 0L
                suba[0]  = wh[0]
            endif
        endif else begin
            wh = where(a EQ b[0], nw)
            if nw GT 0 then begin
                suba[wh] = 0L
                subb[0]  = wh[0]
            endif
        endelse
        return
 endif
        
 c = [ a, b ]                   <span class="comments">;combined list of a and b</span>
 ind = [ lindgen(na), lindgen(nb) ]       <span class="comments">;combined list of indices</span>
 vec = [ intarr(na), replicate(1,nb) ]  <span class="comments">;flag of which vector in  combined </span>
                                         <span class="comments">;list   0 - a   1 - b</span>

<span class="comments">; sort combined list</span>

 if da EQ 7 OR db EQ 7 then begin
     <span class="comments">;; String sort (w/ double key)</span>
     sub = sort(c+strtrim(vec,2))
 endif else begin
     <span class="comments">;; Number sort (w/ double key)</span>
     eps = (machar(/double)).eps
     sub = sort(double(c)*(1d + vec*eps))
 endelse

 c = c[sub]
 ind = ind[sub]
 vec = vec[sub]
 
 n = na + nb                    <span class="comments">;total elements in c</span>
 wh = where( c[1:*] NE c, ct)
 if ct EQ 0 then begin
     whfirst = [0]
     whlast  = [n-1]
 endif else begin
     whfirst = [0, wh+1]
     whlast  = [wh, n-1]
 endelse
 
 vec0 = vec[whfirst]
 vec1 = vec[whlast]
 <span class="comments">;; 0 = present in A but not B</span>
 <span class="comments">;; 1 = can't occur (since the array was sorted on 'VEC')</span>
 <span class="comments">;; 2 = present in both</span>
 <span class="comments">;; 3 = present in B but not A</span>
 matchtype = vec0 + vec1*2

 nm = n_elements(matchtype)
 mm = ind*0L & wa = mm & wb = mm
 for i = 0, nm-1 do begin
     mm[whfirst[i]:whlast[i]] = matchtype[i]
     wa[whfirst[i]:whlast[i]] = ind[whfirst[i]]
     wb[whfirst[i]:whlast[i]] = ind[whlast[i]]
 endfor

 suba = lonarr(na)-1 & subb = lonarr(nb)-1

 wh = where(mm EQ 2 AND vec EQ 0, ct)
 if ct GT 0 then suba[ind[wh]] = wb[wh]
 wh = where(mm EQ 2 AND vec EQ 1, ct)
 if ct GT 0 then subb[ind[wh]] = wa[wh]

 return
end
</code>
    </div>
  </body>
</html>