<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxbopen.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxbopen.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">	PRO FXBOPEN, UNIT, FILENAME0, EXTENSION, HEADER, NO_TDIM=NO_TDIM, $
                ERRMSG=ERRMSG, ACCESS=ACCESS, REOPEN=REOPEN
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;	FXBOPEN</span>
<span class="comments">; Purpose     : </span>
<span class="comments">;	Open binary table extension in a disk FITS file for reading or updating</span>
<span class="comments">; Explanation : </span>
<span class="comments">;	Opens a binary table extension in a disk FITS file for reading.  The</span>
<span class="comments">;	columns are then read using FXBREAD, and the file is closed when done</span>
<span class="comments">;	with FXBCLOSE.</span>
<span class="comments">; Use         : </span>
<span class="comments">;	FXBOPEN, UNIT, FILENAME, EXTENSION  [, HEADER ]</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;       FILENAME  = Name of FITS file to be opened.  Optional</span>
<span class="comments">;                   extension *number* may be specified, in either of</span>
<span class="comments">;                   the following formats (using the FTOOLS</span>
<span class="comments">;                   convention): FILENAME[EXT] or FILENAME+EXT, where</span>
<span class="comments">;                   EXT is 1 or higher.  Such an extension</span>
<span class="comments">;                   specification takes priority over EXTENSION.</span>
<span class="comments">;                </span>
<span class="comments">;	EXTENSION = Either the number of the FITS extension, starting with the</span>
<span class="comments">;		    first extension after the primary data unit being one; or a</span>
<span class="comments">;		    character string containing the value of EXTNAME to search</span>
<span class="comments">;		    for.</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;	None.</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;	UNIT	  = Logical unit number of the opened file.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;	HEADER	  = String array containing the FITS binary table extension</span>
<span class="comments">;		    header.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;	NO_TDIM	  = If set, then any TDIMn keywords found in the header are</span>
<span class="comments">;		    ignored.</span>
<span class="comments">;</span>
<span class="comments">;       ACCESS    = A scalar string describing access privileges as</span>
<span class="comments">;                   one of READ ('R') or UPDATE ('RW').</span>
<span class="comments">;                   DEFAULT: 'R'</span>
<span class="comments">;</span>
<span class="comments">;       REOPEN    = If set, UNIT must be an already-opened file unit.</span>
<span class="comments">;                   FXBOPEN will treat the file as a FITS file.</span>
<span class="comments">;</span>
<span class="comments">;	ERRMSG	  = If defined and passed, then any error messages will be</span>
<span class="comments">;		    returned to the user in this parameter rather than</span>
<span class="comments">;		    depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;		    encountered, then a null string is returned.  In order to</span>
<span class="comments">;		    use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;			ERRMSG = ''</span>
<span class="comments">;			FXBOPEN, ERRMSG=ERRMSG, ...</span>
<span class="comments">;			IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;	FXBFINDLUN, FXBPARSE, FXHREAD, FXPAR</span>
<span class="comments">; Common      : </span>
<span class="comments">;	Uses common block FXBINTABLE--see "fxbintable.pro" for more</span>
<span class="comments">;	information.</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;	The file must be a valid FITS file.</span>
<span class="comments">; Side effects: </span>
<span class="comments">;	None.</span>
<span class="comments">; Category    : </span>
<span class="comments">;	Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;	W. Thompson, Feb 1992, based on READFITS by J. Woffard and W. Landsman.</span>
<span class="comments">;	W. Thompson, Feb 1992, changed from function to procedure.</span>
<span class="comments">;	W. Thompson, June 1992, fixed up error handling.</span>
<span class="comments">; Written     : </span>
<span class="comments">;	William Thompson, GSFC, February 1992.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;	Version 1, William Thompson, GSFC, 12 April 1993.</span>
<span class="comments">;		Incorporated into CDS library.</span>
<span class="comments">;	Version 2, William Thompson, GSFC, 27 May 1994</span>
<span class="comments">;		Added ERRMSG keyword.</span>
<span class="comments">;	Version 3, William Thompson, GSFC, 21 June 1994</span>
<span class="comments">;		Extended ERRMSG to call to FXBPARSE</span>
<span class="comments">;       Version 4, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;       Version 4, 23 June 1994</span>
<span class="comments">;</span>
<span class="comments">; Added ACCESS, REOPEN keywords, and FXFILTER package, CM 1999 Feb 03</span>
<span class="comments">; Added FILENAME[EXT] and FILENAME+EXT extension parsing, CM 1999 Jun 28</span>
<span class="comments">; Some general tidying, CM 1999 Nov 18</span>
<span class="comments">;       Allow for possible 64bit integer number of bytes W. Landsman Nov 2007</span>
<span class="comments">;       Make Ndata a 64bit integer to deal with larger files, E. Hivon, Mar 2008</span>
<span class="comments">;       </span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;</span>
@fxbintable
	ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
	IF N_PARAMS() LT 3 THEN BEGIN
		MESSAGE = 'Syntax:  FXBOPEN, UNIT, FILENAME, EXTENSION  ' + $
			'[, HEADER ]'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Check the type of the EXTENSION parameter.</span>
<span class="comments">;</span>
	IF N_ELEMENTS(EXTENSION) NE 1 THEN BEGIN
		MESSAGE = 'EXTENSION must be a scalar'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
	SZ = SIZE(EXTENSION)
	ETYPE = SZ[SZ[0]+1]
	IF ETYPE EQ 8 THEN BEGIN
		MESSAGE = 'EXTENSION must not be a structure'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  If EXTENSION is of type string, then search for the proper extension by</span>
<span class="comments">;  name.  Otherwise, search by number.</span>
<span class="comments">;</span>
	IF ETYPE EQ 7 THEN BEGIN
		S_EXTENSION = STRTRIM(STRUPCASE(EXTENSION),2)
	END ELSE BEGIN
		I_EXTENSION = FIX(EXTENSION)
		IF I_EXTENSION LT 1 THEN BEGIN
			MESSAGE = 'EXTENSION must be greater than zero'
			IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
				ERRMSG = MESSAGE
				RETURN
			END ELSE MESSAGE, MESSAGE
		ENDIF
	ENDELSE
<span class="comments">;</span>
<span class="comments">;  Check access parameter</span>
        IF N_ELEMENTS(ACCESS) EQ 0 THEN ACCESS='R'
        SZ = SIZE(ACCESS)
        IF SZ[SZ[0]+1] NE 7 THEN GOTO, ACCERR
        IF STRUPCASE(ACCESS) NE 'R' AND STRUPCASE(ACCESS) NE 'RW' THEN BEGIN
            ACCERR:
            MESSAGE = "ACCESS must be either 'R' or 'RW'"
            IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                ERRMSG = MESSAGE
                RETURN
            END ELSE MESSAGE, MESSAGE
        ENDIF
            
<span class="comments">;</span>
<span class="comments">;  Establish the read/write state</span>
<span class="comments">;</span>
	ST = 1                                    <span class="comments">; Read only</span>
        IF STRUPCASE(ACCESS) EQ 'RW' THEN ST = 2  <span class="comments">; Read/write</span>

<span class="comments">;</span>
<span class="comments">;  Get a logical unit number, and open the file.</span>
<span class="comments">;</span>
        FILENAME = FILENAME0
        IF NOT KEYWORD_SET(REOPEN) THEN BEGIN

            <span class="comments">;; Check for extension name at the end of a filename</span>
            LEN = STRLEN(FILENAME0)
            NEWEXT = 0L
            BFILENAME = BYTE(FILENAME)
            B0 = (BYTE('0'))(0) & B9 = (BYTE('9'))(0) 
            I = LEN-1
            BB = BFILENAME[I]

            <span class="comments">;; First case:  FILENAME[5]</span>
            IF LEN GE 4 AND STRING(BB) EQ ']' THEN BEGIN <span class="comments">;; Count backwards</span>
                I = I - 1
                IF BFILENAME[I] GE B0 AND BFILENAME[I] LE B9 THEN BEGIN
                    WHILE I GT 0 AND $
                      BFILENAME[I] GE B0 AND BFILENAME[I] LT B9 DO I = I - 1
                    IF I GT 0 AND STRING(BFILENAME[I]) EQ '[' THEN BEGIN
                        NEWEXT = LONG(STRMID(FILENAME,I+1,10))
                        FLEN = I
                    ENDIF
                ENDIF
            ENDIF

            <span class="comments">;; Second case: FILENAME+5</span>
            IF LEN GE 3 AND BB GE B0 AND BB LE B9 THEN BEGIN <span class="comments">;; Count backwards</span>
                WHILE I GT 0 AND $
                  BFILENAME[I] GE B0 AND BFILENAME[I] LT B9 DO I = I - 1
                IF I GT 0 AND STRING(BFILENAME[I]) EQ '+' THEN BEGIN
                    NEWEXT = LONG(STRMID(FILENAME,I+1,10))
                    FLEN = I
                ENDIF
            ENDIF
            IF NEWEXT GT 0 THEN BEGIN
                FILENAME = STRMID(FILENAME, 0, FLEN)
                I_EXTENSION = NEWEXT
                ETYPE = 1
            ENDIF

            <span class="comments">;; Open the file</span>
            IF ST EQ 1 THEN $
              OPENR, UNIT, FILENAME, /BLOCK, /GET_LUN, ERROR=ERROR $
            ELSE $
              OPENU, UNIT, FILENAME, /BLOCK, /GET_LUN, ERROR=ERROR
            IF ERROR NE 0 THEN GOTO, NO_SUCH_FILE
        ENDIF

<span class="comments">;</span>
<span class="comments">;  Reopen the file if requested.  Essentially this means seeking to</span>
<span class="comments">;  the start, after some error checking.</span>
<span class="comments">;        </span>
        IF KEYWORD_SET(REOPEN) THEN BEGIN
            SZ = SIZE(UNIT)
            IF N_ELEMENTS(UNIT) NE 1 OR SZ[SZ[0]+1] EQ 8 THEN BEGIN
                MESSAGE = 'UNIT must be a scalar numeric type'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF

<span class="comments">;</span>
<span class="comments">;  Error checking on file unit</span>
<span class="comments">;</span>
            UNIT = UNIT[0]
            FS = FSTAT(UNIT)
            IF (FS.OPEN NE 1) OR (FS.READ NE 1) $
              OR (ST EQ 2 AND FS.WRITE NE 1) THEN BEGIN
                MESSAGE = 'UNIT '+strtrim(unit,2)+' must be open for reading'
                IF ST EQ 2 THEN MESSAGE = MESSAGE + '/writing'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                    ERRMSG = MESSAGE
                    RETURN
                END ELSE MESSAGE, MESSAGE
            ENDIF

            <span class="comments">;; Seek to the start of the file</span>
            POINT_LUN, UNIT, 0L
        ENDIF


<span class="comments">;</span>
<span class="comments">;  Store the UNIT number in the common block, and leave space for the other</span>
<span class="comments">;  parameters.  Initialize the common block if need be.  ILUN is an index into</span>
<span class="comments">;  the arrays.</span>
<span class="comments">;</span>
	ILUN = FXBFINDLUN(UNIT)
<span class="comments">;</span>
<span class="comments">;  Mark the file as open for read or write.</span>
<span class="comments">;</span>
	STATE[ILUN] = ST
<span class="comments">;</span>
<span class="comments">;  Read the primary header.</span>
<span class="comments">;</span>
	FXHREAD,UNIT,HEADER,STATUS
	IF STATUS NE 0 THEN BEGIN
		FREE_LUN,UNIT
		MESSAGE = 'Unable to read primary FITS header'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
	I_EXT = 0
<span class="comments">;</span>
<span class="comments">;  Make sure that the file does contain extensions.</span>
<span class="comments">;</span>
	START = 0L
	IF NOT FXPAR(HEADER,'EXTEND', START=START) THEN BEGIN
		FREE_LUN, UNIT
		MESSAGE = 'File ' + FILENAME + ' does not contain extensions'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Get the number of bytes taken up by the data.</span>
<span class="comments">;</span>
NEXT_EXT:
	BITPIX = FXPAR(HEADER,'BITPIX', START=START)
	NAXIS  = FXPAR(HEADER,'NAXIS',  START=START)
	GCOUNT = FXPAR(HEADER,'GCOUNT', START=START)
	IF GCOUNT EQ 0 THEN GCOUNT = 1
	PCOUNT = FXPAR(HEADER,'PCOUNT', START=START)
	IF NAXIS GT 0 THEN BEGIN 
		DIMS = FXPAR(HEADER,'NAXIS*')		<span class="comments">;Read dimensions</span>
		NDATA = long64(DIMS[0])
		IF NAXIS GT 1 THEN FOR I=2,NAXIS DO NDATA = NDATA*DIMS[I-1]
	ENDIF ELSE NDATA = 0
	NBYTES = LONG64(ABS(BITPIX) / 8) * GCOUNT * (PCOUNT + NDATA)
<span class="comments">;</span>
<span class="comments">;  Read the next extension header in the file.</span>
<span class="comments">;</span>
	NREC = (NBYTES + 2879) / 2880
	POINT_LUN, -UNIT, POINTLUN			<span class="comments">;Current position</span>
	MHEAD0 = POINTLUN + NREC*2880L
	POINT_LUN, UNIT, MHEAD0				<span class="comments">;Next FITS extension</span>
	FXHREAD,UNIT,HEADER,STATUS
	IF STATUS NE 0 THEN BEGIN
		FREE_LUN,UNIT
		MESSAGE = 'Requested extension not found'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
	I_EXT = I_EXT + 1
<span class="comments">;</span>
<span class="comments">;  Check to see if the current extension is the one desired.</span>
<span class="comments">;</span>
	START = 0L
	IF ETYPE EQ 7 THEN BEGIN
		EXTNAME = STRTRIM(STRUPCASE(FXPAR(HEADER,'EXTNAME', $
                                                  START=START)),2)
		IF EXTNAME EQ S_EXTENSION THEN GOTO, DONE
	END ELSE IF I_EXT EQ I_EXTENSION THEN GOTO, DONE
	GOTO, NEXT_EXT
<span class="comments">;</span>
<span class="comments">;  Check to see if the extension type is BINTABLE or A3DTABLE.</span>
<span class="comments">;</span>
DONE:
	XTENSION = STRTRIM(STRUPCASE(FXPAR(HEADER,'XTENSION', START=START)),2)
	IF (XTENSION NE 'BINTABLE') AND (XTENSION NE 'A3DTABLE') THEN BEGIN
		IF ETYPE EQ 7 THEN EXT = S_EXTENSION ELSE EXT = I_EXTENSION
		FREE_LUN,UNIT
		MESSAGE = 'Extension ' + STRTRIM(EXT,2) +		$
			' is not a binary table'
		IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
			ERRMSG = MESSAGE
			RETURN
		END ELSE MESSAGE, MESSAGE
	ENDIF
<span class="comments">;</span>
<span class="comments">;  Get the rest of the information, and store it in the common block.</span>
<span class="comments">;</span>
	MHEADER[ILUN] = MHEAD0
	FXBPARSE,ILUN,HEADER,NO_TDIM=NO_TDIM,ERRMSG=ERRMSG
	RETURN
<span class="comments">;</span>
<span class="comments">;  Error point for not being able to open the file</span>
<span class="comments">;</span>
NO_SUCH_FILE:
	MESSAGE = 'Unable to open file ' + STRTRIM(FILENAME,2)
	IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
		ERRMSG = MESSAGE
		RETURN
	END ELSE MESSAGE, MESSAGE
	END
</code>
    </div>
  </body>
</html>