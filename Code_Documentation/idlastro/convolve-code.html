<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:22 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>convolve.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="convolve.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="convolve:source"></a>function convolve, image, psf, FT_PSF=psf_FT, FT_IMAGE=imFT, NO_FT=noft, $
                        CORRELATE=correlate, AUTO_CORRELATION=auto, $
			NO_PAD = no_pad
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       CONVOLVE</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Convolution of an image with a Point Spread Function (PSF)</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       The default is to compute the convolution using a product of </span>
<span class="comments">;       Fourier transforms (for speed).</span>
<span class="comments">;</span>
<span class="comments">;       The image is padded with zeros so that a large PSF does not</span>
<span class="comments">;       overlap one edge of the image with the opposite edge of the image.</span>
<span class="comments">;</span>
<span class="comments">;       This routine is now partially obsolete due to the introduction of  the</span>
<span class="comments">;       intrinsic CONVOL_FFT() function in IDL 8.1</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       imconv = convolve( image1, psf, FT_PSF = psf_FT )</span>
<span class="comments">;  or:</span>
<span class="comments">;       correl = convolve( image1, image2, /CORREL )</span>
<span class="comments">;  or:</span>
<span class="comments">;       correl = convolve( image, /AUTO )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       image = 2-D array (matrix) to be convolved with psf</span>
<span class="comments">;       psf = the Point Spread Function, (size &lt; or = to size of image).</span>
<span class="comments">;</span>
<span class="comments">;       The PSF *must* be symmetric about the point</span>
<span class="comments">;       FLOOR((n_elements-1)/2), where n_elements is the number of</span>
<span class="comments">;       elements in each dimension.  For Gaussian PSFs, the maximum</span>
<span class="comments">;       of the PSF must occur in this pixel (otherwise the convolution</span>
<span class="comments">;       will shift everything in the image).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       FT_PSF = passes out/in the Fourier transform of the PSF,</span>
<span class="comments">;               (so that it can be re-used the next time function is called).</span>
<span class="comments">;       FT_IMAGE = passes out/in the Fourier transform of image.</span>
<span class="comments">;</span>
<span class="comments">;       /CORRELATE uses the conjugate of the Fourier transform of PSF,</span>
<span class="comments">;               to compute the cross-correlation of image and PSF,</span>
<span class="comments">;               (equivalent to IDL function convol() with NO rotation of PSF)</span>
<span class="comments">;</span>
<span class="comments">;       /AUTO_CORR computes the auto-correlation function of image using FFT.</span>
<span class="comments">;</span>
<span class="comments">;       /NO_FT overrides the use of FFT, using IDL function convol() instead.</span>
<span class="comments">;               (then PSF is rotated by 180 degrees to give same result)</span>
<span class="comments">;</span>
<span class="comments">;       /NO_PAD - if set, then do not pad the image to avoid edge effects.</span>
<span class="comments">;               This will improve memory and speed of the computation at the </span>
<span class="comments">;               expense of edge effects.   This was the default method prior </span>
<span class="comments">;               to October 2009</span>
<span class="comments">; METHOD:</span>
<span class="comments">;       When using FFT, PSF is centered & expanded to size of image.</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       written, Frank Varosi, NASA/GSFC 1992.</span>
<span class="comments">;       Appropriate precision type for result depending on input image</span>
<span class="comments">;                               Markus Hundertmark February 2006</span>
<span class="comments">;       Fix the bug causing the recomputation of FFT(psf) and/or FFT(image)</span>
<span class="comments">;                               Sergey Koposov     December 2006</span>
<span class="comments">;       Fix the centering bug</span>
<span class="comments">;                               Kyle Penner        October 2009</span>
<span class="comments">;       Add /No_PAD keyword for better speed and memory usage when edge effects</span>
<span class="comments">;            are not important.    W. Landsman      March 2010</span>
<span class="comments">;       Add warning when kernel type does not match integer array</span>
<span class="comments">;             W. Landsman Feb 2012</span>
<span class="comments">;-</span>
        compile_opt idl2
        sp = size( psf_FT,/str )  &  sif = size( imFT, /str )
        sim = size( image )  


        if (sim[0] NE 2) || keyword_set( noft ) then begin
                if keyword_set( auto ) then begin
                        message,"auto-correlation only for images with FFT",/INF
                        return, image
                 endif
		 dtype = size(image,/type)
		 if dtype LE 3 then if size(psf,/type) NE dtype then $
		    message,/CON, $
		 'WARNING - ' + size(psf,/TNAME) +  $
		 ' kernel converted to type ' + size(image,/tname)    
		 if keyword_set( correlate ) then $
                                return, convol( image, psf ) $
                 else    return, convol( image, rotate( psf, 2 ) )
           endif

       if keyword_Set(No_Pad) then begin 
 
        sc = sim/2  &  npix = N_elements( image )
        if (sif.N_dimensions NE 2) || ((sif.type NE 6) && (sif.type NE 9)) || $
           (sif.dimensions[0] NE sim[1]) || (sif.dimensions[1] NE sim[2]) then imFT = FFT( image,-1 )

        if keyword_set( auto ) then $
         return, shift( npix*real_part(FFT( imFT*conj( imFT ),1 )), sc[1],sc[2] )

        if (sp.N_dimensions NE 2) || ((sp.type NE 6) && (sp.type NE 9)) || $
           (sp.dimensions[0] NE sim[1]) || (sp.dimensions[1] NE sim[2]) then begin
                sp = size( psf )
                if (sp[0] NE 2) then begin
                        message,"must supply PSF matrix (2nd arg.)",/INFO
                        return, image
                   endif
                Loc = ( sc - sp/2 ) > 0         <span class="comments">;center PSF in new array,</span>
                s = (sp/2 - sc) > 0        <span class="comments">;handle all cases: smaller or bigger</span>
                L = (s + sim-1) &lt<span class="comments">; (sp-1)</span>
                psf_FT = conj(image)*0 <span class="comments">;initialise with correct size+type according </span>
                <span class="comments">;to logic of conj and set values to 0 (type of psf_FT is conserved)  </span>
                psf_FT[ Loc[1], Loc[2] ] = psf[ s[1]:L[1], s[2]:L[2] ]
                psf_FT = FFT( psf_FT, -1, /OVERWRITE )
           endif

        if keyword_set( correlate ) then $
                conv = npix * real_part(FFT( imFT * conj( psf_FT ), 1 ))  $
          else  conv = npix * real_part(FFT( imFT * psf_FT, 1 )) 

        sc = sc + (sim MOD 2)   <span class="comments">;shift correction for odd size images.</span>

        return, shift( conv, sc[1], sc[2] )
   endif else begin  
 
 
          sc = floor((sim-1)/2) & npix = n_elements(image)*4.
        <span class="comments">; the spooky factor of 4 in npix is because we're going to pad the image</span>
        <span class="comments">; with zeros</span>

         if (sif.N_dimensions NE 2) || ((sif.type NE 6) && (sif.type NE 9)) || $
           (sif.dimensions[0] NE sim[1]) || (sif.dimensions[1] NE sim[2]) then begin

            <span class="comments">; here is where we make an array with twice the dimensions of image and</span>
            <span class="comments">; pad with zeros -- thanks to Daniel Eisenstein for this fix</span>

            image_big = dblarr(sim[1]*2,sim[2]*2)
            image_big[0:sim[1]-1,0:sim[2]-1] = image
            imFT = FFT( image_big,-1 )
            npix = n_elements(image_big)

        endif


        if keyword_set( auto ) then begin
         intermed = shift( npix*real_part(FFT( imFT*conj( imFT ),1 )), sc[1],sc[2] )
         return, intermed[0:sim[1]-1,0:sim[2]-1]
     endif


        if (sp.N_dimensions NE 2) || ((sp.type NE 6) && (sp.type NE 9)) OR $
           (sp.dimensions[0] NE sim[1]) || (sp.dimensions[1] NE sim[2]) then begin
                sp = size( psf )
                if (sp[0] NE 2) then begin
                        message,"must supply PSF matrix (2nd arg.)",/INFO
                        return, image
                   endif
                <span class="comments">; this obfuscated line determines the offset between the center of the</span>
                <span class="comments">; image and the center of the PSF</span>
                Loc = ( sc - floor((sp-1)/2) )  > 0

                psf_image = dblarr(sim[1]*2,sim[2]*2)
                psf_image[Loc[1]:Loc[1]+sp[1]-1, Loc[2]:Loc[2]+sp[2]-1] = psf
                psf_FT = FFT(psf_image, -1)
           endif

        if keyword_set( correlate ) then begin
                conv = npix * real_part(FFT( imFT * conj( psf_FT ), 1 ))
                conv = shift(conv, sc[1], sc[2])
            endif else begin
                conv = npix * real_part(FFT( imFT * psf_FT, 1 )) 
                conv = shift(conv, -sc[1], -sc[2])

            endelse

        
        return, conv[0:sim[1]-1,0:sim[2]-1]
      endelse
end
</code>
    </div>
  </body>
</html>