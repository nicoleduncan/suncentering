<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:02 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>skyadj_cube.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="skyadj_cube.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:                    </span>
<span class="comments">;        SKYADJ_CUBE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Sky adjust the planes of a datacube.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       When removing cosmic rays from a set of images, it is desirable that</span>
<span class="comments">;       all images have the same sky level.    This procedure (called by</span>
<span class="comments">;       CR_REJECT) removes the sky from each image in a data cube.    </span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       SKYADJ_CUBE,Datacube,Skyvals,Totsky</span>
<span class="comments">;</span>
<span class="comments">; MODIFIED ARGUMENT:</span>
<span class="comments">;       Datacube:  3-D array with one image of same field in each plane.</span>
<span class="comments">;                  Returned with sky in each plane adjusted to zero.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT ARGUMENTS:</span>
<span class="comments">;       Skyvals:   Array of sky values used on each plane of datacube.</span>
<span class="comments">;                  For a scalar sky, this parameter is a vector</span>
<span class="comments">;                  containing the sky value for each image plane.  For a</span>
<span class="comments">;                  vector sky, this parameter is a 2-D array where each</span>
<span class="comments">;                  line corresponds to one image plane.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;       REGION   - [X0,X1,Y0,Y1] to restrict area used for computation</span>
<span class="comments">;                  of sky.  Default is 0.1*Xdim, 0.9*Xdim, 0.1*Ydim,</span>
<span class="comments">;                  0.9*Ydim.  If INPUT_MASK is specified, the two </span>
<span class="comments">;                  specs are combined, i.e., the intersection of the</span>
<span class="comments">;                  areas is used.</span>
<span class="comments">;       VERBOSE  - Flag.  If set, print information on skyvals.</span>
<span class="comments">;       NOEDIT   - Flag.  If set, return sky values without changing</span>
<span class="comments">;                  datacube.</span>
<span class="comments">;       XMEDSKY  - Flag.  If set, return vector sky as a function of X.</span>
<span class="comments">;       SELECT   - Array of subscripts of planes of the cube to process.</span>
<span class="comments">;                  (Default=all)</span>
<span class="comments">;       EXTRAPR  - Applies only in XMEDSKY mode.</span>
<span class="comments">;                  Subregion to use for polynomial extrapolation of sky</span>
<span class="comments">;                  vector into portions excluded by REGION parameter.</span>
<span class="comments">;                  (Default=first and last 10% of pixels; set to zero</span>
<span class="comments">;                  to defeat extrapolation)</span>
<span class="comments">;       EDEGREE  - Applies only in XMEDSKY mode.  </span>
<span class="comments">;                  Degree of polynomial for extrapolation (Default=1)</span>
<span class="comments">;       INPUT_MASK - Cube of flags corresponding to data cube.  If used,</span>
<span class="comments">;                  the sky computation is restricted to the smallest </span>
<span class="comments">;                  contiguous rectangle containing all the pixels flagged</span>
<span class="comments">;                  valid (with 1 rather than 0).</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Uses astronomy library "sky" routine for scalar sky and</span>
<span class="comments">;       column-by-column median for vector sky.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   10 Jul. 1997   - Written.  R. S. Hill, Hughes STX</span>
<span class="comments">;   20 Oct. 1997   - 1-D sky option.  RSH</span>
<span class="comments">;    7 Aug. 1998   - SELECT keyword.  RSH</span>
<span class="comments">;    6 Oct. 1998   - Extrapolation.  RSH</span>
<span class="comments">;    7 Oct. 1998   - INPUT_MASK added.  RSH</span>
<span class="comments">;   21 Oct. 1998   - Fallback to 3-sigma clipped mean if mode fails.  RSH</span>
<span class="comments">;   22 Mar. 2000   - Combine mask with region rather having mask</span>
<span class="comments">;                    override region.  Improve comments.  RSH</span>
<span class="comments">;   16 June 2000   - On_error and message used.  Square brackets for array </span>
<span class="comments">;                    subscripts.  EXTRAP included in this file.  </span>
<span class="comments">;                    WBL & RSH, 16 June 2000</span>
<span class="comments">;-</span>
<a id="EXTRAP:source"></a>pro EXTRAP, Deg, X, Y, Y2, LIMS=lims
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       EXTRAP</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       This procedure fills in the ends of a one-dimensional array from</span>
<span class="comments">;       interior portions using polynomial extrapolation.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       Image processing</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       EXTRAP, Deg, X, Y, Y2</span>
<span class="comments">;</span>
<span class="comments">; INPUT POSITIONAL PARAMETERS:</span>
<span class="comments">;       Deg:   Degree of polynomial</span>
<span class="comments">;       X:     Independent variable</span>
<span class="comments">;       Y:     Dependent variable</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;       LIMS:  3-element array giving range of X to be used to fit</span>
<span class="comments">;              polynomial and starting point where extrapolation is</span>
<span class="comments">;              to be substituted; if not given, you click on a plot;</span>
<span class="comments">;              order of elements is [xmin, xmax, xstart]; if LIMS is</span>
<span class="comments">;              specified, then program is silent</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT POSITIONAL PARAMETERS:</span>
<span class="comments">;       Y2:    Dependent variable with extrapolated portion filled in</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;     May pop a window for selecting range.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by RSH, RITSS, 14 Aug 98</span>
<span class="comments">;     Spiffed up for library.  RSH, 6 Oct 98</span>
<span class="comments">;-</span>
IF n_params(0) LT 1 THEN BEGIN
    print, 'CALLING SEQUENCE:  extrap, deg, x, y, y2'
    print, 'KEYWORD PARAMETER:  lims'
    RETALL
ENDIF
IF NOT keyword_set(lims) THEN BEGIN
    verbose = 1b
    savedev = strtrim(strupcase(!D.name),2)
    set_plot, 'X'
    window, /free
    plot,x,y
    print, 'Click on fit limit 1'
    cursor, xx1, yy1, /down, /data
    print, 'Click on fit limit 2'
    cursor, xx2, yy2, /down, /data
    print, 'Click starting point of extrapolation'
    cursor, xx3, yy3, /down, /data
    wdelete, !D.window
    IF savedev NE 'X' THEN set_plot, savedev
ENDIF ELSE BEGIN
    verbose = 0b
    xx1 = lims[0]
    xx2 = lims[1]
    xx3 = lims[2]
ENDELSE
IF verbose THEN print,'Extrapolating from region ',xx1, ' to ', xx2
wmin = min(where(x ge min([xx1,xx2])))
wmax = max(where(x le max([xx1,xx2])))
coeff = poly_fit(x[wmin:wmax],y[wmin:wmax], deg, yfit, /double)
xhalf = 0.5*(min(x)+max(x))
up = 1b
if xx3 lt xhalf then up = 0b
ypoly = poly(x, coeff)
y2 = y
IF up THEN BEGIN
    if verbose then print, 'Extrapolating above x = ',xx3
    y2[wstart] = ypoly[wstart:*]
ENDIF ELSE BEGIN
    if verbose then print, 'Extrapolating below x = ',xx3
    y2[0]   = ypoly[0:wstart]
ENDELSE
RETURN
END

PRO SKYADJ_CUBE,Datacube,Skyvals,Totsky, XMEDSKY=xmedsky, $
                REGION=region,VERBOSE=verbose,NOEDIT=noedit, $
                SELECT=select,EXTRAPR=extrapr,EDEGREE=edegree, $
                INPUT_MASK=input_mask


xmed = keyword_set(xmedsky)
verbose=keyword_set(verbose)
ipm = keyword_set(input_mask)
szc = size(datacube)
xdim = szc[1]
ydim = szc[2]
zdim = szc[3]

<span class="comments">;</span>
<span class="comments">;  Default region is between 10% and 90% of range in each</span>
<span class="comments">;  coordinate</span>
IF n_elements(region) LT 1 THEN BEGIN
    xmarg = xdim/10
    ymarg = ydim/10
    region = [xmarg,xdim-xmarg,ymarg,ydim-ymarg]
ENDIF

<span class="comments">;</span>
<span class="comments">;  Arrays to hold min and max good pixels according to input</span>
<span class="comments">;  mask</span>
xmin = intarr(zdim)
xmax = xmin
ymax = xmin
ymin = xmin

<span class="comments">;</span>
<span class="comments">;  Process input mask if any</span>
IF ipm THEN BEGIN
    <span class="comments">;</span>
    <span class="comments">;  Check size</span>
    szm = size(input_mask)
    w_dim_ne = where(szc[0:3] NE szm[0:3], cw_dim_ne)
    IF cw_dim_ne GT 0 THEN BEGIN
        print, 'SKYADJ_CUBE:  INPUT_MASK has different dims from ' $
          + 'DATACUBE'
        print, 'Executing RETALL.'
        retall
    ENDIF
    <span class="comments">;</span>
    <span class="comments">;  Go through planes of mask one by one</span>
    FOR i=0,zdim-1 DO BEGIN
        <span class="comments">;</span>
        <span class="comments">;  Integrate over Y</span>
        xtot = total(input_mask[*,*,i],2)
        <span class="comments">;</span>
        <span class="comments">;  Integrate over X</span>
        ytot = total(input_mask[*,*,i],1)
        <span class="comments">;</span>
        <span class="comments">;  Non-zero in each dimension</span>
        wxt = where(xtot GT 0,cwxt)
        wyt = where(ytot GT 0,cwyt)
        <span class="comments">;</span>
        <span class="comments">;  If whole image masked out something wrong</span>
        IF cwxt LE 0 OR cwyt LE 0 THEN BEGIN
            print, 'SKYADJ_CUBE:  INPUT_MASK invalid'
            print, 'Executing RETALL'
            retall
        ENDIF
        <span class="comments">;</span>
        <span class="comments">;  Find smallest rectangle containing all the good pixels</span>
        xmin1 = min(wxt,max=xmax1)
        ymin1 = min(wyt,max=ymax1)
        xmin[i] = xmin1
        ymin[i] = ymin1
        xmax[i] = xmax1
        ymax[i] = ymax1
    ENDFOR
ENDIF ELSE BEGIN
    <span class="comments">;</span>
    <span class="comments">;  No input mask:  set limits to whole image</span>
    xmin[*] = 0
    ymin[*] = 0
    xmax[*] = xdim-1
    ymax[*] = ydim-1
ENDELSE

IF n_elements(edegree) LT 1 THEN edegree=1
IF n_elements(extrapr) LT 1 THEN extrapr=0.1
do_extrap=keyword_set(extrapr)

IF n_elements(select) LT 1 THEN select=indgen(zdim)
nsel = n_elements(select)

<span class="comments">;</span>
<span class="comments">;  Initialize sky arrays</span>
IF xmed THEN BEGIN
    skyvals = fltarr(xdim,zdim) - 32768.
ENDIF ELSE BEGIN
    skyvals = fltarr(zdim) - 32768.
ENDELSE 
skyplane = fltarr(xdim,ydim)

<span class="comments">;</span>
<span class="comments">;  Go through all the planes that are in the selected set</span>
<span class="comments">;  (probably usually all of them)</span>
FOR i=0,nsel-1 DO BEGIN
    sel = select[i]
    plane = datacube[*,*,sel]
    <span class="comments">;</span>
    <span class="comments">;  Final clip region</span>
    clip_par = [xmin[sel]>region[0],xmax[sel]&lt<span class="comments">;region[1], $</span>
                ymin[sel]>region[2],ymax[sel]&lt<span class="comments">;region[3]]</span>
    <span class="comments">;</span>
    <span class="comments">;  Is sky a function of X or a scalar?</span>
    IF xmed THEN BEGIN
        <span class="comments">;</span>
        <span class="comments">;  Function of X -- do it</span>
        xmedsky, plane, bkg, clip=clip_par
        <span class="comments">;</span>
        <span class="comments">;  Extrapolate beyond clip points if desired</span>
        IF do_extrap THEN BEGIN
            xrange = clip_par[1]-clip_par[0]+1
            extsize = round(extrapr*xrange)
            indx = indgen(xdim)
            extrap, edegree, indx, temporary(bkg), bkg2, $
                lims=[clip_par[0],clip_par[0]+extsize, $
                clip_par[0]+0.4*extsize]
            extrap, edegree, temporary(indx), temporary(bkg2), bkg3, $
                lims=[clip_par[1]-extsize,clip_par[1], $
                clip_par[1]-0.4*extsize]
        ENDIF ELSE BEGIN
            bkg3 = temporary(bkg)
        ENDELSE
        <span class="comments">;</span>
        <span class="comments">;  Store sky vector</span>
        skyvals[0,sel] = bkg3
        <span class="comments">;</span>
        <span class="comments">;  Make sky image</span>
        FOR j=0,ydim-1 DO BEGIN 
            skyplane[0,j] = bkg3
        ENDFOR 
    ENDIF ELSE BEGIN 
        <span class="comments">;</span>
        <span class="comments">;  Scalar sky -- use DAOPHOT algorithm (mode as linear comb</span>
        <span class="comments">;  of mean and median)</span>
        sky, plane[clip_par[0]:clip_par[1],clip_par[2]:clip_par[3]], $
          skymode, skysig, /silent
        IF skysig LT 0 THEN BEGIN
            <span class="comments">;</span>
            <span class="comments">;  Doesn't always work, but this does</span>
            print, 'SKYADJ_CUBE:  Fallback to 3-sigma clipped sky ' $
                + 'for plane '+strn(i)
            meanclip, plane[clip_par[0]:clip_par[1],clip_par[2]:clip_par[3]], $
                skymode, skysig, verbose=verbose
        ENDIF
        <span class="comments">;</span>
        <span class="comments">;  Save sky value</span>
        skyvals[sel] = skymode
        <span class="comments">;</span>
        <span class="comments">;  Make sky image</span>
        skyplane[*] = skymode
    ENDELSE 
    <span class="comments">;</span>
    <span class="comments">;  Substract the sky unless for some reason the caller says not</span>
    IF NOT keyword_set(noedit) THEN BEGIN
        IF verbose THEN print,'SKYADJ_CUBE:  Adjusting plane ', $
            strn(sel)
        datacube[0,0,sel] = plane-skyplane
    ENDIF
ENDFOR

<span class="comments">;</span>
<span class="comments">;  Report results</span>
IF verbose THEN BEGIN
    IF xmed THEN BEGIN 
        print,'SKYADJ_CUBE:  1-D sky as function of X'
        print,'              Average values per image plane are'
        FOR i=0,zdim-1 DO $
          print,'             ',avg(skyvals[*,i])
    ENDIF ELSE BEGIN
        print,'SKYADJ_CUBE:  Scalar sky for each image plane'
        print,'              Values are '
        print,'              ',skyvals
    ENDELSE
    print,'              Region used = ', clip_par
ENDIF 

<span class="comments">;</span>
<span class="comments">;  Compute total sky for sum of image planes</span>
IF xmed THEN BEGIN
    totsky = total(skyvals[*,select],2)
ENDIF ELSE begin
    totsky = total(skyvals[select])
ENDELSE

RETURN
END

</code>
    </div>
  </body>
</html>