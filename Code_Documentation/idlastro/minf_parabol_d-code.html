<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>minf_parabol_d.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="minf_parabol_d.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; Procedure minF_parabol_D,</span>
<span class="comments">; first, a utility function which gets derivative in 1-D:</span>
<span class="comments">;------------------------------------------------------------------------------</span>
<a id="call_func_deriv:source"></a>function call_func_deriv, func_name, x, deriv, POINT_NDIM=pn, DIRECTION=dirn

        f = call_function( func_name, pn + x * dirn, grad )

        deriv = total( [grad * dirn] )

return, f
end
<span class="comments">;------------------------------------------------------------------------------</span>
<a id="minF_parabol_D:source"></a>pro minF_parabol_D, xa,xb,xc, xmin, fmin, FUNC_NAME=func_name,    $
                                          MAX_ITERATIONS=maxit,   $
                                          TOLERANCE=TOL,          $
                                          POINT_NDIM=pn, DIRECTION=dirn
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MINF_PARABOL_D</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Minimize a function using a modified  Brent's method with derivatives</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Based on the procedure DBRENT in Numerical Recipes by Press et al.</span>
<span class="comments">;       Finds a local minimum of a 1-D function up to specified tolerance,</span>
<span class="comments">;       using the first derivative of function in the algorithm.</span>
<span class="comments">;       This routine assumes that the function has a minimum nearby.</span>
<span class="comments">;       (recommend first calling minF_bracket, xa,xb,xc, to bracket minimum).</span>
<span class="comments">;       Routine can also be applied to a scalar function of many variables,</span>
<span class="comments">;       for such case the local minimum in a specified direction is found,</span>
<span class="comments">;       This routine is called by minF_conj_grad, to locate minimum in the </span>
<span class="comments">;       direction of the conjugate gradient of function of many variables.</span>
<span class="comments">;</span>
<span class="comments">; CALLING EXAMPLES:</span>
<span class="comments">;       minF_parabol_D, xa,xb,xc, xmin, fmin, FUNC_NAME="name"  ;for 1-D func.</span>
<span class="comments">;  or:</span>
<span class="comments">;       minF_parabol_D, xa,xb,xc, xmin, fmin, FUNC="name", $</span>
<span class="comments">;                                         POINT=[0,1,1],   $</span>
<span class="comments">;                                         DIRECTION=[2,1,1]     ;for 3-D func.</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       xa,xb,xc = scalars, 3 points which bracket location of minimum,</span>
<span class="comments">;               that is, f(xb) &lt; f(xa) and f(xb) &lt; f(xc), so minimum exists.</span>
<span class="comments">;               When working with function of N variables</span>
<span class="comments">;               (xa,xb,xc) are then relative distances from POINT_NDIM,</span>
<span class="comments">;               in the direction specified by keyword DIRECTION,</span>
<span class="comments">;               with scale factor given by magnitude of DIRECTION.</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;       FUNC_NAME = function name (string)</span>
<span class="comments">;               Calling mechanism should be:  F = func_name( px, gradient )</span>
<span class="comments">;               where:</span>
<span class="comments">;                       px = scalar or vector of independent variables, input.</span>
<span class="comments">;                       F = scalar value of function at px.</span>
<span class="comments">;                       gradient = derivative of function, a scalar if 1-D,</span>
<span class="comments">;                               a gradient vector if N-D,</span>
<span class="comments">;                               (should only be computed if arg. is present).</span>
<span class="comments">;</span>
<span class="comments">;       POINT_NDIM = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the starting point in N-dim space.</span>
<span class="comments">;               Default = 0, which assumes function is 1-D.</span>
<span class="comments">;       DIRECTION = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the direction in N-dim space</span>
<span class="comments">;               along which to bracket the local minimum, (default=1 for 1-D).</span>
<span class="comments">;               (xa, xb, xc, x_min are then relative distances from POINT_NDIM)</span>
<span class="comments">;       MAX_ITER = maximum allowed number iterations, default=100.</span>
<span class="comments">;       TOLERANCE = desired accuracy of minimum location, default=sqrt(1.e-7).</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       xmin = estimated location of minimum.</span>
<span class="comments">;               When working with function of N variables,</span>
<span class="comments">;               xmin is the relative distance from POINT_NDIM,</span>
<span class="comments">;               in the direction specified by keyword DIRECTION,</span>
<span class="comments">;               with scale factor given by magnitude of DIRECTION,</span>
<span class="comments">;               so that min. Loc. Pmin = Point_Ndim + xmin * Direction.</span>
<span class="comments">;       fmin = value of function at xmin (or Pmin).</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       Brent's method to minimize a function by using parabolic interpolation</span>
<span class="comments">;       and using first derivative of function,</span>
<span class="comments">;       from Numerical Recipes (by Press, et al.), sec.10.3 (p.287),</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1992.</span>
<span class="comments">;-</span>
        zeps = 1.e-7    <span class="comments">;machine epsilon, smallest addition.</span>
        if N_elements( TOL ) NE 1 then TOL = sqrt( zeps )
        if N_elements( maxit ) NE 1 then maxit = 100

        if N_elements( pn ) LE 0 then begin
                pn = 0
                dirn = 1
           endif

        xLo = xa &lt<span class="comments">; xc</span>
        xHi = xa > xc
        xmin = xb
        fmin = call_func_deriv( func_name, xmin, dx, POINT=pn, DIR=dirn )
        xv = xmin  &  xw = xmin
        fv = fmin  &  fw = fmin
        dv = dx  &  dw = dx
        es = 0.

        for iter = 1,maxit do begin

                xm = (xLo + xHi)/2.
                TOL1 = TOL * abs(xmin) + zeps
                TOL2 = 2*TOL1

                if ( abs( xmin - xm ) LE ( TOL2 - (xHi-xLo)/2. ) ) then return

                if (abs( es ) GT TOL1) then begin

                        d1 = 2*(xHi-xLo)
                        d2 = d1
                        if (dw NE dx) then d1 = (xw-xmin)*dx/(dx-dw)
                        if (dv NE dx) then d2 = (xv-xmin)*dx/(dx-dv)
                        u1 = xmin + d1
                        u2 = xmin + d2
                        ok1 = ((xLo-u1)*(u1-xHi) GT 0) AND (dx*d1 LE 0)
                        ok2 = ((xLo-u2)*(u2-xHi) GT 0) AND (dx*d2 LE 0)
                        olde = es
                        es = ds

                        if NOT (ok1 OR ok2) then goto,BISECT

                        if (ok1 AND ok2) then begin

                            if (abs( d1 ) LT abs( d2 )) then ds=d1 else ds=d2

                         endif else if (ok1) then ds=d1 else ds=d2

                        if (abs( ds ) LE abs( olde/2 )) then begin

                                xu = xmin + ds

                                if ((xu-xLo) LT TOL2) OR $
                                   ((xHi-xu) LT TOL2) then $
                                             ds = TOL1 * (1-2*((xm-xmin) LT 0))
                                goto,STEP
                          endif
                   endif

        BISECT: if (dx GE 0) then  es = xLo-xmin  else  es = xHi-xmin
                ds = es/2

        STEP:   sign = 1 - 2*(ds LT 0)
                xu = xmin + sign * ( abs( ds ) > TOL1 )
                fu = call_func_deriv( func_name, xu, du, POINT=pn, DIR=dirn )

                if (fu GT fmin) AND (abs( ds ) LT TOL1) then return

                if (fu LE fmin) then begin

                        if (xu GE xmin) then xLo=xmin else xHi=xmin
                        xv = xw  &  fv = fw  &  dv = dw
                        xw = xmin  &  fw = fmin  &  dw = dx
                        xmin = xu  &  fmin = fu  &  dx = du
                
                  endif else begin

                        if (xu LT xmin) then xLo=xu else xHi=xu

                        if (fu LE fw) OR (xw EQ xmin) then begin

                                xv = xw  &  fv = fw  &  dv = dw
                                xw = xu  &  fw = fu  &  dw = du

                          endif else if (fu LE fv) OR (xv EQ xmin) $
                                                   OR (xv EQ xw) then begin
                                xv = xu  &  fv = fu  &  dv = du
                           endif
                   endelse
          endfor

        message,"exceeded maximum number of iterations: "+strtrim(iter,2),/INFO
return
end
</code>
    </div>
  </body>
</html>