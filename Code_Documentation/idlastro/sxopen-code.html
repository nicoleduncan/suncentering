<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:04 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sxopen.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sxopen.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="SXOPEN:source"></a>pro SXOPEN,unit,fname,header,history,access
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       SXOPEN</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Open a Space Telescope formatted (STSDAS) header file.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Saves the parameters required subsequent SX routines in</span>
<span class="comments">;       the common block Stcommn.  Optionally save the header in </span>
<span class="comments">;       the string array Header, and the history in the string array</span>
<span class="comments">;       History.  Open the data file associated with this</span>
<span class="comments">;       header on the same unit.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       SXOPEN, Unit, Fname [, Header [,History] [,Access]]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Unit = IDL unit used for IO.  Must be from 1 to 9.</span>
<span class="comments">;       Fname = File name of header file.  Default extension</span>
<span class="comments">;               is .hhh for header files and .hhd for data</span>
<span class="comments">;               files.    If an extension is supplied it must have the </span>
<span class="comments">;               form .xxh where xx are any alphanumeric characters. The</span>
<span class="comments">;               data file must have extension .xxd</span>
<span class="comments">;               No version number is allowed.  Most recent versions</span>
<span class="comments">;               of the files are used.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT PARAMETER:</span>
<span class="comments">;       Access = 'R' to open for read, 'W' to open for write.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       Stcommn = Common block containing ST parameter blocks.</span>
<span class="comments">;               (Long arrays.)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT PARAMETERS:</span>
<span class="comments">;       Header = 80 char by N string array containing the</span>
<span class="comments">;               names, values and comments from the FITS header.</span>
<span class="comments">;               Use the function SXPAR to obtain individual</span>
<span class="comments">;               parameter values.</span>
<span class="comments">;       History = String array containing the value of the</span>
<span class="comments">;               history parameter.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       STCOMMN - Contains RESULT(20,10) where RESULT(i,LUN) =</span>
<span class="comments">;       0 - 121147 for consistency check, 1 - Unit for consistency,</span>
<span class="comments">;       2 - bitpix, 3 - naxis, 4 - groups (0 or 1), 5 - pcount,</span>
<span class="comments">;       6 - gcount, 7 - psize, 8 - data type as idl type code,</span>
<span class="comments">;       9 - bytes / record, 10 to 10+N-1 - dimension N,</span>
<span class="comments">;       17 = record length of file in bytes.</span>
<span class="comments">;       18 - # of groups written, 19 = gcount.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;       The data and header files are accessed.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       Works only for disc files.  The data file must have</span>
<span class="comments">;       must have the extension ".xxd" and the header file must</span>
<span class="comments">;       have the extension ".xxh" where x is any alphanumeric character</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       The header file is opened and each line is read.</span>
<span class="comments">;       Important parameters are stored in the output</span>
<span class="comments">;       parameter.  If the last two parameters are specified</span>
<span class="comments">;       the parameter names and values are stored.  The common</span>
<span class="comments">;       block STCOMMN is filled with the type of data, dimensions,</span>
<span class="comments">;       etc. for use by SXREAD.</span>
<span class="comments">;</span>
<span class="comments">;       If access is for write, each element of the header</span>
<span class="comments">;       array, which must be supplied, is written to the</span>
<span class="comments">;       header file.  The common block is filled with</span>
<span class="comments">;       relevant parameters for SXWRITE.  A keyword of "END"</span>
<span class="comments">;       ends the header.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, DMS, May, 1983.</span>
<span class="comments">;       D. Lindler Feb. 1990</span>
<span class="comments">;               Modified to allow var. record length header files.</span>
<span class="comments">;       D. Lindler April 1990   Conversion to new VMS IDL</span>
<span class="comments">;       Added /BLOCK when opening new .hhd file</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Recognize unsigned datatype for V5.1 or greater   W. Landsman Jan 2000</span>
<span class="comments">;       Assume since V5.5  W. Landsman Sep 2006</span>
<span class="comments">;-</span>
<span class="comments">;------------------------------------------------------------------------------</span>
        On_error,2
        common stcommn,result,filename
<span class="comments">;</span>
     if N_params() LT 2 then begin
         print, 'Syntax: SXOPEN, unit, fname, [ header, history, access]'
         return
     endif
<span class="comments">;</span>
        if N_elements(result) NE 200 then begin <span class="comments">;defined?</span>
                result = lonarr(20,10)
                filename = strarr(10)
                endif
<span class="comments">;</span>
        if (unit lt 1) OR (unit gt 9) then $
                message,'Unit number must be from 1 to 9.'
<span class="comments">;</span>
        close,unit              <span class="comments">;close unit first</span>
<span class="comments">;</span>
        n = N_params(0)              <span class="comments">;# of parameters we have</span>
        if n LT 5 then access = 'R'   <span class="comments">;read access if unspecified</span>
<span class="comments">;</span>
<span class="comments">; Add default extension (.hhh) if not specified       </span>
<span class="comments">;</span>
        xname=strtrim(fname,2)
        if strmid(xname,strlen(xname)-4,1) NE '.' then xname = xname + '.hhh'
        t=xname                         <span class="comments">;Open keywords.</span>
        CASE strupcase(access) OF
'R':    sxhread,fname,header               <span class="comments">;Read FITS header</span>
'W':    sxhwrite,fname,header              <span class="comments">;Write FITS header</span>
ELSE:   message,'Illegal access value, must be R or W'
        ENDCASE
<span class="comments">;</span>
        result[*,unit]=0        <span class="comments">;Zero our block     </span>
        filename[unit]=fname    <span class="comments">;Save file name   </span>
        result[0,unit]=121147L  <span class="comments">;Code for descr block   </span>
        result[1,unit] = unit   <span class="comments">;Save unit number    </span>
        result[6,unit]=1        <span class="comments">;Default value of GCOUNT is 1</span>
<span class="comments">;</span>
<span class="comments">; Get keyword names and values from header array</span>
<span class="comments">;</span>
 name =  strtrim(strmid(header,0,8),2)   <span class="comments">;param name</span>
 value = strtrim(strmid(header,10,20),2) <span class="comments">;param value</span>
<span class="comments">;</span>
 L_bitpix = where(name EQ 'BITPIX',nfound)
      if nfound GT 0 then result[2,unit] = value[L_bitpix[0]] else $
       message,'Required Keyword BITPIX not found',/CON
<span class="comments">;</span>
 l_naxis = where(strmid(name,0,5) EQ 'NAXIS',nfound)         
      IF nfound GT 0 then BEGIN
           axis = fix(strtrim(strmid(name[l_naxis],5,3),2))
           for i=0,nfound-1 do begin
                if axis[i] EQ 0 then  $
                       result[3,unit]=value[l_naxis[i]] else  $  <span class="comments">;# of dimensions</span>
                       result[9+axis[i],unit]=value[l_naxis[i]] <span class="comments">;each dimension</span>
            endfor
       endif else message,'Required Keyword NAXIS not found'
<span class="comments">;           </span>
 if n GE 4 then BEGIN                <span class="comments">;Create history parameter?</span>
   L_hist = where(name EQ 'HISTORY',nfound)  
   IF nfound then history = strtrim(strmid(header[l_hist],8,72),2) else $
                  history = ''  
ENDIF
<span class="comments">;</span>
 L_groups = where(name EQ 'GROUPS',nfound)
   if nfound GT 0 then result[4,unit] = value[L_groups[0]] eq 'T'
<span class="comments">;</span>
 L_pcount = where(name EQ 'PCOUNT',nfound)
   if nfound GT 0 then result[5,unit] = value[L_pcount[0]]
<span class="comments">;</span>
 L_gcount = where(name EQ 'GCOUNT',nfound)
if nfound GT 0 then result[6,unit] = value[L_gcount[0]]
<span class="comments">;</span>
 L_psize = where(name EQ 'PSIZE',nfound)
 if nfound GT 0 then result[7,unit] = value[L_psize[0]]/8 $
               else result[7,unit] = result[5,unit]*result[2,unit]
<span class="comments">;</span>
 L_datatype = where(name EQ 'DATATYPE',nfound)
 if nfound GT 0 then begin 
                v = value[L_datatype[0]]      <span class="comments">;Process data type.</span>
                v = strmid(v,1,strlen(v)-2)   <span class="comments">;Remove apostrophes</span>
                v = strtrim(v,2)                    <span class="comments">;trim blanks</span>
                CASE v OF       <span class="comments">;Cvt datatype to IDL type code    </span>
                'BYTE':                 result[8,unit]=1
                'LOGICAL*1':            result[8,unit]=1        <span class="comments">;Byte</span>
                'INTEGER*1':            result[8,unit]=1
                'REAL*4':               result[8,unit]=4
                'INTEGER*2':            result[8,unit]=2
                'UNSIGNED*2':           result[8,unit]=12
                'INTEGER*4':            result[8,unit]=3
                'UNSIGNED*4':           result[8,unit]=13 
                'REAL*8':               result[8,unit]=5
                'COMPLEX*8':            result[8,unit]=6
                ELSE:                   message,'Undefined Datatype value'
                ENDCASE         <span class="comments">;V OF</span>
 endif                       <span class="comments">;DATATYPE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; If DATATYPE not specified assume integer of size specified by BITPIX</span>
<span class="comments">;</span>
        if result[8,unit] EQ 0 then begin
                CASE result[2,unit] OF
                        8: result[8,unit]=1             <span class="comments">;byte</span>
                       16: result[8,unit]=2             <span class="comments">;integer*2</span>
                       32: result[8,unit]=3             <span class="comments">;integer*4</span>
                      -32: result[8,unit]=4
                      -64: result[8,unit]=5
                     else: message,'Unable to determine data type'
                ENDCASE
        endif
<span class="comments">;      </span>
        bytes = abs(result[2,unit])/8l  <span class="comments">;bytes/datum</span>
        for j=1,result[3,unit] do $     <span class="comments">;accum bytes/record</span>
                        bytes=bytes*result[9+j,unit]
        bytes = bytes + result[7,unit]     <span class="comments">;+ header.</span>
        result[9,unit]=bytes               <span class="comments">;Save bytes/record. </span>
<span class="comments">;</span>
        xname=strmid(xname,0,strlen(xname)-1)+'d'   <span class="comments">;Change to data filename  </span>
<span class="comments">;</span>
        If result[3,unit] GT 0 then begin      <span class="comments">;NAXIS non-zero?</span>
          close,unit
          if strupcase(access) eq 'R' then $
                openr,unit,xname  $
          else begin
                nrecs = (result[6,unit]*result[9,unit]+511)/512
                openw, unit, xname
          endelse
        result[17,unit] = 512           <span class="comments">;Save record length    </span>
        endif else result[17,unit]=0    <span class="comments">;NAXIS = 0</span>
        return
end  
</code>
    </div>
  </body>
</html>