<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:02 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>srcor.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="srcor.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO srcor,x1in,y1in,x2in,y2in,dcr,ind1,ind2,option=option,magnitude=magnitude,$
   spherical=spherical,silent=silent,count = count
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       SRCOR</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Correlate the source positions found on two lists.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Source matching is done by finding sources within a specified radius.</span>
<span class="comments">;       If you have position errors available and wish to match by significance</span>
<span class="comments">;       level, then try match_xy.pro in the TARA library </span>
<span class="comments">;      (http://www.astro.psu.edu/xray/docs/TARA/)</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       srcor,x1in,ylin,x2in,y2in,dcr,ind1,ind2,</span>
<span class="comments">;                         [MAGNITUDE=,SPHERICAL=,COUNT=,/SILENT]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       x1in,y1in - First set of x and y coordinates.  The program</span>
<span class="comments">;                   marches through this list element by element,</span>
<span class="comments">;                   looking in list 2 for the closest match.  So, the program</span>
<span class="comments">;                   will run faster if this is the shorter of the two lists.</span>
<span class="comments">;                   Unless you use the option or magnitude keyword, there is</span>
<span class="comments">;                   nothing to guarantee unique matches.  </span>
<span class="comments">;       x2in,y2in - Second set of x and y coordinates.  This list is</span>
<span class="comments">;                   searched in its entirety every time one element of list 1</span>
<span class="comments">;                   is processed.</span>
<span class="comments">;       dcr - Critical radius outside which correlations are rejected;</span>
<span class="comments">;             but see 'option' below.</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;       option - Changes behavior of program and description of output</span>
<span class="comments">;                lists slightly, as follows: </span>
<span class="comments">;       OPTION=0 or left out</span>
<span class="comments">;             Same as older versions of SRCOR.  The closest match from list2</span>
<span class="comments">;             is found for each element of list 1, but if the distance is</span>
<span class="comments">;             greater than DCR, the match is thrown out.  Thus the index</span>
<span class="comments">;             of that element within list 1 will not appear in the IND1 output</span>
<span class="comments">;             array.</span>
<span class="comments">;       OPTION=1</span>
<span class="comments">;             Forces the output mapping to be one-to-one.  OPTION=0 results,</span>
<span class="comments">;             in general, in a many-to-one mapping from list 1 to list 2.</span>
<span class="comments">;             Under OPTION=1, a further processing step is performed to</span>
<span class="comments">;             keep only the minimum-distance match, whenever an entry from</span>
<span class="comments">;             list 1 appears more than once in the initial mapping.</span>
<span class="comments">;       OPTION=2</span>
<span class="comments">;             Same as OPTION=1, except the critical distance parameter DCR</span>
<span class="comments">;             is ignored.  I.e., the closest object is retrieved from list 2</span>
<span class="comments">;             for each object in list 1 WITHOUT a critical-radius criterion,</span>
<span class="comments">;             then the clean-up of duplicates is done as under OPTION=1.</span>
<span class="comments">;       magnitude</span>
<span class="comments">;             An array of stellar magnitudes corresponding to x1in and y1in.  </span>
<span class="comments">;             If this is supplied, then the brightest star from list 1</span>
<span class="comments">;             within the selected distance of the star in list 2 is taken.</span>
<span class="comments">;             The option keyword is ignored in this case.</span>
<span class="comments">;       spherical</span>
<span class="comments">;             If SPHERICAL=1, it is assumed that the input arrays are in</span>
<span class="comments">;             celestial coordinates (RA and Dec), with x1in and x2in in</span>
<span class="comments">;             decimal hours and y1in and y2in in decimal degrees.  If</span>
<span class="comments">;             SPHERICAL=2 then it is assumed that the input arrays are in</span>
<span class="comments">;             longitude and latitude with x1in,x2in,y1in,y2in in decimal</span>
<span class="comments">;             degrees.  In both cases, the critial radius dcr is in</span>
<span class="comments">;             *arcseconds*.  Calculations of spherical distances are made</span>
<span class="comments">;             with the gcirc program.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       ind1 - index of matched stars in first list, set to -1 if no matches</span>
<span class="comments">;              found</span>
<span class="comments">;       ind2 - index of matched stars in second list</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       Count - integer giving number of matches returned</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       GCIRC, REMOVE</span>
<span class="comments">; REVISON HISTORY:</span>
<span class="comments">;       Adapted from UIT procedure  J.Wm.Parker, SwRI 29 July 1997</span>
<span class="comments">;       Improve speed for spherical searches, added /SILENT keyword  </span>
<span class="comments">;                               W. Landsman  Mar 2009</span>
<span class="comments">;       Avoid error when no matches found with /SPHERICAL  O. Trottier June 2009</span>
<span class="comments">;       Added output Count keyword     W.L   June 2009</span>
<span class="comments">;       Adjust right ascension for cosine angle W.L. December 2009</span>
<span class="comments">;       Return as soon as no matches found W.L.  December 2009</span>
<span class="comments">;       Use some V6.0 notation  W.L.   February 2011</span>
<span class="comments">;       Fix problem when /Spherical and Option =2 set, and sources separated</span>
<span class="comments">;          by more han 180 degrees.   W.L.  March 2011</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
<span class="comments">;</span>
 ON_Error,2   <span class="comments">; Return if error (incl. non-info message)</span>
 compile_opt idl2
<span class="comments">;;;</span>
<span class="comments">;   If not enough parameters, then print out the syntax.</span>
<span class="comments">;</span>
IF N_params() lt 7 THEN BEGIN
  print,'SRCOR calling sequence: '
  print,'srcor,x1in,y1in,x2in,y2in,dcr,ind1,ind2 [,option={0, 1, or 2}] $'
  print,'      [,magnitude=mag_list_1, COUNT=count, spherical={1 or 2}, /SILENT]'
  RETURN
ENDIF
 count = 0

<span class="comments">;;;</span>
<span class="comments">;   Keywords.</span>
<span class="comments">;</span>
IF ~keyword_set(option) THEN option=0
IF (option lt 0) or (option gt 2) THEN MESSAGE,'Invalid option code.'

SphereFlag = keyword_set(Spherical)

<span class="comments">;;;</span>
<span class="comments">;   Store the input variables into internal arrays that we can manipulate and</span>
<span class="comments">; modify.</span>
<span class="comments">;</span>
x1 = x1in
y1 = y1in
x2 = x2in
y2 = y2in 

<span class="comments">;;;</span>
<span class="comments">;   If the Spherical keyword is set, then convert the input values (degrees</span>
<span class="comments">; and maybe hours) into radians, so GCIRC doesn't have to make this calculation</span>
<span class="comments">; each time it is called in the FOR loop.  Also convert the critical radius</span>
<span class="comments">; (which is in arcsec, so convert by 3600.) to radians</span>
<span class="comments">;</span>
if SphereFlag then begin
   dcr2 = dcr
   XScale = Spherical EQ 1 ? 15.0 : 1.0
   d2r  = !DPI/180.0d0
   x1 = x1 * (XScale * d2r)
   y1 = y1 * d2r
   x2 = x2 * (XScale * d2r)
   y2 = y2 * d2r
   cosy2 = sin(y2)
   dcr2 = dcr2 * (d2r / 3600.)
   radcr2 = dcr2/cos(y2)        <span class="comments">;Adjust RA for declination</span>
endif else dcr2=dcr^2


<span class="comments">;;;</span>
<span class="comments">;   Set up some other variables.</span>
<span class="comments">;</span>
 n1 = N_elements(x1)  
 n2 = N_elements(x2) 
 if ~keyword_set(silent) then begin 
      message,/info,'Option code = '+strtrim(option,2)
      message,/info,strtrim(n1,2)+' sources in list 1'
       message,/info,strtrim(n2,2)+' sources in list 2'
  endif

<span class="comments">;;;</span>
<span class="comments">;   The main loop.  Step through each index of list 1, look for matches in 2.</span>
<span class="comments">;</span>
  nmch = 0L
 ind1 = lonarr(n1)-1 & ind2 = ind1
   
   if SphereFlag then begin         
      if option EQ 2 then begin      <span class="comments">;Closest source, no critical distance</span>
<span class="comments">;For speed we find the maximum value of cos(d) where d is the arc distance</span>
<span class="comments">;This avoids having to calculate the arc cosine.    Test modified Mar 2011       </span>
         cosy2 = cos(y2)
          siny2 = sin(y2)
     FOR i=0L,n1-1 DO BEGIN
         d2  =  siny2*sin(y1[i]) + cosy2*cos(y1[i])*cos(x1[i]-x2)
         dmch = max(d2,m)                 <span class="comments">;Uncommented 29-May-2009 	 </span>
	 ind1[nmch] = i
         ind2[nmch] = m
         nmch++
      ENDFOR
      
      endif else begin               <span class="comments">;Closest source within critical distance</span>
        
<span class="comments">;For speed we first find sources within a square of the size of the critical</span>
<span class="comments">;distance.    Exact distances are then computed for sources within the square.      </span>
     FOR i=0L,n1-1 DO BEGIN
           xx = x1[i] & yy = y1[i]

        g = where(( x2 GE (xx-radcr2)) and (x2 LE (xx+radcr2)) and $
	(y2 GE (yy-dcr2)) and  (y2 LE (yy + dcr2)), Ng)

        if Ng GT 0 then begin 
          gcirc,0,x2[g],y2[g],xx,yy,d2
          dmch = min(d2,mg)
          if dmch LE dcr2 then begin 
	      ind1[nmch] = i
	      ind2[nmch] = g[mg]
	      nmch++
       endif
       endif 
       ENDFOR
       endelse
    endif else begin 
    FOR i=0L,n1-1 DO BEGIN

       d2=(x1[i]-x2)^2+(y1[i]-y2)^2
       dmch=min(d2,m)
         IF (option eq 2) || (dmch le dcr2) THEN BEGIN
      ind1[nmch] = i
      ind2[nmch] = m
      nmch++
   ENDIF 
   ENDFOR  
   endelse

if ~keyword_set(silent) then message,/info,strtrim(nmch,2)+' matches found.'

count = nmch
if nmch GT 0 then begin 
   ind1 = ind1[0:nmch-1]
   ind2 = ind2[0:nmch-1]
endif else begin 
   ind1 = -1 & ind2 = -1
   return
endelse   
<span class="comments">;;;</span>
<span class="comments">;   Modify the matches depending on input options.</span>
<span class="comments">;</span>
use_mag = (n_elements(magnitude) ge 1)
IF (option eq 0) && (~use_mag) THEN RETURN
if ~keyword_set(silent) then begin
IF use_mag THEN BEGIN
   message,/info,'Cleaning up output list using magnitudes.'
ENDIF ELSE BEGIN
   
   IF option eq 1 then message,/info,'Cleaning up output list (option = 1).'
   IF option eq 2 then message,/info,'Cleaning up output list (option = 2).'
ENDELSE
endif

FOR i=0L,max(ind2) DO BEGIN
   csave = n_elements(ind2)
   ww = where(ind2 eq i,count) <span class="comments">; All but one of the list in WW must</span>
                               <span class="comments">; eventually be removed.</span>
   IF count gt 1 THEN BEGIN
      IF use_mag THEN BEGIN
         dummy = min(magnitude[ind1[ww]],m)
      ENDIF ELSE BEGIN
         xx=x2[i] & yy=y2[i]
         if SphereFlag then gcirc,0,xx,yy,x1[ind1[ww]],y1[ind1[ww]],d2 else $
                            d2=(xx-x1[ind1[ww]])^2+(yy-y1[ind1[ww]])^2
         IF n_elements(d2) ne count THEN MESSAGE,'Logic error 1'
         dummy = min(d2,m)
      ENDELSE
      remove,m,ww              <span class="comments">; Delete the minimum element</span>
                               <span class="comments">; from the deletion list itself.</span>

      remove,ww,ind1,ind2      <span class="comments">; Now delete the deletion list from</span>
                               <span class="comments">; the original index arrays.</span>
      IF n_elements(ind2) ne (csave-count+1) THEN MESSAGE,'Logic error 2'
      IF n_elements(ind1) ne (csave-count+1) THEN MESSAGE,'Logic error 3'
      IF n_elements(ind2) ne n_elements(ind1) THEN MESSAGE,'Logic error 4'
   ENDIF
ENDFOR

 count = N_elements(ind1)
 if ~keyword_set(silent) then $
  message,/info,strtrim(n_elements(ind1),2)+' final matches found'

<span class="comments">;</span>
RETURN
end
</code>
    </div>
  </body>
</html>