<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:06 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tabinv.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tabinv.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO TABINV, XARR, X, IEFF, FAST = fast
<span class="comments">;+ </span>
<span class="comments">; NAME:</span>
<span class="comments">;       TABINV     </span>
<span class="comments">; PURPOSE:  </span>
<span class="comments">;       To find the effective index of a function value in an ordered vector.</span>
<span class="comments">;       </span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       TABINV, XARR, X, IEFF, [/FAST]</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       XARR - the vector array to be searched, must be monotonic</span>
<span class="comments">;               increasing or decreasing</span>
<span class="comments">;       X    - the function value(s) whose effective</span>
<span class="comments">;               index is sought (scalar or vector)</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       IEFF - the effective index or indices of X in XARR</span>
<span class="comments">;              always floating point, same # of elements as X</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT:</span>
<span class="comments">;       /FAST - If this keyword is set, then the input vector is not checked</span>
<span class="comments">;               for monotonicity, in order to improve the program speed.</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       TABINV will abort if XARR is not monotonic.  (Equality of </span>
<span class="comments">;       neighboring values in XARR is allowed but results may not be</span>
<span class="comments">;       unique.)  This requirement may mean that input vectors with padded</span>
<span class="comments">;       zeroes could cause routine to abort.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       VALUE_LOCATE() is used to find the values XARR[I]</span>
<span class="comments">;       and XARR[I+1] where XARR[I] &lt; X &lt; XARR[I+1].</span>
<span class="comments">;       IEFF is then computed using linear interpolation </span>
<span class="comments">;       between I and I+1.</span>
<span class="comments">;               IEFF = I + (X-XARR[I]) / (XARR[I+1]-XARR[I])</span>
<span class="comments">;       Let N = number of elements in XARR</span>
<span class="comments">;               if x &lt; XARR[0] then IEFF is set to 0</span>
<span class="comments">;               if x > XARR[N-1] then IEFF is set to N-1</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Set all flux values of a spectrum (WAVE vs FLUX) to zero</span>
<span class="comments">;       for wavelengths less than 1150 Angstroms.</span>
<span class="comments">;         </span>
<span class="comments">;       IDL> tabinv, wave, 1150.0, I</span>
<span class="comments">;       IDL> flux[ 0:fix(I) ] = 0.                         </span>
<span class="comments">;</span>
<span class="comments">; FUNCTIONS CALLED:</span>
<span class="comments">;       None</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Adapted from the IUE RDAF                     January, 1988         </span>
<span class="comments">;       More elegant code  W. Landsman                August, 1989</span>
<span class="comments">;       Mod to work on 2 element decreasing vector    August, 1992</span>
<span class="comments">;       Updated for V5.3 to use VALUE_LOCATE()     W. Landsman January 2000</span>
<span class="comments">;       Work when both X and Xarr are integers     W. Landsman August 2001</span>
<span class="comments">;       Use ARRAY_EQUAL, always internal double precision W.L.  July 2009</span>
<span class="comments">;       Allow Double precision output, faster test for monotonicity.</span>
<span class="comments">;                    WL, January 2012</span>
<span class="comments">;-               </span>
 On_error,2
 compile_opt idl2

 if N_params() LT 3 then begin
     print,'Syntax- TABINV, XARR, X, I, [/FAST]'
     return
 endif

 Npoints = N_elements(xarr) & npt= npoints - 1
 if ( Npoints LE 1 ) then message, /TRACE, $
   'Search vector (first parameter) must contain at least 2 elements'

 do_double= (size(xarr,/tname) EQ 'DOUBLE') || (size(x,/TNAME) EQ 'DOUBLE')

 if ~keyword_set(fast) then begin

 <span class="comments">; Test for monotonicity (everywhere increasing or decreasing vector)</span>

  i = xarr[1:*] GE xarr
   test = array_equal( i, 1b) || array_equal(i, 0b) 
     if ~test then  message, $
       'ERROR - First parameter must be a monotonic vector' 
 endif

 if do_double then ieff = double( VALUE_LOCATE(xarr,x)) else $
                   ieff = float(  VALUE_LOCATE(xarr,x))
 g = where( (ieff LT npt) and (ieff GE 0), Ngood)
 if Ngood GT 0 then begin
      neff = ieff[g]
      x0 = double(xarr[neff])
      diff =  x[g] - x0
      ieff[g] = neff +  diff / (xarr[neff+1] - x0 ) 
 endif
     
 ieff = ieff > 0.0

 return
 end
</code>
    </div>
  </body>
</html>