<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:28 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>eq2hor.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="eq2hor.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   EQ2HOR</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;    Convert celestial  (ra-dec) coords to local horizon coords (alt-az).</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;    eq2hor, ra, dec, jd, alt, az, [ha, LAT= , LON= , /WS, OBSNAME= , $</span>
<span class="comments">;                       /B1950 , PRECESS_= 0, NUTATE_= 0, REFRACT_= 0, $</span>
<span class="comments">;                       ABERRATION_= 0, ALTITUDE= , /VERBOSE, _EXTRA= ]</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;  This  code calculates horizon (alt,az) coordinates from equatorial</span>
<span class="comments">;  (ra,dec) coords.   It is typically accurate to about 1 arcsecond or better (I</span>
<span class="comments">;  have checked the output against the publicly available XEPHEM software). It</span>
<span class="comments">;  performs precession, nutation, aberration, and refraction corrections.  The</span>
<span class="comments">;  perhaps best thing about it is that it can take arrays as inputs, in all</span>
<span class="comments">;  variables and keywords EXCEPT Lat, lon, and Altitude (the code assumes these</span>
<span class="comments">;  aren't changing), and uses vector arithmetic in every calculation except</span>
<span class="comments">;  when calculating the precession matrices.</span>
<span class="comments">;</span>
<span class="comments">; INPUT VARIABLES:</span>
<span class="comments">;       RA   : Right Ascension of object  (J2000) in degrees (FK5); scalar or</span>
<span class="comments">;              vector.</span>
<span class="comments">;       Dec  : Declination of object (J2000) in degrees (FK5), scalar or vector.</span>
<span class="comments">;       JD   : Julian Date [scalar or vector]</span>
<span class="comments">;</span>
<span class="comments">;       Note: if RA and DEC are arrays, then alt and az will also be arrays.</span>
<span class="comments">;             If RA and DEC are arrays, JD may be a scalar OR an array of the</span>
<span class="comments">;             same dimensionality.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       lat   : north geodetic latitude of location in degrees</span>
<span class="comments">;       lon   : EAST longitude of location in degrees (Specify west longitude</span>
<span class="comments">;               with a negative sign.)</span>
<span class="comments">;       /WS    : Set this to get the azimuth measured westward from south (not</span>
<span class="comments">;               East of North).</span>
<span class="comments">;       obsname: Set this to a valid observatory name to be used by the</span>
<span class="comments">;              astrolib OBSERVATORY procedure, which will return the latitude</span>
<span class="comments">;              and longitude to be used by this program.</span>
<span class="comments">;       /B1950 : Set this if your ra and dec are specified in B1950, FK4</span>
<span class="comments">;              coordinates (instead of J2000, FK5)</span>
<span class="comments">;       precess_ : Set this to 1 to force precession [default], 0 for no</span>
<span class="comments">;               precession correction</span>
<span class="comments">;       nutate_  : Set this to 1 to force nutation [default], 0 for no nutation.</span>
<span class="comments">;       aberration_ : Set this to 1 to force aberration correction [default],</span>
<span class="comments">;                     0 for no correction.</span>
<span class="comments">;       refract_ : Set to 1 to force refraction correction [default], 0 for no</span>
<span class="comments">;                     correction.</span>
<span class="comments">;       altitude: The altitude of the observing location, in meters. [default=0].</span>
<span class="comments">;       verbose: Set this for verbose output.  The default is verbose=0.</span>
<span class="comments">;       _extra: This is for setting TEMPERATURE or PRESSURE explicitly, which are</span>
<span class="comments">;               used by CO_REFRACT to calculate the refraction effect of the</span>
<span class="comments">;               atmosphere. If you don't set these, the program will make an</span>
<span class="comments">;               intelligent guess as to what they are (taking into account your</span>
<span class="comments">;               altitude).  See CO_REFRACT for more details.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT VARIABLES: (all double precision)</span>
<span class="comments">;       alt    : altitude (in degrees)</span>
<span class="comments">;       az     : azimuth angle (in degrees, measured EAST from NORTH, but see</span>
<span class="comments">;                keyword WS above.)</span>
<span class="comments">;       ha     : hour angle (in degrees) (optional)</span>
<span class="comments">;</span>
<span class="comments">; DEPENDENCIES:</span>
<span class="comments">;       NUTATE, PRECESS, OBSERVATORY, SUNPOS, ADSTRING()</span>
<span class="comments">;       CO_NUTATE, CO_ABERRATION, CO_REFRACT, ALTAZ2HADEC, SETDEFAULTVALUE</span>
<span class="comments">;</span>
<span class="comments">; BASIC STEPS</span>
<span class="comments">;   Apply refraction correction to find apparent Alt.</span>
<span class="comments">;   Calculate Local Mean Sidereal Time</span>
<span class="comments">;   Calculate Local Apparent Sidereal Time</span>
<span class="comments">;   Do Spherical Trig to find apparent hour angle, declination.</span>
<span class="comments">;   Calculate Right Ascension from hour angle and local sidereal time.</span>
<span class="comments">;   Nutation Correction to Ra-Dec</span>
<span class="comments">;   Aberration correction to Ra-Dec</span>
<span class="comments">;       Precess Ra-Dec to current equinox.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;CORRECTIONS I DO NOT MAKE:</span>
<span class="comments">;   *  Deflection of Light by the sun due to GR. (typically milliarcseconds,</span>
<span class="comments">;        can be arseconds within one degree of the sun)</span>
<span class="comments">;   *  The Effect of Annual Parallax (typically &lt; 1 arcsecond)</span>
<span class="comments">;   *  and more (see below)</span>
<span class="comments">;</span>
<span class="comments">; TO DO</span>
<span class="comments">;    * Better Refraction Correction.  Need to put in wavelength dependence,</span>
<span class="comments">;    and integrate through the atmosphere.</span>
<span class="comments">;        * Topocentric Parallax Correction (will take into account elevation of</span>
<span class="comments">;          the observatory)</span>
<span class="comments">;    * Proper Motion (but this will require crazy lookup tables or something).</span>
<span class="comments">;        * Difference between UTC and UT1 in determining LAST -- is this</span>
<span class="comments">;          important?</span>
<span class="comments">;        * Effect of Annual Parallax (is this the same as topocentric Parallax?)</span>
<span class="comments">;    * Polar Motion</span>
<span class="comments">;        * Better connection to Julian Date Calculator.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE</span>
<span class="comments">;</span>
<span class="comments">;  Find the position of the open cluster NGC 2264 at the Effelsburg Radio</span>
<span class="comments">;  Telescope in Germany, on June 11, 2023, at local time 22:00 (METDST).</span>
<span class="comments">;  The inputs will then be:</span>
<span class="comments">;</span>
<span class="comments">;       Julian Date = 2460107.250</span>
<span class="comments">;       Latitude = 50d 31m 36s</span>
<span class="comments">;       Longitude = 06h 51m 18s</span>
<span class="comments">;       Altitude = 369 meters</span>
<span class="comments">;       RA (J2000) = 06h 40m 58.2s</span>
<span class="comments">;       Dec(J2000) = 09d 53m 44.0s</span>
<span class="comments">;</span>
<span class="comments">;  IDL> eq2hor, ten(6,40,58.2)*15., ten(9,53,44), 2460107.250d, alt, az, $</span>
<span class="comments">;               lat=ten(50,31,36), lon=ten(6,51,18), altitude=369.0, /verb, $</span>
<span class="comments">;                pres=980.0, temp=283.0</span>
<span class="comments">;</span>
<span class="comments">; The program produces this output (because the VERBOSE keyword was set)</span>
<span class="comments">;</span>
<span class="comments">; Latitude = +50 31 36.0   Longitude = +06 51 18.0</span>
<span class="comments">; Julian Date =  2460107.250000</span>
<span class="comments">; Ra, Dec:  06 40 58.2  +09 53 44.0   (J2000)</span>
<span class="comments">; Ra, Dec:  06 42 15.7  +09 52 19.2   (J2023.4422)</span>
<span class="comments">; Ra, Dec:  06 42 13.8  +09 52 26.9   (fully corrected)</span>
<span class="comments">; LMST = +11 46 42.0</span>
<span class="comments">; LAST = +11 46 41.4</span>
<span class="comments">; Hour Angle = +05 04 27.6  (hh:mm:ss)</span>
<span class="comments">; Az, El =  17 42 25.6  +16 25 10.3   (Apparent Coords)</span>
<span class="comments">; Az, El =  17 42 25.6  +16 28 22.8   (Observer Coords)</span>
<span class="comments">;</span>
<span class="comments">; Compare this with the result from XEPHEM:</span>
<span class="comments">; Az, El =  17h 42m 25.6s +16d 28m 21s</span>
<span class="comments">;</span>
<span class="comments">; This 1.8 arcsecond discrepancy in elevation arises primarily from slight</span>
<span class="comments">; differences in the way I calculate the refraction correction from XEPHEM, and</span>
<span class="comments">; is pretty typical.</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Chris O'Dell</span>
<span class="comments">;       Univ. of Wisconsin-Madison</span>
<span class="comments">;   Observational Cosmology Laboratory</span>
<span class="comments">;   Email: odell@cmb.physics.wisc.edu</span>
<span class="comments">;  Revision History: </span>
<span class="comments">;    August 2012  Use Strict_Extra to flag spurious keywords W. Landsman</span>
<span class="comments">;-</span>

<a id="eq2hor:source"></a>pro eq2hor, ra, dec, jd, alt, az, ha, lat=lat, lon=lon, WS=WS, obsname=obsname,$
     B1950 = B1950, verbose=verbose, precess_=precess_, nutate_=nutate_, $
                refract_ = refract_, aberration_ = aberration_,  $
                altitude = altitude, _extra= _extra

 On_error,2
 compile_opt idl2
 
if N_params() LT 4 then begin
    print,'Syntax - EQ2HOR, ra, dec, jd, alt, az, [ha, LAT= , LON= , /WS, '
    print,'          OBSNAME= ,/B1950 , PRECESS_= 0, NUTATE_= 0, REFRACT_= 0 '
    print,'          ABERRATION_= 0, ALTITUDE= , /VERBOSE, TEMPERATURE=, ' +$
          'PRESSURE = ]'
     return
 endif

<span class="comments">;*******************************************************************************</span>
<span class="comments">; INITIALIZE STUFF</span>

<span class="comments">; If no lat or lng entered, use Pine Bluff Observatory values!</span>
<span class="comments">;   (near Madison, Wisconsin, USA)</span>
<span class="comments">; * Feel free to change these to your favorite observatory *</span>
setdefaultvalue, lat,   43.0783d <span class="comments">; (this is the declination of the zenith)</span>
setdefaultvalue, lon, -89.865d
setdefaultvalue, altitude, 0.                <span class="comments">; [meters]</span>
if keyword_set(obsname) then begin
        <span class="comments">;override lat,lon, altitude if observatory name has been specified</span>
        observatory, obsname, obs
        lat = obs.latitude
        lon = -1*obs.longitude <span class="comments">; minus sign is because OBSERVATORY uses west</span>
<span class="comments">;                               longitude as positive.</span>
        altitude = obs.altitude
endif

setdefaultvalue, precess_, 1
setdefaultvalue, nutate_, 1
setdefaultvalue, aberration_, 1
setdefaultvalue, refract_ , 1
v = keyword_set(verbose)

<span class="comments">; conversion factors</span>
d2r = !dpi/180.
h2r = !dpi/12.
h2d = 15.d

ra_ = ra <span class="comments">; do this so we don't change ra, dec arrays.</span>
dec_ = dec

if v then print, 'Latitude = ', adstring(lat), '   Longitude = ', adstring(lon)
if v then print, 'Julian Date = ', jd, format='(A,f15.6)'
if keyword_set(B1950) then s_now='   (J1950)' else s_now='   (J2000)'
if v then print, 'Ra, Dec: ', adstring(ra_,dec_), s_now

<span class="comments">;******************************************************************************</span>
<span class="comments">; PRECESS coordinates to current date</span>
<span class="comments">; (uses astro lib procedure PRECESS.pro)</span>
J_now = (JD - 2451545.)/365.25 + 2000.0 <span class="comments">; compute current equinox</span>
if precess_ then begin
        if keyword_set(B1950) then begin
                for i=0,n_elements(jd)-1 do begin
                        ra_i = ra_[i] & dec_i = dec_[i]
                        precess, ra_i, dec_i, 1950.0, J_now[i], /FK4
                        ra_[i] = ra_i & dec_[i] = dec_i
                endfor
        endif else begin
                for i=0,n_elements(jd)-1 do begin
                        ra_i = ra_[i] & dec_i = dec_[i]
                        precess, ra_i, dec_i, 2000.0, J_now[i]
                        ra_[i] = ra_i & dec_[i] = dec_i
                endfor
        endelse
endif

if v then print, 'Ra, Dec: ', adstring(ra_,dec_), '   (J' + $
          strcompress(string(J_now),/rem)+')'


<span class="comments">;******************************************************************************</span>
<span class="comments">; calculate NUTATION and ABERRATION Corrections to Ra-Dec</span>
co_nutate, jd, ra_, dec_, dra1, ddec1, eps=eps, d_psi=d_psi
co_aberration, jd, ra_, dec_, dra2, ddec2, eps=eps

<span class="comments">; make nutation and aberration corrections</span>
ra_ = ra_ + (dra1*nutate_ + dra2*aberration_)/3600.
dec_ = dec_ + (ddec1*nutate_ + ddec2*aberration_)/3600.

if v then print, 'Ra, Dec: ', adstring(ra_,dec_), '   (fully corrected)'


<span class="comments">;**************************************************************************************</span>
<span class="comments">;Calculate LOCAL MEAN SIDEREAL TIME</span>
ct2lst, lmst, lon, 0, jd  <span class="comments">; get LST (in hours) - note:this is independent of</span>
                           <span class="comments">;time zone  since giving jd</span>
lmst = lmst*h2d <span class="comments">; convert LMST to degrees (btw, this is the RA of the zenith)</span>
<span class="comments">; calculate local APPARENT sidereal time</span>
LAST = lmst + d_psi *cos(eps)/3600. <span class="comments">; add correction in degrees</span>
if v then print, 'LMST = ', adstring(lmst/15.)
if v then print, 'LAST = ', adstring(last/15.)

<span class="comments">;******************************************************************************</span>
<span class="comments">; Find hour angle (in DEGREES)</span>
ha = last - ra_
w = where(ha LT 0)
if w[0] ne -1 then ha[w] = ha[w] + 360.
ha = ha mod 360.
if v then print, 'Hour Angle = ', adstring(ha/15.), '  (hh:mm:ss)'

<span class="comments">;******************************************************************************</span>
<span class="comments">; Now do the spherical trig to get APPARENT alt,az.</span>
hadec2altaz, ha, dec_, lat, alt, az, WS=WS

if v then print,'Az, El = ', adstring(az,alt), '   (Apparent Coords)'

<span class="comments">;*******************************************************************************************</span>
<span class="comments">; Make Correction for ATMOSPHERIC REFRACTION</span>
<span class="comments">; (use this for visible and radio wavelengths; author is unsure about other wavelengths.</span>
<span class="comments">;  See the comments in CO_REFRACT.pro for more details.)</span>
if refract_ then alt = $
      co_refract(alt, altitude=altitude, _strict_extra=_extra, /to_observed)
if v then print,'Az, El = ', adstring(az,alt), '   (Observer Coords)'

end
</code>
    </div>
  </body>
</html>