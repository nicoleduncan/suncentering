<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:30 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fits_open.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fits_open.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="fits_open:source"></a>pro fits_open,filename,fcb,write=write,append=append,update=update, $
                 no_abort=no_abort,message=message,hprint=hprint,fpack=fpack
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       FITS_OPEN</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Opens a FITS (Flexible Image Transport System) data file.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Used by FITS_READ and FITS_WRITE</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       FITS_OPEN, filename, fcb</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       filename : name of the FITS file to open, scalar string</span>
<span class="comments">;                  FITS_OPEN can also open gzip compressed (.gz) file *for </span>
<span class="comments">;                  reading only*, although there is a performance penalty </span>
<span class="comments">;                  FPACK ( http://heasarc.gsfc.nasa.gov/fitsio/fpack/ ) </span>
<span class="comments">;                  compressed FITS files can be read provided that the FPACK </span>
<span class="comments">;                  software is installed.</span>
<span class="comments">;*OUTPUTS:</span>
<span class="comments">;       fcb : (FITS Control Block) a IDL structure containing information</span>
<span class="comments">;               concerning the file.  It is an input to FITS_READ, FITS_WRITE</span>
<span class="comments">;               FITS_CLOSE and MODFITS.  </span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       /APPEND: Set to append to an existing file.</span>
<span class="comments">;       /FPACK - Signal that the file is compressed with the FPACK software. </span>
<span class="comments">;               http://heasarc.gsfc.nasa.gov/fitsio/fpack/ ) By default, </span>
<span class="comments">;               FITS_OPEN assumes that if the file name extension ends in </span>
<span class="comments">;               .fz that it is fpack compressed.     The FPACK software must</span>
<span class="comments">;               be installed on the system </span>
<span class="comments">;       /HPRINT - print headers with routine HPRINT as they are read.</span>
<span class="comments">;               (useful for debugging a strange file)</span>
<span class="comments">;       /NO_ABORT: Set to quietly return to calling program when an I/O error  </span>
<span class="comments">;               is encountered, and return  a non-null string</span>
<span class="comments">;               (containing the error message) in the keyword MESSAGE.    </span>
<span class="comments">;               If /NO_ABORT not set, then FITS_OPEN will display the error </span>
<span class="comments">;               message and return to the calling program.</span>
<span class="comments">;       /UPDATE Set this keyword to open an existing file for update</span>
<span class="comments">;       /WRITE: Set this keyword to open a new file for writing. </span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       MESSAGE = value: Output error message.    If the FITS file was opened</span>
<span class="comments">;               successfully, then message = ''.</span>
<span class="comments">;       </span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The output FCB should be passed to the other FITS routines (FITS_OPEN,</span>
<span class="comments">;       FITS_READ, FITS_HELP, and FITS_WRITE).  It has the following structure</span>
<span class="comments">;       when FITS_OPEN is called without /WRITE or /APPEND keywords set.</span>
<span class="comments">;</span>
<span class="comments">;           FCB.FILENAME - name of the input file</span>
<span class="comments">;               .UNIT - unit number the file is opened to</span>
<span class="comments">;               .FCOMPRESS - 1 if unit is a FPACK compressed file opened with</span>
<span class="comments">;                    a pipe to SPAWN</span>
<span class="comments">;               .NEXTEND - number of extensions in the file.</span>
<span class="comments">;               .XTENSION - string array giving the extension type for each</span>
<span class="comments">;                       extension.</span>
<span class="comments">;               .EXTNAME - string array giving the extension name for each</span>
<span class="comments">;                       extension. (null string if not defined the extension)</span>
<span class="comments">;               .EXTVER - vector of extension version numbers (0 if not</span>
<span class="comments">;                       defined)</span>
<span class="comments">;               .EXTLEVEL - vector of extension levels (0 if not defined)</span>
<span class="comments">;               .GCOUNT - vector with the number of groups in each extension.</span>
<span class="comments">;               .PCOUNT - vector with parameter count for each group</span>
<span class="comments">;               .BITPIX - BITPIX for each extension with values</span>
<span class="comments">;                                  8    byte data</span>
<span class="comments">;                                16     short word integers</span>
<span class="comments">;                                32     long word integers</span>
<span class="comments">;                               -32     IEEE floating point</span>
<span class="comments">;                               -64     IEEE double precision floating point</span>
<span class="comments">;               .NAXIS - number of axes for each extension.  (0 for null data</span>
<span class="comments">;                       units)</span>
<span class="comments">;               .AXIS - 2-D array where axis(*,N) gives the size of each axes</span>
<span class="comments">;                       for extension N</span>
<span class="comments">;               .START_HEADER - vector giving the starting byte in the file</span>
<span class="comments">;                               where each extension header begins</span>
<span class="comments">;               .START_DATA - vector giving the starting byte in the file</span>
<span class="comments">;                               where the data for each extension begins</span>
<span class="comments">;</span>
<span class="comments">;               .HMAIN - keyword parameters (less standard required FITS</span>
<span class="comments">;                               keywords) for the primary data unit.</span>
<span class="comments">;               .OPEN_FOR_WRITE - flag (0= open for read, 1=open for write, </span>
<span class="comments">;                                                2=open for update)</span>
<span class="comments">;               .LAST_EXTENSION - last extension number read.</span>
<span class="comments">;               .RANDOM_GROUPS - 1 if the PDU is random groups format,</span>
<span class="comments">;                               0 otherwise</span>
<span class="comments">;               .NBYTES - total number of (uncompressed) bytes in the FITS file</span>
<span class="comments">;</span>
<span class="comments">;       When FITS open is called with the /WRITE or /APPEND option, FCB</span>
<span class="comments">;       contains:</span>
<span class="comments">;</span>
<span class="comments">;           FCB.FILENAME - name of the input file</span>
<span class="comments">;               .UNIT - unit number the file is opened to</span>
<span class="comments">;               .NEXTEND - number of extensions in the file.</span>
<span class="comments">;               .OPEN_FOR_WRITE - flag (1=open for write, 2=open for append</span>
<span class="comments">;                                       3=open for update)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       Open a FITS file for reading:</span>
<span class="comments">;               FITS_OPEN,'myfile.fits',fcb</span>
<span class="comments">;</span>
<span class="comments">;       Open a new FITS file for output:</span>
<span class="comments">;               FITS_OPEN,'newfile.fits',fcb,/write</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       GET_PIPE_FILESIZE (for Fcompress'ed files) HPRINT, SXDELPAR, SXPAR()</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       Written by:     D. Lindler      August, 1995</span>
<span class="comments">;       July, 1996      NICMOS  Modified to allow open for overwrite</span>
<span class="comments">;                               to allow primary header to be modified</span>
<span class="comments">;       DJL Oct. 15, 1996   corrected to properly extend AXIS when more</span>
<span class="comments">;                       than 100 extensions present</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Use Message = '' rather than !ERR =1 as preferred signal of normal</span>
<span class="comments">;           operation   W. Landsman  November 2000</span>
<span class="comments">;       Lindler, Dec, 2001, Modified to use 64 bit words for storing byte</span>
<span class="comments">;             positions within the file to allow support for very large</span>
<span class="comments">;             files </span>
<span class="comments">;       Work with gzip compressed files W. Landsman    January 2003</span>
<span class="comments">;       Fix gzip compress for V5.4 and earlier  W.Landsman/M.Fitzgerald Dec 2003 </span>
<span class="comments">;       Assume since V5.3 (STRSPLIT, OPENR,/COMPRESS) W. Landsman Feb 2004</span>
<span class="comments">;       Treat FTZ extension as gzip compressed W. Landsman Sep 2004</span>
<span class="comments">;       Assume since V5.4 fstat.compress available W. Landsman Apr 2006</span>
<span class="comments">;       FCB.Filename  now expands any wildcards W. Landsman July 2006</span>
<span class="comments">;       Make ndata 64bit for very large files B. Garwood/W. Landsman Sep 2006</span>
<span class="comments">;       Open with /SWAP_IF_LITTLE_ENDIAN, remove obsolete keywords to OPEN</span>
<span class="comments">;                W. Landsman  Sep 2006</span>
<span class="comments">;       Warn that one cannot open a compressed file for update W.L. April 2007</span>
<span class="comments">;       Use post-V6.0 notation W.L. October 2010</span>
<span class="comments">;       Support FPACK compressed files, new .FCOMPRESS tag to FCB structure</span>
<span class="comments">;               W.L.  December 2010</span>
<span class="comments">;       Read gzip'ed files even if gzip is not installed W.L. October 2012</span>
<span class="comments">;-</span>
<span class="comments">;--------------------------------------------------------------------</span>
      compile_opt idl2
<span class="comments">; if no parameters supplied, print calling sequence</span>
<span class="comments">;</span>
       if N_params() LT 1 then begin
          print,'Syntax - FITS_OPEN, filename, fcb'
          print,' Input Keywords:  /Append, /Hprint, /No_abort, /Update, /Write'
          print,' Output Keyword:  Message= '
          return
       endif
<span class="comments">;</span>
<span class="comments">; set default keyword parameters</span>
<span class="comments">;</span>

        message = ''
        open_for_read = 1
        open_for_update = 0
        open_for_write = 0
        open_for_overwrite = 0
        if keyword_set(write) then begin
                open_for_read = 0
                open_for_update = 0
                open_for_write = 1
                open_for_overwrite = 0
        end
        if keyword_set(append) then begin
                open_for_read = 0
                open_for_write = 0
                open_for_update = 1
                open_for_overwrite = 0
        end     
        if keyword_set(update) then begin
                open_for_read = 1 
                open_for_write = 0
                open_for_update = 0 
                open_for_overwrite = 1 
        end     
<span class="comments">;</span>
<span class="comments">; on I/O errors goto statement ioerror:</span>
<span class="comments">;</span>
        on_ioerror,ioerror
<span class="comments">;</span>
<span class="comments">; open file</span>
<span class="comments">;</span>

        ext = strlowcase(strmid(filename, 2, /rev))
        docompress = (ext EQ '.gz') || (ext EQ 'ftz') 
        fcompress = keyword_set(fpack) || ( ext EQ '.fz')
         if docompress && open_for_overwrite then begin 
            message = 'Compressed FITS files cannot be open for update'
            if ~keyword_set(no_abort) then $
                   message,' ERROR: '+message,/CON
            return
       endif   
 <span class="comments">;</span>
<span class="comments">; open file</span>
<span class="comments">;</span>
       if ~fcompress then get_lun,unit
       if fcompress then $
                spawn,'funpack -S ' + filename, unit=unit,/sh else $	
       if docompress then $
                openr,unit,filename, /compress,/swap_if_little else begin
       case 1 of
                keyword_set(append): openu,unit,filename,/swap_if_little
                keyword_set(update): openu,unit,filename,/swap_if_little
                keyword_set(write) : openw,unit,filename,/swap_if_little
                else               : openr,unit,filename,/swap_if_little
        endcase
        endelse

        file = fstat(unit)
        fname = file.name          <span class="comments">;In case the user input a wildcard</span>
        docompress = file.compress

<span class="comments">; Need to spawn to "gzip -l" to get the number of uncompressed bytes in a gzip</span>
<span class="comments">; compressed file.  If gzip doesn't work for some reason then use </span>
<span class="comments">; get_pipe_filesize.</span>

        if fcompress then begin 
	      get_pipe_filesize,unit, nbytes_in_file
	      free_lun,unit
	      spawn,'funpack -S ' + filename, unit=unit,/sh
        endif else if docompress then begin 
	     if !VERSION.OS_FAMILY Eq 'Windows' then $
	           fname = file_search(fname,/fully_qualify)
             spawn,'gzip -l ' + fname, output
             output = strtrim(output,2)
             g = where(strmid(output,0,8) EQ 'compress', Nfound)
	     if Nfound EQ 0 then begin
	            get_pipe_filesize, unit, nbytes_in_file
		    close,unit
		    openr,unit,filename, /compress,/swap_if_little
             endif else $
	         nbytes_in_file = long64((strsplit(output[g[0]+1],/extract))[1])
        endif else nbytes_in_file = file.size
	
<span class="comments">;</span>
<span class="comments">; create vectors needed to store header information for each extension</span>
<span class="comments">;</span>
        n = 100
        xtension = strarr(n)
        extname = strarr(n)
        extver = lonarr(n)
        extlevel = lonarr(n)
        gcount = lonarr(n)
        pcount = lonarr(n)
        bitpix = lonarr(n)
        naxis  = lonarr(n)
        axis = lonarr(20,n)
        start_header = lon64arr(n)        <span class="comments">; starting byte in file for header</span>
        start_data = lon64arr(n)          <span class="comments">; starting byte in file for data</span>
        position = 0ULL             <span class="comments">; current byte position in file</span>
        skip = 0ULL                 <span class="comments">; Amount to skip from current position</span>
<span class="comments">;</span>
<span class="comments">; read and process each header in the file if open for read or update</span>
<span class="comments">;</span>
        extend_number = 0               <span class="comments">; current extension number being</span>
                                        <span class="comments">; processed</span>
 
        if open_for_read || open_for_update then begin
            main_header = 1             <span class="comments">; first header in file flag</span>
            h = bytarr(80,36,/nozero)   <span class="comments">; read buffer</span>
<span class="comments">;</span>
<span class="comments">; loop on headers in the file</span>
<span class="comments">;</span>
            repeat begin
            if skip GT 0 then if fcompress then mrd_skip,unit,skip else $
	                                     point_lun,unit,position 
              start = position
<span class="comments">;</span>
<span class="comments">; loop on header blocks</span>
<span class="comments">;</span>
                first_block = 1         <span class="comments">; first block in header flag</span>
                repeat begin

                    if ~fcompress && position+2879 ge nbytes_in_file then begin
                        if extend_number eq 0 then begin
                                message = 'EOF encountered while reading header'
                                goto,error_exit
                        endif
                        print,'EOF encountered reading extension header'
                        print,'Only '+strtrim(extend_number-1,2) + $
                                ' extensions processed'
                        goto,done_headers
                    endif

                    readu,unit,h
                    position = position + 2880
                    hdr = string(h>32b)
                    endline = where(strmid(hdr,0,8) eq 'END     ',nend)
                    if nend gt 0 then hdr = hdr[0:endline[0]]
                    if first_block then begin
<span class="comments">;</span>
<span class="comments">; check for valid header (SIMPLE keyword must be first for PDU and</span>
<span class="comments">; XTENSION keyword for the extensions.</span>
<span class="comments">;</span>
                        header = hdr 
                        keyword = strmid(header[0],0,8)
                        if (extend_number eq 0) && $
                           (keyword ne 'SIMPLE  ') then begin
                                message = 'Invalid header, no SIMPLE keyword'
                                goto,error_exit
                        endif

                        if (extend_number gt 0) && $
                           (keyword ne 'XTENSION') then begin
                                print,'Invalid extension header encountered'
                                print,'XTENSION keyword missing'
                                print,'Only '+strtrim(extend_number-1,2) + $
                                        ' extensions processed'
                                goto,done_headers
                        endif

                    end else header = [header,hdr]
                    first_block = 0
                end until (nend gt 0)   

<span class="comments">;</span>
<span class="comments">; print header if hprint set</span>
<span class="comments">;</span>
                if keyword_set(hprint) then hprint,header
<span class="comments">;</span>
<span class="comments">; end of loop on header blocks</span>
<span class="comments">;</span>
<span class="comments">; Increase size of vectors if needed</span>
<span class="comments">;</span>
                if extend_number ge n then begin
                        xtension = [xtension,strarr(n)]
                        extname = [extname,strarr(n)]
                        extver = [extver,lonarr(n)]
                        extlevel = [extver,lonarr(n)]
                        gcount = [gcount,lonarr(n)]
                        pcount = [pcount,lonarr(n)]
                        bitpix = [bitpix,lonarr(n)]
                        naxis  = [naxis,lonarr(n)]
                        old_axis = axis
                        axis = lonarr(20,n*2)
                        axis[0,0] = old_axis
                        start_header = [start_header,lonarr(n)]
                        start_data = [start_data,lonarr(n)]
                        n = n*2
                end
<span class="comments">;</span>
<span class="comments">; extract information from header</span>
<span class="comments">;</span>
                xtension[extend_number] = strtrim(sxpar(header,'xtension'))
                st = sxpar(header,'extname', Count = N_extname)
                if N_extname EQ 0 then st = ''
                extname[extend_number] = strtrim(st,2)  
                extver[extend_number] = sxpar(header,'extver')          
                extlevel[extend_number] = sxpar(header,'extlevel')              
                gcount[extend_number] = sxpar(header,'gcount')
                pcount[extend_number] = sxpar(header,'pcount')
                bitpix[extend_number] = sxpar(header,'bitpix')
                nax = sxpar(header,'naxis')
                naxis[extend_number] = nax
                if nax gt 0 then begin 
		    naxisi = sxpar(header,'naxis*')
		    axis[0,extend_number] = naxisi
		    ndata = product(naxisi,/integer)
                endif else ndata = 0 
		
               start_data[extend_number] = position    
                start_header[extend_number] = start
<span class="comments">;</span>
<span class="comments">; if first header, save without FITS required keywords</span>
<span class="comments">;</span>
                if extend_number eq 0 then begin
                    hmain = header
                    random_groups = sxpar(header,'groups')
                    sxdelpar,hmain,['SIMPLE','BITPIX','NAXIS','NAXIS1', $
                                    'NAXIS2','NAXIS3','NAXIS4','NAXIS5', $
                                    'NAXIS6','NAXIS7','NAXIS8','EXTEND', $
                                    'PCOUNT','GCOUNT','GROUPS','BSCALE', $
                                    'BZERO','NPIX1','NPIX2','PIXVALUE']
                        if (pcount[0] gt 0) then for i=1,pcount[0] do $
                        sxdelpar,hmain,['ptype','pscal','pzero']+strtrim(i,2)
                endif
<span class="comments">;</span>
<span class="comments">; skip past data to go to next header</span>
<span class="comments">;</span>
                nbytes = (abs(bitpix[extend_number])/8) * $
                       (gcount[extend_number]>1)*(pcount[extend_number] + ndata)
                skip = (nbytes + 2879)/2880*2880
                position += skip

<span class="comments">;</span>
<span class="comments">; end loop on headers</span>
<span class="comments">;           </span>

                extend_number +=  1
            end until (position ge nbytes_in_file-2879)
        end
<span class="comments">;</span>
<span class="comments">; point at end of file in /extend</span>
<span class="comments">;</span>
done_headers:
        if open_for_update then point_lun,unit,nbytes_in_file
<span class="comments">;</span>
<span class="comments">; number of extensions</span>
<span class="comments">;</span>
        if open_for_write then nextend = -1 $
                          else nextend = extend_number - 1
<span class="comments">;</span>
<span class="comments">; set up blank hmain if open for write</span>
<span class="comments">;</span>
        if open_for_write then begin
                hmain = strarr(1)
                hmain[0] = 'END     '
        end
<span class="comments">;</span>
<span class="comments">; create output structure for the file control block</span>
<span class="comments">;</span>
        if open_for_write or open_for_update then begin
                fcb = {filename:fname,unit:unit,nextend:nextend, $
                        open_for_write:open_for_write + open_for_update*2}
           end else begin
                nx = nextend
               fcb = {filename:fname,unit:unit,fcompress:fcompress, $
		        nextend:nextend, $
                         xtension:xtension[0:nx],extname:extname[0:nx], $
                        extver:extver[0:nx],extlevel:extlevel[0:nx], $
                        gcount:gcount[0:nx],pcount:pcount[0:nx], $
                        bitpix:bitpix[0:nx],naxis:naxis[0:nx], $
                        axis:axis[*,0:nx], $
                        start_header:start_header[0:nx], $
                        start_data:start_data[0:nx],hmain:hmain, $
                        open_for_write:open_for_overwrite*3,$
                        last_extension:-1, $
                        random_groups:random_groups, $
                        nbytes: nbytes_in_file }
        end
         if fcompress then begin
	
	       free_lun,unit	      
               spawn,'funpack -S ' + filename, unit=unit,/sh 
         endif 
        !err = 1            <span class="comments">;For obsolete users still using !err</span>
        return
<span class="comments">;</span>
<span class="comments">; error exit</span>
<span class="comments">;</span>
ioerror: 
        message = !ERROR_STATE.msg
error_exit:
        free_lun,unit
        !err = -1
        if keyword_set(no_abort) then return
        message,' ERROR: '+message,/CON
        return
end
</code>
    </div>
  </body>
</html>