<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:59 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>rdplot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="rdplot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="RESET_RDPLOT:source"></a>pro RESET_RDPLOT
<span class="comments">;</span>
<span class="comments">;   If the user crashes out of the RDPLOT program, they can call this procedure</span>
<span class="comments">; to reset the graphics device functions to default values.</span>
<span class="comments">;</span>
device, /CURSOR_CROSSHAIR, SET_GRAPHICS_FUNCTION=3, BYPASS_TRANSLATION=0
end



<a id="RDPLOT:source"></a>pro RDPLOT, x, y, WaitFlag, DATA=Data, DEVICE=Device, NORMAL=Normal, $
   NOWAIT=NoWait, WAIT=Wait, DOWN=Down, CHANGE=Change, Err=Err, $
   PRINT=Print, XTITLE=XTitle,YTITLE=YTitle, XVALUES=XValues,YVALUES=YValues, $
   FULLCURSOR=FullCursor, NOCLIP=NoClip, LINESTYLE=Linestyle, THICK=Thick, $
   COLOR=Color, BACKGROUND=BackGround, CROSS=Cross, ACCUMULATE=Accumulate
   
<span class="comments">;*******************************************************************************</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   RDPLOT</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Like CURSOR but with a full-screen cursor and continuous readout option</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;   This program is designed to essentially mimic the IDL CURSOR command,</span>
<span class="comments">;   but with the additional options of continuously printing out the data</span>
<span class="comments">;   values of the cursor's position, and using a full-screen cursor rather </span>
<span class="comments">;   than a small cross cursor.  The full screen cursor uses OPLOT and </span>
<span class="comments">;   X-windows graphics masking to emulate the cursor.</span>
<span class="comments">;      One difference is that IF the PRINT keyword is set but the DOWN,</span>
<span class="comments">;   WAIT, CHANGE, or NOWAIT keywords are not set, then the leftmost mouse</span>
<span class="comments">;   button will print a "newline" line-feed, but not exit.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   RDPLOT [, X, Y] [, WaitFlag] [, /DATA | /DEVICE | /NORMAL]</span>
<span class="comments">;      [, /NOWAIT | /WAIT | /DOWN | /CHANGE] </span>
<span class="comments">;      [, /FULLCURSOR] [, /NOCLIP] [, /CROSS] [, /ACCUMULATE]</span>
<span class="comments">;      [, ERR=, PRINT=, XTITLE=, YTITLE=, XVALUES=, YVALUES=</span>
<span class="comments">;       , LINESTYLE=, THICK=, COLOR=, BACKGROUND=]</span>
<span class="comments">;</span>
<span class="comments">; REQUIRED INPUTS:</span>
<span class="comments">;   None.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS: </span>
<span class="comments">;   WAITFLAG = Uses the same table as the intrinsic CURSOR command, But note</span>
<span class="comments">;	that unlike the CURSOR command, there is no UP keyword.</span>
<span class="comments">;		WaitFlag=0 sets the NOWAIT keyword</span>
<span class="comments">;		WaitFlag=1 sets the WAIT keyword {default}</span>
<span class="comments">;		WaitFlag=2 sets the CHANGE keyword</span>
<span class="comments">;		WaitFlag=3 sets the DOWN keyword</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUTS:</span>
<span class="comments">;    X - a named variable to receive the final cursor X position, scalar</span>
<span class="comments">;        or vector (if /ACCUMULATE is set)</span>
<span class="comments">;    Y - a named variable to receive the final cursor Y position, scalar</span>
<span class="comments">;        or vector (if /ACCUMULATE is set)</span>
<span class="comments">; OPTIONAL KEYWORD INPUT PARAMETERS:</span>
<span class="comments">;   /DATA - data coordinates are displayed and returned.</span>
<span class="comments">;   /DEVICE - device coordinates are displayed and returned.</span>
<span class="comments">;   /NORMAL - normal coordinates are displayed and returned.</span>
<span class="comments">;      Default is to use DATA coordinates if available (see notes).</span>
<span class="comments">;   /NOWAIT = if non-zero the routine will immediately return the cursor's</span>
<span class="comments">;      present position.</span>
<span class="comments">;   /WAIT - if non-zero will wait for a mouse key click before returning.  If</span>
<span class="comments">;      cursor key is already down, then procedure immediately exits.</span>
<span class="comments">;   /DOWN - equivalent to WAIT *except* that if the mouse key is already down</span>
<span class="comments">;      when the procedure is called, the procedure will wait until the mouse</span>
<span class="comments">;      key is clicked down again.</span>
<span class="comments">;   /CHANGE - returns when the mouse is moved OR a key is clicked up or down.</span>
<span class="comments">;   PRINT = if non-zero will continuously print out (at the terminal) the data </span>
<span class="comments">;      values of the cursor's position.  If PRINT>1, program will printout a </span>
<span class="comments">;      brief header describing the mouse button functions.  However, note that </span>
<span class="comments">;      the button functions are overridden if any of the DOWN, WAIT, or</span>
<span class="comments">;      CHANGE values are non-zero.</span>
<span class="comments">;   XTITLE = label used to describe the values of the abscissa if PRINT>0.</span>
<span class="comments">;   YTITLE = label used to describe the values of the ordinate if PRINT>0.</span>
<span class="comments">;   XVALUES = a vector corresponding to the values to be printed when the</span>
<span class="comments">;	PRINT keyword is set.  This allows the user the option of printing</span>
<span class="comments">;	out other values rather than the default X coordinate position of</span>
<span class="comments">;	the cursor.  E.g., if XVALUES is a string vector of dates such as</span>
<span class="comments">;	['May 1', 'May 2', ...], then those dates will be printed rather than</span>
<span class="comments">;	the X value of the cursor's position: if X=1 then 'May 2' would be</span>
<span class="comments">;	printed, etc.  This requires that the values of the X coordinate read</span>
<span class="comments">;	by the cursor must be positive (can't access negative elements).</span>
<span class="comments">;       If XVALUES=-1, then NO values for X will be printed.</span>
<span class="comments">;   YVALUES = analogous to the XVALUES keyword.</span>
<span class="comments">;   /FULLCURSOR - if non-zero default cursor is blanked out and full-screen </span>
<span class="comments">;      (or full plot window, depending on the value of NOCLIP) lines are</span>
<span class="comments">;      drawn; their intersecton is centered on the cursor position.</span>
<span class="comments">;   /NOCLIP - if non-zero will make a full-screen cursor, otherwise it will</span>
<span class="comments">;      default to the value in !P.NOCLIP.</span>
<span class="comments">;   LINESTYLE = style of line that makes the full-screen cursor.</span>
<span class="comments">;   THICK = thickness of the line that makes the full-screen cursor.</span>
<span class="comments">;   COLOR = color of the full-screen cursor.</span>
<span class="comments">;   BACKGROUND = color of the background of the plot device.  If this has</span>
<span class="comments">;      been set to !P.BackGround, then this keyword is unnecessary.</span>
<span class="comments">;   CROSS = if non-zero will show the regular cross AND full screen cursors.</span>
<span class="comments">;   /ACCUMULATE - all of the positions for which the left button was</span>
<span class="comments">;      clicked are stored in the X and Y variables.  Has no effect if X and Y </span>
<span class="comments">;      are not present.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD OUTPUT PARAMETER:</span>
<span class="comments">;   ERR = returns the most recent value of the !mouse.button value.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;   Note that this procedure does not allow the "UP" keyword/flag...which </span>
<span class="comments">;   doesn't seem to work too well in the origianl CURSOR version anyway.</span>
<span class="comments">;</span>
<span class="comments">;   If a data coordinate system has not been established, then RDPLOT will</span>
<span class="comments">;   create one identical to the device coordinate system.   Note that this</span>
<span class="comments">;   kluge is required even if the user specified /NORMAL coordinates, since</span>
<span class="comments">;   RDPLOT makes use of the OPLOT procedure.  This new data coordinate system</span>
<span class="comments">;   is effectively "erased" (!X.CRange and !Y.CRange are both set to zero)</span>
<span class="comments">;   upon exit of the routine so as to not change the plot status from the</span>
<span class="comments">;   user's point of view.</span>
<span class="comments">;</span>
<span class="comments">;   Only tested on X-windows systems.  If this program is interrupted, the</span>
<span class="comments">;   graphics function might be left in a non-standard state; in that case,</span>
<span class="comments">;   run the program RESET_RDPLOT to return the standard graphics functions,</span>
<span class="comments">;   or type the command:   DEVICE, /CURSOR_CROSS, SET_GRAPHICS=3, BYPASS=0</span>
<span class="comments">;</span>
<span class="comments">;   Robishaw added /ACCUMULATE keyword to pass back all the positions at</span>
<span class="comments">;   which the mouse was left-clicked.  In addition, the value of the exit</span>
<span class="comments">;   click is returned unless the cursor did not change position between the</span>
<span class="comments">;   last left-click and the exit click.</span>
<span class="comments">;</span>
<span class="comments">; BUGS:</span>
<span class="comments">;   NOTE: (1/27/05) The bugs below have been fixed by Robishaw and tested</span>
<span class="comments">;   on Solaris, Linux and OS-X.</span>
<span class="comments">;</span>
<span class="comments">;   It is assumed that the current background of the plot is correctly</span>
<span class="comments">;   defined by the value in !P.Background.  Otherwise, the color of the</span>
<span class="comments">;   long cursor probably will not be correct.  Sometimes the color doesn't</span>
<span class="comments">;   work anyway, and I'm not sure why.</span>
<span class="comments">;   NOTE: Robishaw fixed this 1/27/05.</span>
<span class="comments">;</span>
<span class="comments">;   There may be some cases (e.g., when THICK>1 and NOCLIP=0) when the</span>
<span class="comments">;   full-screen cursor is not correctly erased, leaving "ghost images" on the</span>
<span class="comments">;   plot.  It just seems that the screen updates get slow or the positions</span>
<span class="comments">;   ambiguous with a thick line and the cursor off the plot.</span>
<span class="comments">;   NOTE: Robishaw fixed this 1/27/05.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;   Basically is a bells-n-whistles version of the CURSOR procedure.  All</span>
<span class="comments">;   the details are covered in the above discussion of the keywords.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;   A silly, but informative one:</span>
<span class="comments">;   Months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', $</span>
<span class="comments">;             'Aug', 'Sep', 'Oct', 'Nov', 'Dec']</span>
<span class="comments">;   plot, indgen(12), xrange=[-5, 15]</span>
<span class="comments">;   rdplot, /FULL, /PRINT, XTITLE='Month: ', YTITLE='Y-value per month = ', $</span>
<span class="comments">;      xvalues=Months</span>
<span class="comments">;</span>
<span class="comments">;   If your plot has a non-black background color, be sure to set either</span>
<span class="comments">;   !p.background or the BACKGROUND keyword.  Here are examples of how to</span>
<span class="comments">;   use a blue full-screen cursor on a plot with a red background and</span>
<span class="comments">;   yellow axes and data. First, deal with color decomposition off:</span>
<span class="comments">;   device, decomposed=0</span>
<span class="comments">;   tvlct, [255,255,0], [0,255,0], [0,0,255], 1</span>
<span class="comments">;   plot, randomn(seed,1024), XSTYLE=19, PSYM=3, COLOR=2, BACK=1</span>
<span class="comments">;   rdplot, /PRINT, /FULL, THICK=5, /NOCLIP, BACK=1, COLOR=3</span>
<span class="comments">;</span>
<span class="comments">;   For decomposition on (TrueColor or DirectColor only):</span>
<span class="comments">;   device, decomposed=1</span>
<span class="comments">;   plot, randomn(seed,1024), XSTYLE=19, PSYM=3, COLOR=65535l, BACK=255l</span>
<span class="comments">;   rdplot, /PRINT, /FULL, THICK=5, /NOCLIP, BACK=255l, COLOR=16711680l</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written (originally named CURFULL) by J.Wm.Parker  1993 Nov 22 </span>
<span class="comments">;   Created data coordinates if not already present, W. Landsman Nov. 93</span>
<span class="comments">;   Added continuous printout of data values, COLOR and FULLCURSOR keywords</span>
<span class="comments">;      (so that default is that it acts just like the cursor command).</span>
<span class="comments">;      Changed name from CURFULL to RDPLOT.   J.Wm.Parker  1994 Apr 20</span>
<span class="comments">;   Modified (with some translation table assistance from the IDL support </span>
<span class="comments">;      group) to correctly plot the crosshair with the desired IDL </span>
<span class="comments">;      color using the device's translation table to determine the XOR </span>
<span class="comments">;      function and using the BYPASS function.  Added the RESET_RDPLOT</span>
<span class="comments">;      procedure to cleanup crashes that might occur while running</span>
<span class="comments">;      RDPLOT.  Other minor changes/bug fixes.  J.Wm.Parker  1994 May 21</span>
<span class="comments">;   Modified DOWN, WAIT, CHANGE functions to behave more similar to the</span>
<span class="comments">;      generic CURSOR procedure.   J.Wm.Parker  1995 April 24</span>
<span class="comments">;   Added XVALUES, YVALUES keywords and cleanup.   J.Wm.Parker  1995 April 24</span>
<span class="comments">;   Convert to IDL V5.0,  W. Landsman    July 1998</span>
<span class="comments">;   Change !D.NCOLORS to !D.TABLE_SIZE for 24 bit displays W. Landsman May 2000</span>
<span class="comments">;   Skip translation table for TrueColor visuals   W. Landsman  March 2001</span>
<span class="comments">;   Fixed /FULLCURSOR ghosts. Fixed to properly deal with background colors</span>
<span class="comments">;      in 24-bit visual classes (TrueColor and DirectColor).  Added</span>
<span class="comments">;      BACKGROUND keyword. Tim Robishaw 2005 Jan 27       </span>
<span class="comments">;   Added /ACCUMULATE keyword. T. Robishaw 2006 Nov 8</span>
<span class="comments">;   Corrected following problems. When /CHANGE and /PRINT were set,</span>
<span class="comments">;      returned X & Y were different than those printed.  When /PRINT and</span>
<span class="comments">;      /NOWAIT were set, or /PRINT and /WAIT were set and the routine was</span>
<span class="comments">;      entered with a mouse button clicked, nothing was printed. When</span>
<span class="comments">;      /PRINT and /DOWN were set, if routine was started with button down,</span>
<span class="comments">;      advertised behavior was that routine would exit on next down click;</span>
<span class="comments">;      in practice if cursor was not moved, successive down clicks had no</span>
<span class="comments">;      effect.  Now, if X is passed as an output variable, requires that Y</span>
<span class="comments">;      is also passed, like CURSOR.  Bottom line is that RDPLOT now really</span>
<span class="comments">;      does behave like CURSOR and when /PRINT is set, the values printed</span>
<span class="comments">;      correspond to those returned in X & Y.  T. Robishaw 2006 Nov 12</span>
<span class="comments">;   Fixed misbehavior when color decomposition was set to off for</span>
<span class="comments">;      TrueColor and DirectColor.  Now thoroughly tested on PseudoColor</span>
<span class="comments">;      displays as well as both decomposition states for TrueColor and</span>
<span class="comments">;      DirectColor.  Also made the default cursor color white when</span>
<span class="comments">;      decomposition is on (this has been its default value for</span>
<span class="comments">;      decomposition off). T. Robishaw 2006 Nov 16</span>
<span class="comments">;-</span>
<span class="comments">;*******************************************************************************</span>
On_error,2

<span class="comments">;;;</span>
<span class="comments">;   If the device does not support windows, then this program can not be used.</span>
<span class="comments">;</span>
if ((!D.Flags and 256) ne 256) then message, $
  'ERROR - Current graphics device ' + !D.NAME + ' does not support windows'

<span class="comments">;;;</span>
<span class="comments">;   Like cursor, require that if present, both X and Y be specified...</span>
<span class="comments">;</span>
if (N_Params() eq 1) then message, $
   'Incorrect number of arguments. Both X & Y must be present.'

<span class="comments">;;;</span>
<span class="comments">;   Keywords, keywords.</span>
<span class="comments">;</span>
if (N_Params() eq 3) then begin
   case WaitFlag of
      0 : NoWait = 1
      1 : Wait = 1
      2 : Change = 1
      3 : Down = 1
      else : Wait = 1
   endcase
endif

NoWait = keyword_set(NoWait)
Wait = keyword_set(Wait)
Down = keyword_set(Down)<span class="comments">; or Wait</span>
Change = keyword_set(Change)
FullCursor = keyword_set(FullCursor)

<span class="comments">;;;</span>
<span class="comments">;   If plotting coordinates are not already established, and the NORMAL keyword</span>
<span class="comments">; is not set, then use device coordinates.</span>
<span class="comments">;   Note that even if this procedure was called with the DATA keyword set, that</span>
<span class="comments">; the DEVICE keyword will always take precedence over the DATA keyword in the</span>
<span class="comments">; cursor command.  However, if the NORMAL and DEVICE keywords are both set,</span>
<span class="comments">; then very strange values are returned.</span>
<span class="comments">;</span>
UndefinedPlot = ((!X.CRange[0] eq 0) and (!X.CRange[1] eq 0))
if UndefinedPlot then plot, [0,!D.X_Size], [0,!D.Y_Size], /NODATA, $
   XSTYLE=5, YSTYLE=5, XMARGIN=[0,0], YMARGIN=[0,0], /NOERASE

<span class="comments">;;;</span>
<span class="comments">;   Initialize the !mouse.button variable.  The value of !mouse.button </span>
<span class="comments">; corresponds to the BYTE  value of the buttons on the mouse from left to right,</span>
<span class="comments">; lowest bit first.  So, the left button gives !mouse.button = 1, next button </span>
<span class="comments">; gives !mouse.button = 2, then 4.</span>
<span class="comments">;  Read in the cursor with no wait.  If the user does not want to wait, or if </span>
<span class="comments">; the DOWN or WAIT keywords are set AND the mouse key is depressed, then we're</span>
<span class="comments">; done (I hate GOTO's, but it is appropriate here).</span>
<span class="comments">; NOTE: Robishaw gets rid of GOTO statement... if user asks for value to be</span>
<span class="comments">;       printed, it should be printed!</span>
<span class="comments">;</span>
!mouse.button = 0
cursor, X, Y, /NOWAIT, DATA=Data, DEVICE=Device, NORMAL=Normal
<span class="comments">;if (keyword_set(NoWait) or (Wait and (!mouse.button gt 0))) then $</span>
<span class="comments">;            goto, LABEL_DONE</span>
<span class="comments">;;;</span>
<span class="comments">;   PRINTOUT SETUP SECTION ==================================================</span>
<span class="comments">;;;</span>

<span class="comments">;;;</span>
<span class="comments">;   Is the PRINT keyword set?  Then we have a lot of things to set up.  First,</span>
<span class="comments">; set up carriage return and line feed variables for the formatted printout,</span>
<span class="comments">; and define the titles for the printed values.</span>
<span class="comments">;</span>
if keyword_set(Print) then begin 
   if not(keyword_set(XTitle)) then XTitle = "X = "
   if not(keyword_set(YTitle)) then YTitle = "Y = "
   Blanks  = "                    "

<span class="comments">;;;</span>
<span class="comments">;   Now, if the XValues and/or YValues keywords are set, then deal with them.</span>
<span class="comments">; Also, we may want to suppress the printing of the X or Y values (e.g.,</span>
<span class="comments">; XValues=-1 or YValues=-1 sets the ShowX and ShowY variables).</span>
<span class="comments">;</span>
   ShowX = 1
   UseXV = keyword_set(XValues)
   if UseXV then begin
      XVSt = string(XValues)
      XVtop = n_elements(XValues) - 1
      XVfmt = "(A" + strtrim(max(strlen(XVst))+3,2) + ")"
      if ((XVtop eq 0) and (strtrim(XVSt[0],2) eq '-1')) then ShowX = 0
   endif else XVfmt = "(A13)"
   if not(ShowX) then XTitle = ''

   ShowY = 1
   UseYV = keyword_set(YValues)
   if UseYV then begin
      YVSt = string(YValues)
      YVtop = n_elements(YValues) - 1
      YVfmt = "(A" + strtrim(max(strlen(YVst)),2) + ")"
      if ((YVtop eq 0) and (strtrim(YVSt[0],2) eq '-1')) then ShowY = 0
   endif else YVfmt = "(A13)"
   if not(ShowY) then YTitle = ''

<span class="comments">;;;</span>
<span class="comments">;   If Print>1, then printout the informative header, which will vary depending</span>
<span class="comments">; on the values of the DOWN and CHANGE keywords.</span>
<span class="comments">;</span>
   if (Print gt 1) and not(NoWait) then begin
      print
      if Change then begin
         print, " Hit any mouse button or move the mouse to exit."
      endif else begin
         if Down or Wait then begin
            print, " Hit any mouse button to exit."
         endif else begin
            print, '  Mouse Button:   LEFT         MIDDLE        RIGHT'
            print, ' Result Action:   New Line     Exit          Exit'
         endelse
      endelse
      print
   endif

endif else Print = 0


<span class="comments">;;;</span>
<span class="comments">;   FULL-SCREEN CURSOR SETUP SECTION =======================================</span>
<span class="comments">;;;</span>

<span class="comments">;;;;</span>
<span class="comments">; If using the full-screen cursor:</span>
<span class="comments">;   Determine the data range for the full screen.</span>
<span class="comments">;   Blank out the regular cross cursor if the CROSS keyword is not set.</span>
<span class="comments">;   Set up the linestyle, thickness, clipping, and color parameters for the </span>
<span class="comments">; oplot commands.</span>
<span class="comments">;   Set up the graphics to be XOR with the overplotted crosshair, and figure</span>
<span class="comments">; out the color to use for plotting the crosshair {details below}.</span>
<span class="comments">;</span>
if FullCursor then begin
   Yfull = convert_coord([0.0,1.0], [0.0,1.0], /NORMAL, /TO_DATA)
   Xfull = Yfull[0,*]
   Yfull = Yfull[1,*]

   device, GET_GRAPHICS=OldGraphics, SET_GRAPHICS=6
   if not(keyword_set(Cross)) then device, CURSOR_IMAGE=intarr(16)

   if not(keyword_set(Linestyle)) then Linestyle = 0
   if not(keyword_set(Thick)) then Thick = 1
   NoClip = keyword_set(NoClip)

<span class="comments">;;;</span>
<span class="comments">;   I think the best way to make the fullscreen cursor work is to use the XOR</span>
<span class="comments">; graphics function - overplotting a line will XOR with the data already on</span>
<span class="comments">; the screen, then overplotting the same line again will XOR again, effectively</span>
<span class="comments">; erasing the line and returning the device to its original state/appearance.</span>
<span class="comments">;    But first, let me present a quick primer on plotting colors in IDL and the </span>
<span class="comments">; related color tables and translation table:</span>
<span class="comments">;   Normally, when a color N (a number between 0 and 255 which refers to a</span>
<span class="comments">; particular color in the currently loaded IDL color table) is used in one of</span>
<span class="comments">; the plotting or tv commands, the value that is actually sent to the display is</span>
<span class="comments">; the value in the N-th bin of the translation table.  E.g., if the background</span>
<span class="comments">; color is 0, then the actual (device) color value of the background is the</span>
<span class="comments">; value in the zeroth bin of the translation table.  Similarly, if the user</span>
<span class="comments">; wants to plot the color defined by number 147 in the IDL color table, the</span>
<span class="comments">; actual (device) color value of that color is the value in the 147th bin</span>
<span class="comments">; of the translation table.</span>
<span class="comments">;  So in the following example, let's pretend we have the following situation:</span>
<span class="comments">;   IDL> PRINT, !D.N_Colors</span>
<span class="comments">;            222</span>
<span class="comments">;   IDL> PRINT, !P.Background</span>
<span class="comments">;              0</span>
<span class="comments">;   IDL> DEVICE, TRANSLATION=TTab</span>
<span class="comments">;   IDL> PRINT, TTab[0]</span>
<span class="comments">;             34</span>
<span class="comments">;   IDL> PRINT, TTab[147]</span>
<span class="comments">;            181</span>
<span class="comments">;   When we set DEVICE,SET_GRAPHICS=6, and do an overplot, it performs an XOR</span>
<span class="comments">; function between the overplot's translated color value and the background's</span>
<span class="comments">; translated color value.</span>
<span class="comments">;   If we want the resulting color to be the IDL color 147, then we have to </span>
<span class="comments">; overplot with the color whose translated color value XOR'ed with the </span>
<span class="comments">; background's translated color value (34) will equal 181, which is the </span>
<span class="comments">; translated color value of the desired IDL color 147.</span>
<span class="comments">;</span>
<span class="comments">; Symbolically:</span>
<span class="comments">; *  TTab[Desired Color] = TTab[OPLOT color] XOR TTab[Background]</span>
<span class="comments">; *  OPLOT Color = where( TTab eq (TTab[Desired Color] XOR TTab[Background]) )</span>
<span class="comments">;</span>
<span class="comments">; Numerically {using the above example}:</span>
<span class="comments">; *  OPLOT Color = where( TTab eq (TTab[147] XOR TTab[0]) )</span>
<span class="comments">; *  OPLOT Color = where( TTab eq (181 XOR 34) )</span>
<span class="comments">; *  OPLOT Color = where( TTab eq 151 )</span>
<span class="comments">;</span>
<span class="comments">;   Fine.</span>
<span class="comments">;   HOWEVER...since the translation table often does NOT contain the full range</span>
<span class="comments">; of possible numbers (e.g., 0 to 255), the result of the XOR function between </span>
<span class="comments">; the background and the oplot color may be a value that does NOT appear in the </span>
<span class="comments">; translation table.  This is particularly a problem for colors near the bottom</span>
<span class="comments">; of the translation table where the result of the XOR function may be less than</span>
<span class="comments">; the lowest value in TTab.</span>
<span class="comments">;   To fix this problem, I bypass the translation table, and directly send the</span>
<span class="comments">; device color (e.g., the value 151 in the above example) to the OPLOT command.</span>
<span class="comments">;   There is still some bug here - sometimes the color still isn't right.  I'll</span>
<span class="comments">; have to talk to the IDL support people about this {as soon as our support</span>
<span class="comments">; license is renewed!}</span>
<span class="comments">; NOTE: Took a while to figure out how to make the full cursor work with</span>
<span class="comments">;       both a specified cursor color and a non-black background.  We stick</span>
<span class="comments">;       with the XOR graphics function.  However, we need to deal with the</span>
<span class="comments">;       complex case of an indexed color model (Decompositon off) for the</span>
<span class="comments">;       TrueColor and DirectColor visual classes.  For TrueColor, we get</span>
<span class="comments">;       the RGB triplet stored in the color table at the indices specified</span>
<span class="comments">;       by Color and BackGround and convert them to 24-bit decomposed color</span>
<span class="comments">;       indices.  Then we turn on color decomposition.  Before we exit, we</span>
<span class="comments">;       turn it back off.  For DirectColor, we just need to XOR the 8-bit</span>
<span class="comments">;       color table indices.</span>
<span class="comments">;</span>

   <span class="comments">; CHECK FOR THE VISUAL CLASS AND COLOR DECOMPOSITION STATE...</span>
   device, Get_Visual_Name=VisualName, Get_Decomposed=Decomposed

   <span class="comments">; SET COLOR KEYWORDS IF NOT DEFINED...</span>
   if ((size(Color))[1] eq 0) then $   <span class="comments">;  if undefined</span>
      Color = Decomposed ? !D.N_Colors - 1 : !D.Table_Size - 1
   if (N_elements(BACKGROUND) eq 0) then BackGround = !P.BackGround
   
   <span class="comments">; Are we using a TrueColor or DirectColor visual class...</span>
   if (VisualName eq 'TrueColor') OR (VisualName eq 'DirectColor') then begin
      if (VisualName eq 'TrueColor') AND not(Decomposed) then begin
         <span class="comments">; For TrueColor with color decomposition off, we need to...</span>
         <span class="comments">; Turn on Color Decomposition...</span>
         device, Decomposed=1
         <span class="comments">; Get the RGB triplets stored in our color table...</span>
         tvlct, rct, gct, bct, /GET
         <span class="comments">; Find the corresponding 24-bit decomposed color indices...</span>
         CTab = long(rct) + ishft(long(gct),8) + ishft(long(bct),16)
         DevColor = CTab[Color]
         DevBack = CTab[BackGround]
      endif else begin
         <span class="comments">; If TrueColor or Directcolor with Decomposition On, or</span>
         <span class="comments">; DirectColor with Decomposition Off...</span>
         DevColor = Color
         DevBack  = BackGround
      endelse
   endif else begin
      <span class="comments">; If we're not using TrueColor or DirectColor, then we'll</span>
      <span class="comments">; access the translation table...</span>
      device, TRANSLATION=TTab, BYPASS_TRANSLATION=1
      if (Color ge !D.Table_size) then $
         message, /INFO, $
                  'Trying to draw cursor with color table index GT Table Size'
      DevColor = TTab[Color &lt<span class="comments">; (!D.Table_size - 1)]</span>
      if (BackGround ge !D.Table_size) then $
         message, /INFO, $
                  'Specified background has color table index GT Table Size'
      DevBack  = TTab[BackGround &lt<span class="comments">; (!D.Table_size - 1)]</span>
   endelse
   OColor = DevColor xor DevBack
endif


<span class="comments">;;;</span>
<span class="comments">;   FINALLY...THE PLOT READING SECTION  ====================================</span>
<span class="comments">;;;</span>

<span class="comments">;;;</span>
<span class="comments">;   If the cursor is beyond the boundaries of the window (device coordinates of</span>
<span class="comments">; X=-1 and Y=-1), then wait until the cursor is moved into the window.</span>
<span class="comments">;</span>
cursor, X, Y, /NOWAIT, /DEVICE
if ((X lt 0) or (Y lt 0)) then cursor, X, Y, /CHANGE


<span class="comments">;;;</span>
<span class="comments">;   Begin the loop that will repeat until a button is clicked (or a change if</span>
<span class="comments">; that is what the user wanted).   Err0 is used to keep track if the procedure</span>
<span class="comments">; was entered with a key already down, then it will be non-zero until that</span>
<span class="comments">; key has been released, at which point it will be permanantly set to zero.</span>
<span class="comments">; NOTE: Robishaw's edits make Err0 obsolete so these lines are commented.</span>
<span class="comments">;   Wait for a change (movement or key click).  Delete the old lines, and</span>
<span class="comments">; if we don't exit the loop, repeat and draw new lines.</span>
<span class="comments">;</span>
cursor, X, Y, /NOWAIT, DATA=Data, DEVICE=Device, NORMAL=Normal
<span class="comments">;Err0 = !mouse.button</span>

NClicks = 0l
repeat begin    <span class="comments">; here we go!</span>

<span class="comments">;;;</span>
<span class="comments">;   This wait is a kludge to prevent ghosts from being left when /FULLCURSOR</span>
<span class="comments">;   is set.</span>
<span class="comments">;</span>
    if FullCursor then wait, 0  <span class="comments">; black magic</span>

<span class="comments">;;;</span>
<span class="comments">;   If doing a full-screen cursor, overplot two full-screen lines intersecting </span>
<span class="comments">; at that position.</span>
<span class="comments">;</span>
   if FullCursor then begin
      XY = convert_coord(X,Y, DATA=Data,DEVICE=Device,NORMAL=Normal, /TO_DATA)
      Xdata = XY[0] * [1.0,1.0]
      Ydata = XY[1] * [1.0,1.0]
      oplot,Xdata,Yfull,LINE=Linestyle,THICK=Thick,NOCLIP=NoClip,COLOR=OColor
      oplot,Xfull,Ydata,LINE=Linestyle,THICK=Thick,NOCLIP=NoClip,COLOR=OColor
   endif

<span class="comments">;;;</span>
<span class="comments">;   If printing out data values, do so.</span>
<span class="comments">;   !mouse.button=1 is the signal for a new line.</span>
<span class="comments">;</span>
   if (Print gt 0) then begin

      if ShowX then begin
         if UseXV then Xst = XVSt[(X+0.5) > 0 &lt<span class="comments">; XVtop] else Xst = strtrim(X,2)</span>
         XSt = XTitle + string(Xst + Blanks, FORMAT=XVfmt)
      endif else Xst = ''
      if ShowY then begin
         if UseYV then Yst = YVSt[(Y+0.5) > 0 &lt<span class="comments">; YVtop] else Yst = strtrim(Y,2)</span>
         YSt = YTitle + string(Yst + Blanks, FORMAT=YVfmt)
      endif else Yst = ''

      print, Xst, Yst, format='($,2A,%"\R")'

      <span class="comments">; If left button pressed, then print out a new line; accumulate</span>
      <span class="comments">; position if /ACCUMULATE set...</span>
      if (!mouse.button eq 1) and $
         not(Down or Wait or Change or NoWait) then begin <span class="comments">;  new line?</span>
         print, format='($,%"\n")'
         NClicks = NClicks + 1l
         if Arg_Present(y) then begin
            if keyword_set(ACCUMULATE) and (NClicks gt 1) then begin
               xout = [xout,x]
               yout = [yout,y]
            endif else begin
               xout = x
               yout = y
            endelse
         endif
      endif

      <span class="comments">; If button is held down, don't continue until button is released...</span>
      if ( (!mouse.button eq 1) and not(Wait or Change or NoWait) ) $
         <span class="comments">; if entered with a button down, wait for next down click before</span>
         <span class="comments">; returning...</span>
         or ( (!mouse.button gt 1) and Down) then begin
         while (!mouse.button gt 0) do begin
            wait, 0.1
            cursor, XX, YY, /NOWAIT
         endwhile
      endif
   endif

   <span class="comments">;Err0 = Err0 &lt; !mouse.button</span>

<span class="comments">;;;</span>
<span class="comments">;  Check to see that the cursor's current position is really the last measured </span>
<span class="comments">; position (the mouse could have moved during a delay in the last section).  If</span>
<span class="comments">; so, then go on.  If not, then wait for some change in the mouse's status </span>
<span class="comments">; before going on.</span>
<span class="comments">;  In either case, once we are going on, then if doing a full-screen cursor, </span>
<span class="comments">; overplot the previous lines {the XOR graphics function will return the plot</span>
<span class="comments">; to its original appearance}.  Repeat until exit signal.</span>
<span class="comments">;</span>

   <span class="comments">; There are a few cases where we just want to exit immediately...</span>
   InstantOut = ( NoWait ) OR $  <span class="comments">; if /NoWait is set</span>
                <span class="comments">; if /WAIT is set and *any* button is pressed, even if</span>
                <span class="comments">; a button is being held down when the routine is called...</span>
                ( Wait AND (!mouse.button gt 0) ) OR $
                <span class="comments">; if /CHANGE is set and *any* button is pressed...</span>
                ( Change AND (NClicks gt 0) )

   if not(InstantOut) then begin
      cursor, XX, YY, /NOWAIT, DATA=Data, DEVICE=Device, NORMAL=Normal
      if ((XX eq X) and (YY eq Y)) then $
         cursor, XX, YY, /CHANGE, DATA=Data, DEVICE=Device, NORMAL=Normal
      <span class="comments">; Load the new XX and YY values into the X and Y variables...</span>
      X = XX
      Y = YY
   endif

   <span class="comments">; Erase the full cursor...</span>
   if FullCursor then begin
      oplot,Xdata,Yfull,LINE=Linestyle,THICK=Thick,NOCLIP=NoClip,COLOR=OColor
      oplot,Xfull,Ydata,LINE=Linestyle,THICK=Thick,NOCLIP=NoClip,COLOR=OColor
   endif

   <span class="comments">; Handle case of /CHANGE but cursor was moved rather than a button</span>
   <span class="comments">; clicked; we use kludge of incrementing NClicks counter...</span>
   <span class="comments">; this will force the new position to be printed...</span>
   if Change AND (NClicks eq 0) then begin
      XOut = X
      YOut = Y
      NClicks = NClicks + 1
      ExitFlag = 0
      continue
   endif

   Err = !mouse.button

   ExitFlag = (Down AND (Err gt 0)) OR (Err gt 1) OR InstantOut

endrep until ExitFlag

<span class="comments">;;;</span>
<span class="comments">; If exit click was at a position different from last left-click, then add</span>
<span class="comments">; this to the list of positions...</span>
<span class="comments">;</span>
if (NClicks gt 0) then begin
   last_left_click = keyword_set(ACCUMULATE) ? NClicks-1 : 0
   if not((X eq XOut[last_left_click]) and $
          (Y eq YOut[last_left_click])) then begin
      XOut = [XOut,X]
      YOut = [YOut,Y]
   endif
endif else begin
   XOut = X
   YOut = Y
endelse

if (Print gt 0) then print

<span class="comments">;LABEL_DONE:</span>

<span class="comments">;;;</span>
<span class="comments">;  Done!  Go back to the default Graphics and cursor in case they were changed.</span>
<span class="comments">;  Also erase the plot ranges if they originally were not defined.</span>
<span class="comments">;</span>
if FullCursor then device,/CURSOR_CROSSHAIR,SET_GRAPHICS=OldGraphics,Bypass=0

<span class="comments">; If the color decomposition was off when we started, shut it off again...</span>
if (VisualName eq 'TrueColor') and not(Decomposed) then device, Decomposed=0

if UndefinedPlot then begin
   !X.CRange = 0
   !Y.CRange = 0
endif

<span class="comments">;;;</span>
<span class="comments">;  Assign X & Y to the accumulated values if /ACCUMULATE is set...</span>
if keyword_set(ACCUMULATE) and Arg_Present(Y) then begin
   X = temporary(XOut)
   Y = temporary(YOut)
endif

end   <span class="comments">;   RDPLOT</span>
</code>
    </div>
  </body>
</html>