<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:11 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>wcs_rotate.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="wcs_rotate.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       WCS_ROTATE </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Rotate between standard (e.g. celestial) and native coordinates</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Computes a spherical coordinate rotation between native coordinates </span>
<span class="comments">;       and  standard celestial coordinate system (celestial, Galactic, or</span>
<span class="comments">;       ecliptic).   Applies the equations in Appendix B of the paper </span>
<span class="comments">;       "Representation of Celestial Coordinates in FITS" by Calabretta </span>
<span class="comments">;       Greisen (2002, A&A, 395, 1077).    Also see </span>
<span class="comments">;       http://fits.gsfc.nasa.gov/fits_wcs.html</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       Mapping and Auxiliary FITS Routine</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       WCS_ROTATE, longitude, latitude, phi, theta, crval, </span>
<span class="comments">;               [LONGPOLE = , LATPOLE = , /REVERSE, /ORIGIN ]</span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS:</span>
<span class="comments">;       crval - 2 element vector containing standard system coordinates (the </span>
<span class="comments">;               longitude and latitude) of the reference point</span>
<span class="comments">;</span>
<span class="comments">; INPUT OR OUTPUT PARAMETERS</span>
<span class="comments">;       longitude - longitude of data, scalar or vector, in degrees, in the</span>
<span class="comments">;               standard celestial coordinate system</span>
<span class="comments">;       latitude - latitude of data, same number of elements as longitude, </span>
<span class="comments">;               in degrees</span>
<span class="comments">;       phi - longitude of data in the native system, in degrees, scalar or</span>
<span class="comments">;               vector</span>
<span class="comments">;       theta - latitude of data in the native system, in degrees, scalar or</span>
<span class="comments">;               vector</span>
<span class="comments">;</span>
<span class="comments">;       If the keyword(REVERSE) is set then phi and theta are input parameters</span>
<span class="comments">;       and longitude and latitude are computed.    Otherwise, longitude and</span>
<span class="comments">;       latitude are input parameters and phi and theta are computed.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUT PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;      ORIGIN - If this keyword is set and non-zero, then the reference point</span>
<span class="comments">;               given by CRVAL in the native system is assumed to be at the</span>
<span class="comments">;               origin of the coordinates, rather than at the North Pole.</span>
<span class="comments">;               ORIGIN should be set for cylindrical projections (Cylindrical</span>
<span class="comments">;               perspective-CYP, Cartesian - CAR, Mercator - MER, Cylindrical</span>
<span class="comments">;               Equal area - CEA) and conventional projections (Bonne's equal</span>
<span class="comments">;               area - BON, Polyconic - PCO, Sinusoidal - GLS, Parabolic - PAR,</span>
<span class="comments">;               Aitoff - AIT, Mollweide - MOL, COBE quadrilateralized sphere -</span>
<span class="comments">;               CSC, Quadrilateralized Spherical Cube - QSC, and Tangential</span>
<span class="comments">;               Spherical Cube - TSC)</span>
<span class="comments">;</span>
<span class="comments">;       LONGPOLE - native longitude of standard system's North Pole, default</span>
<span class="comments">;               for a Zenithal system is 180 degrees</span>
<span class="comments">;       LATPOLE -  native latitude of the standard system's North Pole</span>
<span class="comments">;       /REVERSE - if set then phi and theta are input parameters and longitude</span>
<span class="comments">;                  and latitude are computed.    By default, longitude and</span>
<span class="comments">;                  latitude are input parameters and phi and theta are computed.</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written    W. Landsman               December, 1994</span>
<span class="comments">;       Fixed error in finding North Pole if /ORIGIN and LONGPOLE NE 180</span>
<span class="comments">;       Xiaoyi Wu and W. Landsman,   March, 1996</span>
<span class="comments">;       Fixed implementation of March 96 error, J. Thieler,  April 1996</span>
<span class="comments">;       Updated to IDL V5.0   W. Landsman    December 1997</span>
<span class="comments">;       Fixed determination of alpha_p if /ORIGIN and LONGPOLE EQ 180</span>
<span class="comments">;               W. Landsman    May 1998</span>
<span class="comments">;       Ensure argument of ASIN() is -1&lt;x&lt;-1 after roundoff </span>
<span class="comments">;               W. Landsman/R. Arendt  June 2002</span>
<span class="comments">;       Call WCS_GETPOLE, accept LATPOLE keyword, update cylindrical coords</span>
<span class="comments">;               W. Landsman  June 2003 </span>
<span class="comments">;       Don't attempt to rotate NaN values   W. Landsman  May 2004</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

<a id="wcs_rotate:source"></a>pro wcs_rotate, longitude, latitude, phi, theta, crval, LONGPOLE = longpole, $
          LATPOLE = latpole,REVERSE=reverse, ORIGIN = origin, THETA0 = theta0


<span class="comments">; check to see that enough parameters (at least 4) were sent</span>
 if (N_params() lt 5) then begin
    print,'Syntax - WCS_ROTATE, longitude, latitude, phi, theta, crval'
    print,'               LATPOLE =,  LONGPOLE = , /REVERSE, /ORIGIN' 
    return
 endif 

 <span class="comments">; DEFINE ANGLE CONSTANTS </span>
 pi = !DPI
 pi2 = pi/2.d0
 radeg = 1.8d2/pi

 if keyword_set( REVERSE) then begin
        if min([ N_elements(phi), N_elements(theta) ]) EQ 0 then          $
        message,'ERROR - Native Coordinates (phi,theta) not defined'    
 endif else begin
        if min([ N_elements(longitude), N_elements(latitude) ]) EQ 0 then $ 
        message, 'ERROR - Celestial Coordinates (long,lat) not defined' 
 endelse

<span class="comments">; Longpole is the longitude in the native system of the North Pole in the</span>
<span class="comments">; standard system (default = 180 degrees).</span>

 if N_elements(longpole) eq 0 then longpole = 1.8d2
 phi_p = double(longpole)/radeg
 sp = sin(phi_p)
 cp = cos(phi_p)

<span class="comments">; If Theta0 = 90 then CRVAL gives the coordinates of the origin in the</span>
<span class="comments">; native system.   This must be converted (using Eq. 7 in Greisen & Calabretta</span>
<span class="comments">; with theta0 = 0) to give the coordinates of the North pole (alpha_p, delta_p)</span>

 if theta0 EQ 90 then begin
        alpha_p = double(crval[0])/radeg
        delta_p = double(crval[1])/radeg
 endif else WCS_GETPOLE, crval, longpole, theta0, alpha_p, delta_p, $
            LATPOLE = latpole
    
<span class="comments">; compute useful quantities relating to reference angles</span>
  sa = sin(alpha_p)
  ca = cos(alpha_p)
  sd = sin(delta_p)
  cd = cos(delta_p)

<span class="comments">; calculate rotation matrix </span>

  r = [ [-sa*sp - ca*cp*sd,  ca*sp - sa*cp*sd, cp*cd ] , $
        [ sa*cp - ca*sp*sd, -ca*cp - sa*sp*sd, sp*cd ] , $
        [ ca*cd           ,  sa*cd           , sd    ] ]

<span class="comments">; solve the set of equations for each datum point</span>

 if keyword_set(REVERSE) then begin
        latitude = phi
        longitude = theta
        g = where( finite(phi) and finite(theta), Ng )
        if Ng EQ 0 then return
        phi1 = double(phi[g])/radeg
        theta1 = double(theta[g])/radeg
        r = transpose(r)
 endif else begin
        phi = longitude
        phi1 = double(longitude)/radeg
        theta1 = double(latitude)/radeg
 endelse

<span class="comments">; define the right-hand side of the equations</span>

 l = cos(theta1)*cos(phi1)
 m = cos(theta1)*sin(phi1)
 n = sin(theta1)

<span class="comments">; find solution to the system of equations and put it in b</span>
<span class="comments">; Can't use matrix notation in case l,m,n are vectors</span>

 b0 = r[0,0]*l + r[1,0]*m + r[2,0]*n
 b1 = r[0,1]*l + r[1,1]*m + r[2,1]*n
 b2 = (r[0,2]*l + r[1,2]*m + r[2,2]*n) > (-1) &lt<span class="comments">; 1 ;Account for possible roundoff</span>

<span class="comments">; use b0,b1,b2 to compute "native" latitude and longitude</span>

 if keyword_set(REVERSE) then begin
        latitude[g] = asin(b2)*radeg
        longitude[g] = atan( b1, b0)*radeg
 endif else begin
        theta = asin(b2)*radeg
        phi = atan( b1, b0)*radeg
 endelse

 return
 end
</code>
    </div>
  </body>
</html>