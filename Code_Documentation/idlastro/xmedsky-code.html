<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:13 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>xmedsky.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="xmedsky.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO XMEDSKY, Image, Bkg, CLIP=clip, Nsig = nsig
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       XMEDSKY</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Subtract sky from an image as a 1-D function of X</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       This procedure is designed to remove the sky from slitless spectra.</span>
<span class="comments">;       The sky is assumed to vary with wavelength (along a row) but not with</span>
<span class="comments">;       position (along a column).    The sky is computed as the </span>
<span class="comments">;       column-by-column median of pixels within 3 sigma of the image global </span>
<span class="comments">;       median.   This procedure is called by the cosmic ray rejection routine</span>
<span class="comments">;       CR_REJECT</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       XMEDSKY, Image, Bkg, [ CLIP=[x0, x1, y0, y1], NSIG= ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       Image:  Input image for which sky vector is to be computed.</span>
<span class="comments">;       </span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       CLIP:   [x0, x1, y0, y1]: region of image to be used for all</span>
<span class="comments">;               statistical computations.    Default is to use the entire</span>
<span class="comments">;               image.   For STIS 1024 x 512 slitless spectra, the suggested</span>
<span class="comments">;               value is CLIP = [32,1023,12,499]</span>
<span class="comments">;       NSIG:   Positive scalar giving the number of sigma a pixel must be above</span>
<span class="comments">;               the global median to be reject.   Default is 3 sigma.</span>
<span class="comments">; OUTPUT PARAMETER:</span>
<span class="comments">;       Bkg:    Vector of sky values.</span>
<span class="comments">;;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written by:     R. S. Hill, Hughes STX, 20 Oct. 1997</span>
<span class="comments">;       Converted to V5.0, use STDDEV()   W. Landsman   June 1998</span>
<span class="comments">;       Check for valid WHERE, added NSIG keyword  W. Landsman   December 2000 </span>
<span class="comments">;       Assume since V5.1 so always use STDDEV  W. Landsman Feb 2004 </span>
<span class="comments">;       Assume since V5.6 use DIMEN keyword to MEDIAN W. Landsman Jan 2008  </span>
<span class="comments">;-</span>
 compile_opt idl2
 if N_params() LT 2 then begin
        print,'Syntax - Xmedsky, Image, Bkg, [CLIP = ]'
        return
 endif
 if N_elements(nsig) EQ 0 then nsig=3
 sz = size(image)
 nbkg = sz[1]
 if N_elements(clip) LT 1 then clip = [0,sz[1]-1,0,sz[2]-1 ]

  bkg = median( image, dimen=2)

 tmpimg=image
 FOR i=0,sz[2]-1 DO tmpimg[0,i] = image[*,i] - bkg

<span class="comments">; Now get the global median and standard deviation</span>

 totmed = median(tmpimg[clip[0]:clip[1],clip[2]:clip[3]])
 totsdv = stddev(tmpimg[clip[0]:clip[1],clip[2]:clip[3]]) 

<span class="comments">; Create a mask array showing where pixels are more than 3 (or Nsig) sigma</span>
<span class="comments">; from the global median.</span>

 mask = byte(0*image+1)
 watt = where(abs(temporary(tmpimg)-totmed) GT (nsig*totsdv), cwatt)
 if cwatt GT 0 then mask[watt] = 0

<span class="comments">; Now recompute column by column median using only unmasked pixels within the</span>
<span class="comments">; clipped region.</span>

 FOR i=0,nbkg-1 DO BEGIN
   wmi = where(mask[i,clip[2]:clip[3]], cwmi)
   if cwmi GT 0 THEN $
       bkg[i]=median( image[i,clip[2] + wmi ] )
 ENDFOR

 return
 END

</code>
    </div>
  </body>
</html>