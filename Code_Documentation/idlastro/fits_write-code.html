<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:31 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fits_write.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fits_write.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="fits_write:source"></a>pro fits_write,file_or_fcb,data,header_in,extname=extname,extver=extver, $
		xtension=xtension, extlevel=extlevel, $
		no_abort=no_abort, message = message, header = header, $
		no_data = no_data
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	FITS_WRITE</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	To write a FITS primary data unit or extension.</span>
<span class="comments">;</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       ***NOTE** This version of FITS_READ must be used with a post Sep 2006</span>
<span class="comments">;          version of FITS_OPEN.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	FITS_WRITE, filename_or_fcb, data, [header_in]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	FILENAME_OR_FCB: name of the output data file or the FITS control</span>
<span class="comments">;		block returned by FITS_OPEN (called with the /WRITE or</span>
<span class="comments">;		/APPEND) parameters.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;	DATA: data array to write.  If not supplied or set to a scalar, a</span>
<span class="comments">;		null image is written.</span>
<span class="comments">;	HEADER_IN: FITS header keyword.  If not supplied, a minimal basic</span>
<span class="comments">;		header will be created.  Required FITS keywords, SIMPLE,</span>
<span class="comments">;		BITPIX, XTENSION, NAXIS, ... are added by FITS_WRITE and</span>
<span class="comments">;		do not need to be supplied with the header.  If supplied,</span>
<span class="comments">;		their values will be updated as necessary to reflect DATA.</span>
<span class="comments">;</span>
<span class="comments">; INPUT KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;	XTENSION: type of extension to write (Default="IMAGE"). If not</span>
<span class="comments">;		supplied, it will be taken from HEADER_IN.  If not in either</span>
<span class="comments">;		place, the default is "IMAGE".  This parameter is ignored</span>
<span class="comments">;		when writing the primary data unit.     Note that binary and</span>
<span class="comments">;               and ASCII table extensions already have a properly formatted</span>
<span class="comments">;               header (e.g. with TTYPE* keywords) and byte array data. </span>
<span class="comments">;	EXTNAME: EXTNAME for the extension.  If not supplied, it will be taken</span>
<span class="comments">;		from HEADER_IN.  If not supplied and not in HEADER_IN, no</span>
<span class="comments">;		EXTNAME will be written into the output extension.</span>
<span class="comments">;	EXTVER: EXTVER for the extension.  If not supplied, it will be taken</span>
<span class="comments">;               from HEADER_IN.  If not supplied and not in HEADER_IN, no</span>
<span class="comments">;               EXTVER will be written into the output extension.</span>
<span class="comments">;	EXTLEVEL: EXTLEVEL for the extension.  If not supplied, it will be taken</span>
<span class="comments">;               from HEADER_IN.  If not supplied and not in HEADER_IN, no</span>
<span class="comments">;               EXTLEVEL will be written into the output extension.</span>
<span class="comments">;       /NO_ABORT: Set to return to calling program instead of a RETALL</span>
<span class="comments">;               when an I/O error is encountered.  If set, the routine will</span>
<span class="comments">;               return  a non-null string (containing the error message) in the</span>
<span class="comments">;               keyword MESSAGE.   If /NO_ABORT not set, then FITS_WRITE will </span>
<span class="comments">;               print the message and issue a RETALL</span>
<span class="comments">;	/NO_DATA: Set if you only want FITS_WRITE to write a header.  The</span>
<span class="comments">;		header supplied will be written without modification and</span>
<span class="comments">;		the user is expected to write the data using WRITEU to unit</span>
<span class="comments">;		FCB.UNIT. When FITS_WRITE is called with /NO_DATA, the user is</span>
<span class="comments">;		responsible for the validity of the header, and must write</span>
<span class="comments">;		the correct amount and format of the data.  When FITS_WRITE</span>
<span class="comments">;		is used in this fashion, it will pad the data from a previously</span>
<span class="comments">;		written extension to 2880 blocks before writting the header.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT KEYWORD PARAMETERS:</span>
<span class="comments">;       MESSAGE: value of the error message for use with /NO_ABORT</span>
<span class="comments">;	HEADER: actual output header written to the FITS file.</span>
<span class="comments">;</span>
<span class="comments">; NOTES:</span>
<span class="comments">;	If the first call to FITS_WRITE is an extension, FITS_WRITE will</span>
<span class="comments">;	automatically write a null image as the primary data unit.</span>
<span class="comments">;</span>
<span class="comments">;	Keywords and history in the input header will be properly separated</span>
<span class="comments">;	into the primary data unit and extension portions when constructing</span>
<span class="comments">;	the output header (See FITS_READ for information on the internal</span>
<span class="comments">;	Header format which separates the extension and PDU header portions).</span>
<span class="comments">;	</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;	Write an IDL variable to a FITS file with the minimal required header.</span>
<span class="comments">;		FITS_WRITE,'newfile.fits',ARRAY</span>
<span class="comments">;</span>
<span class="comments">;	Write the same array as an image extension, with a null Primary data</span>
<span class="comments">;	unit.</span>
<span class="comments">;		FITS_WRITE,'newfile.fits',ARRAY,xtension='IMAGE'</span>
<span class="comments">;</span>
<span class="comments">;	Write 4 additional image extensions to the same file.</span>
<span class="comments">;		FITS_OPEN,'newfile.fits',fcb</span>
<span class="comments">;		FITS_WRITE,fcb,data1,extname='FLUX',extver=1</span>
<span class="comments">;		FITS_WRITE,fcb,err1,extname'ERR',extver=1</span>
<span class="comments">;		FITS_WRITE,fcb,data2,extname='FLUX',extver=2</span>
<span class="comments">;		FITS_WRITE,fcb,err2,extname='ERR',extver=2</span>
<span class="comments">;		FITS_CLOSE,FCB</span>
<span class="comments">;		</span>
<span class="comments">; WARNING: </span>
<span class="comments">;       FITS_WRITE currently does not completely update the file control block.</span>
<span class="comments">;       When mixing FITS_READ and FITS_WRITE commands it is safer to use </span>
<span class="comments">;       file names, rather than passing the file control block.</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;	FITS_OPEN, SXADDPAR, SXDELPAR, SXPAR()</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;	Written by:	D. Lindler	August, 1995</span>
<span class="comments">;	Work for variable length extensions  W. Landsman   August 1997</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;	PCOUNT and GCOUNT added for IMAGE extensions   J. Graham  October 1999</span>
<span class="comments">;       Write unsigned data types      W. Landsman   December 1999</span>
<span class="comments">;       Pad data area with zeros not blanks  W. McCann/W. Landsman October 2000</span>
<span class="comments">;       Return Message='' to signal normal operation W. Landsman Nov. 2000</span>
<span class="comments">;       Ensure that required extension table keywords are in proper order</span>
<span class="comments">;             W.V. Dixon/W. Landsman          March 2001</span>
<span class="comments">;       Assume since V5.1, remove NaNValue keyword   W. Landsman Nov. 2002</span>
<span class="comments">;       Removed obsolete !ERR system variable  W. Landsman Feb 2004</span>
<span class="comments">;       Check that byte array supplied with table extension W. Landsman Mar 2004</span>
<span class="comments">;       Make number of bytes 64bit to avoid possible overflow W.L  Apr 2006</span>
<span class="comments">;       Asuume FITS_OPEN has opened the file with /SWAP_IF_LITTLE_ENDIAN</span>
<span class="comments">;                         W. Landsman   September 2006</span>
<span class="comments">;       Removes BZERO and BSCALE for floating point output, D. Lindler, Sep 2008</span>
<span class="comments">;-</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; print calling sequence if no parameters supplied</span>
<span class="comments">;</span>
	if n_params() lt 1 then begin
	    print,'Calling Sequence: FITS_WRITE,file_or_fcb,data,header_in'
	    print,'Input Keywords: extname, extver, xtension, extlevel,' + $
                                    '/no_abort, /no_data'
	    print,'Output Keywords:  message, header ' 
	    return
	end
<span class="comments">;</span>
<span class="comments">; Open file if file name is supplied instead of a FCB</span>
<span class="comments">;</span>
        message = ''
        s = size(file_or_fcb) & fcbtype = s[s[0]+1]
	fcbsize = n_elements(file_or_fcb)
        if (fcbsize ne 1) || ((fcbtype ne 7) && (fcbtype ne 8)) then begin
                message = 'Invalid Filename or FCB supplied'
                goto,error_exit
        end

        if fcbtype eq 7 then begin
		if keyword_set(no_data) then begin
			print,'FITS_WRITE: Must have FCB supplied for NO_DATA'
			retall
		endif
                fits_open,file_or_fcb,fcb,/write, $
					no_abort=no_abort,message=message
		if message NE '' then goto,error_exit
           end else fcb = file_or_fcb
<span class="comments">;</span>
<span class="comments">; if user did not pad data to 2880 blocks, pad it now</span>
<span class="comments">;</span>
	point_lun,-fcb.unit,current_position
	npad = 2880 - (current_position mod 2880)
	if npad eq 2880 then npad = 0
	if npad gt 0 then writeu,fcb.unit,bytarr(npad)
<span class="comments">;</span>
<span class="comments">; if no_data, just go and write user header as supplied</span>
<span class="comments">;</span>
	if keyword_set(no_data) then begin
		header = header_in
		goto,write_header
	end
<span class="comments">;</span>
<span class="comments">; if header not supplied then set it to a null header</span>
<span class="comments">;</span>
	if n_elements(header_in) le 1 then begin
		header = strarr(1)
		header[0] = 'END     '
	end else header = header_in

<span class="comments">;</span>
<span class="comments">; on I/O error go to statement IOERROR</span>
<span class="comments">;</span>
<span class="comments">;	on_ioerror,ioerror</span>
<span class="comments">;</span>
<span class="comments">; verify file is open for writing</span>
<span class="comments">;</span>
	if fcb.open_for_write eq 0 then begin
		message,'File is not open for writing'
		goto,error_exit
	endif
<span class="comments">;</span>
<span class="comments">; determine bitpix and axis information</span>
<span class="comments">;</span>
	s = size(data)
	naxis = s[0]
	if naxis gt 0 then axis = s[1:naxis]
	idltype = s[naxis+1]

	if (idltype gt 5) && (idltype NE 12) && (idltype NE 13) then begin
		message='Data array is an invalid type'
		goto,error_exit
	endif
	bitpixs = [8,8,16,32,-32,-64,0,0,0,0,0,0,16,32]
	bitpix = bitpixs[idltype]
<span class="comments">;</span>
<span class="comments">; determine extname, extver, xtension and extlevel and delete current values</span>
<span class="comments">;</span>
	if n_elements(xtension) gt 0 then begin
		Axtension = xtension
	   end else begin
		Axtension = sxpar(header,'xtension', Count = N_Axtension)
		if N_Axtension EQ 0 then Axtension = ''
 	end
        if Axtension EQ 'BINTABLE' or (Axtension EQ 'TABLE') then $
                if idltype GT 1 then begin
                     message='A Byte array must be supplied with a ' + $
                             'BINTABLE or TABLE extension'
                     goto, error_exit
                 endif

	if n_elements(extname) gt 0 then begin
		Aextname = extname
	   end else begin
		Aextname = sxpar(header,'extname', Count = N_Aextname)
		if N_Aextname EQ 0 then Aextname = ''
	end

	if n_elements(extver) gt 0 then $
		Aextver = extver $
		else Aextver = sxpar(header,'extver')

	if n_elements(extlevel) gt 0 then $
		Aextlevel = extlevel $
		else Aextlevel = sxpar(header,'extlevel')

	sxdelpar,header,['XTENSION','EXTNAME','EXTVER','EXTLEVEL']

<span class="comments">;</span>
<span class="comments">; separate header into main and extension header</span>
<span class="comments">;</span>
	keywords = strmid(header,0,8)
	hpos1 = where(keywords eq 'BEGIN MA') & hpos1 = hpos1[0] <span class="comments">;begin main</span>
	hpos2 = where(keywords eq 'BEGIN EX') & hpos2 = hpos2[0] <span class="comments">;begin ext.</span>
	hpos3 = where(keywords eq 'END     ') & hpos3 = hpos3[0] <span class="comments">;end of header	</span>

	if (hpos1 gt 0) && (hpos2 lt hpos1) then begin
		message,'Invalid header BEGIN EXTENSION HEADER ... out of place'
		goto,error_exit
	endif

	if (hpos3 lt 0) then begin
		print,'FITS_WRITE: END missing from input header and was added'
		header = [header,'END     ']
		hpos2 = n_elements(header)-1
	end
<span class="comments">;</span>
<span class="comments">; determine if a extension was supplied and no primary data unit (PDU)</span>
<span class="comments">; was written</span>
<span class="comments">;</span>
	if (fcb.nextend eq -1) then begin		<span class="comments">;no pdu written yet?</span>
	    if (hpos2 gt 0) || (Axtension ne '') || (Aextname ne '') || $
	       (Aextver ne 0) || (Aextlevel ne 0) then begin
<span class="comments">;</span>
<span class="comments">; write null image PDU</span>
<span class="comments">;</span>
			if (hpos1 gt 0) && (hpos2 gt (hpos1+1)) then $
				hmain = [header[hpos1+1:hpos2-1],'END     ']
			fits_write,fcb,0,hmain,/no_abort,message=message
			if message NE '' then goto,error_exit
	    end
	end
<span class="comments">;</span>
<span class="comments">; For extensions, do not use PDU portion of the header</span>
<span class="comments">;</span>
	if (hpos2 gt 0) then header = header[hpos2+1:hpos3]
<span class="comments">;</span>
<span class="comments">; create required keywords for the header</span>
<span class="comments">;</span>
	h = strarr(20)
	h[0] = 'END     '

	if fcb.nextend eq -1 then begin
		sxaddpar,h,'SIMPLE','T','image conforms to FITS standard' 
	   end else begin
		if Axtension eq '' then Axtension = 'IMAGE   '
		sxaddpar,h,'XTENSION',Axtension,'extension type'
	end
	sxaddpar,h,'BITPIX',bitpix,'bits per data value'
	sxaddpar,h,'NAXIS',naxis,'number of axes'
	if naxis gt 0 then for i=1,naxis do $
		sxaddpar,h,'NAXIS'+strtrim(i,2),axis[i-1]
	if fcb.nextend eq -1 then begin
		sxaddpar,h,'EXTEND','T','file may contain extensions'
	end else begin    <span class="comments">;PCOUNT, GCOUNT are mandatory for extensions</span>
 		sxaddpar,h,'PCOUNT',0
 		sxaddpar,h,'GCOUNT',1
                if (Axtension eq 'BINTABLE') || $
                   (Axtension eq 'TABLE   ') then begin
                       tfields = sxpar(header,'TFIELDS') > 0              
                       sxaddpar,h,'TFIELDS',tfields
                endif 
		if Aextname ne '' then sxaddpar,h,'EXTNAME',Aextname
		if Aextver gt 0 then sxaddpar,h,'EXTVER',Aextver
		if Aextlevel gt 0 then sxaddpar,h,'EXTLEVEL',Aextlevel
	endelse
        if idltype EQ 12 then $
               sxaddpar,header,'BZERO',32768,'Data is unsigned integer'
        if idltype EQ 13 then $
               sxaddpar,header,'BZERO',2147483648,'Data is unsigned long'
        if idltype GE 12 then sxdelpar,header,'BSCALE'
	if (idltype EQ 4) || (idltype EQ 5) then $
	          sxdelpar,header,['BSCALE','BZERO']
<span class="comments">;</span>
<span class="comments">; delete special keywords from user supplied header</span>
<span class="comments">;</span>
	pcount = sxpar(header,'pcount')
        groups = sxpar(header,'groups')
        sxdelpar,header,['SIMPLE','BITPIX','NAXIS','NAXIS1','NAXIS2','NAXIS3', $
			'NAXIS4','NAXIS5','NAXIS6','NAXIS7','NAXIS8','EXTEND', $
                        'PCOUNT','GCOUNT','GROUPS','TFIELDS']
        if groups then if (pcount gt 0) then for i=1,pcount do $
                        sxdelpar,header,['ptype','pscal','pzero']+strtrim(i,2)
<span class="comments">;</span>
<span class="comments">; combine the two headers</span>
<span class="comments">;</span>
	last = where(strmid(h,0,8) eq 'END     ')
	header = [h[0:last[0]-1],header]

<span class="comments">;</span>
<span class="comments">; convert header to bytes and write</span>
<span class="comments">;</span>
write_header:
	last = where(strmid(header,0,8) eq 'END     ')
	n = last[0] + 1
	byte_header = replicate(32b,80,n)
	for i=0,n-1 do byte_header[0,i] = byte(header[i])
	writeu,fcb.unit,byte_header
<span class="comments">;</span>
<span class="comments">; pad header to 2880 byte records</span>
<span class="comments">;</span>
	npad = 2880 - (80L*n mod 2880)	
	if npad eq 2880 then npad = 0
	if (npad gt 0) then writeu,fcb.unit,replicate(32b,npad)
	nbytes_header =  npad + n*80
	if keyword_set(no_data) then return
<span class="comments">;</span>
<span class="comments">; process data</span>
<span class="comments">;</span>
	if naxis gt 0 then begin
<span class="comments">;</span>
<span class="comments">; convert to IEEE</span>
<span class="comments">;</span>
            unsigned = (idltype EQ 12) || (idltype EQ 13)
            if idltype EQ 12 then newdata = fix(data - 32768)
            if idltype EQ 13 then newdata = long(data - 2147483648)
<span class="comments">;</span>
<span class="comments">; write the data</span>
<span class="comments">;</span>
	    nbytes = long64(N_elements(data)) * (abs(bitpix)/8)
	    npad = 2880 - (nbytes mod 2880)
	    if npad eq 2880 then npad = 0
	    if unsigned then writeu,fcb.unit,newdata else writeu,fcb.unit,data
            if npad gt 0 then begin
                if Axtension EQ 'TABLE   ' then padnum = 32b else padnum = 0b
	        writeu,fcb.unit,replicate(padnum,npad)
            endif
	    nbytes_data = nbytes + npad
	  end else begin
	    nbytes_data = 0
	end
<span class="comments">;</span>
<span class="comments">; done, update file control block</span>
<span class="comments">;</span>
	fcb.nextend = fcb.nextend + 1
	if fcbtype eq 7 then fits_close,fcb else file_or_fcb = fcb
        !err = 1
	return
<span class="comments">;</span>
<span class="comments">; error exit</span>
<span class="comments">;</span>
ioerror:
	message = !error_state.msg
error_exit:
	if fcbtype eq 7 then free_lun,fcb.unit
        !err = -1
	if keyword_set(no_abort) then return
	message,' ERROR: '+message,/CON
	retall
end
</code>
    </div>
  </body>
</html>