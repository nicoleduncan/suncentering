<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:56 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>poly_smooth.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="poly_smooth.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="poly_smooth:source"></a>function poly_smooth, data, width, DEGREE=degree, NLEFT=nl, NRIGHT=nr,  $
                                DERIV_ORDER=order, COEFFICIENTS=filter_coef
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       POLY_SMOOTH  </span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Apply a least-squares (Savitzky-Golay) polynomial smoothing filter</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Reduce noise in 1-D data (e.g. time-series, spectrum) but retain </span>
<span class="comments">;       dynamic range of variations in the data by applying a least squares </span>
<span class="comments">;       smoothing polynomial filter,</span>
<span class="comments">;</span>
<span class="comments">;       Also called the Savitzky-Golay smoothing filter, cf. Numerical</span>
<span class="comments">;       Recipes (Press et al. 1992, Sec.14.8)</span>
<span class="comments">;</span>
<span class="comments">;       The low-pass filter coefficients are computed by effectively</span>
<span class="comments">;       least-squares fitting a polynomial in moving window,</span>
<span class="comments">;       centered on each data point, so the new value will be the</span>
<span class="comments">;       zero-th coefficient of the polynomial. Approximate first derivates</span>
<span class="comments">;       of the data can be computed by using first degree coefficient of</span>
<span class="comments">;       each polynomial, and so on. The filter coefficients for a specified</span>
<span class="comments">;       polynomial degree and window width are computed independent of any</span>
<span class="comments">;       data, and stored in a common block. The filter is then convolved</span>
<span class="comments">;       with the data array to result in smoothed data with reduced noise,</span>
<span class="comments">;       but retaining higher order variations (better than SMOOTH).</span>
<span class="comments">;</span>
<span class="comments">;       This procedure became partially obsolete in IDL V5.4 with the </span>
<span class="comments">;       introduction of the SAVGOL function, which computes the smoothing</span>
<span class="comments">;       coefficients.</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;</span>
<span class="comments">;       spectrum = poly_smooth( data, [ width, DEGREE = , NLEFT = , NRIGHT = </span>
<span class="comments">;                                       DERIV_ORDER = ,COEFF = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       data = 1-D array, such as a spectrum or time-series.</span>
<span class="comments">;</span>
<span class="comments">;       width = total number of data points to use in filter convolution,</span>
<span class="comments">;               (default = 5, using 2 past and 2 future data points),</span>
<span class="comments">;               must be larger than DEGREE of polynomials, and a guideline is to</span>
<span class="comments">;               make WIDTH between 1 and 2 times the FWHM of desired features.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;       DEGREE = degree of polynomials to use in designing the filter</span>
<span class="comments">;               via least squares fits, (default DEGREE = 2)</span>
<span class="comments">;               The higher degrees will preserve sharper features.</span>
<span class="comments">;</span>
<span class="comments">;       NLEFT = # of past data points to use in filter convolution,</span>
<span class="comments">;               excluding current point, overrides width parameter,</span>
<span class="comments">;               so that width = NLEFT + NRIGHT + 1.  (default = NRIGHT)</span>
<span class="comments">;</span>
<span class="comments">;       NRIGHT = # of future data points to use (default = NLEFT).</span>
<span class="comments">;</span>
<span class="comments">;       DERIV_ORDER = order of derivative desired (default = 0, no derivative).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;</span>
<span class="comments">;       COEFFICIENTS = optional output of the filter coefficients applied,</span>
<span class="comments">;               but they are all stored in common block for reuse, anyway.</span>
<span class="comments">; RESULTS:</span>
<span class="comments">;       Function returns the data convolved with polynomial filter coefs.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;       Given a wavelength - flux spectrum (w,f), apply a 31 point quadratic</span>
<span class="comments">;       smoothing filter and plot</span>
<span class="comments">;</span>
<span class="comments">;       IDL> cgplot, w, poly_smooth(f,31) </span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;       common poly_smooth, degc, nlc, nrc, coefs, ordermax</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       As described in Numerical Recipies, 2nd edition sec.14.8, </span>
<span class="comments">;       Savitsky-Golay filter.</span>
<span class="comments">;       Matrix of normal eqs. is formed by starting with small terms</span>
<span class="comments">;       and then adding progressively larger terms (powers).</span>
<span class="comments">;       The filter coefficients of up to derivative ordermax are stored</span>
<span class="comments">;       in common, until the specifications change, then recompute coefficients.</span>
<span class="comments">;       Coefficients are stored in convolution order, zero lag in the middle.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1993.</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Use /EDGE_TRUNCATE keyword to CONVOL  W. Landsman March 2006</span>
<span class="comments">;-</span>
        compile_opt idl2
        On_error,2

        if N_params() LT 1 then begin
                print,'Syntax - smoothdata = ' + $ 
                        'poly_smooth( data , width, [ DEGREE = , NLEFT = '
        print,f='(35x,A)', 'NRIGHT = , DERIV_ORDER =, COEFFICIENT = ]'
        return, -1
        endif

  common poly_smooth, degc, nlc, nrc, coefs, ordermax

        if N_elements( degree ) NE 1 then degree = 2
        if N_elements( order ) NE 1 then order = 0
        order = ( order &lt<span class="comments">; (degree-1) ) > 0</span>

        if N_elements( width ) EQ 1 then begin
                width = fix( width ) > 3
                if (N_elements(nr) NE 1) AND (N_elements(nl) NE 1) then begin
                        nl = width/2
                        nr = width - nl -1
                   endif
           endif

        if N_elements( nr ) NE 1 then begin
                if N_elements( nl ) EQ 1 then  nr = nl  else  nr = 2
           endif

        if N_elements( nl ) NE 1 then begin
                if N_elements( nr ) EQ 1 then  nl = nr  else  nl = 2
           endif

        if N_elements( coefs ) LE 1 then begin
                degc = 0
                nlc = 0
                nrc = 0
                ordermax = 3
           endif

        if (degree NE degc) OR (nl NE nlc) OR (nr NE nrc) OR $
                                                (order GT ordermax) then begin
                degree = degree > 2
                ordermax = ( ordermax &lt<span class="comments">; 3 ) > order</span>
                nj = degree+1
                nl = nl > 0
                nr = nr > 0
                nrl = nr + nl + 1

                if (nrl LE degree) then begin
                        message,"# of points in filter must be > degree",/INFO
                        return, data
                   endif

                ATA = fltarr( nj, nj )
                ATA[0,0] = 1
                iaj = indgen( nj ) # replicate( 1, nj )
                iaj = iaj + transpose( iaj )
                m1_iaj = (-1)^iaj

                for k = 1, nr>nl do begin
                    k_iaj = float( k )^iaj
                    CASE 1 OF
                        ( k LE nr&lt<span class="comments">;nl ): ATA = ATA + ( k_iaj + k_iaj*m1_iaj )</span>
                        ( k LE nr ):    ATA = ATA + k_iaj
                        ( k LE nl ):    ATA = ATA + k_iaj * m1_iaj
                     ENDCASE
                  endfor

                LUdc, ATA, LUindex, /COL

                Bmat = fltarr( nj, degree&lt<span class="comments">;(ordermax+1) )</span>
                B = fltarr( nj )

                for m = 0, (degree-1)&lt<span class="comments">;ordermax do begin</span>
                        B[*] = 0
                        B[m] = 1
                        Bmat[0,m] = LUsol(ATA, LUindex, B, /COL)
                  endfor

                kvec = [0]
                if (nl GT 0) then kvec = [ rotate( -indgen( nl )-1, 2 ), kvec ]
                if (nr GT 0) then kvec = [ kvec, indgen( nr )+1 ]
                Kmat = fltarr( nrl, nj )
                Kmat[*,0] = 1
                for m = 1,degree do Kmat[0,m] = Kmat[*,m-1] * kvec

                coefs = Kmat # Bmat
                degc = degree
                nlc = nl
                nrc = nr

                if (nr GT nl) then begin
                        sc = size( coefs )
                        coefs = [  fltarr( nr-nl, sc[2] ),  coefs ]
                  endif else if (nl GT nr) then begin
                        sc = size( coefs )
                        coefs = [ coefs,  fltarr( nl-nr, sc[2] )  ]
                   endif
           endif

        filter_coef = coefs[*,order]

return, convol( data, filter_coef, /EDGE_TRUNCATE )
end
</code>
    </div>
  </body>
</html>