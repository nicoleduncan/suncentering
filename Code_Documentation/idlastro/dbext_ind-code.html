<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:26 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbext_ind.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbext_ind.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbext_ind:source"></a>pro dbext_ind,list,item,dbno,values
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       DBEXT_IND</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       routine to read a indexed item values from index file</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:  </span>
<span class="comments">;       dbext_ind,list,item,dbno,values</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       list - list of entry numbers to extract values for</span>
<span class="comments">;               (if it is a scalar, values for all entries are extracted)</span>
<span class="comments">;       item - item to extract</span>
<span class="comments">;       dbno - number of the opened data base</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;       values - vector of values returned as function value</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       version 1  D. Lindler  Feb 88</span>
<span class="comments">;       Faster processing of string values    W. Landsman   April, 1992</span>
<span class="comments">;       William Thompson, GSFC/CDS (ARC), 30 May 1994</span>
<span class="comments">;               Added support for external (IEEE) data format</span>
<span class="comments">;       Allow multiple valued (nonstring) index items W. Landsman  November 2000      </span>
<span class="comments">;       Use 64bit integer index for large databases W. Landsman  February 2001</span>
<span class="comments">;       Fix sublisting of multiple valued index items W. Landsman  March 2001</span>
<span class="comments">;       Check whether any supplied entries are valid W. Landsman Jan 2009</span>
<span class="comments">;-</span>
On_error,2
compile_opt idl2
<span class="comments">;</span>
if N_params() LT 4 then begin
     print,'Syntax - DBEXT_IND, list, item, dbno, values'
     return
endif

<span class="comments">; Determine first and last block to extract</span>
<span class="comments">;</span>
s=size(list) & ndim=s[0]
if (ndim GT 0) then if (list[0] EQ -1) then ndim=0
zeros = 0                               <span class="comments">;flag if zero's present in list</span>
if ndim EQ 0 then begin
        minl = 1
        maxl = db_info('ENTRIES',dbno)
    end else begin
        minl = min(list)
        if minl EQ 0 then begin <span class="comments">;any zero values in list</span>
                zeros = 1
                nonzero = where(list GT 0, Ngood, comp=bad)
		if Ngood EQ 0 then message,'ERROR - No valid entry numbers supplied'
                minl = min(list[nonzero])
        endif
        maxl=max(list)
 end
<span class="comments">;</span>
<span class="comments">; get item info</span>
<span class="comments">;</span>
db_item,item,it,ivalnum,dtype,sbyte,numvals,nbytes
nbytes = nbytes[0]
if N_elements(it) GT 1 then $
        message,'ERROR - Only one item can be extracted by dbext_ind'

itnum = db_item_info('itemnumber',it[0])  <span class="comments">;item number in this dbno</span>
<span class="comments">;</span>
<span class="comments">; determine if indexed</span>
<span class="comments">;</span>
index_type = db_item_info('index',it[0])
if index_type EQ 0  then $
        message,'ERROR - Requested item is not indexed'

if index_type EQ 3 then $
        message,'ERROR - Unsorted values of item not recorded in index file'
<span class="comments">;</span>
<span class="comments">; get unit number of index file and read header info</span>
<span class="comments">;</span>
 unit=db_info('UNIT_DBX',dbno)
 external = db_info('EXTERNAL',dbno)     <span class="comments">;External (IEEE) data format?</span>
 p=assoc(unit,lonarr(2))
 h=p[0]
 if external then ieee_to_host,h
 p = assoc(unit,lonarr(7,h[0]),8)
 header = p[0]
 if external then ieee_to_host,header
 items = header[0,*]
 pos = where(items EQ itnum, Nindex) & pos=pos[0]
 if Nindex LT 1 then $
        message,'Item not indexed, DBNO may be wrong'

<span class="comments">;</span>
<span class="comments">; find starting location to read</span>
<span class="comments">;</span>
if index_type NE 4 then sblock=header[4,pos] else sblock=header[6,pos]
<span class="comments">;</span>
numvals = numvals[0]
sbyte = 512LL*sblock
sbyte = sbyte+(minl-1L)*nbytes*numvals
nv = (maxl-minl+1L) <span class="comments">;number of bytes to extract</span>
<span class="comments">;            </span>
<span class="comments">; create mapped i/o variable</span>
<span class="comments">;</span>
dtype = dtype[0]

if dtype NE 7 then begin
   if numvals GT 1 then $ 
   p = assoc(unit, make_array(size=[2,numvals,nv,dtype,0],/NOZERO), sbyte ) else $
   p = assoc(unit, make_array(size=[1,nv,dtype,0],/NOZERO), sbyte ) 
 endif else  p = assoc(unit, make_array(size=[2,nbytes,nv,1,0],/NOZERO), sbyte )

<span class="comments">;</span>
<span class="comments">; read values from file</span>
<span class="comments">; Modified, April 92 to delay conversion to string until the last step WBL</span>
<span class="comments">;</span>
values = p[0]
if external then ieee_to_host,values
<span class="comments">;</span>
<span class="comments">; if subset list specified perform extraction</span>
<span class="comments">;</span>

if ndim NE 0 then begin
        if zeros then begin                     <span class="comments">;zero out bad values</span>
                if dtype NE 7 then begin        <span class="comments">;not a string?</span>
                        if numvals EQ 1 then begin
                             values = values[(list-minl)>0 ]
                             values[bad]=0
                        endif else begin 
                             values = values[*,(list-minl)>0 ]
                             values[*,bad] = intarr(numvals)
                        endelse
                   end else begin                       <span class="comments">;string </span>
                        values = values[*, (list-minl)>0 ]
                        if N_elements(bad) EQ 1 then bad = bad[0]
                        values[0,bad] = replicate( 32b, nbytes )
                   endelse
           end else begin
                  if (dtype EQ 7) or (numvals GT 1) then  $
                            values = values[*, list-minl] $
                      else  values = values[ list-minl ]
        end
end
if dtype EQ 7 then values = string(values)
return
end
</code>
    </div>
  </body>
</html>