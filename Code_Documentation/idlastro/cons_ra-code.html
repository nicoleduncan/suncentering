<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:22 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cons_ra.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cons_ra.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION CONS_RA,RA,Y,ASTR, DELTA      <span class="comments">;Find line of constant RA</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       CONS_RA</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Obtain the X and Y coordinates of a line of constant right ascension</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Return a set of X pixel values given an image with astrometry, </span>
<span class="comments">;       and either</span>
<span class="comments">;       (1) a set of Y pixel values, and a scalar right ascension (or </span>
<span class="comments">;           longitude), or</span>
<span class="comments">;       (2) a set of right ascension values, and a scalar Y value.</span>
<span class="comments">;</span>
<span class="comments">;       In usage (1), CONS_RA can be used to determine the (X,Y) values</span>
<span class="comments">;       of a line of constant right ascension.  In usage (2), CONS_RA can</span>
<span class="comments">;       used to determine the X positions of specified RA values, along a</span>
<span class="comments">;       line of constant Y.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       X = CONS_RA( RA, Y, ASTR, [ DEC] )</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:         </span>
<span class="comments">;       RA -  Right Ascension value in DEGREES (0 &lt; RA &lt; 360.).  If Y is a</span>
<span class="comments">;               vector, then RA must be a scalar</span>
<span class="comments">;       Y -   Specified Y pixel value(s) for line of constant right ascension</span>
<span class="comments">;               If RA is a vector, then Y must be a scalar</span>
<span class="comments">;       ASTR - Astrometry structure as extracted from a FITS header by the </span>
<span class="comments">;               procedure EXTAST</span>
<span class="comments">; OUTPUTS</span>
<span class="comments">;       X   - Computed set of X pixel values.   The number of elements of X</span>
<span class="comments">;               is the maximum of the number of elements of RA and Y.</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       DEC - Computed set of declinations (in DEGREES) for X,Y, coordinates</span>
<span class="comments">; NOTES:</span>
<span class="comments">;       The algorithm (and notation) is based on AIPS Memo 27 by Eric Greisen,</span>
<span class="comments">;       with modifications for a coordinate description (CD) matrix as </span>
<span class="comments">;       described in Paper II of Calabretta & Greisen (2002, A&A, 395, 1077).</span>
<span class="comments">;       These documents are available from </span>
<span class="comments">;       http://www.cv.nrao.edu/fits/documents/wcs/wcs.html</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       Implemented only for the TANgent, SIN and CARtesian projections </span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written, Wayne Landsman  STX Co.        April, 1988</span>
<span class="comments">;       Algorithm adapted from AIPS memo No. 27 by Eric Greisen</span>
<span class="comments">;       New astrometry structure</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Added SIN projection    W. Landsman   January 2000</span>
<span class="comments">;       Fix possible sign error introduced Jan. 2000   W. Landsman  May 2000</span>
<span class="comments">;       Work for the CARee' projection W. Landsman   May 2003</span>
<span class="comments">;       For TAN projection ensure angles between -90 and 90 W. Landsman Jan 2008</span>
<span class="comments">;-</span>
  On_error,2
  compile_opt idl2

  if ( N_params() LT 3 ) then begin
        print,'Syntax - X = CONS_RA( RA, Y, ASTR, [ Dec ])'
        return, 0
  endif

  radeg = 180.0/!DPI
  n = N_elements(y)
  nra = N_elements(ra)
  crpix = astr.crpix - 1.
  crval = astr.crval/RADEG
  cdelt = astr.cdelt
  cdelta = [ [ cdelt[0], 0.],[0., cdelt[1] ] ]
  cd = astr.cd/RADEG
  cdel0 = cos( crval[1] )  &    sdel0 = sin( crval[1] )
  delra = ra/RADEG - crval[0]
  cdelra = cos( delra )    &    sdelra = sin( delra )

  ctype = strupcase( strmid(astr.ctype[0], 5,3))
  case ctype of 
  
  'TAN': begin
 
  cdi = invert( cdelta # cd )     <span class="comments">;Greisen uses invert of CD matrix</span>
  yy = y - ( crpix[1])    <span class="comments">;New coordinate origin, Unit pixel offset in CRPIX</span>
  delta = atan((sdel0*cdelra*cdi[1,1] - sin(delra)*cdi[1,0] + yy*cdelra*cdel0) $
              / (cdel0*cdi[1,1] - yy*sdel0))
	      
  end
  'SIN': begin

  A = -cd[0,0]*cdelt[0] 
  B = -cd[0,1]*cdelt[0] 
  C =  cd[1,0]*cdelt[1]
  D =  cd[1,1]*cdelt[1] 
  yy = (y - crpix[1])*(b*c - a*d)   <span class="comments">;New coordinate origin</span>
  aa = cdel0*d
  bb = sdel0*cdelra*d + sdelra*b
  denom = sqrt(aa^2 + bb^2)
  delta = atan(bb/aa)  + asin(yy/denom)

  end

  'CAR': begin
  A = -cd[0,0]*cdelt[0] 
  B = -cd[0,1]*cdelt[0] 
  C =  cd[1,0]*cdelt[1]
  D =  cd[1,1]*cdelt[1] 
  delta = (y - crpix[1])*(b*c - a*d)  +crval[1]  <span class="comments">;New coordinate origin</span>
  if (N_elements(delta) EQ 1) and (Nra GT 1)  then $
           delta = replicate(delta[0],Nra)

  end

  ELSE: message,'ERROR - Program only works for TAN and SIN projections'
  endcase

  delta = delta*RADEG
  if (Nra EQ 1) and (n GT 1) then $
  ad2xy, replicate(ra,n), delta, astr, x else $
  ad2xy, ra, delta, astr, x

  return, x
  end
</code>
    </div>
  </body>
</html>