<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:27 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dbwrt.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dbwrt.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="dbwrt:source"></a>pro dbwrt,entry,index,append,noconvert=noconvert
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	DBWRT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	procedure to update or add a new entry to a data base</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	dbwrt, entry, [ index, append, /NoConvert ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	entry - entry record to be updated or added if first</span>
<span class="comments">;		item (entry number=0)</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;	index - optional integer flag,  if set to non zero then index</span>
<span class="comments">;		file is  updated. (default=0, do not update index file)</span>
<span class="comments">;		(Updating the index file is time-consuming, and should</span>
<span class="comments">;		normally be done after all changes have been made.</span>
<span class="comments">;	append - optional integer flag, if set to non-zero the record</span>
<span class="comments">;		is appended as a new entry, regardless of what the</span>
<span class="comments">;		entry number in the record is.  The entry number will</span>
<span class="comments">;		be reset to the next entry number in the file.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	data base file is updated.                    </span>
<span class="comments">;	If index is non-zero then the index file is updated.</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;	NoConvert - If set then don't convert to host format with an external</span>
<span class="comments">;		database.    Useful when the calling program decides that</span>
<span class="comments">;		conversion isn't needed (i.e. on a big-endian machine), or </span>
<span class="comments">;		takes care of the conversion itself.</span>
<span class="comments">; OPERATIONAL NOTES:</span>
<span class="comments">;	!PRIV must be greater than 1 to execute</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;	version 2  D. Lindler  Feb. 1988 (new db format)</span>
<span class="comments">;	converted to IDL Version 2.  M. Greason, STX, June 1990.</span>
<span class="comments">;	William Thompson, GSFC/CDS (ARC), 28 May 1994</span>
<span class="comments">;		Added support for external (IEEE) representation.</span>
<span class="comments">;	Faster handling of byte swapping  W. L.  August 2010</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------</span>
 COMMON db_com,qdb,qitems,qdbrec

 if N_params() LT 2 then index=0
 if N_params() LT 3 then append=0

<span class="comments">; Byte swapping is needed if database is in external format, and user is on </span>
<span class="comments">; a little endian machine, and /noconvert is not st </span>

 bswap = (qdb[119] eq 1) && ~keyword_set(noconvert) && ~is_ieee_big()

 
<span class="comments">; get some info on the data base</span>

 update = db_info( 'UPDATE' )   
 if update EQ 0 then message,'Database opened for read only'

 len = db_info( 'LENGTH', 0 )	<span class="comments">;record length</span>
 qnentry = db_info( 'ENTRIES', 0 )

<span class="comments">; determine if entry is correct size</span>

 s = size(entry)
 if s[0] NE 1 then message,'Entry must be a 1-dimensional array'

 if s[1] NE len then $
	message,'Entry not the proper length of '+strtrim(len,2)+' bytes'

 if s[2] NE 1 then $
        message,'Entry vector (first parameter) must be a byte array'

<span class="comments">; get entry number</span>

 enum = append ? 0 : dbxval(entry,3,1,0,4)
 if ( enum GT qnentry ) || ( enum LT 0 ) then $
    message,'Invalid entry number of '+strtrim(enum,2)+' (first value in entry)'

 if enum EQ 0 then begin		<span class="comments">;add new entry</span>
	qnentry = qnentry+1
	qdb[84] = byte(qnentry,0,4)
	enum = qnentry
	dbxput,long(enum),entry,3,0,4
        newentry = 1b
 endif else newentry =0b
 if bswap then begin
      tmp = entry 
      db_ent2ext, tmp
      qdbrec[enum]=tmp
  endif else qdbrec[enum] =  entry
 
<span class="comments">; update index file if necessary</span>

 if index EQ 0 then return
 nitems = db_info( 'ITEMS', 0 )                    <span class="comments">;Total number of items</span>
 indextype = db_item_info( 'INDEX', indgen(nitems))  <span class="comments">;Which ones are indexed?</span>
 indexed = where(indextype,nindex)
 if nindex LE 0 then return            <span class="comments">;If no indexed items, then we are done</span>
 indextype = indextype[indexed]        <span class="comments">;Now contains only indexed items</span>
 unit = db_info( 'UNIT_DBX', 0 )
 reclong = assoc(unit,lonarr(2),0)
 h = reclong[0]
 maxentries = h[1]
 if bswap then swap_endian_inplace, maxentries
 if newentry then $
   if (maxentries LT qnentry) then begin   <span class="comments">;Enough room for new indexed items?</span>
     print,'DBWRT -- maxentries too small'
     print,'Rerun DBCREATE with maxentries in .dbd file at least ',qnentry
     return
 endif

 reclong = assoc(unit,lonarr(7,nindex),8)
 header = reclong[0]
 if bswap then swap_endian_inplace,header
 hitem = header[0,*]            <span class="comments">;indexed item number</span>
 hblock = header[3,*]
 sblock = header[4,*]  & sblock = sblock[*]
 iblock = header[5,*]  & iblock = iblock[*]
 ublock = header[6,*]  & ublock = ublock[*]
 db_item, indexed, itnum, ivalnum, idltype, startbyte, numvals, nbytes
 pos = where(hitem EQ itnum ) 
 for i = 0, nindex-1 do begin
     v = dbxval( entry, idltype[i], numvals[i], startbyte[i], nbytes[i] )
     sbyte = nbytes[i] * (enum-1)  
     isort = (indextype[i] EQ 3) || (indextype[i] EQ 4)

     datarec = dbindex_blk(unit, sblock[pos[i]], 512, sbyte, idltype[i])
     reclong = assoc(unit,lonarr(1),(iblock[pos]*512L))

     case indextype[i] of

	1:  datarec[0] = bswap ? swap_endian(v) : v
	    

	2:  begin
	      datarec[0] = bswap ? swap_endian(v) : v
	      if (qnentry mod 512) EQ 0 then begin        <span class="comments">;Update</span>
	      nb = qnentry/512
              hbyte = nbytes[i] * nb
              datarec = dbindex_blk(unit,hblock[pos[i]],512,hbyte,idltype[i])
	      datarec[0] = bswap ? swap_endian(v) : v
              endif
      end
	3: begin                          <span class="comments">;SORT</span>

	   datarec = dbindex_blk(unit,sblock[pos[i]],512,0,idltype[i])
	   values = datarec[0:(qnentry-1)]                  <span class="comments">;Read in old values</span>
	   if bswap then swap_endian_inplace, values
	   reclong = dbindex_blk(unit,iblock[pos[i]],512,0,3)
	   sub = reclong[0:(qnentry-1)]                     <span class="comments">;Read in old indices</span>
	   if bswap then swap_endian_inplace, sub
	   if enum lt qnentry then begin       		<span class="comments">;Change an old value?</span>
	       sort_index = where(sub EQ enum)          <span class="comments">;Which value to change</span>
	       sort_index = sort_index[0]
	       if values[sort_index] EQ v $      <span class="comments">;Value remains the same so</span>
                   then isort =0  $          <span class="comments">;don't bother sorting again</span>
	        else values[sort_index] = v            <span class="comments">;Update with new value</span>
	   endif else values = [values,v]            <span class="comments">;Append a new value</span>
	   end

	4: begin                          <span class="comments">;SORT/INDEX</span>

	   values = datarec[qnentry-1,ublock*512]    <span class="comments">;Update index record</span>
	   if bswap then swap_endian_inplace, values
	   if enum lt qnentry then begin
	        if values[enum-1] EQ v then isort = 0 else values[enum-1] = v 
 	   endif else  values = [values,v]
	   datarec = dbindex_blk(unit,ublock[pos[i]],512,sbyte,idltype[i])
	   datarec[0] = bswap ? swap_endian(v) : v
	   end

	else:

	endcase

 if isort then begin                  <span class="comments">;resort values?</span>
	sub = bsort(values)
	values = values[sub]
	nb = (qnentry + 511)/512
	ind = indgen(nb)*512L
	sval = values[ind]
<span class="comments">;</span>
	datarec = dbindex_blk(unit, hblock[pos[i]], 512, 0, idltype[i])
	datarec[0] = bswap ? swap_endian(sval) : sval
<span class="comments">;</span>
	datarec = dbindex_blk(unit, sblock[pos[i]], 512, 0, idltype[i])
	datarec[0] = bswap ?swap_endian(values) : values
<span class="comments">;</span>
	reclong = dbindex_blk(unit, iblock[pos[i]], 512, 0, 3)
	reclong[0] = bswap ?swap_endian(sub+1) : sub+1
 endif

 endfor

 return
 end
</code>
    </div>
  </body>
</html>