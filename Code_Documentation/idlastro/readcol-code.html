<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:58:00 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>readcol.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="readcol.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="readcol:source"></a>pro readcol,name,v1,V2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15, $
            v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,v30,$
            v31,v32,v33,v34,v35,v36,v37,v38,v39,v40, COMMENT = comment, $
            FORMAT = fmt, DEBUG=debug, SILENT=silent, SKIPLINE = skipline, $
            NUMLINE = numline, DELIMITER = delimiter, NAN = NaN, $
            PRESERVE_NULL = preserve_null, COUNT=ngood, NLINES=nlines, $
            STRINGSKIP = skipstart, QUICK = quick, COMPRESS = compress
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       READCOL</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Read a free-format ASCII file with columns of data into IDL vectors </span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Lines of data not meeting the specified format (e.g. comments) are </span>
<span class="comments">;       ignored.  By default, columns may be separated by commas or spaces.</span>
<span class="comments">;</span>
<span class="comments">;       Use READFMT to read a fixed-format ASCII file.   Use RDFLOAT for</span>
<span class="comments">;       much faster I/O (but less flexibility).    Use FORPRINT to write </span>
<span class="comments">;       columns of data (inverse of READCOL).   </span>
<span class="comments">;</span>
<span class="comments">;       If you sure that all lines meet the specified format (excluding </span>
<span class="comments">;       commented and SKIPed lines) then the speed for reading large files</span>
<span class="comments">;       can be significantly improved by setting the /QUICK keyword.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       READCOL, name, v1, [ v2, v3, v4, v5, ...  v40 , COMMENT=, /NAN</span>
<span class="comments">;           DELIMITER= ,FORMAT = , /DEBUG ,  /SILENT , SKIPLINE = , NUMLINE = </span>
<span class="comments">;           COUNT =, STRINGSKIP= </span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       NAME - Name of ASCII data file, scalar string.  </span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       FORMAT - scalar string containing a letter specifying an IDL type</span>
<span class="comments">;               for each column of data to be read.  Allowed letters are </span>
<span class="comments">;               A - string data, B - byte, D - double precision, F- floating </span>
<span class="comments">;               point, I - short integer, L - longword, LL - 64 bit integer, </span>
<span class="comments">;               U - unsigned short integer, UL - unsigned long integer </span>
<span class="comments">;               Z - longword hexadecimal, and X - skip a column.</span>
<span class="comments">;</span>
<span class="comments">;               Columns without a specified format are assumed to be floating </span>
<span class="comments">;               point.  Examples of valid values of FMT are</span>
<span class="comments">;</span>
<span class="comments">;       'A,B,I'        ;First column to read as a character string, then </span>
<span class="comments">;                       1 column of byte data, 1 column integer data</span>
<span class="comments">;       'L,L,L,L'       ;Four columns will be read as longword arrays.</span>
<span class="comments">;       ' '             ;All columns are floating point</span>
<span class="comments">;</span>
<span class="comments">;       If a FORMAT keyword string is not supplied, then all columns are </span>
<span class="comments">;       assumed to be floating point.</span>
<span class="comments">;</span>
<span class="comments">;       /SILENT - Normally, READCOL will display each line that it skips over.</span>
<span class="comments">;               If SILENT is set and non-zero then these messages will be </span>
<span class="comments">;               suppressed.</span>
<span class="comments">;       /DEBUG - If this keyword is non-zero, then additional information is</span>
<span class="comments">;                printed as READCOL attempts to read and interpret the file.</span>
<span class="comments">;       COMMENT - single character specifying comment character.   Any line </span>
<span class="comments">;                beginning with this character will be skipped.   Default is</span>
<span class="comments">;                no comment lines.</span>
<span class="comments">;       /COMPRESS - If set, then the file is assumed to be gzip compressed.</span>
<span class="comments">;                There is no automatic recognition of compressed files</span>
<span class="comments">;                by extension type.</span>
<span class="comments">;       DELIMITER - Character(s) specifying delimiter used to separate </span>
<span class="comments">;                columns.   Usually a single character but, e.g. delimiter=':,'</span>
<span class="comments">;                specifies that either a colon or comma as a delimiter. </span>
<span class="comments">;                Set DELIM = string(9b) to read tab separated data</span>
<span class="comments">;                The default delimiter is either a comma or a blank.</span>
<span class="comments">;       /NAN - if set, then an empty field will be read into a floating or </span>
<span class="comments">;                double numeric variable as NaN; by default an empty field is </span>
<span class="comments">;                converted to 0.0.</span>
<span class="comments">;       /PRESERVE_NULL - If set, then spaces are considered to be valid fields,</span>
<span class="comments">;                useful if the columns contain missing data.   Note that between</span>
<span class="comments">;                April and December 2006, /PRESERVE_NULL was the default.</span>
<span class="comments">;       /QUICK -  If set, then READCOL does not check that each individual line</span>
<span class="comments">;                matches the supplied format.     This makes READCOL less </span>
<span class="comments">;                flexible but can provide a significant speed improvement when</span>
<span class="comments">;                reading large files.                       </span>
<span class="comments">;       SKIPLINE - Scalar specifying number of lines to skip at the top of file</span>
<span class="comments">;               before reading.   Default is to start at the first line.</span>
<span class="comments">;       NUMLINE - Scalar specifying number of lines in the file to read.  </span>
<span class="comments">;               Default is to read the entire file</span>
<span class="comments">;       STRINGSKIP - will skip all lines that begin with the specified string.</span>
<span class="comments">;               (Unlike COMMENT this can be more than 1 character.) Useful to </span>
<span class="comments">;               skip over comment lines.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       V1,V2,V3,...V40 - IDL vectors to contain columns of data.</span>
<span class="comments">;               Up to 40 columns may be read.  The type of the output vectors</span>
<span class="comments">;               are as specified by FORMAT.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORDS:</span>
<span class="comments">;       COUNT - integer giving the number of valid lines actually read</span>
<span class="comments">;       NLINES - integer giving the total number of lines in the file </span>
<span class="comments">;                (as returned by FILE_LINES)</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;       Each row in a file position.dat contains a star name and 6 columns</span>
<span class="comments">;       of data giving an RA and Dec in sexagesimal format.   Read into IDL </span>
<span class="comments">;       variables.   (NOTE: The star names must not include the delimiter </span>
<span class="comments">;       as a part of the name, no spaces or commas as default.)</span>
<span class="comments">;</span>
<span class="comments">;       IDL> FMT = 'A,I,I,F,I,I,F'</span>
<span class="comments">;       IDL> READCOL,'position.dat',F=FMT,name,hr,min,sec,deg,dmin,dsec  </span>
<span class="comments">;</span>
<span class="comments">;       The HR,MIN,DEG, and DMIN variables will be integer vectors.</span>
<span class="comments">;</span>
<span class="comments">;       Alternatively, all except the first column could be specified as</span>
<span class="comments">;       floating point.</span>
<span class="comments">;</span>
<span class="comments">;       IDL> READCOL,'position.dat',F='A',name,hr,min,sec,deg,dmin,dsec </span>
<span class="comments">;</span>
<span class="comments">;       To read just the variables HR,MIN,SEC</span>
<span class="comments">;       IDL> READCOL,'position.dat',F='X,I,I,F',HR,MIN,SEC</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       This procedure is designed for generality and not for speed.</span>
<span class="comments">;       If a large ASCII file is to be read repeatedly, it may be worth</span>
<span class="comments">;       writing a specialized reader.</span>
<span class="comments">;</span>
<span class="comments">;       Columns to be read as strings must not contain the delimiter character</span>
<span class="comments">;       (i.e. commas or spaces by default).   Either change the default </span>
<span class="comments">;       delimiter with the DELIMITER keyword, or use READFMT to read such files.</span>
<span class="comments">;</span>
<span class="comments">;       Numeric values are converted to specified format.  For example,</span>
<span class="comments">;       the value 0.13 read with an 'I' format will be converted to 0.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED</span>
<span class="comments">;       GETTOK(), STRNUMBER()</span>
<span class="comments">;       The version of STRNUMBER() must be after August 2006.</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written         W. Landsman                 November, 1988</span>
<span class="comments">;       Modified             J. Bloch                   June, 1991</span>
<span class="comments">;       (Fixed problem with over allocation of logical units.)</span>
<span class="comments">;       Added SKIPLINE and NUMLINE keywords  W. Landsman    March 92</span>
<span class="comments">;       Read a maximum of 25 cols.  Joan Isensee, Hughes STX Corp., 15-SEP-93.</span>
<span class="comments">;       Call NUMLINES() function W. Landsman          Feb. 1996</span>
<span class="comments">;       Added DELIMITER keyword  W. Landsman          Nov. 1999</span>
<span class="comments">;       Fix indexing typos (i for k) that mysteriously appeared W. L. Mar. 2000</span>
<span class="comments">;       Hexadecimal support added.  MRG, RITSS, 15 March 2000.</span>
<span class="comments">;       Default is comma or space delimiters as advertised   W.L. July 2001</span>
<span class="comments">;       Faster algorithm, use STRSPLIT if V5.3 or later  W.L.  May 2002</span>
<span class="comments">;       Accept null strings separated by delimiter ,e.g. ',,,'</span>
<span class="comments">;       Use SCOPE_VARFETCH instead of EXECUTE() for >V6.1  W.L. Jun 2005</span>
<span class="comments">;       Added compile_opt idl2   W. L.  July 2005</span>
<span class="comments">;       Added the NaN keyword   W. L      August 2006</span>
<span class="comments">;       Added /PRESERVE_NULL keyword  W.L.  January 2007</span>
<span class="comments">;       Assume since V5.6 (FILE_LINES available ) W.L. Nov 2007</span>
<span class="comments">;       Added COUNT output keyword  W.L.  Aug 2008</span>
<span class="comments">;       Added NLINES output keyword W.L.   Nov 2008</span>
<span class="comments">;       Added SKIPSTART keyword  Stephane Beland January 2008</span>
<span class="comments">;       Renamed SKIPSTART to STRINGSKIP to keep meaning of SKIP W.L. Feb 2008</span>
<span class="comments">;       Assume since V6.1, SCOPE_VARFETCH available W.L. July 2009</span>
<span class="comments">;       Read up to 40 columns W.L. Aug 2009</span>
<span class="comments">;       Use pointers instead of SCOPE_VARFETCH. Fixes bug with</span>
<span class="comments">;       IDL Workbench and runs 20% faster Douglas J. Marshall/W.L. Nov 2009</span>
<span class="comments">;       Recognize  LL, UL, and ULL data types, don't use 'val' output from </span>
<span class="comments">;           STRNUMBER()   W.L.  Feb 2010</span>
<span class="comments">;       Graceful return even if no valid lines are present D. Sahnow April 2010</span>
<span class="comments">;       Ability to read tab separated data WL April 2010</span>
<span class="comments">;       Free memory used by pointers  WL  July 2010</span>
<span class="comments">;       Added /QUICK keyword  WL  Sep 2010</span>
<span class="comments">;       Accept normal FORTRAN formats (e.g. F5.1) P. Noterdaeme/W.L Jan 2011</span>
<span class="comments">;       Add COMPRESS keyword, IDL 6 notation W. Landsman/J. Bailin   Feb 2011</span>
<span class="comments">;       Allow filename to be 1 element array W.Landsman/S.Antonille Apr 2011</span>
<span class="comments">;       Feb 2010 change caused errors when reading blanks as numbers. </span>
<span class="comments">;                          W.L. July 2012</span>
<span class="comments">;-</span>
  On_error,2                    <span class="comments">;Return to caller</span>
  compile_opt idl2

  if N_params() lt 2 then begin
    print,'Syntax - READCOL, name, v1, [ v2, v3,...v40, /NAN, DELIMITER=,/QUICK'
    print,'        FORMAT= ,/SILENT  ,SKIPLINE =, NUMLINE = , /DEBUG, COUNT=]'
     return
  endif

<span class="comments">; Get number of lines in file</span>

  ngood = 0L                 <span class="comments">;Number of good lines</span>
  nlines = FILE_LINES( name, COMPRESS=compress )
  

  if keyword_set(DEBUG) then $
     message,'File ' + name+' contains ' + strtrim(nlines,2) + ' lines',/INF

  if ~keyword_set( SKIPLINE ) then skipline = 0
  nlines = nlines - skipline
  if nlines LE 0 then begin
     message,'ERROR - File ' + name+' contains no data',/CON
     return
  endif     
  if keyword_set( NUMLINE) then nlines = numline &lt<span class="comments">; nlines</span>

  if ~keyword_set( SKIPSTART ) then begin
     skipstart_flg=0 
  endif else begin
     skipstart_flg=1
     nskipstart = strlen(skipstart)
  endelse

  ncol = N_params() - 1         <span class="comments">;Number of columns of data expected</span>
  vv = 'v' + strtrim( indgen(ncol)+1, 2)
  nskip = 0

  if N_elements(fmt) GT 0 then begin <span class="comments">;FORMAT string supplied?</span>

     if size(fmt,/tname) NE 'STRING' then $
        message,'ERROR - Supplied FORMAT keyword must be a scalar string'
<span class="comments">;   Remove blanks from format string</span>
     frmt = strupcase(strcompress(fmt,/REMOVE))   
     remchar, frmt, '('         <span class="comments">;Remove parenthesis from format</span>
     remchar, frmt, ')'           

<span class="comments">;   Determine number of columns to skip ('X' format)</span>
     pos = strpos(frmt, 'X', 0)

     while pos NE -1 do begin
        pos = strpos( frmt, 'X', pos+1)
        nskip++
     endwhile

  endif else begin              <span class="comments">;Read everything as floating point</span>

     frmt = 'F'
     if ncol GT 1 then for i = 1,ncol-1 do frmt = frmt + ',F'
     if ~keyword_set( SILENT ) then message, $
        'Format keyword not supplied - All columns assumed floating point',/INF

  endelse

  nfmt = ncol + nskip
  idltype = intarr(nfmt)
  bigarr = ptrarr(ncol)

<span class="comments">; Create output arrays according to specified formats</span>

  k = 0L                        <span class="comments">;Loop over output columns</span>
  hex = bytarr(nfmt)
  for i = 0L, nfmt-1 do begin

     fmt1 = gettok( frmt, ',' )
     if fmt1 EQ '' then fmt1 = 'F' <span class="comments">;Default is F format</span>
     case strmid(fmt1,0,1) of 
        'A':  idltype[i] = 7          
        'D':  idltype[i] = 5
        'F':  idltype[i] = 4
        'I':  idltype[i] = 2
        'B':  idltype[i] = 1
        'L':  idltype[i] = strmid(fmt1,0,2) EQ 'LL' ? 14 : 3 
	'U':  if strmid(fmt1,1,1) NE 'L' then idltype[i] = 12 else $
	      idltype[i] = strmid(fmt1,2,1) EQ 'L' ? 15 : 13
        'Z':  begin 
           idltype[i] = 3       <span class="comments">;Hexadecimal</span>
           hex[i] = 1b
        end
        'X':  idltype[i] = 0    <span class="comments">;IDL type of 0 ==> to skip column</span>
        ELSE:  message,'Illegal format ' + fmt1 + ' in field ' + strtrim(i,2)
     endcase

<span class="comments">; Define output arrays</span>

     if idltype[i] GT 0 then begin
        bigarr[k] = ptr_new(make_array(nlines,type=idltype[i]))
        k++
     endif

  endfor
  goodcol = where(idltype)
  idltype = idltype[goodcol]
  check_numeric = (idltype NE 7)
  openr, lun, name, /get_lun, compress=compress

  temp = ' '
  skip_lun,lun,skipline, /lines

  if ~keyword_set(delimiter) then delimiter = ' ,'
  
  for j = 0L, nlines[0]-1 do begin
     readf, lun, temp
     if skipstart_flg then begin
                                <span class="comments">; requested to skip lines starting with specifc string</span>
        if strmid(temp,0,nskipstart) eq skipstart then begin
           ngood--
           goto, BADLINE
        endif
     endif

     if strlen(temp) LT ncol then begin <span class="comments">;Need at least 1 chr per output line</span>
        ngood--
        if ~keyword_set(SILENT) then $
           message,'Skipping Line ' + strtrim(skipline+j+1,2),/INF
        goto, BADLINE 
     endif

     temp = strtrim(temp,1)     <span class="comments">;Remove leading spaces</span>
     if keyword_set(comment) then if strmid(temp,0,1) EQ comment then begin
        ngood--
        if keyword_set(DEBUG) then $
           message,'Skipping Comment Line ' + strtrim(skipline+j+1,2),/INF
        goto, BADLINE 
     endif

       var = delimiter EQ string(9b) ?  $
        strsplit(  temp,delimiter,/extract, preserve=preserve_null) $
       :strsplit(strcompress(temp) ,delimiter,/extract, preserve=preserve_null) 
     if N_elements(var) LT nfmt then begin 
        if ~keyword_set(SILENT) then $ 
           message,'Skipping Line ' + strtrim(skipline+j+1,2),/INF 
        ngood--            
        goto, BADLINE           <span class="comments">;Enough columns?</span>
     endif
     var = var[goodcol]

     k = 0
     if keyword_set(quick) then $      <span class="comments">;Don't check for valid numeric values</span>
     
         for i = 0L,ncol-1 do (*bigarr[i])[ngood] = var[i]   $
    
    else begin 
     
     
     for i = 0L,ncol-1 do begin
        
        if check_numeric[i] then begin                      <span class="comments">;Check for valid numeric data</span>
           tst = strnumber(var[i],val,hex=hex[i],NAN=nan)   <span class="comments">;Valid number?</span>
           if ~tst  then begin                           <span class="comments">;If not, skip this line</span>
              if ~keyword_set(SILENT) then $ 
                 message,'Skipping Line ' + strtrim(skipline+j+1,2),/INF 
              ngood--
              goto, BADLINE 
           endif
        endif 
	if strlen(strtrim(var[i],2)) Eq 0 then begin
	   if keyword_set(NAN) then (*bigarr[k])[ngood] = !VALUES.F_NAN else $
	                            (*bigarr[k])[ngood] = 0 
        endif else (*bigarr[k])[ngood] = var[i]
        k++

     endfor

endelse
     BADLINE:  ngood++

  endfor

  free_lun,lun
  if ngood EQ 0 then begin 
     message,'ERROR - No valid lines found for specified format',/INFORM
     return
  endif

  if ~keyword_set(SILENT) then $
     message,strtrim(ngood,2) + ' valid lines read', /INFORM  

<span class="comments">; Compress arrays to match actual number of valid lines</span>
  if ngood lt Nlines then for i=0,ncol-1 do $
     (*bigarr[i]) = (*bigarr[i])[0:ngood-1]

<span class="comments">; Use SCOPE_VARFETCH to place into output variables..</span>
   for i=0,ncol-1 do $
         (SCOPE_VARFETCH(vv[i],LEVEL=0)) = reform(*bigarr[i])
    ptr_free, bigarr	 
  return
end
</code>
    </div>
  </body>
</html>