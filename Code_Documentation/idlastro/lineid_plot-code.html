<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:45 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>lineid_plot.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="lineid_plot.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="lineid_plot:source"></a>pro lineid_plot,wave,flux,wline,text1,text2, extend=extend, $
	lcharthick = lcharthick,lcharsize=lcharsize,window=window, $
	 _EXTRA = extra
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	LINEID_PLOT</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Plot spectrum with specified line identifications annotated at the</span>
<span class="comments">;	 top of the plot.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	lineid_plot, wave, flux, wline, text1, [ text2, </span>
<span class="comments">;			LCHARSIZE=, LCHARTHICK=, EXTEND =, ...plotting keywords]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	wave - wavelength vector for the plot</span>
<span class="comments">;	flux - flux vector</span>
<span class="comments">;	wline - wavelength vector of line identifications.  (only the lines </span>
<span class="comments">;		between	the plot limits will be used)</span>
<span class="comments">;	text1 - string array of text to be used to annotate each line</span>
<span class="comments">;	text2 - (OPTIONAL) second string array of text to be used for</span>
<span class="comments">;		line annotation.  Since the text is written with</span>
<span class="comments">;		proportional spaced characters, TEXT2 can be used if</span>
<span class="comments">;		you want two sets of annotation to be alinged:</span>
<span class="comments">;</span>
<span class="comments">;		eg:	Cr IV  1390.009</span>
<span class="comments">;			Fe V   1390.049</span>
<span class="comments">;			Ni IV  1390.184</span>
<span class="comments">;			    instead of</span>
<span class="comments">;			Cr IV 1390.009</span>
<span class="comments">;			Fe V 1390.049</span>
<span class="comments">;			Ni IV 1390.184</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD INPUTS:</span>
<span class="comments">;	EXTEND - specifies that the annotated lines should have a dotted line </span>
<span class="comments">;		extended to the spectrum to indicate the line position.  </span>
<span class="comments">;		EXTEND can be a scalar (applies to all lines) or a vector with</span>
<span class="comments">;		a different value for each line.  The value of EXTEND gives </span>
<span class="comments">;		the line IDL plot line thickness for the dotted lines.</span>
<span class="comments">;		If EXTEND is a vector each dotted line can have a different </span>
<span class="comments">;		thickness.  A value of 0 indicates that no dotted line is to </span>
<span class="comments">;		be drawn. (default = scalar 0)</span>
<span class="comments">;	LCHARSIZE - the character size of the annotation for each line.</span>
<span class="comments">;		If can be a vector so that different lines are annotated with </span>
<span class="comments">;		different size characters.  LCHARSIZE can be used to make </span>
<span class="comments">;		stronger lines have a larger annotation. (default = scalar 1.0).</span>
<span class="comments">;	LCHARTHICK = the character thickness of the annotation for each line. </span>
<span class="comments">;		It can be a vector so that different lines are annotated with </span>
<span class="comments">;		characters of varying thickness.   LCHARTHICK can be used to </span>
<span class="comments">;		make stronger lines have a bolder annotation. </span>
<span class="comments">;		(default = !p.charthick)</span>
<span class="comments">;</span>
<span class="comments">;	LINEID_PLOT uses the _EXTRA facility to allow the use of any cgPLOT</span>
<span class="comments">;	keywords (e.g. AXISCOLOR, LINESTYLE, CHARSIZE) to be passed to the </span>
<span class="comments">;       plot.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;	Program uses SET_VIEWPORT to set the !P.POSITION parameter to allow</span>
<span class="comments">;	room for the annotation.   This system variable can be reset to the </span>
<span class="comments">;	default value by setting !P.POSTION=0 or typing SET_VIEWPORT with no </span>
<span class="comments">;	parameters</span>
<span class="comments">;</span>
<span class="comments">; OPERATIONAL NOTES:</span>
<span class="comments">;	Once the program has completed, You can use OPLOT to draw additional</span>
<span class="comments">;	plots on the display. </span>
<span class="comments">;</span>
<span class="comments">;	If your annotated characters are not being rotated properly,</span>
<span class="comments">;	try setting !P.FONT to a non zero value.</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;	Annotate some interstellar lines between 1240 and 1270 A.</span>
<span class="comments">;</span>
<span class="comments">;	IDL> w = 1240+ indgen(300)*0.1    ;Make a wavelength vector</span>
<span class="comments">;	IDL> f = randomn(seed,300)        ;Random flux vector</span>
<span class="comments">;	IDL> id = ['N V','Si II','Si II','Si II']   ;Line IDs</span>
<span class="comments">;	IDL> wl = [1242.80,1260.42,1264.74,1265.00] ;Line positions</span>
<span class="comments">;	IDL> lineid_plot,w,f,wl,id,wl,/ext</span>
<span class="comments">;</span>
<span class="comments">;	Note that LINEID_PLOT is smart enough not to overlap the annotation</span>
<span class="comments">;	for the two closely spaced lines at 1264.74 and 1265.00	</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;	version 1  D. Lindler Jan, 1992</span>
<span class="comments">;	Sept 27, 1993  DJL  fixed bug in /extend option</span>
<span class="comments">;	Apr 19, 1994 DJL corrected bug in sorting of charthick (cthick)</span>
<span class="comments">;	Sep 1996, W. Landsman,  added _EXTRA keyword, changed keyword names</span>
<span class="comments">;		CHARTHICK==>LCHARTHICK, CHARSIZE==>LCHARSIZE</span>
<span class="comments">;       Work with !P.MULTI   W. Landsman   December 2003</span>
<span class="comments">;       Use Coyote graphics routines  W. Landsman February 2011</span>
<span class="comments">;-</span>
<span class="comments">;----------------------------------------------------------------------------</span>
	On_error,2

	if n_params() lt 4 then begin
	   print,'Syntax - LINEID_PLOT, wave, flux, wline, text1 [,text2, '
	   print,'       LCHARTHICK=, EXTEND=, LCHARSIZE= ...plotting keywords]'
	   return
	end
<span class="comments">;</span>
<span class="comments">; initialization</span>
<span class="comments">;</span>

	setdefaultvalue, lcharsize, 1
	n = n_elements(wline)
	setdefaultvalue,text2,strarr(n)
	if n_elements(lcharsize) eq 1 then csize = replicate(lcharsize,n) $
				     else csize = lcharsize
	setdefaultvalue, extend, 0
	if n_elements(extend) eq 1 then ethick = replicate(extend,n) $
				   else ethick = extend
	if n_elements(lcharthick) eq 0 then cthick = !p.charthick $
				      else cthick = lcharthick
	if n_elements(cthick) eq 1 then cthick = replicate(cthick,n)
<span class="comments">;</span>
<span class="comments">; First make a plot without any data to get the region size.    Then use</span>
<span class="comments">; the position keyword to assign a plot area that allows room for the </span>
<span class="comments">; line annotation and plot the data</span>
<span class="comments">;       </span>
        plot,wave,flux,xsty=4,ysty=4,/nodata,/noerase
        x0 = !X.region[0]
        y0 = !Y.region[0]
        xsize = !X.region[1] - x0
        ysize = !Y.region[1] - y0
        pos = [x0+xsize*0.13,y0+ysize*0.1, x0+xsize*0.95, y0+ysize*0.65]
	cgplot,wave,flux,_EXTRA=extra,pos = pos, Window=window       
        if keyword_set(window) then cgcontrol,execute=0
<span class="comments">;</span>
<span class="comments">; get data ranges</span>
<span class="comments">;</span>
	xmin = !x.crange[0]
	xmax = !x.crange[1]
	ymin = !y.crange[0]
	ymax = !y.crange[1]
	xrange = xmax-xmin
	yrange = ymax-ymin
<span class="comments">;</span>
<span class="comments">; find lines within x range and sort them</span>
<span class="comments">;</span>
	good = where((wline gt xmin) and (wline lt xmax),nlines)
	if nlines lt 1 then return
	wl = wline[good]
	csize = csize[good] & cthick = cthick[good] & ethick = ethick[good]
	txt1 = text1[good] & txt2 = text2[good] 

	sub = sort(wl)
	wl = wl[sub] & csize = csize[sub] & ethick = ethick[sub]
	cthick = cthick[sub] 
	txt1 = txt1[sub] & txt2 = txt2[sub] 
	maxids = 65/(total(csize)/nlines)   <span class="comments">;maximum number of identifications</span>
	if nlines gt maxids then begin
		print,'Too many lines to mark'
		return
	endif

<span class="comments">;</span>
<span class="comments">; determine character height in wavelength units</span>
<span class="comments">;</span>
	char_height = abs(xrange) / 65 * csize
<span class="comments">;</span>
<span class="comments">; adjust wavelengths of where to print the line ids</span>
<span class="comments">;</span>
	wlp = wl		<span class="comments">;wavelength to print text</span>
<span class="comments">;</span>
<span class="comments">; test to see if we can just equally space the annotated lines</span>
<span class="comments">;</span>
	if (nlines gt maxids*0.85) and (n_elements(charsize) eq 1) then begin
		wlp = findgen(nlines) * (xrange/(nlines-1)) + xmin
		goto,print_text
	end
<span class="comments">;</span>
<span class="comments">; iterate to find room to annotate each line</span>
<span class="comments">;</span>
	changed = 1		<span class="comments">;flag saying we moved a wlp position</span>
	niter = 0
	factor = 0.35		<span class="comments">;size of adjustments in text position</span>
	while changed do begin	<span class="comments">;iterate</span>
	    changed = 0
	    for i=0,nlines-1 do begin
<span class="comments">;</span>
<span class="comments">; determine the difference of the annotation from the lines on the</span>
<span class="comments">; left and right of it and the required separation</span>
<span class="comments">;</span>
		if i gt 0 then begin
			diff1 = wlp[i]-wlp[i-1]
			separation1 = (char_height[i]+char_height[i-1])/2.0
		    end else begin
			diff1 = wlp[i] - xmin + char_height[i]*1.01
			separation1 = char_height[i]
		end

		if i lt (nlines-1) then begin
			diff2 = wlp[i+1] - wlp[i]
			separation2 = (char_height[i]+char_height[i+1])/2.0
		    end else begin
			diff2 = xmax + char_height[i]*1.01 - wlp[i]
			separation2 = char_height[i]
		end
<span class="comments">;</span>
<span class="comments">; determine if line annotation should be moved</span>
<span class="comments">;</span>
		if (diff1 lt separation1) or (diff2 lt separation2) then begin
		    if wlp[i] eq xmin then diff1 = 0
		    if wlp[i] eq xmax then diff2 = 0
		    if diff2 gt diff1 then $
				wlp[i] = (wlp[i] + separation2*factor) &lt<span class="comments">; xmax $</span>
			   else wlp[i] = (wlp[i] - separation1*factor) > xmin
		    changed = 1
		endif

	    end

	    if niter eq 300 then $		<span class="comments">; fine adjustment for </span>
			factor = factor/3	<span class="comments">; crowded field</span>
			

	    if niter eq 1000 then changed=0	<span class="comments">; stop at 1000 iterations</span>
	    niter = niter + 1

	endwhile

<span class="comments">;</span>
<span class="comments">; print line id's</span>
<span class="comments">;</span>
print_text:
	maxcsize = max(csize)
	start_arrow = ymax + yrange/60
	bend1 = ymax + yrange/30
	bend2 = ymax + (yrange/30)*3
	stop_arrow = ymax + (yrange/30)*4
	start_text1 = stop_arrow + yrange/50*maxcsize
	start_text2 = start_text1 +  $
			max(strlen(strtrim(txt1,1)))*yrange/50*maxcsize
	start_text3 = start_text2 +  $
			max(strlen(strtrim(txt2,1)))*yrange/50*maxcsize

	for i=0,nlines-1 do begin
		cgplots,[wl[i],wl[i],wlp[i],wlp[i]], ADDCMD=window, $
		      [start_arrow,bend1,bend2,stop_arrow]
		cgtext,wlp[i] + char_height[i]/2, start_text1, txt1[i], $
		    orientation = 90, size=csize[i], charthick = cthick[i],$
		    window = window
		cgtext,wlp[i] + char_height[i]/2, start_text2, txt2[i], $
		  orientation = 90, size=csize[i], charthick = cthick[i],$
		  window= window
	endfor
<span class="comments">;</span>
<span class="comments">; extend selected lines down to the spectrum</span>
<span class="comments">;</span>
	good = where((ethick gt 0) and (wl gt xmin) and (wl lt xmax),n)
	if n lt 1 then return
	ww = wl[good]
	ethick = ethick[good]
	linterp,wave,flux,ww,ff
	ymax = !y.crange[1]
	ymin = !y.crange[0]
	offset = (ymax-ymin)/20.0
	for i=0,n-1 do $
	   cgplots,[ww[i],ww[i]],[(ff[i]+offset)&lt<span class="comments">;ymax>ymin,ymax], $</span>
				line=2,thick = ethick[i],ADDCMD=window
	if keyword_set(window) then cgcontrol,execute=1			

return
end
</code>
    </div>
  </body>
</html>