<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:59 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>read_key.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="read_key.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION read_key, wait
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	READ_KEY</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	To read a keystroke and return its ASCII equivalent</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;	If an ESCAPE sequence was produced and  the sequence is</span>
<span class="comments">;	recognized (e.g. up arrow), then a code is returned.</span>
<span class="comments">;</span>
<span class="comments">;       This functionality is mostly made obsolete by the addition of the</span>
<span class="comments">;       ESCAPE and KEY_NAME keywords to GET_KBRD in IDL V6.2</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	key = READ_KEY(Wait)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	Wait  -  The wait flag.  If non-zero, execution is halted until a</span>
<span class="comments">;	         key is struck.  If zero, execution returns immediately and</span>
<span class="comments">;	         a zero is returned if there was no keystroke waiting in the</span>
<span class="comments">;	         keyboard buffer.  If not specified, zero is assumed.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT:</span>
<span class="comments">;	Returned - The key struck.  The ASCII code for non-escape sequences.</span>
<span class="comments">;	           Escape sequence equivalents:</span>
<span class="comments">;			Up Arrow     --  128</span>
<span class="comments">;			Down Arrow   --  130</span>
<span class="comments">;			Left Arrow   --  129</span>
<span class="comments">;			Right Arrow  --  131</span>
<span class="comments">;			Else         --    0</span>
<span class="comments">;</span>
<span class="comments">;	The return value is a byte value.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;	Written by Michael R. Greason, STX, 22 June 1990.</span>
<span class="comments">;	Rewritten for a SUN workstation.  MRG, STX, 23 August 1990.</span>
<span class="comments">;	Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
<span class="comments">;			Check the input parameter.</span>
<span class="comments">;</span>
IF (n_params(0) LT 1) THEN wait = 0
<span class="comments">;</span>
<span class="comments">;			Get the keystroke.</span>
<span class="comments">;</span>
key = byte(get_kbrd(wait))
key = key[0]
<span class="comments">;</span>
<span class="comments">;			If it is an ESCAPE, get the rest of it and </span>
<span class="comments">;			then decode it.</span>
<span class="comments">;</span>
IF (key EQ 27B) THEN BEGIN
	st = bytarr(10)
<span class="comments">;</span>
<span class="comments">;				Get the rest of the escape sequence.</span>
<span class="comments">;</span>
	i = 0
	REPEAT BEGIN
		key = byte(get_kbrd(0))
		st[i] = key[0]
		i = i + 1
	ENDREP UNTIL (st[i-1] EQ 0B)
<span class="comments">;</span>
<span class="comments">;				Decode the escape sequence.</span>
<span class="comments">;</span>
	CASE string(st) OF
		'[A' : key = 128B
		'[B' : key = 130B
		'[D' : key = 129B
		'[C' : key = 131B
		ELSE : BEGIN
				 IF (i GT 1) THEN key = 0B ELSE key = 27B
		       END
	ENDCASE
ENDIF
<span class="comments">;</span>
<span class="comments">;			If it is a CSI, get the rest of it and </span>
<span class="comments">;			then decode it.</span>
<span class="comments">;</span>
IF (key EQ '9B'XB) THEN BEGIN
	st = bytarr(10)
<span class="comments">;</span>
<span class="comments">;				Get the rest of the sequence.</span>
<span class="comments">;</span>
	i = 0
	REPEAT BEGIN
		key = byte(get_kbrd(0))
		st[i] = key[0]
		i = i + 1
	ENDREP UNTIL (st[i-1] EQ 0B)
<span class="comments">;</span>
<span class="comments">;				Decode the sequence.</span>
<span class="comments">;</span>
	CASE string(st) OF
		'A' : key = 128B
		'B' : key = 130B
		'D' : key = 129B
		'C' : key = 131B
		ELSE : BEGIN
				 IF (i GT 1) THEN key = 0B ELSE key = '9B'XB
		       END
	ENDCASE
ENDIF
<span class="comments">;</span>
<span class="comments">;			If it is a SS3, get the rest of it and </span>
<span class="comments">;			then decode it.</span>
<span class="comments">;</span>
IF (key EQ '8F'XB) THEN BEGIN
	st = bytarr(10)
<span class="comments">;</span>
<span class="comments">;				Get the rest of the sequence.</span>
<span class="comments">;</span>
	i = 0
	REPEAT BEGIN
		key = byte(get_kbrd(0))
		st[i] = key[0]
		i = i + 1
	ENDREP UNTIL (st[i-1] EQ 0B)
<span class="comments">;</span>
<span class="comments">;				Decode the sequence.</span>
<span class="comments">;</span>
	CASE string(st) OF
		ELSE : BEGIN
				 IF (i GT 1) THEN key = 0B ELSE key = '8F'XB
		       END
	ENDCASE
ENDIF
<span class="comments">;</span>
RETURN, key
END
</code>
    </div>
  </body>
</html>