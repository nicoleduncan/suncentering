<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:46 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>match.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="match.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="match:source"></a>pro match, a, b, suba, subb, COUNT = count, SORT = sort, epsilon=epsilon
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MATCH</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Routine to match values in two vectors.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       match, a, b, suba, subb, [ COUNT =, /SORT, EPSILON =  ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       a,b - two vectors to match elements, numeric or string data types</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       suba - subscripts of elements in vector a with a match</span>
<span class="comments">;               in vector b</span>
<span class="comments">;       subb - subscripts of the positions of the elements in</span>
<span class="comments">;               vector b with matchs in vector a.</span>
<span class="comments">;</span>
<span class="comments">;       suba and subb are ordered such that a[suba] equals b[subb]</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       /SORT - By default, MATCH uses two different algorithm: (1) the</span>
<span class="comments">;               /REVERSE_INDICES keyword to HISTOGRAM is used for integer data,</span>
<span class="comments">;               while (2) a sorting algorithm is used for non-integer data.  The</span>
<span class="comments">;               histogram algorithm is usually faster, except when the input</span>
<span class="comments">;               vectors are sparse and contain very large numbers, possibly</span>
<span class="comments">;               causing memory problems.   Use the /SORT keyword to always use</span>
<span class="comments">;               the sort algorithm.</span>
<span class="comments">;       epsilon - if values are within epsilon, they are considered equal. Used only</span>
<span class="comments">;               only for non-integer matching.  Note that input vectors should </span>
<span class="comments">;               be unique to within epsilon to provide one-to-one mapping.. </span>
<span class="comments">;               Default=0.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL KEYWORD OUTPUT:</span>
<span class="comments">;       COUNT - set to the number of matches, integer scalar</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;       The obsolete system variable !ERR is set to the number of matches;</span>
<span class="comments">;       however, the use !ERR is deprecated in favor of the COUNT keyword</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;       The vectors a and b should not have duplicate values within them.</span>
<span class="comments">;       You can use rem_dup function to remove duplicate values</span>
<span class="comments">;       in a vector</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       If a = [3,5,7,9,11]   & b = [5,6,7,8,9,10]</span>
<span class="comments">;       then</span>
<span class="comments">;               IDL> match, a, b, suba, subb, COUNT = count</span>
<span class="comments">;</span>
<span class="comments">;       will give suba = [1,2,3], subb = [0,2,4],  COUNT = 3</span>
<span class="comments">;       and       a[suba] = b[subb] = [5,7,9]</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; METHOD:</span>
<span class="comments">;       For non-integer data types, the two input vectors are combined and</span>
<span class="comments">;       sorted and the consecutive equal elements are identified.   For integer</span>
<span class="comments">;       data types, the /REVERSE_INDICES keyword to HISTOGRAM of each array</span>
<span class="comments">;       is used to identify where the two arrays have elements in common.</span>
<span class="comments">; HISTORY:</span>
<span class="comments">;       D. Lindler  Mar. 1986.</span>
<span class="comments">;       Fixed "indgen" call for very large arrays   W. Landsman  Sep 1991</span>
<span class="comments">;       Added COUNT keyword    W. Landsman   Sep. 1992</span>
<span class="comments">;       Fixed case where single element array supplied   W. Landsman Aug 95</span>
<span class="comments">;       Use a HISTOGRAM algorithm for integer vector inputs for improved</span>
<span class="comments">;             performance                W. Landsman         March 2000</span>
<span class="comments">;       Work again for strings           W. Landsman         April 2000</span>
<span class="comments">;       Use size(/type)                  W. Landsman         December 2002</span>
<span class="comments">;       Work for scalar integer input    W. Landsman         June 2003</span>
<span class="comments">;       Assume since V5.4, use COMPLEMENT to WHERE() W. Landsman Apr 2006</span>
<span class="comments">;       Added epsilon keyword            Kim Tolbert         March 14, 2008</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
 On_error,2
 compile_opt idl2

 if N_elements(epsilon) EQ 0 then epsilon = 0

 if N_params() LT 3 then begin
     print,'Syntax - match, a, b, suba, subb, [ COUNT =, EPSILON=, /SORT]'
     print,'    a,b -- input vectors for which to match elements'
     print,'    suba,subb -- output subscript vectors of matched elements'
     return
 endif

 da = size(a,/type) & db =size(b,/type)
 if keyword_set(sort) then hist = 0b else $
 hist = (( da LE 3 ) or (da GE 12)) and  ((db LE 3) or (db GE 12 ))

 if not hist then begin           <span class="comments">;Non-integer calculation</span>

 na = N_elements(a)              <span class="comments">;number of elements in a</span>
 nb = N_elements(b)             <span class="comments">;number of elements in b</span>

<span class="comments">; Check for a single element array</span>

 if (na EQ 1) or (nb EQ 1) then begin
        if (nb GT 1) then begin
                subb = where(b EQ a[0], nw)
                if (nw GT 0) then suba = replicate(0,nw) else suba = [-1]
        endif else begin
                suba = where(a EQ b[0], nw)
                if (nw GT 0) then subb = replicate(0,nw) else subb = [-1]
        endelse
        count = nw
        return
 endif

 c = [ a, b ]                   <span class="comments">;combined list of a and b</span>
 ind = [ lindgen(na), lindgen(nb) ]       <span class="comments">;combined list of indices</span>
 vec = [ bytarr(na), replicate(1b,nb) ]  <span class="comments">;flag of which vector in  combined</span>
                                         <span class="comments">;list   0 - a   1 - b</span>

<span class="comments">; sort combined list</span>

 sub = sort(c)
 c = c[sub]
 ind = ind[sub]
 vec = vec[sub]

<span class="comments">; find duplicates in sorted combined list</span>

 n = na + nb                            <span class="comments">;total elements in c</span>
 if epsilon eq 0. then $
    firstdup = where( (c EQ shift(c,-1)) and (vec NE shift(vec,-1)), Count ) $
 else $
    firstdup = where( (abs(c - shift(c,-1)) lt epsilon) and (vec NE shift(vec,-1)), Count )

 if Count EQ 0 then begin               <span class="comments">;any found?</span>
        suba = lonarr(1)-1
        subb = lonarr(1)-1
        return
 end

 dup = lonarr( Count*2 )                     <span class="comments">;both duplicate values</span>
 even = lindgen( N_elements(firstdup))*2     <span class="comments">;Changed to LINDGEN 6-Sep-1991</span>
 dup[even] = firstdup
 dup[even+1] = firstdup+1
 ind = ind[dup]                         <span class="comments">;indices of duplicates</span>
 vec = vec[dup]                         <span class="comments">;vector id of duplicates</span>
 subb = ind[ where( vec, complement = vzero) ]             <span class="comments">;b subscripts</span>
 suba = ind[ vzero]

 endif else begin             <span class="comments">;Integer calculation using histogram.</span>

 minab = min(a, MAX=maxa) > min(b, MAX=maxb) <span class="comments">;Only need intersection of ranges</span>
 maxab = maxa &lt<span class="comments">; maxb</span>

<span class="comments">;If either set is empty, or their ranges don't intersect:</span>
<span class="comments">;  result = NULL (which is denoted by integer = -1)</span>
  !ERR = -1
  suba = -1
  subb = -1
  COUNT = 0L
 if (maxab lt minab) or (maxab lt 0) then return

 ha = histogram([a], MIN=minab, MAX=maxab, reverse_indices=reva)
 hb = histogram([b], MIN=minab, MAX=maxab, reverse_indices=revb)

 r = where((ha ne 0) and (hb ne 0), count)
 if count gt 0 then begin
  suba = reva[reva[r]]
  subb = revb[revb[r]]
 endif
 endelse

 return

 end
</code>
    </div>
  </body>
</html>