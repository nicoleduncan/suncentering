<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:37 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>fxhmodify.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="fxhmodify.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO FXHMODIFY, FILENAME, NAME, VALUE, COMMENT, BEFORE=BEFORE,   $
               AFTER=AFTER, FORMAT=FORMAT, EXTENSION=EXTENSION, ERRMSG=ERRMSG,$
               NOGROW=NOGROW
<span class="comments">;+</span>
<span class="comments">; NAME: </span>
<span class="comments">;       FXHMODIFY</span>
<span class="comments">; PURPOSE     : </span>
<span class="comments">;       Modify a FITS header in a file on disk.</span>
<span class="comments">; Explanation : </span>
<span class="comments">;       Opens a FITS file, and adds or modifies a parameter in the FITS header.</span>
<span class="comments">;       Can be used for either the main header, or for an extension header. </span>
<span class="comments">;       The modification is performed directly on the disk file.</span>
<span class="comments">; Use         : </span>
<span class="comments">;       FXHMODIFY, FILENAME, NAME, VALUE, COMMENT</span>
<span class="comments">; Inputs      : </span>
<span class="comments">;       FILENAME = String containing the name of the file to be read.</span>
<span class="comments">;</span>
<span class="comments">;       NAME    = Name of parameter, scalar string  If NAME is already in the </span>
<span class="comments">;                 header the value and possibly comment fields are modified. </span>
<span class="comments">;                 Otherwise a new record is added to the header.  If NAME is </span>
<span class="comments">;                 equal to either "COMMENT" or "HISTORY" then the value will be </span>
<span class="comments">;                 added to the record without replacement.  In this case the </span>
<span class="comments">;                 comment parameter is ignored.</span>
<span class="comments">;</span>
<span class="comments">;       VALUE   = Value for parameter.  The value expression must be of the</span>
<span class="comments">;                 correct type, e.g. integer, floating or string.  String</span>
<span class="comments">;                 values of 'T' or 'F' are considered logical values.</span>
<span class="comments">;</span>
<span class="comments">; Opt. Inputs : </span>
<span class="comments">;       COMMENT = String field.  The '/' is added by this routine.  Added</span>
<span class="comments">;                 starting in position 31.  If not supplied, or set equal to ''</span>
<span class="comments">;                 (the null string), then any previous comment field in the</span>
<span class="comments">;                 header for that keyword is retained (when found).</span>
<span class="comments">; Outputs     : </span>
<span class="comments">;       None.</span>
<span class="comments">; Opt. Outputs: </span>
<span class="comments">;       None.</span>
<span class="comments">; Keywords    : </span>
<span class="comments">;       EXTENSION = Either the number of the FITS extension, starting with the</span>
<span class="comments">;                   first extension after the primary data unit being one; or a</span>
<span class="comments">;                   character string containing the value of EXTNAME to search</span>
<span class="comments">;                   for.  If not passed, then the primary FITS header is</span>
<span class="comments">;                   modified.           </span>
<span class="comments">;</span>
<span class="comments">;       BEFORE  = Keyword string name.  The parameter will be placed before the</span>
<span class="comments">;                 location of this keyword.  For example, if BEFORE='HISTORY'</span>
<span class="comments">;                 then the parameter will be placed before the first history</span>
<span class="comments">;                 location.  This applies only when adding a new keyword;</span>
<span class="comments">;                 keywords already in the header are kept in the same position.</span>
<span class="comments">;</span>
<span class="comments">;       AFTER   = Same as BEFORE, but the parameter will be placed after the</span>
<span class="comments">;                 location of this keyword.  This keyword takes precedence over</span>
<span class="comments">;                 BEFORE.</span>
<span class="comments">;</span>
<span class="comments">;       FORMAT  = Specifies FORTRAN-like format for parameter, e.g. "F7.3".  A</span>
<span class="comments">;                 scalar string should be used.  For complex numbers the format</span>
<span class="comments">;                 should be defined so that it can be applied separately to the</span>
<span class="comments">;                 real and imaginary parts.</span>
<span class="comments">;       ERRMSG  = If defined and passed, then any error messages will be</span>
<span class="comments">;                 returned to the user in this parameter rather than</span>
<span class="comments">;                 depending on the MESSAGE routine in IDL.  If no errors are</span>
<span class="comments">;                 encountered, then a null string is returned.  In order to</span>
<span class="comments">;                 use this feature, ERRMSG must be defined first, e.g.</span>
<span class="comments">;</span>
<span class="comments">;                       ERRMSG = ''</span>
<span class="comments">;                       FXHMODIFY, ERRMSG=ERRMSG, ...</span>
<span class="comments">;                       IF ERRMSG NE '' THEN ...</span>
<span class="comments">;</span>
<span class="comments">; Calls       : </span>
<span class="comments">;       FXHREAD, FXPAR, FXADDPAR, BLKSHIFT</span>
<span class="comments">; Restrictions: </span>
<span class="comments">;       This routine can not be used to modify any of the keywords that control</span>
<span class="comments">;       the structure of the FITS file, e.g. BITPIX, NAXIS, PCOUNT, etc.  Doing</span>
<span class="comments">;       so could corrupt the readability of the FITS file.</span>
<span class="comments">; Example:</span>
<span class="comments">;       Modify the name 'OBJECT' keyword in the primary FITS header of a FITS </span>
<span class="comments">;       file 'spec98.ccd' to contain the value 'test domeflat'</span>
<span class="comments">;</span>
<span class="comments">;       IDL> fxhmodify, 'spec98.ccd', 'OBJECT', 'test domeflat'</span>
<span class="comments">;</span>
<span class="comments">; Side effects: </span>
<span class="comments">;       If adding a record to the FITS header would increase the</span>
<span class="comments">;       number of 2880 byte records stored on disk, then the file is</span>
<span class="comments">;       enlarged before modification, unless the NOGROW keyword is passed.</span>
<span class="comments">;  </span>
<span class="comments">; Category    : </span>
<span class="comments">;       Data Handling, I/O, FITS, Generic.</span>
<span class="comments">; Prev. Hist. : </span>
<span class="comments">;       None.</span>
<span class="comments">; Written     : </span>
<span class="comments">;       William Thompson, GSFC, 3 March 1994.</span>
<span class="comments">; Modified    : </span>
<span class="comments">;       Version 1, William Thompson, GSFC, 3 March 1994.</span>
<span class="comments">;       Version 2, William Thompson, GSFC, 31 May 1994</span>
<span class="comments">;               Added ERRMSG keyword.</span>
<span class="comments">;       Version 3, William Thompson, GSFC, 23 June 1994</span>
<span class="comments">;               Modified so that ERRMSG is not touched if not defined.</span>
<span class="comments">;      Version 3.1 Wayne Landsman GSFC   17 March 2006</span>
<span class="comments">;               Fix problem in BLKSHIFT call if primary header  extended</span>
<span class="comments">;       Version 3.2 W. Landsman 14 November 204 </span>
<span class="comments">;               Allow for need for 64bit number of bytes</span>
<span class="comments">;; Version     :</span>
<span class="comments">;       Version 3.2, 14 Nov 2007</span>
<span class="comments">;-</span>
<span class="comments">;</span>
        COMPILE_OPT IDL2
        ON_ERROR, 2
<span class="comments">;</span>
<span class="comments">;  Check the number of parameters.</span>
<span class="comments">;</span>
        IF N_PARAMS() LT 3 THEN BEGIN
                MESSAGE = $     <span class="comments">;Need at least 3 parameters</span>
                    'Syntax:  FXHMODIFY, FILENAME, NAME, VALUE [, COMMENT ]'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  If passed, check the type of the EXTENSION parameter.</span>
<span class="comments">;</span>
        IF N_ELEMENTS(EXTENSION) GT 1 THEN BEGIN
                MESSAGE = 'EXTENSION must be a scalar'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        END ELSE IF N_ELEMENTS(EXTENSION) EQ 1 THEN BEGIN
                SZ = SIZE(EXTENSION)
                ETYPE = SZ[SZ[0]+1]
                IF ETYPE EQ 8 THEN BEGIN
                        MESSAGE = 'EXTENSION must not be a structure'
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                ENDIF
<span class="comments">;</span>
<span class="comments">;  If EXTENSION is of type string, then search for the proper extension by</span>
<span class="comments">;  name.  Otherwise, search by number.</span>
<span class="comments">;</span>
                IF ETYPE EQ 7 THEN BEGIN
                        S_EXTENSION = STRTRIM(STRUPCASE(EXTENSION),2)
                END ELSE BEGIN
                        I_EXTENSION = FIX(EXTENSION)
                        IF I_EXTENSION LT 1 THEN BEGIN
                                MESSAGE = 'EXTENSION must be greater than zero'
                                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                        ERRMSG = MESSAGE
                                        RETURN
                                END ELSE MESSAGE, MESSAGE
                        ENDIF
                ENDELSE
        ENDIF
<span class="comments">;</span>
<span class="comments">;  Get the UNIT number, and open the file.</span>
<span class="comments">;</span>
        OPENU, UNIT, FILENAME, /BLOCK, /GET_LUN
<span class="comments">;</span>
<span class="comments">;  Read in the primary FITS header.</span>
<span class="comments">;</span>
        FXHREAD,UNIT,HEADER,STATUS
        IF STATUS NE 0 THEN BEGIN
                FREE_LUN,UNIT
                MESSAGE = 'Unable to read FITS header'
                IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                        ERRMSG = MESSAGE
                        RETURN
                END ELSE MESSAGE, MESSAGE
        ENDIF
        MHEAD0 = 0
        I_EXT = 0
<span class="comments">;</span>
<span class="comments">;  If the EXTENSION parameter was passed, then look for the requested</span>
<span class="comments">;  extension.</span>
<span class="comments">;</span>
        IF N_ELEMENTS(EXTENSION) EQ 1 THEN BEGIN
<span class="comments">;</span>
<span class="comments">;  Make sure that the file does contain extensions.</span>
<span class="comments">;</span>
                IF NOT FXPAR(HEADER,'EXTEND') THEN BEGIN
                        FREE_LUN, UNIT
                        MESSAGE = 'File ' + FILENAME +  $
                                ' does not contain extensions'
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                ENDIF
<span class="comments">;</span>
<span class="comments">;  Get the number of bytes taken up by the data.</span>
<span class="comments">;</span>
NEXT_EXT:
                BITPIX = FXPAR(HEADER,'BITPIX')
                NAXIS  = FXPAR(HEADER,'NAXIS')
                GCOUNT = FXPAR(HEADER,'GCOUNT')
                IF GCOUNT EQ 0 THEN GCOUNT = 1
                PCOUNT = FXPAR(HEADER,'PCOUNT')
                IF NAXIS GT 0 THEN BEGIN 
                        DIMS = FXPAR(HEADER,'NAXIS*')   <span class="comments">;Read dimensions</span>
                        NDATA = DIMS[0]
                        IF NAXIS GT 1 THEN FOR I=2,NAXIS DO     $
                                NDATA = NDATA*DIMS[I-1]
                ENDIF ELSE NDATA = 0
                NBYTES = LONG64(ABS(BITPIX) / 8) * GCOUNT * (PCOUNT + NDATA)
<span class="comments">;</span>
<span class="comments">;  Read the next extension header in the file.</span>
<span class="comments">;</span>
                NREC = (NBYTES + 2879) / 2880
                POINT_LUN, -UNIT, POINTLUN              <span class="comments">;Current position</span>
                MHEAD0 = POINTLUN + NREC*2880L
                POINT_LUN, UNIT, MHEAD0                 <span class="comments">;Next FITS extension</span>
                FXHREAD,UNIT,HEADER,STATUS
                POINT_LUN, -UNIT, END_HEADER
                IF STATUS NE 0 THEN BEGIN
                        FREE_LUN,UNIT
                        MESSAGE = 'Requested extension not found'
                        IF N_ELEMENTS(ERRMSG) NE 0 THEN BEGIN
                                ERRMSG = MESSAGE
                                RETURN
                        END ELSE MESSAGE, MESSAGE
                ENDIF
                I_EXT = I_EXT + 1
<span class="comments">;</span>
<span class="comments">;  Check to see if the current extension is the one desired.</span>
<span class="comments">;</span>
                IF ETYPE EQ 7 THEN BEGIN
                        EXTNAME = STRTRIM(STRUPCASE(FXPAR(HEADER,'EXTNAME')),2)
                        IF EXTNAME EQ S_EXTENSION THEN GOTO, DONE
                END ELSE IF I_EXT EQ I_EXTENSION THEN GOTO, DONE
                GOTO, NEXT_EXT
DONE:
        ENDIF ELSE POINT_LUN, -UNIT, END_HEADER

<span class="comments">;</span>
<span class="comments">;  Add or modify the keyword parameter in the header, keeping track of the</span>
<span class="comments">;  initial size of the header array.</span>
<span class="comments">;</span>
        IEND = WHERE(STRMID(HEADER,0,8) EQ 'END     ')
        N_INITIAL = 1 + IEND[0]/36
        IF N_PARAMS() EQ 4 THEN BEGIN
                FXADDPAR, HEADER, NAME, VALUE , COMMENT, BEFORE=BEFORE, $
                        AFTER=AFTER, FORMAT=FORMAT
        END ELSE BEGIN
                FXADDPAR, HEADER, NAME, VALUE, BEFORE=BEFORE, AFTER=AFTER, $
                        FORMAT=FORMAT
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  If the length of the header has changed, then print an error message.</span>
<span class="comments">;</span>
        IEND = WHERE(STRMID(HEADER,0,8) EQ 'END     ')
        N_FINAL = 1 + IEND[0]/36
        IF N_FINAL NE N_INITIAL THEN BEGIN
            IF KEYWORD_SET(NOGROW) THEN BEGIN
                MESSAGE, /CONTINUE, 'Adding parameter would increase ' + $
                        'header length, no action taken.'
            ENDIF ELSE BEGIN
                <span class="comments">;; Increase size of the file by inserting multiples of</span>
                <span class="comments">;; 2880 bytes at the end of the current header.  Then</span>
                <span class="comments">;; resume normal operations.</span>
                BLKSHIFT, UNIT, END_HEADER, (N_FINAL-N_INITIAL)*36L*80L
                GOTO, WRITE_HEADER
            ENDELSE
<span class="comments">;</span>
<span class="comments">;  Otherwise, rewind to the beginning of the header, and write the new header</span>
<span class="comments">;  over the old header.  Convert to byte and force into 80 character lines.</span>
<span class="comments">;</span>
        ENDIF ELSE BEGIN
            WRITE_HEADER:
                BHDR = REPLICATE(32B, 80, 36*N_FINAL)
                FOR N = 0,IEND[0] DO BHDR[0,N] = BYTE(STRMID(HEADER[N],0,80))
                POINT_LUN, UNIT, MHEAD0
                WRITEU, UNIT, BHDR
        ENDELSE
<span class="comments">;</span>
<span class="comments">;  Close the file and return.</span>
<span class="comments">;</span>
        FREE_LUN, UNIT
        IF N_ELEMENTS(ERRMSG) NE 0 THEN ERRMSG = ''
        RETURN
        END
</code>
    </div>
  </body>
</html>