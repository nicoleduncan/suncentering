<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:46 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>linterp.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="linterp.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="linterp:source"></a>pro linterp, Xtab, Ytab, Xint, Yint, MISSING = missing, NoInterp = NoInterp
<span class="comments">;+</span>
<span class="comments">; NAME:   </span>
<span class="comments">;       LINTERP  </span>
<span class="comments">; PURPOSE: </span>
<span class="comments">;       Linearly interpolate tabulated 1-d data from one grid to a new one.</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       The results of LINTERP are numerically equivalent to the IDL intrinsic</span>
<span class="comments">;       INTERPOL() function, but note the following:</span>
<span class="comments">;         (1) LINTERP is a procedure rather than a function</span>
<span class="comments">;         (2) INTERPOL() extrapolates beyond the end points whereas LINTERP</span>
<span class="comments">;             truncates to the endpoints (or uses the MISSING keyword)</span>
<span class="comments">;         (3) LINTERP (unlike INTERPOL) uses the intrinsic INTERPOLATE function</span>
<span class="comments">;                 and thus may have a speed advantage</span>
<span class="comments">;         (4) LINTERP always converts the new grid vector to floating point </span>
<span class="comments">;                (because INTERPOLATE does this) whereas INTERPOL() will </span>
<span class="comments">;                 keep double precision if supplied.</span>
<span class="comments">;</span>
<span class="comments">;       Use QUADTERP for quadratic interpolation.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       LINTERP, Xtab, Ytab, Xint, Yint, [MISSING =, /NoInterp ]   </span>
<span class="comments">;</span>
<span class="comments">; INPUT PARAMETERS: </span>
<span class="comments">;       Xtab -  Vector containing the current independent variable grid.</span>
<span class="comments">;               Must be monotonic increasing or decreasing</span>
<span class="comments">;       Ytab -  Vector containing the current dependent variable values at </span>
<span class="comments">;               the XTAB grid points.</span>
<span class="comments">;       Xint -  Scalar or vector containing the new independent variable grid </span>
<span class="comments">;               points for which interpolated value(s) of the dependent </span>
<span class="comments">;               variable are sought.    Note that -- due to a limitation of the</span>
<span class="comments">;               intrinsic INTERPOLATE() function -- Xint is always converted to</span>
<span class="comments">;               floating point internally.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT PARAMETERS:</span>
<span class="comments">;       Yint  -  Scalar or vector with the interpolated value(s) of the </span>
<span class="comments">;               dependent variable at the XINT grid points.</span>
<span class="comments">;               YINT is double precision if XTAB or YTAB are double,</span>
<span class="comments">;               otherwise YINT is REAL*4</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORD:</span>
<span class="comments">;       MISSING - Scalar specifying YINT value(s) to be assigned, when Xint</span>
<span class="comments">;               value(s) are outside of the range of Xtab.     Default is to</span>
<span class="comments">;               truncate the out of range YINT value(s) to the nearest value </span>
<span class="comments">;               of YTAB.   See the help for the INTERPOLATE function.</span>
<span class="comments">;       /NoINTERP - If supplied then LINTERP returns the YTAB value(s) </span>
<span class="comments">;               associated with the closest XTAB value(s)rather than </span>
<span class="comments">;               interpolating.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       To linearly interpolate from a spectrum wavelength-flux pair</span>
<span class="comments">;       Wave, Flux to another wavelength grid defined as:</span>
<span class="comments">;       WGrid = [1540., 1541., 1542., 1543., 1544, 1545.]</span>
<span class="comments">;   </span>
<span class="comments">;       IDL>  LINTERP, Wave, Flux, WGrid, FGrid  </span>
<span class="comments">;</span>
<span class="comments">;       FGRID will be a 6 element vector containing the values of Flux</span>
<span class="comments">;       linearly interpolated onto the WGrid wavelength scale</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE: </span>
<span class="comments">;       Uses TABINV to calculate the effective index of the values</span>
<span class="comments">;       in Xint in the table Xtab.  The resulting index is used</span>
<span class="comments">;       with the intrinsic INTERPOLATE function to find the corresponding </span>
<span class="comments">;       Yint value in Ytab.  Unless the MISSING keyword is supplied, out</span>
<span class="comments">;       of range Yint values are truncated to the nearest value of Ytab.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES CALLED:</span>
<span class="comments">;       TABINV, ZPARCHECK</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Adapted from the IUE RDAF,  W. Landsman      October, 1988</span>
<span class="comments">;       Modified to use the new INTERPOLATE function        June, 1992</span>
<span class="comments">;       Modified to always return REAL*4             October, 1992</span>
<span class="comments">;       Added MISSING keyword                        August, 1993</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;       Added NoInterp keyword  W. Landsman      July 1999</span>
<span class="comments">;       Work for unsigned, 64 bit integers  W. Landsman  October 2001</span>
<span class="comments">;-</span>
 On_error,2
 compile_opt idl2

 if N_params() LT 4 then begin
   print,'Syntax - LINTERP, Xtab, Ytab, Xint, Yint, [ MISSING = ]' 
   print,'    Xtab, Ytab - Input X and Y vectors'
   print,'    Xint - Input X value (scalar or vector) at which to interpolate'
   print,'    Yint - Output interpolated Y value(s)'
   return
 endif

 numeric = [indgen(5)+1,12,13,14,15]      <span class="comments">;Numeric datatypes</span>
 zparcheck, 'LINTERP', Xtab, 1, numeric, 1, 'Current X Vector' 
 zparcheck, 'LINTERP', Ytab, 2, numeric, 1, 'Current Y Vector' 
 zparcheck, 'LINTERP', Xint, 3, numeric, [0,1], 'New X Vector or Scalar'

<span class="comments">; Determine index of data-points from which interpolation is made</span>

 npts = min( [ N_elements(Xtab), N_elements(Ytab) ] )
 tabinv, Xtab, Xint, r                                    
 if keyword_set(NoInterp) then Yint = Ytab[round(r)] else begin
 ytype = size( Ytab, /TYPE)

<span class="comments">; Perform linear interpolation</span>

 if (ytype LE 3) || (ytype GE 12) then  $             <span class="comments">;Integer or byte input?</span>
     Yint = interpolate( float(Ytab), r) else $
     Yint = interpolate( Ytab, r)

 endelse 

 if N_elements(missing) EQ 1 then begin
        Xmin = min( [ Xtab[0],Xtab[npts-1] ], max = Xmax)
        bad = where( (Xint LT Xmin) or (Xint GT Xmax ), Nbad)
        if Nbad GT 0 then Yint[bad] = missing
 endif
        
 return
 end                                        
</code>
    </div>
  </body>
</html>