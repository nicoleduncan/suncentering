<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:40 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>hastrom.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="hastrom.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="hastrom:source"></a>pro hastrom,oldim,oldhd,newim,newhd,refhd,MISSING=missing, INTERP = interp, $
                  ERRMSG = errmsg,CUBIC = cubic, DEGREE = Degree, NGRID = Ngrid
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       HASTROM</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Transformation of an image to align it with a reference image</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       A  transformation is applied (using POLY_2D) to an image so that   </span>
<span class="comments">;       its astrometry is identical with that in a reference header.  This</span>
<span class="comments">;       procedure can be used to align two images.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;       HASTROM, oldim, oldhd, newim, newhd, refhd, [MISSING =, INTERP = ]</span>
<span class="comments">;                            or</span>
<span class="comments">;       HASTROM, oldim, oldhd, refhd, [MISSING =, INTERP ={0,1,2}, NGRID =, </span>
<span class="comments">;                                      CUBIC =, DEGREE = ]</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       OLDIM - Image array to be manipulated.  If only 3 parameters are</span>
<span class="comments">;               supplied then OLDIM and OLDHD will be modified to contain </span>
<span class="comments">;               the output image array and header</span>
<span class="comments">;       OLDHD - FITS header array for OLDIM, containing astrometry parameters</span>
<span class="comments">;       REFHD - Reference header, containing astrometry parameters.  OLDIM</span>
<span class="comments">;               will be rotated, shifted, and compressed or expanded until</span>
<span class="comments">;               its astrometry matches that in REFHD.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       NEWIM - Image array after transformation has been performed.</span>
<span class="comments">;               The dimensions of NEWIM will be identical to the NAXIS1 and </span>
<span class="comments">;               NAXIS2 keywords specified in REFHD.  Regions on the reference </span>
<span class="comments">;               image that do not exist in OLDIM can be assigned a value with</span>
<span class="comments">;               the MISSING keyword.</span>
<span class="comments">;       NEWHD - Updated FITS image header associated with NEWIM</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;       MISSING - Set this keyword to a scalar value which will be assigned</span>
<span class="comments">;               to pixels in the output image which are out of range of the</span>
<span class="comments">;               supplied imput image.  If not supplied, then linear </span>
<span class="comments">;               extrapolation is used.   See the IDL manual on POLY_2D.</span>
<span class="comments">;               ***NOTE: A bug was introduced into the POLY_2D function in IDL </span>
<span class="comments">;               V5.5 (fixed in V6.1) such that the MISSING keyword</span>
<span class="comments">;               may not work properly with floating point data***</span>
<span class="comments">;       INTERP - Scalar, one of 0, 1, or 2 determining type of interpolation</span>
<span class="comments">;               0 nearest neighbor, 1 (default) bilinear interpolation, </span>
<span class="comments">;               2 cubic interpolation.</span>
<span class="comments">;       CUBIC - a scalar value between -1 and 0 specifying cubic interpolation</span>
<span class="comments">;               with the specified value as the cubic interpolation parameter.</span>
<span class="comments">;              (see poly_2d for info).    Setting CUBIC to a value greater </span>
<span class="comments">;               than zero is equivalent to setting CUBIC = -1. </span>
<span class="comments">;       NGRID -  Integer scalar specifying the number of equally spaced grid </span>
<span class="comments">;               points on each axis to use to specify the transformation.   </span>
<span class="comments">;               The value of NGRID must always be greater than DEGREE + 1.</span>
<span class="comments">;               The default is DEGREE + 2 which equals 3 (9 total points) for</span>
<span class="comments">;               DEGREE=1 (linear warping).</span>
<span class="comments">;       DEGREE - Integer scalar specifying the degree of the transformation.</span>
<span class="comments">;               See the routine POLYWARP for more info.   Default = </span>
<span class="comments">;               1 (linear transformation) unless polynomial ('SIP') distortion </span>
<span class="comments">;               parameters are present in either the input or reference FITS</span>
<span class="comments">;               header.    In that case, the default degree is equal to the</span>
<span class="comments">;               degree of the distortion polynomial.</span>
<span class="comments">; OPTIONAL OUTPUT KEYWORD:</span>
<span class="comments">;       ERRMSG - If this keyword is supplied, then any error messages will be</span>
<span class="comments">;               returned to the user in this parameter rather than depending on</span>
<span class="comments">;               on the MESSAGE routine in IDL.   If no errors are encountered</span>
<span class="comments">;               then a null string is returned.               </span>
<span class="comments">; NOTES:</span>
<span class="comments">;       (1) The 3 parameter calling sequence is less demanding on virtual </span>
<span class="comments">;               memory.</span>
<span class="comments">;       (2) The astrometry in OLDHD will be precessed to match the equinox</span>
<span class="comments">;                given in REFHD.</span>
<span class="comments">;       (3) If an ST Guidestar image is used for the reference header, then the</span>
<span class="comments">;                output header will be converted to standard astrometry.  </span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       Suppose one has an image array, IM, and an associated FITS header H.</span>
<span class="comments">;       One desires to warp the image array so that it is aligned with another</span>
<span class="comments">;       image with a FITS header, HREF.    Both headers contain astrometry info.</span>
<span class="comments">;       Set pixel values to 0 where there is no overlap between the input and</span>
<span class="comments">;       reference image, and use linear interpolation (default)</span>
<span class="comments">;</span>
<span class="comments">;       IDL> hastrom, IM, H, HREF, MISSING = 0</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;       ad2xy, check_FITS, extast, get_EQUINOX(), gsssextast, hprecess,</span>
<span class="comments">;       putast, sxaddpar, sxaddhist, sxpar(), xy2ad, zparcheck</span>
<span class="comments">;</span>
<span class="comments">; REVISION HISTORY:</span>
<span class="comments">;       Written  W. Landsman, STX Co.              Feb, 1989</span>
<span class="comments">;       Updated to CHECK_FITS                      Dec, 1991</span>
<span class="comments">;       New astrometry keywords                    Mar, 1994</span>
<span class="comments">;       Recognize GSSS header   W. Landsman        June, 1994</span>
<span class="comments">;       Added CUBIC keyword     W. Landsman        March, 1997</span>
<span class="comments">;       Accept INTERP=0, Convert output GSS header to standard astrometry</span>
<span class="comments">;                               W. Landsman        June 1998</span>
<span class="comments">;       Remove calls to obsolete !ERR system variable   March 2000</span>
<span class="comments">;       Added ERRMSG output keyword  W. Landsman    April 2000</span>
<span class="comments">;       Need to re-extract astrometry after precession  W. Landsman Nov. 2000</span>
<span class="comments">;       Check for distortion parameters in headers, add more FITS HISTORY</span>
<span class="comments">;       information                        W. Landsman   February 2005</span>
<span class="comments">;       Use different coefficient for nearest neighbor to avoid half-pixel</span>
<span class="comments">;       shift with POLY_2D      W. Landsman   Aug 2006</span>
<span class="comments">;       Return ERRMSG if no overlap between images  W. Landsman  Nov 2007</span>
<span class="comments">;       Use V6.0 notation  W. Landsman  Jan 2012</span>
<span class="comments">;       </span>
<span class="comments">;-</span>
 compile_opt idl2
 On_error,2                              <span class="comments">;Return to caller</span>
 npar = N_params()

 if (npar LT 3) or (npar EQ 4) then begin        <span class="comments">;3 parameter calling sequence?</span>
        print,'Syntax:  HASTROM, oldim, oldhd, refhd'
        print,'     or  HASTROM, oldim, oldhd, newim, newhd, refhd'
        print,'                 [ MISSING=, DEGREE=, INTERP=, NGRID=, CUBIC = ]'
        return
 endif  

 if ( npar EQ 3 ) then begin
        zparcheck, 'HASTROM', newim, 3, 7, 1, 'Reference FITS header'
        refhd = newim
 endif else  $
        zparcheck, 'HASTROM', refhd, 5, 7, 1, 'Reference FITS header'

 radeg = 180.D/!DPI                      <span class="comments">;Double precision !RADEG</span>

save_err = arg_present(errmsg)     <span class="comments">;Does user want error msgs returned?</span>

<span class="comments">;                                    Check for valid 2-D image & header</span>
 check_FITS, oldim, oldhd, dimen, /NOTYPE, ERRMSG = errmsg
  if errmsg NE '' then begin
        if ~save_err then message,'ERROR - ' + errmsg,/CON
        return
  endif

  if N_elements(dimen) NE 2 then begin 
        errmsg =  'ERROR - Input image array must be 2-dimensional'
        if ~save_err then message,'ERROR - ' + errmsg,/CON
        return
 endif

 xsize_old = dimen[0]  &  ysize_old = dimen[1]

 xsize_ref = sxpar( refhd, 'NAXIS1' )                <span class="comments">;Get output image size</span>
 ysize_ref = sxpar( refhd, 'NAXIS2' ) 
 if (xsize_ref LT 1) || (ysize_ref LT 1) then begin 
       errmsg = 'ERROR - Reference header must be for a 2-dimensional image'
       if ~save_err then message,'ERROR - ' + errmsg,/CON
       return
 endif
     

<span class="comments">; Extract CD, CRPIX and CRVAL value from image header and reference header</span>

 newhd = oldhd
 extast, newhd, astr_old, par_old    
 if ( par_old LT 0 ) then begin   
       errmsg = 'ERROR - Input FITS Header does not contain astrometry'
       if ~save_err then message,'ERROR - ' + errmsg,/CON
       return
 endif
 extast, refhd, astr_ref, par_ref    
 if ( par_old LT 0 ) || ( par_ref LT 0 ) then begin  
       errmsg = 'ERROR -Reference FITS Header does not contain astrometry'
       if ~save_err then message,'ERROR - ' + errmsg,/CON
       return
 endif


<span class="comments">;   Precess the header if necessary</span>

 refeq = get_equinox( refhd, code)
 if code EQ -1 then message, $
   'WARNING - Equinox not specified in reference header',/CON else begin
   oldeq = get_equinox( oldhd, code)
   if code EQ -1 then message, $
      'WARNING - Equinox not specified in original header',/CON else $
   if oldeq NE refeq then begin      <span class="comments">;Precess header and re-extract structure</span>
           hprecess, newhd, refeq
           extast, newhd, astr_old, par_old
   endif    
 endelse

<span class="comments">; Make a grid of points in the reference image to be used for the transformation</span>

 if ~keyword_set( DEGREE ) then degree = 1
    if tag_exist(astr_old,'DISTORT') then begin
       distort = astr_old.distort
       if distort.name EQ 'SIP' then begin
          na = ((size(distort.ap,/dimen))[0])
          degree = degree > (na -1 )     
        endif
     endif

    if tag_exist(astr_ref,'DISTORT') then begin
       distort = astr_ref.distort
       if distort.name EQ 'SIP' then begin
          na = ((size(distort.a,/dimen))[0])
          degree = degree > (na -1 )     
        endif
     endif
      
 if ~keyword_set(NGRID) then ngrid = (degree + 2)
 if ~keyword_set(CUBIC) then begin 
        cubic = 0
        if N_elements(INTERP) EQ 0 then Interp = 1
 endif

 nxdif = round( xsize_ref / (ngrid-1) ) + 1
 nydif = round( ysize_ref / (ngrid-1) ) + 1

 xref = lonarr(ngrid,ngrid) & yref = xref
 xrow = [ lindgen(ngrid-1)*nxdif, xsize_ref-1. ]
 yrow = [ lindgen(ngrid-1)*nydif, ysize_ref-1. ]

 for i=0,ngrid-1 do xref[0,i] =   xrow     <span class="comments">;Four corners of image</span>
 for i=0,ngrid-1 do yref[0,i] = replicate( yrow[i], ngrid)

<span class="comments">; Find the position of the reference points in the supplied image</span>

 case strmid(astr_ref.ctype[0],5,3) of
       'GSS': gsssxyad, astr_ref, xref, yref, ra, dec
        else: xy2ad, xref, yref, astr_ref, ra, dec
 endcase

 case strmid(astr_old.ctype[0],5,3) of
        'GSS': gsssadxy, astr_old, ra, dec, x, y
        else: ad2xy, ra, dec, astr_old, x, y
 endcase

 if ( max(x) LT 0 ) || ( min(x) GT xsize_old ) || $
    ( max(y) LT 0 ) || ( min(y) GT ysize_old ) then begin
      errmsg = 'No overlap found between original and reference images'
      if ~save_err then begin 
         message,'ERROR - ' + errmsg,/CON
         message,'Be sure you have the right headers and the right equinoxes',/CON
      endif	 
      return
 endif


  if interp EQ 0 $ <span class="comments">;Get coefficients</span>
    then polywarp, x+.5, y+.5, xref, yref, degree, kx, ky $
    else polywarp, x, y, xref, yref, degree, kx, ky 
  
 
 if N_elements(missing) NE 1 then begin        <span class="comments">;Do the warping</span>

 if npar EQ 3 then $
    oldim = poly_2d( temporary(oldim), kx, ky, Interp, xsize_ref, ysize_ref, $
                      CUBIC = cubic) else $
    newim = poly_2d( oldim, kx, ky, Interp, xsize_ref, ysize_ref, CUBIC = cubic)

 endif else begin

 if npar EQ 3 then $
    oldim = poly_2d( temporary(oldim), kx, ky, Interp, xsize_ref, ysize_ref, $
         MISSING=missing, CUBIC = cubic) $
 else $
    newim = poly_2d( oldim, kx, ky, Interp, xsize_ref, ysize_ref, $
          MISSING=missing, CUBIC = cubic)

 endelse

 sxaddpar, newhd, 'NAXIS1', xsize_ref
 sxaddpar, newhd, 'NAXIS2', ysize_ref

 if strmid(astr_ref.ctype[0],5,3) EQ 'GSS' then begin
        refhdnew = refhd
        gsss_stdast,refhdnew
        extast,refhdnew,astr_ref
 endif
 putast, newhd, astr_ref

 label = 'HASTROM: ' + strmid(systime(),4,20)
 image = sxpar( refhd, 'IMAGE', Count = N_image)
 if N_image EQ 1 THEN sxaddhist,label+' Reference Image - ' + image,newhd
 sxaddhist,label+ ' Original Image Size X: ' + strtrim(xsize_old,2) + $
                   ' Y: '  + strtrim(ysize_old,2), newhd
 sxaddhist,'HASTROM: Polynomial Degree used for image warping: ' + $
            strtrim(degree,2), newhd
 if cubic NE 0 then sterp = 'CUBIC = ' + strtrim(cubic,2) else $
     sterp = (['Nearest Neighbor','Linear','Cubic'])[interp]
 sxaddhist,'HASTROM: ' + sterp + ' interpolation',newhd
 sxaddhist,'HASTROM: Number of grid points ' + strtrim(ngrid*ngrid,2), newhd

<span class="comments">; Update BSCALE and BZERO factors in header if necessary.   This is only an</span>
<span class="comments">; approximate correction for nonlinear warping.</span>

 bscale = sxpar( newhd, 'BSCALE', Count = N_Bscale)
 if (N_bscale GT 0 ) && ( bscale NE 1. ) then begin
    getrot, astr_old, rot, cdelt_old
    getrot, astr_ref, rot, cdelt_ref
    pix_ratio = ( cdelt_old[0]*cdelt_old[1]) / (cdelt_ref[0]*cdelt_ref[1] )
    sxaddpar, newhd, 'BSCALE', bscale/pix_ratio
    bzero = sxpar( newhd,'BZERO' )
    if bzero NE 0. then sxaddpar, newhd, 'BZERO', bzero/pix_ratio
 endif

 if npar LT 4 then oldhd = newhd

 return
 end
</code>
    </div>
  </body>
</html>