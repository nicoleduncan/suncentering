<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Mon Sep 30 16:57:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>minf_bracket.pro (Documentation for ./)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="minf_bracket.pro (Documentation for ./)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><a id="minF_bracket:source"></a>pro minF_bracket, xa,xb,xc, fa,fb,fc, FUNC_NAME=func_name, $
                                                POINT_NDIM=pn, DIRECTION=dirn
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;       MINF_BRACKET</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Bracket a local minimum of a 1-D function with 3 points,</span>
<span class="comments">; EXPLANATION:</span>
<span class="comments">;       Brackets a local minimum of a 1-d function with 3 points,</span>
<span class="comments">;       thus ensuring that a minimum exists somewhere in the interval.</span>
<span class="comments">;       This routine assumes that the function has a minimum somewhere....</span>
<span class="comments">;       Routine can also be applied to a scalar function of many variables,</span>
<span class="comments">;       for such case the local minimum in a specified direction is bracketed,</span>
<span class="comments">;       This routine is called by minF_conj_grad, to bracket minimum in the </span>
<span class="comments">;       direction of the conjugate gradient of function of many variables</span>
<span class="comments">; CALLING EXAMPLE:</span>
<span class="comments">;       xa=0  & xb=1                                    </span>
<span class="comments">;       minF_bracket, xa,xb,xc, fa,fb,fc, FUNC_NAME="name"      ;for 1-D func.</span>
<span class="comments">;  or:</span>
<span class="comments">;       minF_bracket, xa,xb,xc, fa,fb,fc, FUNC="name",     $</span>
<span class="comments">;                                         POINT=[0,1,1],   $</span>
<span class="comments">;                                         DIRECTION=[2,1,1]     ;for 3-D func.</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       xa = scalar, guess for point bracketing location of minimum.</span>
<span class="comments">;       xb = scalar, second guess for point bracketing location of minimum.</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;       FUNC_NAME = function name (string)</span>
<span class="comments">;               Calling mechanism should be:  F = func_name( px )</span>
<span class="comments">;               where:</span>
<span class="comments">;                       px = scalar or vector of independent variables, input.</span>
<span class="comments">;                       F = scalar value of function at px.</span>
<span class="comments">;       POINT_NDIM = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the starting point in N-dim space.</span>
<span class="comments">;               Default = 0, which assumes function is 1-D.</span>
<span class="comments">;       DIRECTION = when working with function of N variables,</span>
<span class="comments">;               use this keyword to specify the direction in N-dim space</span>
<span class="comments">;               along which to bracket the local minimum, (default=1 for 1-D).</span>
<span class="comments">;               (xa,xb,xc) are then relative distances from POINT_NDIM.</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       xa,xb,xc = scalars, 3 points which bracket location of minimum,</span>
<span class="comments">;               that is, f(xb) &lt; f(xa) and f(xb) &lt; f(xc), so minimum exists.</span>
<span class="comments">;               When working with function of N variables</span>
<span class="comments">;               (xa,xb,xc) are then relative distances from POINT_NDIM,</span>
<span class="comments">;               in the direction specified by keyword DIRECTION,</span>
<span class="comments">;               with scale factor given by magnitude of DIRECTION.</span>
<span class="comments">; OPTIONAL OUTPUT:</span>
<span class="comments">;       fa,fb,fc = value of function at 3 points which bracket the minimum,</span>
<span class="comments">;                       again note that fb &lt; fa and fb &lt; fc if minimum exists.</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       algorithm from Numerical Recipes (by Press, et al.), sec.10.1 (p.281).</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       Written, Frank Varosi NASA/GSFC 1992.</span>
<span class="comments">;       Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="comments">;-</span>
        goldm = (sqrt(5)+1)/2           <span class="comments">;golden mean factor to march with.</span>
        glimit = 100                    <span class="comments">;maximum factor to try.</span>
        tiny = 1.e-19                   <span class="comments">;a tiny number to avoid divide by zero.</span>

        if N_elements( pn ) LE 0 then begin
                pn = 0
                dirn = 1
           endif

        if (xa EQ xb) then xb = xa + 1
        fa = call_function( func_name, pn + xa * dirn )
        fb = call_function( func_name, pn + xb * dirn )

        if (fb GT fa) then begin
                x = xa  &  xa = xb  &  xb = x
                f = fa  &  fa = fb  &  fb = f
           endif

        xc = xb + goldm * (xb-xa)
        fc = call_function( func_name, pn + xc * dirn )

        while (fb GE fc) do begin

                zba = xb-xa
                zbc = xb-xc
                r = zba * (fb-fc)
                q = zbc * (fb-fa)
                delta = q-r
                sign = 1 - 2 * (delta LT 0)
                xu = xb - (zbc * q - zba * r)/(2* sign * (abs( delta ) > tiny) )
                ulim = xb + glimit * (xc-xb)

                if ( (xb-xu)*(xu-xc) GT 0 ) then begin

                        fu = call_function( func_name, pn + xu * dirn )

                        if (fu LT fc) then begin
                                xa = xb  &  xb = xu
                                fa = fb  &  fb = fu
                                return
                          endif else if (fu GT fb) then begin
                                xc = xu
                                fc = fu
                                return
                           endif

                        xu = xc - goldm * zbc
                        fu = call_function( func_name, pn + xu * dirn )

                 endif else if ( (xc-xu)*(xu-ulim) GT 0 ) then begin

                        fu = call_function( func_name, pn + xu * dirn )

                        if (fu LT fc) then begin
                                xb = xc  &  fb = fc
                                xc = xu  &  fc = fu
                                xu = xc + goldm * (xc-xb)
                                fu = call_function( func_name, pn + xu * dirn )
                           endif

                  endif else if ( (ulim-xc)*(xu-ulim) GE 0 ) then begin

                        xu = ulim
                        fu = call_function( func_name, pn + xu * dirn )

                   endif else begin

                        xu = xc + goldm * (xc-xb)
                        fu = call_function( func_name, pn + xu * dirn )
                    endelse
        
                xa = xb  &  xb = xc  &  xc = xu
                fa = fb  &  fb = fc  &  fc = fu
          endwhile
return
end
</code>
    </div>
  </body>
</html>