<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Aug 27 15:24:09 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>picksun.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="picksun.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION picksun, inputimage, inputstruct
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;       Decides which suns to ignore. Looks along the border pixels of the image and if 6 consecutive pixels are seen, it finds the closest sun (which will be a partial sun) and marks it as no good</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       inputimage: in, required</span>
<span class="comments">;           The raw input image</span>
<span class="comments">;</span>
<span class="comments">;       inputstruct: in, required</span>
<span class="comments">;           Structure containing all the solar information</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       </span>
<span class="comments">;-</span>

s = SIZE(inputimage,/d)
n_col = s[0]
n_row = s[1]
vec = !Null

<span class="comments">; Have to do some stupid strucutre stuff because tags are different</span>
a = fltarr(3)
names = tag_names( !thresh)
if WHERE(names eq 'REG1') ne -1 then a[0] = !thresh.reg1
if WHERE(names eq 'REG2') ne -1 then a[1] = !thresh.reg2
if WHERE(names eq 'REG3') ne -1 then a[2] = !thresh.reg3

<span class="comments">; scan in bottom,right,top,left</span>
threshmask = inputimage gt MIN(a[where(a ne 0)])
bottom = threshmask[*,0]
top = threshmask[*,-1]
left = REFORM(threshmask[0,*])
right = REFORM(threshmask[-1,*])

borderarr = [bottom,right,REVERSE(top),REVERSE(left)]

xarr = [FINDGEN(n_col),REPLICATE(n_col-1,n_row),REVERSE(FINDGEN(n_col)),REPLICATE(0,n_row)]
yarr = [REPLICATE(0,n_col),FINDGEN(n_row),REPLICATE(n_row-1,n_col),REVERSE(FINDGEN(n_row))]

<span class="comments">; If we have 6 consecutive pixels then it's bad</span>
if TOTAL(borderarr) gt 6 then begin
    for i =0,N_ELEMENTS(borderarr)-1 do begin
        <span class="comments">; Keep track of how many consecutive picels there are</span>
        if borderarr[i+1] + borderarr[i] eq 2 then vec = [vec,i] else vec = !Null
        <span class="comments">; If we get 6 in a row, get out of this for loop</span>
        if N_ELEMENTS(vec) gt 6 then break
    endfor

    if vec ne !Null then begin
        xcenter = MEAN(xarr[vec])
        ycenter = MEAN(yarr[vec])
        <span class="comments">; Pick closest center</span>
        sundist = SQRT((inputstruct.xpos-xcenter)^2 + (inputstruct.ypos-ycenter)^2)
        closest_sun = (inputstruct.reg)[WHERE(sundist eq MIN(sundist))]
        borderarr[vec[0]:vec[0] + !param.sundiam]=0
    endif
    
    <span class="comments">; Set the closest sun to the xcenter,ycenter of the consecutive 6 pixels to nearest center</span>
    inputstruct[WHERE(inputstruct.reg eq closest_sun[0])].partial=1


    <span class="comments">; We have 3 suns so I'm making 1 nested if loop</span>
    if TOTAL(borderarr) gt 6 then begin
        for i =0,N_ELEMENTS(borderarr)-1 do begin
            if borderarr[i+1] + borderarr[i] eq 2 then vec = [vec,i] else vec = !Null
            if N_ELEMENTS(vec) gt 6 then break
        endfor

        if vec ne !Null then begin
            xcenter = MEAN(xarr[vec])
            ycenter = MEAN(yarr[vec])

            <span class="comments">; pick closest center</span>
            sundist = SQRT((inputstruct.xpos-xcenter)^2 + (inputstruct.ypos-ycenter)^2)
            closest_sun = (inputstruct.reg)[WHERE(sundist eq MIN(sundist))]
            borderarr[vec[0]:vec[0] + !param.sundiam]=0
        endif

        inputstruct[WHERE(inputstruct.reg eq closest_sun[0])].partial=1
    endif
endif


<span class="comments">; Trying a new method instead of the consecutive 6 pixels check</span>
if N_ELEMENTS(inputstruct) eq 1 then begin
    if inputstruct[0].npix lt !param.sunpixnum * !param.partial_perc then inputstruct[0].partial = 1
endif else begin
    for i = 0,N_ELEMENTS(inputstruct)-1 do begin
        if inputstruct[i].npix lt !param.sunpixnum * !param.partial_perc then inputstruct[i].partial = 1
    endfor
endelse

RETURN,inputstruct
end
</code>
    </div>
  </body>
</html>