<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Aug 27 15:24:07 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gauss_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gauss_fid.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">FUNCTION gauss_fid, inputimage, inputstruct
<span class="comments">; 3x faster than fid_faster</span>
<span class="comments">; .005 to execute if using gaussfit</span>

<span class="comments">; 10x faster than fid_faster if using parapeak</span>
<span class="comments">; .001 to execute if using parapeak</span>

somethresh=100
k=0
length = 31
z=fltarr(3,3,/nozero)
<span class="comments">; cropped-down image of sun</span>
crop = FLOAT(inputimage[inputstruct.limbxpos - !param.crop_box:inputstruct.limbxpos + !param.crop_box,inputstruct.limbypos - !param.crop_box:inputstruct.limbypos + !param.crop_box])

<span class="comments">; plots of x and y totals to identify rows/columns of fiducials</span>
yt = TOTAL(crop,1)
xt = TOTAL(crop,2)

<span class="comments">; array of differences between sum profile and smoothed sum profile</span>
ysums = yt - SMOOTH(yt,15)
xsums = xt - SMOOTH(xt,15)

<span class="comments">; Identify where it looks like a fiducial</span>
yfids = WHERE(ysums le -150)
xfids = WHERE(xsums le -150)

<span class="comments">; Rule out adjacent indices</span>
aa=xfids
aa= [0,aa,0]
bb = aa - SHIFT(aa,1)
cc = aa[WHERE(bb ne 1)]
xx = cc[1:-2]

aa=yfids
aa= [0,aa,0]
bb = aa - SHIFT(aa,1)
cc = aa[WHERE(bb ne 1)]
yy = cc[1:-2]

<span class="comments">; Breaks if indices aren't exactly consecutive... need to work on that</span>

fidpos = REPLICATE({fidpos,x:0.,y:0.,subx:0.,suby:0.},N_ELEMENTS(xx)>N_ELEMENTS(yy))

<span class="comments">; Loop through each x and y position combination </span>
for i = 0,N_ELEMENTS(xx)-1 do begin
    for j = 0,N_ELEMENTS(yy)-1 do begin
        <span class="comments">; To eliminate coords that are just solar pixels and not fiducials (on disk)</span>
        if crop[xx[i],yy[j]] lt 15 then begin
            
            aa = crop[xx[i]-15:xx[i]+15,yy[j]-15:yy[j]+15]

            rowsum=TOTAL(aa,1) <span class="comments">; Summing rows to get a y position profile</span>
            ysum=SMOOTH(rowsum,10)-rowsum   <span class="comments">;The array we're thresholding</span>
            bw = WHERE(ysum gt somethresh,n_bw)

            colsum=TOTAL(aa,2)
            xsum=SMOOTH(colsum,10)-colsum
            dw = WHERE(xsum gt somethresh,n_dw)
            



            <span class="comments">; if there are any array values above a threshold, it's definitely a fiducial</span>
            if n_bw ne 0 and n_dw ne 0 then begin
                    fidpos[k].x=xx[i]
                    fidpos[k].y=yy[j]

                    xgauss = GAUSSFIT(FINDGEN(length),colsum,xcoeff,nterms=5)
                    ygauss = GAUSSFIT(FINDGEN(length),rowsum,ycoeff,nterms=5)
                    
                    <span class="comments">; [1] is the center term</span>
                    fidpos[k].subx = xcoeff[1] + xx[i]-15
                    fidpos[k].suby = ycoeff[1] + yy[j]-15






                    <span class="comments">; Find peaks</span>
                    <span class="comments">; maxx = where(xsum eq max(xsum))</span>
                    <span class="comments">; maxy = where(ysum eq max(ysum))</span>
                    <span class="comments">; ; Fit a parabola to these</span>
                    <span class="comments">; xarr = xsum[maxx-1:maxx+1]</span>
                    <span class="comments">; yarr = ysum[maxy-1:maxy+1]</span>

                    <span class="comments">; ; Making some fake 3x3 so that we can use parapeak</span>
                    <span class="comments">; z[0:2] = xarr * yarr[2]</span>
                    <span class="comments">; z[3:5] = xarr * yarr[1]</span>
                    <span class="comments">; z[6:8] = xarr * yarr[0]</span>
                    
                    <span class="comments">; result = parapeak(z)</span>
                    
                    <span class="comments">; fidpos[k].subx = maxx + result[0] + xx[i] - 15</span>
                    <span class="comments">; fidpos[k].suby = maxy + result[1] + yy[j] - 15</span>

                    <span class="comments">; print,xcoeff[1] + xx[i]-15</span>
                    <span class="comments">; print,subx</span>
                    <span class="comments">; print,ycoeff[1] + yy[j]-15</span>
                    <span class="comments">; print,suby</span>

                    k++
                    if k eq N_ELEMENTS(xx)>N_ELEMENTS(yy) then break
            endif
        endif
    endfor
endfor










<span class="comments">; 20 possible fiducial candidates, how many have duplciates indices? 13? don't think so.</span>









RETURN,fidpos
end
</code>
    </div>
  </body>
</html>