<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Aug 27 15:24:20 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>limbfit.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="limbfit.pro (Documentation for /Users/jerensuzuki/Documents/suncentering/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO limbfit, thresh, xpos, ypos, file, ministrip_length, order, scan_width, sigmavalue, sundiam, nstrips=nstrips, $
        plot=plot, region=region, time=time
<span class="comments">;+</span>
<span class="comments">;   :Description:</span>
<span class="comments">;   Uses the data from makelimbstrips and fits an n-th order polynomial to the limb to find where</span>
<span class="comments">;       it crosses the threshold.</span>
<span class="comments">;</span>
<span class="comments">;   :Params:</span>
<span class="comments">;       file : in, required, type=string, default='triplesun.bmp'</span>
<span class="comments">;           File to be read in</span>
<span class="comments">;       ministrip_length : in, required, default=9</span>
<span class="comments">;           How long the trimmed down strip will be</span>
<span class="comments">;       order : in, required, type=integer, default=3</span>
<span class="comments">;           What order polynomial to use for POLY_FIT()</span>
<span class="comments">;       scan_width : in, required, type=integer, default=5</span>
<span class="comments">;           Indicates how far apart to scan</span>
<span class="comments">;       sigmavalue : in, required, type=integer, default=2</span>
<span class="comments">;           Sets the threshold to be::</span>
<span class="comments">;</span>
<span class="comments">;           max(image) - sigmavalue*stddev(image)</span>
<span class="comments">;</span>
<span class="comments">;       sundiam : in, required, type=byte, default=70</span>
<span class="comments">;           Approximate diameter of sun in pixels. (Based on bmp image)</span>
<span class="comments">;       thresh : out, required, type=float</span>
<span class="comments">;           Threshold used to select pixels</span>
<span class="comments">;       xpos : out, required, type=float</span>
<span class="comments">;           X center</span>
<span class="comments">;       ypos : out, required, type=float</span>
<span class="comments">;           Y center</span>
<span class="comments">;</span>
<span class="comments">;   :Keywords:</span>
<span class="comments">;       nstrips : in, optional, type=byte, default=5</span>
<span class="comments">;           How many strips to select, centered around the row/col diameter</span>
<span class="comments">;       region : in, required, type=integer, default=1</span>
<span class="comments">;           Which sun out of the three to find the center of. Defaults to the brightest sun</span>
<span class="comments">;       plot : in, optional</span>
<span class="comments">;           Makes some nice plots</span>
<span class="comments">;       time : in, optional</span>
<span class="comments">;           Prints the elapsed time</span>
<span class="comments">;-</span>

<span class="comments">; Setting default values</span>
IF n_elements(file)                 EQ 0    THEN file              = 'triplesun.bmp'
IF n_elements(ministrip_length)     EQ 0    THEN ministrip_length  = 9
IF n_elements(nstrips)              EQ 0    THEN nstrips           = 5
IF n_elements(order)                EQ 0    THEN order             = 3
IF n_elements(region)               EQ 0    THEN region            = 1
IF n_elements(scan_width)           EQ 0    THEN scan_width        = 5
IF n_elements(sigmavalue)           EQ 0    THEN sigmavalue        = 2
IF n_elements(sundiam)              EQ 0    THEN sundiam           = 70

<span class="comments">; Run the program to get our structures</span>
makelimbstrips, thresh, xstrips, ystrips, file, ministrip_length, scan_width, sigmavalue, sundiam, $
    nstrips=nstrips, region=region, time=time

start = systime(1,/seconds)

ministrip_side_length = ministrip_length/2
xlen    = 0
xsum    = 0
xnum    = 0   
ylen    = 0
ysum    = 0
ynum    = 0
xarr    = findgen(n_elements(xstrips[4].STARTPOINTS))
yarr    = findgen(n_elements(ystrips[4].STARTPOINTS))
tx      = findgen(n_elements(xstrips[4].STARTPOINTS) * 1000)/100
ylenarr = findgen(n_elements(ystrips))
xlenarr = findgen(n_elements(xstrips))

<span class="comments">;Deal with rows</span>
FOR n=0,n_elements(xstrips)-1 DO BEGIN
    <span class="comments">; Using fz_roots instead of spline interpolating. Saving lines and making code more readable</span>
    startresult     = reform(poly_fit(xarr,xstrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(xarr,xstrips[n].ENDPOINTS,order))

    <span class="comments">; Solving for roots but want to include threshold value</span>
    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF xstrips[n].BEGINDEX GT 0 THEN BEGIN
        <span class="comments">; Get roots (complex)</span>
        begroots    = fz_roots(startresult)
        <span class="comments">; Take only roots with no imaginary components</span>
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        <span class="comments">; Find smallest root (apparently I have to choose the smaller one)</span>
        <span class="comments">; Or i can find the midpoints using the other two roots then take the average of the two,</span>
        <span class="comments">; that way works too, but why would I do that?</span>
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = xstrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF xstrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = xstrips[n].ENDINDEX + endusable
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    <span class="comments">; Stick the midpoints in an array to take the mean of later</span>
    xlenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

FOR n=0,n_elements(ystrips)-1 DO BEGIN
    startresult     = reform(poly_fit(yarr,ystrips[n].STARTPOINTS,order))
    endresult       = reform(poly_fit(yarr,ystrips[n].ENDPOINTS,order))

    startresult[0]  -=thresh
    endresult[0]    -=thresh

    IF ystrips[n].BEGINDEX GT 0 THEN BEGIN
        begroots    = fz_roots(startresult)
        begusable   = (real_part(begroots))[where(imaginary(begroots) eq 0.)]
        begusable   = (begusable[where(begusable gt 0)])[0]
        stripbeg    = ystrips[n].BEGINDEX + begusable
    ENDIF ELSE BEGIN
        begusable   = 0
        stripbeg    = 0
    ENDELSE

    IF ystrips[n].ENDINDEX GT 0 THEN BEGIN
        endroots    = fz_roots(endresult)
        endusable   = (real_part(endroots))[where(imaginary(endroots) eq 0.)]
        endusable   = (endusable[where(endusable gt 0)])[0]
        stripend    = ystrips[n].ENDINDEX + endusable
        
    ENDIF ELSE BEGIN
        endusable   = 0
        stripend    = 0
    ENDELSE

    ylenarr[n] = mean([[stripend],[stripbeg]])
ENDFOR    

<span class="comments">; Get the midpoint of the chords</span>
xpos = mean(xlenarr[where(xlenarr ne 0)])
ypos = mean(ylenarr[where(ylenarr ne 0)])

IF keyword_set(plot) THEN BEGIN
    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,2
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,0
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>

    wn = 3
    startresult = poly_fit(xarr,xstrips[wn].STARTPOINTS,order)
    endresult = poly_fit(xarr,xstrips[wn].ENDPOINTS,order)

    CASE order OF
    1: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr,tx)
        END
    2: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2,tx)
        END
    3: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3,tx)
        END
    4: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4,tx)
        END
    5: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5,tx)
        END    
    6: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6,tx)
        END
    7: BEGIN
        xtmp = spline(xarr,startresult[0] + startresult[1]*xarr + startresult[2]*xarr^2 + $
                startresult[3]*xarr^3 + startresult[4]*xarr^4 + startresult[5]*xarr^5 + $
                startresult[6]*xarr^6 + startresult[7]*xarr^7,tx)
        atmp = spline(xarr,endresult[0] + endresult[1]*xarr + endresult[2]*xarr^2 + $
                endresult[3]*xarr^3 + endresult[4]*xarr^4 + endresult[5]*xarr^5 + $
                endresult[6]*xarr^6 + endresult[7]*xarr^7,tx)
        END
    ENDCASE

    <span class="comments">; A pretty plot for Nicole</span>
    window,3
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part1'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].BEGINDEX,xstrips[wn].startpoints,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].BEGINDEX,xtmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/right,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>
    window,1
    <span class="comments">; set_plot,'ps'</span>
    <span class="comments">; device,filename=file+'part2'+'.ps',/encapsulated</span>
    plot,xarr+xstrips[wn].ENDINDEX,xstrips[wn].ENDPOINTS,xs=3,ys=3,title='Limb Profile',$
        xtitle='Pixel indices of total strip',ytitle='Brightness',psym=-2<span class="comments">;,yr=[0,1.1*max(xtmp)]</span>
    oplot,tx+xstrips[wn].ENDINDEX,atmp,linestyle=1
    hline,thresh,linestyle=2
    legend,['Actual Data Values','Splined Data'],linestyle=[0,1],/bottom,/left,charsize=2
    <span class="comments">; device,/close</span>
    <span class="comments">; set_plot,'x'</span>


    
ENDIF
<span class="comments">; Just an aside, but plotting adds ~ .1 seconds to bring it up to .22 seconds total</span>
finish = systime(1,/seconds)

IF keyword_set(time) THEN  print,'Elapsed Time for limbfit: ',strcompress(finish-start,/rem),' seconds'
<span class="comments">; save,xpos,ypos,thresh,sigmavalue,order,file, ministrip_length,scan_width,$</span>
<span class="comments">;     filename='comp6results.sav',/compress</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>

<span class="comments">; OPENW,1,'comp6results.dat' </span>
<span class="comments">; PRINTF,1,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,1</span>

<span class="comments">; strformatcode = 'a'+strcompress(strlen(file),/rem)</span>
<span class="comments">; OPENW,2,'comp6results.txt' </span>
<span class="comments">; PRINTF,2,xpos,ypos,thresh,sigmavalue,order,ministrip_length,scan_width,file, $</span>
<span class="comments">;     format='(F7.2,1X,F7.2,1X,F7.2,I,1X,I,1X,I,1X,I,1X,'+strformatcode+')'</span>
<span class="comments">; CLOSE,2</span>
RETURN
END
</code>
    </div>
  </body>
</html>